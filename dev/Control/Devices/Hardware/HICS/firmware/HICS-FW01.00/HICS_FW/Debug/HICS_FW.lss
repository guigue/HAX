
HICS_FW.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0001ec9c  00400000  00400000  00010000  2**6
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.exidx    00000008  0041ec9c  0041ec9c  0002ec9c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .relocate     00000b28  20000000  0041eca4  00030000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          0000b1f4  20000b28  0041f7d0  00030b28  2**3
                  ALLOC
  4 .data_sdram1  00050000  61000000  61000000  00040000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data_sdram2  0004e200  63000000  63000000  00090000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  6 .stack        00003004  2000bd1c  0042a9c4  00030b28  2**0
                  ALLOC
  7 .ARM.attributes 0000002e  00000000  00000000  000de200  2**0
                  CONTENTS, READONLY
  8 .comment      00000059  00000000  00000000  000de22e  2**0
                  CONTENTS, READONLY
  9 .debug_info   00051402  00000000  00000000  000de287  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00009426  00000000  00000000  0012f689  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000129cf  00000000  00000000  00138aaf  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_aranges 000022a8  00000000  00000000  0014b47e  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00002108  00000000  00000000  0014d726  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_macro  0001bfe7  00000000  00000000  0014f82e  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   0003142b  00000000  00000000  0016b815  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    0007f3b7  00000000  00000000  0019cc40  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_frame  0000a158  00000000  00000000  0021bff8  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00400000 <exception_table>:
  400000:	20 ed 00 20 e9 6c 40 00 39 6c 40 00 39 6c 40 00      .. .l@.9l@.9l@.
  400010:	39 6c 40 00 39 6c 40 00 39 6c 40 00 00 00 00 00     9l@.9l@.9l@.....
	...
  40002c:	01 0f 41 00 39 6c 40 00 00 00 00 00 f1 10 41 00     ..A.9l@.......A.
  40003c:	39 11 41 00 39 6c 40 00 39 6c 40 00 39 6c 40 00     9.A.9l@.9l@.9l@.
  40004c:	39 6c 40 00 39 6c 40 00 39 6c 40 00 39 6c 40 00     9l@.9l@.9l@.9l@.
  40005c:	39 6c 40 00 39 6c 40 00 99 40 40 00 b1 40 40 00     9l@.9l@..@@..@@.
  40006c:	c9 40 40 00 e1 40 40 00 f9 40 40 00 39 6c 40 00     .@@..@@..@@.9l@.
  40007c:	39 6c 40 00 39 6c 40 00 39 6c 40 00 39 6c 40 00     9l@.9l@.9l@.9l@.
  40008c:	39 6c 40 00 39 6c 40 00 39 6c 40 00 39 6c 40 00     9l@.9l@.9l@.9l@.
  40009c:	39 6c 40 00 39 6c 40 00 39 6c 40 00 39 6c 40 00     9l@.9l@.9l@.9l@.
  4000ac:	39 6c 40 00 39 6c 40 00 39 6c 40 00 39 6c 40 00     9l@.9l@.9l@.9l@.
  4000bc:	39 6c 40 00 39 6c 40 00 39 6c 40 00 39 6c 40 00     9l@.9l@.9l@.9l@.
  4000cc:	c5 49 40 00 39 6c 40 00 39 6c 40 00 39 6c 40 00     .I@.9l@.9l@.9l@.
  4000dc:	39 6c 40 00 39 6c 40 00 39 6c 40 00 39 6c 40 00     9l@.9l@.9l@.9l@.
  4000ec:	39 6c 40 00 e1 00 41 00 39 6c 40 00                 9l@...A.9l@.

004000f8 <__do_global_dtors_aux>:
  4000f8:	b510      	push	{r4, lr}
  4000fa:	4c05      	ldr	r4, [pc, #20]	; (400110 <__do_global_dtors_aux+0x18>)
  4000fc:	7823      	ldrb	r3, [r4, #0]
  4000fe:	b933      	cbnz	r3, 40010e <__do_global_dtors_aux+0x16>
  400100:	4b04      	ldr	r3, [pc, #16]	; (400114 <__do_global_dtors_aux+0x1c>)
  400102:	b113      	cbz	r3, 40010a <__do_global_dtors_aux+0x12>
  400104:	4804      	ldr	r0, [pc, #16]	; (400118 <__do_global_dtors_aux+0x20>)
  400106:	f3af 8000 	nop.w
  40010a:	2301      	movs	r3, #1
  40010c:	7023      	strb	r3, [r4, #0]
  40010e:	bd10      	pop	{r4, pc}
  400110:	20000b28 	.word	0x20000b28
  400114:	00000000 	.word	0x00000000
  400118:	0041eca4 	.word	0x0041eca4

0040011c <frame_dummy>:
  40011c:	4b0c      	ldr	r3, [pc, #48]	; (400150 <frame_dummy+0x34>)
  40011e:	b143      	cbz	r3, 400132 <frame_dummy+0x16>
  400120:	480c      	ldr	r0, [pc, #48]	; (400154 <frame_dummy+0x38>)
  400122:	490d      	ldr	r1, [pc, #52]	; (400158 <frame_dummy+0x3c>)
  400124:	b510      	push	{r4, lr}
  400126:	f3af 8000 	nop.w
  40012a:	480c      	ldr	r0, [pc, #48]	; (40015c <frame_dummy+0x40>)
  40012c:	6803      	ldr	r3, [r0, #0]
  40012e:	b923      	cbnz	r3, 40013a <frame_dummy+0x1e>
  400130:	bd10      	pop	{r4, pc}
  400132:	480a      	ldr	r0, [pc, #40]	; (40015c <frame_dummy+0x40>)
  400134:	6803      	ldr	r3, [r0, #0]
  400136:	b933      	cbnz	r3, 400146 <frame_dummy+0x2a>
  400138:	4770      	bx	lr
  40013a:	4b09      	ldr	r3, [pc, #36]	; (400160 <frame_dummy+0x44>)
  40013c:	2b00      	cmp	r3, #0
  40013e:	d0f7      	beq.n	400130 <frame_dummy+0x14>
  400140:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  400144:	4718      	bx	r3
  400146:	4b06      	ldr	r3, [pc, #24]	; (400160 <frame_dummy+0x44>)
  400148:	2b00      	cmp	r3, #0
  40014a:	d0f5      	beq.n	400138 <frame_dummy+0x1c>
  40014c:	4718      	bx	r3
  40014e:	bf00      	nop
  400150:	00000000 	.word	0x00000000
  400154:	0041eca4 	.word	0x0041eca4
  400158:	20000b2c 	.word	0x20000b2c
  40015c:	6304e200 	.word	0x6304e200
  400160:	00000000 	.word	0x00000000

00400164 <osc_get_rate>:

	return 0;
}

static inline uint32_t osc_get_rate(uint32_t ul_id)
{
  400164:	b480      	push	{r7}
  400166:	b083      	sub	sp, #12
  400168:	af00      	add	r7, sp, #0
  40016a:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  40016c:	687b      	ldr	r3, [r7, #4]
  40016e:	2b07      	cmp	r3, #7
  400170:	d825      	bhi.n	4001be <osc_get_rate+0x5a>
  400172:	a201      	add	r2, pc, #4	; (adr r2, 400178 <osc_get_rate+0x14>)
  400174:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  400178:	00400199 	.word	0x00400199
  40017c:	0040019f 	.word	0x0040019f
  400180:	004001a5 	.word	0x004001a5
  400184:	004001ab 	.word	0x004001ab
  400188:	004001af 	.word	0x004001af
  40018c:	004001b3 	.word	0x004001b3
  400190:	004001b7 	.word	0x004001b7
  400194:	004001bb 	.word	0x004001bb
	case OSC_SLCK_32K_RC:
		return OSC_SLCK_32K_RC_HZ;
  400198:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
  40019c:	e010      	b.n	4001c0 <osc_get_rate+0x5c>

	case OSC_SLCK_32K_XTAL:
		return BOARD_FREQ_SLCK_XTAL;
  40019e:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  4001a2:	e00d      	b.n	4001c0 <osc_get_rate+0x5c>

	case OSC_SLCK_32K_BYPASS:
		return BOARD_FREQ_SLCK_BYPASS;
  4001a4:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  4001a8:	e00a      	b.n	4001c0 <osc_get_rate+0x5c>

	case OSC_MAINCK_4M_RC:
		return OSC_MAINCK_4M_RC_HZ;
  4001aa:	4b08      	ldr	r3, [pc, #32]	; (4001cc <osc_get_rate+0x68>)
  4001ac:	e008      	b.n	4001c0 <osc_get_rate+0x5c>

	case OSC_MAINCK_8M_RC:
		return OSC_MAINCK_8M_RC_HZ;
  4001ae:	4b08      	ldr	r3, [pc, #32]	; (4001d0 <osc_get_rate+0x6c>)
  4001b0:	e006      	b.n	4001c0 <osc_get_rate+0x5c>

	case OSC_MAINCK_12M_RC:
		return OSC_MAINCK_12M_RC_HZ;
  4001b2:	4b08      	ldr	r3, [pc, #32]	; (4001d4 <osc_get_rate+0x70>)
  4001b4:	e004      	b.n	4001c0 <osc_get_rate+0x5c>

	case OSC_MAINCK_XTAL:
		return BOARD_FREQ_MAINCK_XTAL;
  4001b6:	4b07      	ldr	r3, [pc, #28]	; (4001d4 <osc_get_rate+0x70>)
  4001b8:	e002      	b.n	4001c0 <osc_get_rate+0x5c>

	case OSC_MAINCK_BYPASS:
		return BOARD_FREQ_MAINCK_BYPASS;
  4001ba:	4b06      	ldr	r3, [pc, #24]	; (4001d4 <osc_get_rate+0x70>)
  4001bc:	e000      	b.n	4001c0 <osc_get_rate+0x5c>
	}

	return 0;
  4001be:	2300      	movs	r3, #0
}
  4001c0:	4618      	mov	r0, r3
  4001c2:	370c      	adds	r7, #12
  4001c4:	46bd      	mov	sp, r7
  4001c6:	f85d 7b04 	ldr.w	r7, [sp], #4
  4001ca:	4770      	bx	lr
  4001cc:	003d0900 	.word	0x003d0900
  4001d0:	007a1200 	.word	0x007a1200
  4001d4:	00b71b00 	.word	0x00b71b00

004001d8 <sysclk_get_main_hz>:
 */
#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
extern uint32_t sysclk_initialized;
#endif
static inline uint32_t sysclk_get_main_hz(void)
{
  4001d8:	b580      	push	{r7, lr}
  4001da:	af00      	add	r7, sp, #0
	} else if (CONFIG_SYSCLK_SOURCE == SYSCLK_SRC_MAINCK_BYPASS) {
		return OSC_MAINCK_BYPASS_HZ;
	}
#ifdef CONFIG_PLL0_SOURCE
	else if (CONFIG_SYSCLK_SOURCE == SYSCLK_SRC_PLLACK) {
		return pll_get_default_rate(0);
  4001dc:	2006      	movs	r0, #6
  4001de:	4b03      	ldr	r3, [pc, #12]	; (4001ec <sysclk_get_main_hz+0x14>)
  4001e0:	4798      	blx	r3
  4001e2:	4603      	mov	r3, r0
  4001e4:	011b      	lsls	r3, r3, #4

	else {
		/* unhandled_case(CONFIG_SYSCLK_SOURCE); */
		return 0;
	}
}
  4001e6:	4618      	mov	r0, r3
  4001e8:	bd80      	pop	{r7, pc}
  4001ea:	bf00      	nop
  4001ec:	00400165 	.word	0x00400165

004001f0 <sysclk_get_peripheral_hz>:
 * \brief Retrieves the current rate in Hz of the peripheral clocks.
 *
 * \return Frequency of the peripheral clocks, in Hz.
 */
static inline uint32_t sysclk_get_peripheral_hz(void)
{
  4001f0:	b580      	push	{r7, lr}
  4001f2:	af00      	add	r7, sp, #0
	/* CONFIG_SYSCLK_PRES is the register value for setting the expected */
	/* prescaler, not an immediate value. */
	return sysclk_get_main_hz() /
  4001f4:	4b02      	ldr	r3, [pc, #8]	; (400200 <sysclk_get_peripheral_hz+0x10>)
  4001f6:	4798      	blx	r3
  4001f8:	4603      	mov	r3, r0
  4001fa:	085b      	lsrs	r3, r3, #1
		((CONFIG_SYSCLK_PRES == SYSCLK_PRES_3) ? 3 :
			(1 << (CONFIG_SYSCLK_PRES >> PMC_MCKR_PRES_Pos)));
}
  4001fc:	4618      	mov	r0, r3
  4001fe:	bd80      	pop	{r7, pc}
  400200:	004001d9 	.word	0x004001d9

00400204 <spi_reset>:
 * \brief Reset SPI and set it to Slave mode.
 *
 * \param p_spi Pointer to an SPI instance.
 */
static inline void spi_reset(Spi *p_spi)
{
  400204:	b480      	push	{r7}
  400206:	b083      	sub	sp, #12
  400208:	af00      	add	r7, sp, #0
  40020a:	6078      	str	r0, [r7, #4]
	p_spi->SPI_CR = SPI_CR_SWRST;
  40020c:	687b      	ldr	r3, [r7, #4]
  40020e:	2280      	movs	r2, #128	; 0x80
  400210:	601a      	str	r2, [r3, #0]
}
  400212:	bf00      	nop
  400214:	370c      	adds	r7, #12
  400216:	46bd      	mov	sp, r7
  400218:	f85d 7b04 	ldr.w	r7, [sp], #4
  40021c:	4770      	bx	lr

0040021e <spi_set_lastxfer>:
 *  The next transfer is the last transfer and after that CS is de-asserted.
 *
 * \param p_spi Pointer to an SPI instance.
 */
static inline void spi_set_lastxfer(Spi *p_spi)
{
  40021e:	b480      	push	{r7}
  400220:	b083      	sub	sp, #12
  400222:	af00      	add	r7, sp, #0
  400224:	6078      	str	r0, [r7, #4]
	p_spi->SPI_CR = SPI_CR_LASTXFER;
  400226:	687b      	ldr	r3, [r7, #4]
  400228:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
  40022c:	601a      	str	r2, [r3, #0]
}
  40022e:	bf00      	nop
  400230:	370c      	adds	r7, #12
  400232:	46bd      	mov	sp, r7
  400234:	f85d 7b04 	ldr.w	r7, [sp], #4
  400238:	4770      	bx	lr

0040023a <spi_set_master_mode>:
 * \brief Set SPI to Master mode.
 *
 * \param p_spi Pointer to an SPI instance.
 */
static inline void spi_set_master_mode(Spi *p_spi)
{
  40023a:	b480      	push	{r7}
  40023c:	b083      	sub	sp, #12
  40023e:	af00      	add	r7, sp, #0
  400240:	6078      	str	r0, [r7, #4]
	p_spi->SPI_MR |= SPI_MR_MSTR;
  400242:	687b      	ldr	r3, [r7, #4]
  400244:	685b      	ldr	r3, [r3, #4]
  400246:	f043 0201 	orr.w	r2, r3, #1
  40024a:	687b      	ldr	r3, [r7, #4]
  40024c:	605a      	str	r2, [r3, #4]
}
  40024e:	bf00      	nop
  400250:	370c      	adds	r7, #12
  400252:	46bd      	mov	sp, r7
  400254:	f85d 7b04 	ldr.w	r7, [sp], #4
  400258:	4770      	bx	lr

0040025a <spi_set_fixed_peripheral_select>:
 *  Peripheral Chip Select is controlled by SPI_MR.
 *
 * \param p_spi Pointer to an SPI instance.
 */
static inline void spi_set_fixed_peripheral_select(Spi *p_spi)
{
  40025a:	b480      	push	{r7}
  40025c:	b083      	sub	sp, #12
  40025e:	af00      	add	r7, sp, #0
  400260:	6078      	str	r0, [r7, #4]
	p_spi->SPI_MR &= (~SPI_MR_PS);
  400262:	687b      	ldr	r3, [r7, #4]
  400264:	685b      	ldr	r3, [r3, #4]
  400266:	f023 0202 	bic.w	r2, r3, #2
  40026a:	687b      	ldr	r3, [r7, #4]
  40026c:	605a      	str	r2, [r3, #4]
}
  40026e:	bf00      	nop
  400270:	370c      	adds	r7, #12
  400272:	46bd      	mov	sp, r7
  400274:	f85d 7b04 	ldr.w	r7, [sp], #4
  400278:	4770      	bx	lr

0040027a <spi_disable_peripheral_select_decode>:
 * \brief Disable Peripheral Select Decode.
 *
 * \param p_spi Pointer to an SPI instance.
 */
static inline void spi_disable_peripheral_select_decode(Spi *p_spi)
{
  40027a:	b480      	push	{r7}
  40027c:	b083      	sub	sp, #12
  40027e:	af00      	add	r7, sp, #0
  400280:	6078      	str	r0, [r7, #4]
	p_spi->SPI_MR &= (~SPI_MR_PCSDEC);
  400282:	687b      	ldr	r3, [r7, #4]
  400284:	685b      	ldr	r3, [r3, #4]
  400286:	f023 0204 	bic.w	r2, r3, #4
  40028a:	687b      	ldr	r3, [r7, #4]
  40028c:	605a      	str	r2, [r3, #4]
}
  40028e:	bf00      	nop
  400290:	370c      	adds	r7, #12
  400292:	46bd      	mov	sp, r7
  400294:	f85d 7b04 	ldr.w	r7, [sp], #4
  400298:	4770      	bx	lr

0040029a <spi_get_peripheral_select_decode_setting>:
 * \param p_spi Pointer to an SPI instance.
 *
 * \return 1 for decode mode, 0 for direct mode.
 */
static inline uint32_t spi_get_peripheral_select_decode_setting(Spi *p_spi)
{
  40029a:	b480      	push	{r7}
  40029c:	b083      	sub	sp, #12
  40029e:	af00      	add	r7, sp, #0
  4002a0:	6078      	str	r0, [r7, #4]
	if (p_spi->SPI_MR & SPI_MR_PCSDEC) {
  4002a2:	687b      	ldr	r3, [r7, #4]
  4002a4:	685b      	ldr	r3, [r3, #4]
  4002a6:	f003 0304 	and.w	r3, r3, #4
  4002aa:	2b00      	cmp	r3, #0
  4002ac:	d001      	beq.n	4002b2 <spi_get_peripheral_select_decode_setting+0x18>
		return 1;
  4002ae:	2301      	movs	r3, #1
  4002b0:	e000      	b.n	4002b4 <spi_get_peripheral_select_decode_setting+0x1a>
	} else {
		return 0;
  4002b2:	2300      	movs	r3, #0
	}
}
  4002b4:	4618      	mov	r0, r3
  4002b6:	370c      	adds	r7, #12
  4002b8:	46bd      	mov	sp, r7
  4002ba:	f85d 7b04 	ldr.w	r7, [sp], #4
  4002be:	4770      	bx	lr

004002c0 <spi_disable_mode_fault_detect>:
 * \brief Disable Mode Fault Detection.
 *
 * \param p_spi Pointer to an SPI instance.
 */
static inline void spi_disable_mode_fault_detect(Spi *p_spi)
{
  4002c0:	b480      	push	{r7}
  4002c2:	b083      	sub	sp, #12
  4002c4:	af00      	add	r7, sp, #0
  4002c6:	6078      	str	r0, [r7, #4]
	p_spi->SPI_MR |= SPI_MR_MODFDIS;
  4002c8:	687b      	ldr	r3, [r7, #4]
  4002ca:	685b      	ldr	r3, [r3, #4]
  4002cc:	f043 0210 	orr.w	r2, r3, #16
  4002d0:	687b      	ldr	r3, [r7, #4]
  4002d2:	605a      	str	r2, [r3, #4]
}
  4002d4:	bf00      	nop
  4002d6:	370c      	adds	r7, #12
  4002d8:	46bd      	mov	sp, r7
  4002da:	f85d 7b04 	ldr.w	r7, [sp], #4
  4002de:	4770      	bx	lr

004002e0 <spi_disable_loopback>:
 * \brief Disable loopback mode.
 *
 * \param p_spi Pointer to an SPI instance.
 */
static inline void spi_disable_loopback(Spi *p_spi)
{
  4002e0:	b480      	push	{r7}
  4002e2:	b083      	sub	sp, #12
  4002e4:	af00      	add	r7, sp, #0
  4002e6:	6078      	str	r0, [r7, #4]
	p_spi->SPI_MR &= (~SPI_MR_LLB);
  4002e8:	687b      	ldr	r3, [r7, #4]
  4002ea:	685b      	ldr	r3, [r3, #4]
  4002ec:	f023 0280 	bic.w	r2, r3, #128	; 0x80
  4002f0:	687b      	ldr	r3, [r7, #4]
  4002f2:	605a      	str	r2, [r3, #4]
}
  4002f4:	bf00      	nop
  4002f6:	370c      	adds	r7, #12
  4002f8:	46bd      	mov	sp, r7
  4002fa:	f85d 7b04 	ldr.w	r7, [sp], #4
  4002fe:	4770      	bx	lr

00400300 <spi_put>:
 * \param p_spi Base address of the SPI instance.
 * \param data The data byte to be loaded
 *
 */
static inline void spi_put(Spi *p_spi, uint16_t data)
{
  400300:	b480      	push	{r7}
  400302:	b083      	sub	sp, #12
  400304:	af00      	add	r7, sp, #0
  400306:	6078      	str	r0, [r7, #4]
  400308:	460b      	mov	r3, r1
  40030a:	807b      	strh	r3, [r7, #2]
	p_spi->SPI_TDR = SPI_TDR_TD(data);
  40030c:	887a      	ldrh	r2, [r7, #2]
  40030e:	687b      	ldr	r3, [r7, #4]
  400310:	60da      	str	r2, [r3, #12]
}
  400312:	bf00      	nop
  400314:	370c      	adds	r7, #12
  400316:	46bd      	mov	sp, r7
  400318:	f85d 7b04 	ldr.w	r7, [sp], #4
  40031c:	4770      	bx	lr

0040031e <spi_get>:
 * \param p_spi Base address of the SPI instance.
 * \return The data byte
 *
 */
static inline uint16_t spi_get(Spi *p_spi)
{
  40031e:	b480      	push	{r7}
  400320:	b083      	sub	sp, #12
  400322:	af00      	add	r7, sp, #0
  400324:	6078      	str	r0, [r7, #4]
	return (p_spi->SPI_RDR & SPI_RDR_RD_Msk);
  400326:	687b      	ldr	r3, [r7, #4]
  400328:	689b      	ldr	r3, [r3, #8]
  40032a:	b29b      	uxth	r3, r3
}
  40032c:	4618      	mov	r0, r3
  40032e:	370c      	adds	r7, #12
  400330:	46bd      	mov	sp, r7
  400332:	f85d 7b04 	ldr.w	r7, [sp], #4
  400336:	4770      	bx	lr

00400338 <spi_is_tx_empty>:
 *
 * \retval 1 if transmissions are complete.
 * \retval 0 if transmissions are not complete.
 */
static inline uint32_t spi_is_tx_empty(Spi *p_spi)
{
  400338:	b480      	push	{r7}
  40033a:	b083      	sub	sp, #12
  40033c:	af00      	add	r7, sp, #0
  40033e:	6078      	str	r0, [r7, #4]
	if (p_spi->SPI_SR & SPI_SR_TXEMPTY) {
  400340:	687b      	ldr	r3, [r7, #4]
  400342:	691b      	ldr	r3, [r3, #16]
  400344:	f403 7300 	and.w	r3, r3, #512	; 0x200
  400348:	2b00      	cmp	r3, #0
  40034a:	d001      	beq.n	400350 <spi_is_tx_empty+0x18>
		return 1;
  40034c:	2301      	movs	r3, #1
  40034e:	e000      	b.n	400352 <spi_is_tx_empty+0x1a>
	} else {
		return 0;
  400350:	2300      	movs	r3, #0
	}
}
  400352:	4618      	mov	r0, r3
  400354:	370c      	adds	r7, #12
  400356:	46bd      	mov	sp, r7
  400358:	f85d 7b04 	ldr.w	r7, [sp], #4
  40035c:	4770      	bx	lr

0040035e <spi_is_tx_ready>:
 *
 * \retval 1 if transmissions are complete.
 * \retval 0 if transmissions are not complete.
 */
static inline uint32_t spi_is_tx_ready(Spi *p_spi)
{
  40035e:	b480      	push	{r7}
  400360:	b083      	sub	sp, #12
  400362:	af00      	add	r7, sp, #0
  400364:	6078      	str	r0, [r7, #4]
	if (p_spi->SPI_SR & SPI_SR_TDRE) {
  400366:	687b      	ldr	r3, [r7, #4]
  400368:	691b      	ldr	r3, [r3, #16]
  40036a:	f003 0302 	and.w	r3, r3, #2
  40036e:	2b00      	cmp	r3, #0
  400370:	d001      	beq.n	400376 <spi_is_tx_ready+0x18>
		return 1;
  400372:	2301      	movs	r3, #1
  400374:	e000      	b.n	400378 <spi_is_tx_ready+0x1a>
	} else {
		return 0;
  400376:	2300      	movs	r3, #0
	}
}
  400378:	4618      	mov	r0, r3
  40037a:	370c      	adds	r7, #12
  40037c:	46bd      	mov	sp, r7
  40037e:	f85d 7b04 	ldr.w	r7, [sp], #4
  400382:	4770      	bx	lr

00400384 <spi_is_rx_ready>:
 * \param p_spi Pointer to an SPI instance.
 *
 * \return 1 if the SPI Receiver is ready, otherwise 0.
 */
static inline uint32_t spi_is_rx_ready(Spi *p_spi)
{
  400384:	b480      	push	{r7}
  400386:	b083      	sub	sp, #12
  400388:	af00      	add	r7, sp, #0
  40038a:	6078      	str	r0, [r7, #4]
	if ((p_spi->SPI_SR & (SPI_SR_RDRF | SPI_SR_TXEMPTY))
  40038c:	687b      	ldr	r3, [r7, #4]
  40038e:	691a      	ldr	r2, [r3, #16]
  400390:	f240 2301 	movw	r3, #513	; 0x201
  400394:	4013      	ands	r3, r2
  400396:	f240 2201 	movw	r2, #513	; 0x201
  40039a:	4293      	cmp	r3, r2
  40039c:	d101      	bne.n	4003a2 <spi_is_rx_ready+0x1e>
			== (SPI_SR_RDRF | SPI_SR_TXEMPTY)) {
		return 1;
  40039e:	2301      	movs	r3, #1
  4003a0:	e000      	b.n	4003a4 <spi_is_rx_ready+0x20>
	} else {
		return 0;
  4003a2:	2300      	movs	r3, #0
	}
}
  4003a4:	4618      	mov	r0, r3
  4003a6:	370c      	adds	r7, #12
  4003a8:	46bd      	mov	sp, r7
  4003aa:	f85d 7b04 	ldr.w	r7, [sp], #4
  4003ae:	4770      	bx	lr

004003b0 <spi_write_single>:
 * \param p_spi     Base address of the SPI instance.
 * \param data      Data to write.
 *
 */
static inline void spi_write_single(Spi *p_spi, uint8_t data)
{
  4003b0:	b580      	push	{r7, lr}
  4003b2:	b082      	sub	sp, #8
  4003b4:	af00      	add	r7, sp, #0
  4003b6:	6078      	str	r0, [r7, #4]
  4003b8:	460b      	mov	r3, r1
  4003ba:	70fb      	strb	r3, [r7, #3]
	spi_put(p_spi, (uint16_t)data);
  4003bc:	78fb      	ldrb	r3, [r7, #3]
  4003be:	b29b      	uxth	r3, r3
  4003c0:	4619      	mov	r1, r3
  4003c2:	6878      	ldr	r0, [r7, #4]
  4003c4:	4b02      	ldr	r3, [pc, #8]	; (4003d0 <spi_write_single+0x20>)
  4003c6:	4798      	blx	r3
}
  4003c8:	bf00      	nop
  4003ca:	3708      	adds	r7, #8
  4003cc:	46bd      	mov	sp, r7
  4003ce:	bd80      	pop	{r7, pc}
  4003d0:	00400301 	.word	0x00400301

004003d4 <spi_read_single>:
 * \param p_spi     Base address of the SPI instance.
 * \param data      Data to read.
 *
 */
static inline void spi_read_single(Spi *p_spi, uint8_t *data)
{
  4003d4:	b580      	push	{r7, lr}
  4003d6:	b082      	sub	sp, #8
  4003d8:	af00      	add	r7, sp, #0
  4003da:	6078      	str	r0, [r7, #4]
  4003dc:	6039      	str	r1, [r7, #0]
	*data = (uint8_t)spi_get(p_spi);
  4003de:	6878      	ldr	r0, [r7, #4]
  4003e0:	4b04      	ldr	r3, [pc, #16]	; (4003f4 <spi_read_single+0x20>)
  4003e2:	4798      	blx	r3
  4003e4:	4603      	mov	r3, r0
  4003e6:	b2da      	uxtb	r2, r3
  4003e8:	683b      	ldr	r3, [r7, #0]
  4003ea:	701a      	strb	r2, [r3, #0]
}
  4003ec:	bf00      	nop
  4003ee:	3708      	adds	r7, #8
  4003f0:	46bd      	mov	sp, r7
  4003f2:	bd80      	pop	{r7, pc}
  4003f4:	0040031f 	.word	0x0040031f

004003f8 <spi_master_init>:
 *
 * \param p_spi  Base address of the SPI instance.
 *
 */
void spi_master_init(Spi *p_spi)
{
  4003f8:	b580      	push	{r7, lr}
  4003fa:	b082      	sub	sp, #8
  4003fc:	af00      	add	r7, sp, #0
  4003fe:	6078      	str	r0, [r7, #4]
#if SAMG55
	flexcom_enable(BOARD_FLEXCOM_SPI);
	flexcom_set_opmode(BOARD_FLEXCOM_SPI, FLEXCOM_SPI);
#else
	spi_enable_clock(p_spi);
  400400:	6878      	ldr	r0, [r7, #4]
  400402:	4b10      	ldr	r3, [pc, #64]	; (400444 <spi_master_init+0x4c>)
  400404:	4798      	blx	r3
#endif
	spi_reset(p_spi);
  400406:	6878      	ldr	r0, [r7, #4]
  400408:	4b0f      	ldr	r3, [pc, #60]	; (400448 <spi_master_init+0x50>)
  40040a:	4798      	blx	r3
	spi_set_master_mode(p_spi);
  40040c:	6878      	ldr	r0, [r7, #4]
  40040e:	4b0f      	ldr	r3, [pc, #60]	; (40044c <spi_master_init+0x54>)
  400410:	4798      	blx	r3
	spi_disable_mode_fault_detect(p_spi);
  400412:	6878      	ldr	r0, [r7, #4]
  400414:	4b0e      	ldr	r3, [pc, #56]	; (400450 <spi_master_init+0x58>)
  400416:	4798      	blx	r3
	spi_disable_loopback(p_spi);
  400418:	6878      	ldr	r0, [r7, #4]
  40041a:	4b0e      	ldr	r3, [pc, #56]	; (400454 <spi_master_init+0x5c>)
  40041c:	4798      	blx	r3
	spi_set_peripheral_chip_select_value(p_spi, DEFAULT_CHIP_ID);
  40041e:	2100      	movs	r1, #0
  400420:	6878      	ldr	r0, [r7, #4]
  400422:	4b0d      	ldr	r3, [pc, #52]	; (400458 <spi_master_init+0x60>)
  400424:	4798      	blx	r3
	spi_set_fixed_peripheral_select(p_spi);
  400426:	6878      	ldr	r0, [r7, #4]
  400428:	4b0c      	ldr	r3, [pc, #48]	; (40045c <spi_master_init+0x64>)
  40042a:	4798      	blx	r3
	spi_disable_peripheral_select_decode(p_spi);
  40042c:	6878      	ldr	r0, [r7, #4]
  40042e:	4b0c      	ldr	r3, [pc, #48]	; (400460 <spi_master_init+0x68>)
  400430:	4798      	blx	r3
	spi_set_delay_between_chip_select(p_spi, CONFIG_SPI_MASTER_DELAY_BCS);
  400432:	2100      	movs	r1, #0
  400434:	6878      	ldr	r0, [r7, #4]
  400436:	4b0b      	ldr	r3, [pc, #44]	; (400464 <spi_master_init+0x6c>)
  400438:	4798      	blx	r3
}
  40043a:	bf00      	nop
  40043c:	3708      	adds	r7, #8
  40043e:	46bd      	mov	sp, r7
  400440:	bd80      	pop	{r7, pc}
  400442:	bf00      	nop
  400444:	00404491 	.word	0x00404491
  400448:	00400205 	.word	0x00400205
  40044c:	0040023b 	.word	0x0040023b
  400450:	004002c1 	.word	0x004002c1
  400454:	004002e1 	.word	0x004002e1
  400458:	004044ad 	.word	0x004044ad
  40045c:	0040025b 	.word	0x0040025b
  400460:	0040027b 	.word	0x0040027b
  400464:	004044e1 	.word	0x004044e1

00400468 <spi_master_setup_device>:
 * \param baud_rate Baud rate for communication with slave device in Hz.
 * \param sel_id    Board specific select id.
 */
void spi_master_setup_device(Spi *p_spi, struct spi_device *device,
		spi_flags_t flags, uint32_t baud_rate, board_spi_select_id_t sel_id)
{
  400468:	b590      	push	{r4, r7, lr}
  40046a:	b087      	sub	sp, #28
  40046c:	af00      	add	r7, sp, #0
  40046e:	60f8      	str	r0, [r7, #12]
  400470:	60b9      	str	r1, [r7, #8]
  400472:	603b      	str	r3, [r7, #0]
  400474:	4613      	mov	r3, r2
  400476:	71fb      	strb	r3, [r7, #7]
#if (SAM4L)
    int16_t baud_div = spi_calc_baudrate_div(baud_rate, sysclk_get_pba_hz());
#else
	int16_t baud_div = spi_calc_baudrate_div(baud_rate, sysclk_get_peripheral_hz());
  400478:	4b20      	ldr	r3, [pc, #128]	; (4004fc <spi_master_setup_device+0x94>)
  40047a:	4798      	blx	r3
  40047c:	4603      	mov	r3, r0
  40047e:	4619      	mov	r1, r3
  400480:	6838      	ldr	r0, [r7, #0]
  400482:	4b1f      	ldr	r3, [pc, #124]	; (400500 <spi_master_setup_device+0x98>)
  400484:	4798      	blx	r3
  400486:	4603      	mov	r3, r0
  400488:	82fb      	strh	r3, [r7, #22]
	/* avoid Cppcheck Warning */
	UNUSED(sel_id);
	if (-1 == baud_div) {
		Assert(0 == "Failed to find baudrate divider");
	}
	spi_set_transfer_delay(p_spi, device->id, CONFIG_SPI_MASTER_DELAY_BS,
  40048a:	68bb      	ldr	r3, [r7, #8]
  40048c:	6819      	ldr	r1, [r3, #0]
  40048e:	2300      	movs	r3, #0
  400490:	2200      	movs	r2, #0
  400492:	68f8      	ldr	r0, [r7, #12]
  400494:	4c1b      	ldr	r4, [pc, #108]	; (400504 <spi_master_setup_device+0x9c>)
  400496:	47a0      	blx	r4
			CONFIG_SPI_MASTER_DELAY_BCT);
	spi_set_bits_per_transfer(p_spi, device->id,
  400498:	68bb      	ldr	r3, [r7, #8]
  40049a:	681b      	ldr	r3, [r3, #0]
  40049c:	2208      	movs	r2, #8
  40049e:	4619      	mov	r1, r3
  4004a0:	68f8      	ldr	r0, [r7, #12]
  4004a2:	4b19      	ldr	r3, [pc, #100]	; (400508 <spi_master_setup_device+0xa0>)
  4004a4:	4798      	blx	r3
			CONFIG_SPI_MASTER_BITS_PER_TRANSFER);
	spi_set_baudrate_div(p_spi, device->id, baud_div);
  4004a6:	68bb      	ldr	r3, [r7, #8]
  4004a8:	681b      	ldr	r3, [r3, #0]
  4004aa:	8afa      	ldrh	r2, [r7, #22]
  4004ac:	b2d2      	uxtb	r2, r2
  4004ae:	4619      	mov	r1, r3
  4004b0:	68f8      	ldr	r0, [r7, #12]
  4004b2:	4b16      	ldr	r3, [pc, #88]	; (40050c <spi_master_setup_device+0xa4>)
  4004b4:	4798      	blx	r3
	spi_configure_cs_behavior(p_spi, device->id, SPI_CS_KEEP_LOW);
  4004b6:	68bb      	ldr	r3, [r7, #8]
  4004b8:	681b      	ldr	r3, [r3, #0]
  4004ba:	2208      	movs	r2, #8
  4004bc:	4619      	mov	r1, r3
  4004be:	68f8      	ldr	r0, [r7, #12]
  4004c0:	4b13      	ldr	r3, [pc, #76]	; (400510 <spi_master_setup_device+0xa8>)
  4004c2:	4798      	blx	r3
	spi_set_clock_polarity(p_spi, device->id, flags >> 1);
  4004c4:	68bb      	ldr	r3, [r7, #8]
  4004c6:	6819      	ldr	r1, [r3, #0]
  4004c8:	79fb      	ldrb	r3, [r7, #7]
  4004ca:	085b      	lsrs	r3, r3, #1
  4004cc:	b2db      	uxtb	r3, r3
  4004ce:	461a      	mov	r2, r3
  4004d0:	68f8      	ldr	r0, [r7, #12]
  4004d2:	4b10      	ldr	r3, [pc, #64]	; (400514 <spi_master_setup_device+0xac>)
  4004d4:	4798      	blx	r3
	spi_set_clock_phase(p_spi, device->id, ((flags & 0x1) ^ 0x1));
  4004d6:	68bb      	ldr	r3, [r7, #8]
  4004d8:	6819      	ldr	r1, [r3, #0]
  4004da:	79fb      	ldrb	r3, [r7, #7]
  4004dc:	f003 0301 	and.w	r3, r3, #1
  4004e0:	2b00      	cmp	r3, #0
  4004e2:	bf0c      	ite	eq
  4004e4:	2301      	moveq	r3, #1
  4004e6:	2300      	movne	r3, #0
  4004e8:	b2db      	uxtb	r3, r3
  4004ea:	461a      	mov	r2, r3
  4004ec:	68f8      	ldr	r0, [r7, #12]
  4004ee:	4b0a      	ldr	r3, [pc, #40]	; (400518 <spi_master_setup_device+0xb0>)
  4004f0:	4798      	blx	r3
}
  4004f2:	bf00      	nop
  4004f4:	371c      	adds	r7, #28
  4004f6:	46bd      	mov	sp, r7
  4004f8:	bd90      	pop	{r4, r7, pc}
  4004fa:	bf00      	nop
  4004fc:	004001f1 	.word	0x004001f1
  400500:	004046a1 	.word	0x004046a1
  400504:	0040473b 	.word	0x0040473b
  400508:	00404657 	.word	0x00404657
  40050c:	004046dd 	.word	0x004046dd
  400510:	004045b1 	.word	0x004045b1
  400514:	00404511 	.word	0x00404511
  400518:	00404561 	.word	0x00404561

0040051c <spi_select_device>:
 * \param p_spi   Base address of the SPI instance.
 * \param device  SPI device.
 *
 */
void spi_select_device(Spi *p_spi, struct spi_device *device)
{
  40051c:	b580      	push	{r7, lr}
  40051e:	b082      	sub	sp, #8
  400520:	af00      	add	r7, sp, #0
  400522:	6078      	str	r0, [r7, #4]
  400524:	6039      	str	r1, [r7, #0]
	if (spi_get_peripheral_select_decode_setting(p_spi)) {
  400526:	6878      	ldr	r0, [r7, #4]
  400528:	4b10      	ldr	r3, [pc, #64]	; (40056c <spi_select_device+0x50>)
  40052a:	4798      	blx	r3
  40052c:	4603      	mov	r3, r0
  40052e:	2b00      	cmp	r3, #0
  400530:	d00a      	beq.n	400548 <spi_select_device+0x2c>
		if (device->id < MAX_NUM_WITH_DECODER) {
  400532:	683b      	ldr	r3, [r7, #0]
  400534:	681b      	ldr	r3, [r3, #0]
  400536:	2b0f      	cmp	r3, #15
  400538:	d814      	bhi.n	400564 <spi_select_device+0x48>
			spi_set_peripheral_chip_select_value(p_spi, device->id);
  40053a:	683b      	ldr	r3, [r7, #0]
  40053c:	681b      	ldr	r3, [r3, #0]
  40053e:	4619      	mov	r1, r3
  400540:	6878      	ldr	r0, [r7, #4]
  400542:	4b0b      	ldr	r3, [pc, #44]	; (400570 <spi_select_device+0x54>)
  400544:	4798      	blx	r3
	} else {
		if (device->id < MAX_NUM_WITHOUT_DECODER) {
			spi_set_peripheral_chip_select_value(p_spi, (~(1 << device->id)));
		}
	}
}
  400546:	e00d      	b.n	400564 <spi_select_device+0x48>
		if (device->id < MAX_NUM_WITHOUT_DECODER) {
  400548:	683b      	ldr	r3, [r7, #0]
  40054a:	681b      	ldr	r3, [r3, #0]
  40054c:	2b03      	cmp	r3, #3
  40054e:	d809      	bhi.n	400564 <spi_select_device+0x48>
			spi_set_peripheral_chip_select_value(p_spi, (~(1 << device->id)));
  400550:	683b      	ldr	r3, [r7, #0]
  400552:	681b      	ldr	r3, [r3, #0]
  400554:	2201      	movs	r2, #1
  400556:	fa02 f303 	lsl.w	r3, r2, r3
  40055a:	43db      	mvns	r3, r3
  40055c:	4619      	mov	r1, r3
  40055e:	6878      	ldr	r0, [r7, #4]
  400560:	4b03      	ldr	r3, [pc, #12]	; (400570 <spi_select_device+0x54>)
  400562:	4798      	blx	r3
}
  400564:	bf00      	nop
  400566:	3708      	adds	r7, #8
  400568:	46bd      	mov	sp, r7
  40056a:	bd80      	pop	{r7, pc}
  40056c:	0040029b 	.word	0x0040029b
  400570:	004044ad 	.word	0x004044ad

00400574 <spi_deselect_device>:
 * \param device  SPI device.
 *
 * \pre SPI device must be selected with spi_select_device() first.
 */
void spi_deselect_device(Spi *p_spi, struct spi_device *device)
{
  400574:	b580      	push	{r7, lr}
  400576:	b082      	sub	sp, #8
  400578:	af00      	add	r7, sp, #0
  40057a:	6078      	str	r0, [r7, #4]
  40057c:	6039      	str	r1, [r7, #0]
	/* avoid Cppcheck Warning */
	UNUSED(device);
	while (!spi_is_tx_empty(p_spi)) {
  40057e:	bf00      	nop
  400580:	6878      	ldr	r0, [r7, #4]
  400582:	4b08      	ldr	r3, [pc, #32]	; (4005a4 <spi_deselect_device+0x30>)
  400584:	4798      	blx	r3
  400586:	4603      	mov	r3, r0
  400588:	2b00      	cmp	r3, #0
  40058a:	d0f9      	beq.n	400580 <spi_deselect_device+0xc>
	}

	// Assert all lines; no peripheral is selected.
	spi_set_peripheral_chip_select_value(p_spi, NONE_CHIP_SELECT_ID);
  40058c:	210f      	movs	r1, #15
  40058e:	6878      	ldr	r0, [r7, #4]
  400590:	4b05      	ldr	r3, [pc, #20]	; (4005a8 <spi_deselect_device+0x34>)
  400592:	4798      	blx	r3

	// Last transfer, so de-assert the current NPCS if CSAAT is set.
	spi_set_lastxfer(p_spi);
  400594:	6878      	ldr	r0, [r7, #4]
  400596:	4b05      	ldr	r3, [pc, #20]	; (4005ac <spi_deselect_device+0x38>)
  400598:	4798      	blx	r3

}
  40059a:	bf00      	nop
  40059c:	3708      	adds	r7, #8
  40059e:	46bd      	mov	sp, r7
  4005a0:	bd80      	pop	{r7, pc}
  4005a2:	bf00      	nop
  4005a4:	00400339 	.word	0x00400339
  4005a8:	004044ad 	.word	0x004044ad
  4005ac:	0040021f 	.word	0x0040021f

004005b0 <spi_write_packet>:
 *
 * \pre SPI device must be selected with spi_select_device() first.
 */
status_code_t spi_write_packet(Spi *p_spi, const uint8_t *data,
		size_t len)
{
  4005b0:	b580      	push	{r7, lr}
  4005b2:	b088      	sub	sp, #32
  4005b4:	af00      	add	r7, sp, #0
  4005b6:	60f8      	str	r0, [r7, #12]
  4005b8:	60b9      	str	r1, [r7, #8]
  4005ba:	607a      	str	r2, [r7, #4]
	uint32_t timeout = SPI_TIMEOUT;
  4005bc:	f643 2398 	movw	r3, #15000	; 0x3a98
  4005c0:	61fb      	str	r3, [r7, #28]
	uint32_t i = 0;
  4005c2:	2300      	movs	r3, #0
  4005c4:	61bb      	str	r3, [r7, #24]
	uint8_t val;

	while (len) {
  4005c6:	e021      	b.n	40060c <spi_write_packet+0x5c>
		timeout = SPI_TIMEOUT;
  4005c8:	f643 2398 	movw	r3, #15000	; 0x3a98
  4005cc:	61fb      	str	r3, [r7, #28]
		while (!spi_is_tx_ready(p_spi)) {
  4005ce:	e007      	b.n	4005e0 <spi_write_packet+0x30>
			if (!timeout--) {
  4005d0:	69fb      	ldr	r3, [r7, #28]
  4005d2:	1e5a      	subs	r2, r3, #1
  4005d4:	61fa      	str	r2, [r7, #28]
  4005d6:	2b00      	cmp	r3, #0
  4005d8:	d102      	bne.n	4005e0 <spi_write_packet+0x30>
				return ERR_TIMEOUT;
  4005da:	f06f 0302 	mvn.w	r3, #2
  4005de:	e019      	b.n	400614 <spi_write_packet+0x64>
		while (!spi_is_tx_ready(p_spi)) {
  4005e0:	68f8      	ldr	r0, [r7, #12]
  4005e2:	4b0e      	ldr	r3, [pc, #56]	; (40061c <spi_write_packet+0x6c>)
  4005e4:	4798      	blx	r3
  4005e6:	4603      	mov	r3, r0
  4005e8:	2b00      	cmp	r3, #0
  4005ea:	d0f1      	beq.n	4005d0 <spi_write_packet+0x20>
			}
		}
		val = data[i];
  4005ec:	68ba      	ldr	r2, [r7, #8]
  4005ee:	69bb      	ldr	r3, [r7, #24]
  4005f0:	4413      	add	r3, r2
  4005f2:	781b      	ldrb	r3, [r3, #0]
  4005f4:	75fb      	strb	r3, [r7, #23]
		spi_write_single(p_spi, val);
  4005f6:	7dfb      	ldrb	r3, [r7, #23]
  4005f8:	4619      	mov	r1, r3
  4005fa:	68f8      	ldr	r0, [r7, #12]
  4005fc:	4b08      	ldr	r3, [pc, #32]	; (400620 <spi_write_packet+0x70>)
  4005fe:	4798      	blx	r3
		i++;
  400600:	69bb      	ldr	r3, [r7, #24]
  400602:	3301      	adds	r3, #1
  400604:	61bb      	str	r3, [r7, #24]
		len--;
  400606:	687b      	ldr	r3, [r7, #4]
  400608:	3b01      	subs	r3, #1
  40060a:	607b      	str	r3, [r7, #4]
	while (len) {
  40060c:	687b      	ldr	r3, [r7, #4]
  40060e:	2b00      	cmp	r3, #0
  400610:	d1da      	bne.n	4005c8 <spi_write_packet+0x18>
	}

	return STATUS_OK;
  400612:	2300      	movs	r3, #0
}
  400614:	4618      	mov	r0, r3
  400616:	3720      	adds	r7, #32
  400618:	46bd      	mov	sp, r7
  40061a:	bd80      	pop	{r7, pc}
  40061c:	0040035f 	.word	0x0040035f
  400620:	004003b1 	.word	0x004003b1

00400624 <spi_read_packet>:
 * \param len       Length of data to be read.
 *
 * \pre SPI device must be selected with spi_select_device() first.
 */
status_code_t spi_read_packet(Spi *p_spi, uint8_t *data, size_t len)
{
  400624:	b580      	push	{r7, lr}
  400626:	b088      	sub	sp, #32
  400628:	af00      	add	r7, sp, #0
  40062a:	60f8      	str	r0, [r7, #12]
  40062c:	60b9      	str	r1, [r7, #8]
  40062e:	607a      	str	r2, [r7, #4]
	uint32_t timeout = SPI_TIMEOUT;
  400630:	f643 2398 	movw	r3, #15000	; 0x3a98
  400634:	61fb      	str	r3, [r7, #28]
	uint8_t val;
	uint32_t i = 0;
  400636:	2300      	movs	r3, #0
  400638:	61bb      	str	r3, [r7, #24]

	while (len) {
  40063a:	e038      	b.n	4006ae <spi_read_packet+0x8a>
		timeout = SPI_TIMEOUT;
  40063c:	f643 2398 	movw	r3, #15000	; 0x3a98
  400640:	61fb      	str	r3, [r7, #28]
		while (!spi_is_tx_ready(p_spi)) {
  400642:	e007      	b.n	400654 <spi_read_packet+0x30>
			if (!timeout--) {
  400644:	69fb      	ldr	r3, [r7, #28]
  400646:	1e5a      	subs	r2, r3, #1
  400648:	61fa      	str	r2, [r7, #28]
  40064a:	2b00      	cmp	r3, #0
  40064c:	d102      	bne.n	400654 <spi_read_packet+0x30>
				return ERR_TIMEOUT;
  40064e:	f06f 0302 	mvn.w	r3, #2
  400652:	e030      	b.n	4006b6 <spi_read_packet+0x92>
		while (!spi_is_tx_ready(p_spi)) {
  400654:	68f8      	ldr	r0, [r7, #12]
  400656:	4b1a      	ldr	r3, [pc, #104]	; (4006c0 <spi_read_packet+0x9c>)
  400658:	4798      	blx	r3
  40065a:	4603      	mov	r3, r0
  40065c:	2b00      	cmp	r3, #0
  40065e:	d0f1      	beq.n	400644 <spi_read_packet+0x20>
			}
		}
		spi_write_single(p_spi, CONFIG_SPI_MASTER_DUMMY);
  400660:	2180      	movs	r1, #128	; 0x80
  400662:	68f8      	ldr	r0, [r7, #12]
  400664:	4b17      	ldr	r3, [pc, #92]	; (4006c4 <spi_read_packet+0xa0>)
  400666:	4798      	blx	r3

		timeout = SPI_TIMEOUT;
  400668:	f643 2398 	movw	r3, #15000	; 0x3a98
  40066c:	61fb      	str	r3, [r7, #28]
		while (!spi_is_rx_ready(p_spi)) {
  40066e:	e007      	b.n	400680 <spi_read_packet+0x5c>
			if (!timeout--) {
  400670:	69fb      	ldr	r3, [r7, #28]
  400672:	1e5a      	subs	r2, r3, #1
  400674:	61fa      	str	r2, [r7, #28]
  400676:	2b00      	cmp	r3, #0
  400678:	d102      	bne.n	400680 <spi_read_packet+0x5c>
				return ERR_TIMEOUT;
  40067a:	f06f 0302 	mvn.w	r3, #2
  40067e:	e01a      	b.n	4006b6 <spi_read_packet+0x92>
		while (!spi_is_rx_ready(p_spi)) {
  400680:	68f8      	ldr	r0, [r7, #12]
  400682:	4b11      	ldr	r3, [pc, #68]	; (4006c8 <spi_read_packet+0xa4>)
  400684:	4798      	blx	r3
  400686:	4603      	mov	r3, r0
  400688:	2b00      	cmp	r3, #0
  40068a:	d0f1      	beq.n	400670 <spi_read_packet+0x4c>
			}
		}
		spi_read_single(p_spi, &val);
  40068c:	f107 0317 	add.w	r3, r7, #23
  400690:	4619      	mov	r1, r3
  400692:	68f8      	ldr	r0, [r7, #12]
  400694:	4b0d      	ldr	r3, [pc, #52]	; (4006cc <spi_read_packet+0xa8>)
  400696:	4798      	blx	r3

		data[i] = val;
  400698:	68ba      	ldr	r2, [r7, #8]
  40069a:	69bb      	ldr	r3, [r7, #24]
  40069c:	4413      	add	r3, r2
  40069e:	7dfa      	ldrb	r2, [r7, #23]
  4006a0:	701a      	strb	r2, [r3, #0]
		i++;
  4006a2:	69bb      	ldr	r3, [r7, #24]
  4006a4:	3301      	adds	r3, #1
  4006a6:	61bb      	str	r3, [r7, #24]
		len--;
  4006a8:	687b      	ldr	r3, [r7, #4]
  4006aa:	3b01      	subs	r3, #1
  4006ac:	607b      	str	r3, [r7, #4]
	while (len) {
  4006ae:	687b      	ldr	r3, [r7, #4]
  4006b0:	2b00      	cmp	r3, #0
  4006b2:	d1c3      	bne.n	40063c <spi_read_packet+0x18>
	}

	return STATUS_OK;
  4006b4:	2300      	movs	r3, #0
}
  4006b6:	4618      	mov	r0, r3
  4006b8:	3720      	adds	r7, #32
  4006ba:	46bd      	mov	sp, r7
  4006bc:	bd80      	pop	{r7, pc}
  4006be:	bf00      	nop
  4006c0:	0040035f 	.word	0x0040035f
  4006c4:	004003b1 	.word	0x004003b1
  4006c8:	00400385 	.word	0x00400385
  4006cc:	004003d5 	.word	0x004003d5

004006d0 <ioport_set_pin_level>:
 *
 * \param pin IOPORT pin to configure
 * \param level Logical value of the pin
 */
static inline void ioport_set_pin_level(ioport_pin_t pin, bool level)
{
  4006d0:	b480      	push	{r7}
  4006d2:	b08b      	sub	sp, #44	; 0x2c
  4006d4:	af00      	add	r7, sp, #0
  4006d6:	6078      	str	r0, [r7, #4]
  4006d8:	460b      	mov	r3, r1
  4006da:	70fb      	strb	r3, [r7, #3]
  4006dc:	687b      	ldr	r3, [r7, #4]
  4006de:	627b      	str	r3, [r7, #36]	; 0x24
  4006e0:	78fb      	ldrb	r3, [r7, #3]
  4006e2:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
  4006e6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4006e8:	61fb      	str	r3, [r7, #28]
  4006ea:	69fb      	ldr	r3, [r7, #28]
  4006ec:	61bb      	str	r3, [r7, #24]
typedef uint32_t ioport_port_t;
typedef uint32_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 5;
  4006ee:	69bb      	ldr	r3, [r7, #24]
  4006f0:	095b      	lsrs	r3, r3, #5
  4006f2:	617b      	str	r3, [r7, #20]
	} else {
		return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
		       (IOPORT_PIO_OFFSET * port));
	}
#else
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  4006f4:	697b      	ldr	r3, [r7, #20]
  4006f6:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  4006fa:	f203 7307 	addw	r3, r3, #1799	; 0x707
  4006fe:	025b      	lsls	r3, r3, #9
}

__always_inline static void arch_ioport_set_pin_level(ioport_pin_t pin,
		bool level)
{
	Pio *base = arch_ioport_pin_to_base(pin);
  400700:	613b      	str	r3, [r7, #16]

	if (level) {
  400702:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
  400706:	2b00      	cmp	r3, #0
  400708:	d009      	beq.n	40071e <ioport_set_pin_level+0x4e>
  40070a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40070c:	60fb      	str	r3, [r7, #12]
	return 1U << (pin & 0x1F);
  40070e:	68fb      	ldr	r3, [r7, #12]
  400710:	f003 031f 	and.w	r3, r3, #31
  400714:	2201      	movs	r2, #1
  400716:	409a      	lsls	r2, r3
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  400718:	693b      	ldr	r3, [r7, #16]
  40071a:	631a      	str	r2, [r3, #48]	; 0x30
	arch_ioport_set_pin_level(pin, level);
}
  40071c:	e008      	b.n	400730 <ioport_set_pin_level+0x60>
  40071e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  400720:	60bb      	str	r3, [r7, #8]
	return 1U << (pin & 0x1F);
  400722:	68bb      	ldr	r3, [r7, #8]
  400724:	f003 031f 	and.w	r3, r3, #31
  400728:	2201      	movs	r2, #1
  40072a:	409a      	lsls	r2, r3
	} else {
		base->PIO_CODR = arch_ioport_pin_to_mask(pin);
  40072c:	693b      	ldr	r3, [r7, #16]
  40072e:	635a      	str	r2, [r3, #52]	; 0x34
  400730:	bf00      	nop
  400732:	372c      	adds	r7, #44	; 0x2c
  400734:	46bd      	mov	sp, r7
  400736:	f85d 7b04 	ldr.w	r7, [sp], #4
  40073a:	4770      	bx	lr

0040073c <ui_init>:

#include <asf.h>
#include "ui.h"

void ui_init(void)
{
  40073c:	b580      	push	{r7, lr}
  40073e:	af00      	add	r7, sp, #0
	LED_On(LED0);
  400740:	2100      	movs	r1, #0
  400742:	2076      	movs	r0, #118	; 0x76
  400744:	4b01      	ldr	r3, [pc, #4]	; (40074c <ui_init+0x10>)
  400746:	4798      	blx	r3
}
  400748:	bf00      	nop
  40074a:	bd80      	pop	{r7, pc}
  40074c:	004006d1 	.word	0x004006d1

00400750 <ui_powerdown>:

void ui_powerdown(void)
{
  400750:	b480      	push	{r7}
  400752:	af00      	add	r7, sp, #0
	// HICS_TESTE LED_Off(LED0);
}
  400754:	bf00      	nop
  400756:	46bd      	mov	sp, r7
  400758:	f85d 7b04 	ldr.w	r7, [sp], #4
  40075c:	4770      	bx	lr

0040075e <ui_wakeup>:

void ui_wakeup(void)
{
  40075e:	b480      	push	{r7}
  400760:	af00      	add	r7, sp, #0
	// HICS_TESTE LED_On(LED0);
}
  400762:	bf00      	nop
  400764:	46bd      	mov	sp, r7
  400766:	f85d 7b04 	ldr.w	r7, [sp], #4
  40076a:	4770      	bx	lr

0040076c <ui_process>:
void ui_stop_write(void)
{
}

void ui_process(uint16_t framenumber)
{
  40076c:	b480      	push	{r7}
  40076e:	b083      	sub	sp, #12
  400770:	af00      	add	r7, sp, #0
  400772:	4603      	mov	r3, r0
  400774:	80fb      	strh	r3, [r7, #6]
		// HICS_TESTE LED_On(LED0);
	}
	if (1000 == framenumber) {
		// HICS_TESTE LED_Off(LED0);
	}
}
  400776:	bf00      	nop
  400778:	370c      	adds	r7, #12
  40077a:	46bd      	mov	sp, r7
  40077c:	f85d 7b04 	ldr.w	r7, [sp], #4
  400780:	4770      	bx	lr
	...

00400784 <virtual_test_unit_ready>:
//!   It is ready                ->    CTRL_GOOD
//!   Memory unplug              ->    CTRL_NO_PRESENT
//!   Not initialized or changed ->    CTRL_BUSY
//!   An error occurred          ->    CTRL_FAIL
Ctrl_status virtual_test_unit_ready(void)
{
  400784:	b480      	push	{r7}
  400786:	af00      	add	r7, sp, #0
	return b_vmem_unloaded ? CTRL_NO_PRESENT : CTRL_GOOD;
  400788:	4b05      	ldr	r3, [pc, #20]	; (4007a0 <virtual_test_unit_ready+0x1c>)
  40078a:	781b      	ldrb	r3, [r3, #0]
  40078c:	2b00      	cmp	r3, #0
  40078e:	d001      	beq.n	400794 <virtual_test_unit_ready+0x10>
  400790:	2302      	movs	r3, #2
  400792:	e000      	b.n	400796 <virtual_test_unit_ready+0x12>
  400794:	2300      	movs	r3, #0
}
  400796:	4618      	mov	r0, r3
  400798:	46bd      	mov	sp, r7
  40079a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40079e:	4770      	bx	lr
  4007a0:	20006b44 	.word	0x20006b44

004007a4 <virtual_read_capacity>:
//!   It is ready                ->    CTRL_GOOD
//!   Memory unplug              ->    CTRL_NO_PRESENT
//!   Not initialized or changed ->    CTRL_BUSY
//!   An error occurred          ->    CTRL_FAIL
Ctrl_status virtual_read_capacity(uint32_t *uint32_t_nb_sector)
{
  4007a4:	b480      	push	{r7}
  4007a6:	b083      	sub	sp, #12
  4007a8:	af00      	add	r7, sp, #0
  4007aa:	6078      	str	r0, [r7, #4]
	if (b_vmem_unloaded) {
  4007ac:	4b07      	ldr	r3, [pc, #28]	; (4007cc <virtual_read_capacity+0x28>)
  4007ae:	781b      	ldrb	r3, [r3, #0]
  4007b0:	2b00      	cmp	r3, #0
  4007b2:	d001      	beq.n	4007b8 <virtual_read_capacity+0x14>
		return CTRL_NO_PRESENT;
  4007b4:	2302      	movs	r3, #2
  4007b6:	e003      	b.n	4007c0 <virtual_read_capacity+0x1c>
	}

	if (VMEM_NB_SECTOR<8) {
		*uint32_t_nb_sector = 8-1;
	} else {
		*uint32_t_nb_sector = VMEM_NB_SECTOR- 1;
  4007b8:	687b      	ldr	r3, [r7, #4]
  4007ba:	222f      	movs	r2, #47	; 0x2f
  4007bc:	601a      	str	r2, [r3, #0]
	}
	return CTRL_GOOD;
  4007be:	2300      	movs	r3, #0
}
  4007c0:	4618      	mov	r0, r3
  4007c2:	370c      	adds	r7, #12
  4007c4:	46bd      	mov	sp, r7
  4007c6:	f85d 7b04 	ldr.w	r7, [sp], #4
  4007ca:	4770      	bx	lr
  4007cc:	20006b44 	.word	0x20006b44

004007d0 <virtual_wr_protect>:
//! This function returns the write-protected mode
//!
//! @return true if the memory is protected
//!
bool virtual_wr_protect(void)
{
  4007d0:	b480      	push	{r7}
  4007d2:	af00      	add	r7, sp, #0
	return false;
  4007d4:	2300      	movs	r3, #0
}
  4007d6:	4618      	mov	r0, r3
  4007d8:	46bd      	mov	sp, r7
  4007da:	f85d 7b04 	ldr.w	r7, [sp], #4
  4007de:	4770      	bx	lr

004007e0 <virtual_removal>:
//! This function informs about the memory type
//!
//! @return true if the memory is removable
//!
bool virtual_removal(void)
{
  4007e0:	b480      	push	{r7}
  4007e2:	af00      	add	r7, sp, #0
	return true;
  4007e4:	2301      	movs	r3, #1
}
  4007e6:	4618      	mov	r0, r3
  4007e8:	46bd      	mov	sp, r7
  4007ea:	f85d 7b04 	ldr.w	r7, [sp], #4
  4007ee:	4770      	bx	lr

004007f0 <virtual_unload>:
//! This function unloads/loads the memory
//!
//! @return true if the memory is unloaded
//!
bool virtual_unload(bool unload)
{
  4007f0:	b480      	push	{r7}
  4007f2:	b083      	sub	sp, #12
  4007f4:	af00      	add	r7, sp, #0
  4007f6:	4603      	mov	r3, r0
  4007f8:	71fb      	strb	r3, [r7, #7]
	b_vmem_unloaded = unload;
  4007fa:	4a05      	ldr	r2, [pc, #20]	; (400810 <virtual_unload+0x20>)
  4007fc:	79fb      	ldrb	r3, [r7, #7]
  4007fe:	7013      	strb	r3, [r2, #0]
	return true;
  400800:	2301      	movs	r3, #1
}
  400802:	4618      	mov	r0, r3
  400804:	370c      	adds	r7, #12
  400806:	46bd      	mov	sp, r7
  400808:	f85d 7b04 	ldr.w	r7, [sp], #4
  40080c:	4770      	bx	lr
  40080e:	bf00      	nop
  400810:	20006b44 	.word	0x20006b44

00400814 <virtual_usb_trans>:
//!   Not initialized or changed ->    CTRL_BUSY
//!   An error occurred          ->    CTRL_FAIL
//!
static Ctrl_status virtual_usb_trans(uint32_t addr, uint16_t nb_sector,
		bool b_read)
{
  400814:	b590      	push	{r4, r7, lr}
  400816:	b085      	sub	sp, #20
  400818:	af00      	add	r7, sp, #0
  40081a:	6078      	str	r0, [r7, #4]
  40081c:	460b      	mov	r3, r1
  40081e:	807b      	strh	r3, [r7, #2]
  400820:	4613      	mov	r3, r2
  400822:	707b      	strb	r3, [r7, #1]
	}
#else
	uint8_t *ptr_cram;
	uint8_t nb_sector_trans;

	if ((addr > VMEM_NB_SECTOR) ||  (addr + nb_sector > VMEM_NB_SECTOR)) {
  400824:	687b      	ldr	r3, [r7, #4]
  400826:	2b30      	cmp	r3, #48	; 0x30
  400828:	d804      	bhi.n	400834 <virtual_usb_trans+0x20>
  40082a:	887a      	ldrh	r2, [r7, #2]
  40082c:	687b      	ldr	r3, [r7, #4]
  40082e:	4413      	add	r3, r2
  400830:	2b30      	cmp	r3, #48	; 0x30
  400832:	d925      	bls.n	400880 <virtual_usb_trans+0x6c>
		return CTRL_FAIL;
  400834:	2301      	movs	r3, #1
  400836:	e027      	b.n	400888 <virtual_usb_trans+0x74>
	}

	while (nb_sector) {
		// udi_msc_trans_block() is limited to 64KB
		nb_sector_trans = min(nb_sector, 64*(1024/VMEM_SECTOR_SIZE));
  400838:	887b      	ldrh	r3, [r7, #2]
  40083a:	2b7f      	cmp	r3, #127	; 0x7f
  40083c:	d802      	bhi.n	400844 <virtual_usb_trans+0x30>
  40083e:	887b      	ldrh	r3, [r7, #2]
  400840:	b2db      	uxtb	r3, r3
  400842:	e000      	b.n	400846 <virtual_usb_trans+0x32>
  400844:	2380      	movs	r3, #128	; 0x80
  400846:	73fb      	strb	r3, [r7, #15]
		ptr_cram = &vmem_data[addr++ * VMEM_SECTOR_SIZE];
  400848:	687b      	ldr	r3, [r7, #4]
  40084a:	1c5a      	adds	r2, r3, #1
  40084c:	607a      	str	r2, [r7, #4]
  40084e:	025b      	lsls	r3, r3, #9
  400850:	4a0f      	ldr	r2, [pc, #60]	; (400890 <virtual_usb_trans+0x7c>)
  400852:	4413      	add	r3, r2
  400854:	60bb      	str	r3, [r7, #8]
		if (!udi_msc_trans_block( b_read, ptr_cram,
				nb_sector_trans*VMEM_SECTOR_SIZE, NULL)) {
  400856:	7bfb      	ldrb	r3, [r7, #15]
  400858:	025b      	lsls	r3, r3, #9
		if (!udi_msc_trans_block( b_read, ptr_cram,
  40085a:	461a      	mov	r2, r3
  40085c:	7878      	ldrb	r0, [r7, #1]
  40085e:	2300      	movs	r3, #0
  400860:	68b9      	ldr	r1, [r7, #8]
  400862:	4c0c      	ldr	r4, [pc, #48]	; (400894 <virtual_usb_trans+0x80>)
  400864:	47a0      	blx	r4
  400866:	4603      	mov	r3, r0
  400868:	f083 0301 	eor.w	r3, r3, #1
  40086c:	b2db      	uxtb	r3, r3
  40086e:	2b00      	cmp	r3, #0
  400870:	d001      	beq.n	400876 <virtual_usb_trans+0x62>
			return CTRL_FAIL; // transfer aborted
  400872:	2301      	movs	r3, #1
  400874:	e008      	b.n	400888 <virtual_usb_trans+0x74>
		}
		nb_sector -= nb_sector_trans;
  400876:	7bfb      	ldrb	r3, [r7, #15]
  400878:	b29b      	uxth	r3, r3
  40087a:	887a      	ldrh	r2, [r7, #2]
  40087c:	1ad3      	subs	r3, r2, r3
  40087e:	807b      	strh	r3, [r7, #2]
	while (nb_sector) {
  400880:	887b      	ldrh	r3, [r7, #2]
  400882:	2b00      	cmp	r3, #0
  400884:	d1d8      	bne.n	400838 <virtual_usb_trans+0x24>
	}
#endif

	return CTRL_GOOD;
  400886:	2300      	movs	r3, #0
}
  400888:	4618      	mov	r0, r3
  40088a:	3714      	adds	r7, #20
  40088c:	46bd      	mov	sp, r7
  40088e:	bd90      	pop	{r4, r7, pc}
  400890:	20000b44 	.word	0x20000b44
  400894:	00401c01 	.word	0x00401c01

00400898 <virtual_usb_read_10>:
//!   Memory unplug              ->    CTRL_NO_PRESENT
//!   Not initialized or changed ->    CTRL_BUSY
//!   An error occurred          ->    CTRL_FAIL
//!
Ctrl_status virtual_usb_read_10(uint32_t addr, uint16_t nb_sector)
{
  400898:	b580      	push	{r7, lr}
  40089a:	b082      	sub	sp, #8
  40089c:	af00      	add	r7, sp, #0
  40089e:	6078      	str	r0, [r7, #4]
  4008a0:	460b      	mov	r3, r1
  4008a2:	807b      	strh	r3, [r7, #2]
	return virtual_usb_trans(addr, nb_sector, true);
  4008a4:	887b      	ldrh	r3, [r7, #2]
  4008a6:	2201      	movs	r2, #1
  4008a8:	4619      	mov	r1, r3
  4008aa:	6878      	ldr	r0, [r7, #4]
  4008ac:	4b03      	ldr	r3, [pc, #12]	; (4008bc <virtual_usb_read_10+0x24>)
  4008ae:	4798      	blx	r3
  4008b0:	4603      	mov	r3, r0
}
  4008b2:	4618      	mov	r0, r3
  4008b4:	3708      	adds	r7, #8
  4008b6:	46bd      	mov	sp, r7
  4008b8:	bd80      	pop	{r7, pc}
  4008ba:	bf00      	nop
  4008bc:	00400815 	.word	0x00400815

004008c0 <virtual_usb_write_10>:
//!   Memory unplug              ->    CTRL_NO_PRESENT
//!   Not initialized or changed ->    CTRL_BUSY
//!   An error occurred          ->    CTRL_FAIL
//!
Ctrl_status virtual_usb_write_10(uint32_t addr, uint16_t nb_sector)
{
  4008c0:	b580      	push	{r7, lr}
  4008c2:	b082      	sub	sp, #8
  4008c4:	af00      	add	r7, sp, #0
  4008c6:	6078      	str	r0, [r7, #4]
  4008c8:	460b      	mov	r3, r1
  4008ca:	807b      	strh	r3, [r7, #2]
	return virtual_usb_trans(addr, nb_sector, false);
  4008cc:	887b      	ldrh	r3, [r7, #2]
  4008ce:	2200      	movs	r2, #0
  4008d0:	4619      	mov	r1, r3
  4008d2:	6878      	ldr	r0, [r7, #4]
  4008d4:	4b03      	ldr	r3, [pc, #12]	; (4008e4 <virtual_usb_write_10+0x24>)
  4008d6:	4798      	blx	r3
  4008d8:	4603      	mov	r3, r0
}
  4008da:	4618      	mov	r0, r3
  4008dc:	3708      	adds	r7, #8
  4008de:	46bd      	mov	sp, r7
  4008e0:	bd80      	pop	{r7, pc}
  4008e2:	bf00      	nop
  4008e4:	00400815 	.word	0x00400815

004008e8 <osc_enable>:
{
  4008e8:	b580      	push	{r7, lr}
  4008ea:	b082      	sub	sp, #8
  4008ec:	af00      	add	r7, sp, #0
  4008ee:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  4008f0:	687b      	ldr	r3, [r7, #4]
  4008f2:	2b07      	cmp	r3, #7
  4008f4:	d831      	bhi.n	40095a <osc_enable+0x72>
  4008f6:	a201      	add	r2, pc, #4	; (adr r2, 4008fc <osc_enable+0x14>)
  4008f8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  4008fc:	00400959 	.word	0x00400959
  400900:	0040091d 	.word	0x0040091d
  400904:	00400925 	.word	0x00400925
  400908:	0040092d 	.word	0x0040092d
  40090c:	00400935 	.word	0x00400935
  400910:	0040093d 	.word	0x0040093d
  400914:	00400945 	.word	0x00400945
  400918:	0040094f 	.word	0x0040094f
		pmc_switch_sclk_to_32kxtal(PMC_OSC_XTAL);
  40091c:	2000      	movs	r0, #0
  40091e:	4b11      	ldr	r3, [pc, #68]	; (400964 <osc_enable+0x7c>)
  400920:	4798      	blx	r3
		break;
  400922:	e01a      	b.n	40095a <osc_enable+0x72>
		pmc_switch_sclk_to_32kxtal(PMC_OSC_BYPASS);
  400924:	2001      	movs	r0, #1
  400926:	4b0f      	ldr	r3, [pc, #60]	; (400964 <osc_enable+0x7c>)
  400928:	4798      	blx	r3
		break;
  40092a:	e016      	b.n	40095a <osc_enable+0x72>
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_4_MHz);
  40092c:	2000      	movs	r0, #0
  40092e:	4b0e      	ldr	r3, [pc, #56]	; (400968 <osc_enable+0x80>)
  400930:	4798      	blx	r3
		break;
  400932:	e012      	b.n	40095a <osc_enable+0x72>
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_8_MHz);
  400934:	2010      	movs	r0, #16
  400936:	4b0c      	ldr	r3, [pc, #48]	; (400968 <osc_enable+0x80>)
  400938:	4798      	blx	r3
		break;
  40093a:	e00e      	b.n	40095a <osc_enable+0x72>
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_12_MHz);
  40093c:	2020      	movs	r0, #32
  40093e:	4b0a      	ldr	r3, [pc, #40]	; (400968 <osc_enable+0x80>)
  400940:	4798      	blx	r3
		break;
  400942:	e00a      	b.n	40095a <osc_enable+0x72>
		pmc_switch_mainck_to_xtal(PMC_OSC_XTAL,
  400944:	213e      	movs	r1, #62	; 0x3e
  400946:	2000      	movs	r0, #0
  400948:	4b08      	ldr	r3, [pc, #32]	; (40096c <osc_enable+0x84>)
  40094a:	4798      	blx	r3
		break;
  40094c:	e005      	b.n	40095a <osc_enable+0x72>
		pmc_switch_mainck_to_xtal(PMC_OSC_BYPASS,
  40094e:	213e      	movs	r1, #62	; 0x3e
  400950:	2001      	movs	r0, #1
  400952:	4b06      	ldr	r3, [pc, #24]	; (40096c <osc_enable+0x84>)
  400954:	4798      	blx	r3
		break;
  400956:	e000      	b.n	40095a <osc_enable+0x72>
		break;
  400958:	bf00      	nop
}
  40095a:	bf00      	nop
  40095c:	3708      	adds	r7, #8
  40095e:	46bd      	mov	sp, r7
  400960:	bd80      	pop	{r7, pc}
  400962:	bf00      	nop
  400964:	00404195 	.word	0x00404195
  400968:	00404201 	.word	0x00404201
  40096c:	00404271 	.word	0x00404271

00400970 <osc_is_ready>:
{
  400970:	b580      	push	{r7, lr}
  400972:	b082      	sub	sp, #8
  400974:	af00      	add	r7, sp, #0
  400976:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  400978:	687b      	ldr	r3, [r7, #4]
  40097a:	2b07      	cmp	r3, #7
  40097c:	d826      	bhi.n	4009cc <osc_is_ready+0x5c>
  40097e:	a201      	add	r2, pc, #4	; (adr r2, 400984 <osc_is_ready+0x14>)
  400980:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  400984:	004009a5 	.word	0x004009a5
  400988:	004009a9 	.word	0x004009a9
  40098c:	004009a9 	.word	0x004009a9
  400990:	004009bb 	.word	0x004009bb
  400994:	004009bb 	.word	0x004009bb
  400998:	004009bb 	.word	0x004009bb
  40099c:	004009bb 	.word	0x004009bb
  4009a0:	004009bb 	.word	0x004009bb
		return 1;
  4009a4:	2301      	movs	r3, #1
  4009a6:	e012      	b.n	4009ce <osc_is_ready+0x5e>
		return pmc_osc_is_ready_32kxtal();
  4009a8:	4b0b      	ldr	r3, [pc, #44]	; (4009d8 <osc_is_ready+0x68>)
  4009aa:	4798      	blx	r3
  4009ac:	4603      	mov	r3, r0
  4009ae:	2b00      	cmp	r3, #0
  4009b0:	bf14      	ite	ne
  4009b2:	2301      	movne	r3, #1
  4009b4:	2300      	moveq	r3, #0
  4009b6:	b2db      	uxtb	r3, r3
  4009b8:	e009      	b.n	4009ce <osc_is_ready+0x5e>
		return pmc_osc_is_ready_mainck();
  4009ba:	4b08      	ldr	r3, [pc, #32]	; (4009dc <osc_is_ready+0x6c>)
  4009bc:	4798      	blx	r3
  4009be:	4603      	mov	r3, r0
  4009c0:	2b00      	cmp	r3, #0
  4009c2:	bf14      	ite	ne
  4009c4:	2301      	movne	r3, #1
  4009c6:	2300      	moveq	r3, #0
  4009c8:	b2db      	uxtb	r3, r3
  4009ca:	e000      	b.n	4009ce <osc_is_ready+0x5e>
	return 0;
  4009cc:	2300      	movs	r3, #0
}
  4009ce:	4618      	mov	r0, r3
  4009d0:	3708      	adds	r7, #8
  4009d2:	46bd      	mov	sp, r7
  4009d4:	bd80      	pop	{r7, pc}
  4009d6:	bf00      	nop
  4009d8:	004041cd 	.word	0x004041cd
  4009dc:	004042e9 	.word	0x004042e9

004009e0 <osc_get_rate>:
{
  4009e0:	b480      	push	{r7}
  4009e2:	b083      	sub	sp, #12
  4009e4:	af00      	add	r7, sp, #0
  4009e6:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  4009e8:	687b      	ldr	r3, [r7, #4]
  4009ea:	2b07      	cmp	r3, #7
  4009ec:	d825      	bhi.n	400a3a <osc_get_rate+0x5a>
  4009ee:	a201      	add	r2, pc, #4	; (adr r2, 4009f4 <osc_get_rate+0x14>)
  4009f0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  4009f4:	00400a15 	.word	0x00400a15
  4009f8:	00400a1b 	.word	0x00400a1b
  4009fc:	00400a21 	.word	0x00400a21
  400a00:	00400a27 	.word	0x00400a27
  400a04:	00400a2b 	.word	0x00400a2b
  400a08:	00400a2f 	.word	0x00400a2f
  400a0c:	00400a33 	.word	0x00400a33
  400a10:	00400a37 	.word	0x00400a37
		return OSC_SLCK_32K_RC_HZ;
  400a14:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
  400a18:	e010      	b.n	400a3c <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_XTAL;
  400a1a:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  400a1e:	e00d      	b.n	400a3c <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_BYPASS;
  400a20:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  400a24:	e00a      	b.n	400a3c <osc_get_rate+0x5c>
		return OSC_MAINCK_4M_RC_HZ;
  400a26:	4b08      	ldr	r3, [pc, #32]	; (400a48 <osc_get_rate+0x68>)
  400a28:	e008      	b.n	400a3c <osc_get_rate+0x5c>
		return OSC_MAINCK_8M_RC_HZ;
  400a2a:	4b08      	ldr	r3, [pc, #32]	; (400a4c <osc_get_rate+0x6c>)
  400a2c:	e006      	b.n	400a3c <osc_get_rate+0x5c>
		return OSC_MAINCK_12M_RC_HZ;
  400a2e:	4b08      	ldr	r3, [pc, #32]	; (400a50 <osc_get_rate+0x70>)
  400a30:	e004      	b.n	400a3c <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_XTAL;
  400a32:	4b07      	ldr	r3, [pc, #28]	; (400a50 <osc_get_rate+0x70>)
  400a34:	e002      	b.n	400a3c <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_BYPASS;
  400a36:	4b06      	ldr	r3, [pc, #24]	; (400a50 <osc_get_rate+0x70>)
  400a38:	e000      	b.n	400a3c <osc_get_rate+0x5c>
	return 0;
  400a3a:	2300      	movs	r3, #0
}
  400a3c:	4618      	mov	r0, r3
  400a3e:	370c      	adds	r7, #12
  400a40:	46bd      	mov	sp, r7
  400a42:	f85d 7b04 	ldr.w	r7, [sp], #4
  400a46:	4770      	bx	lr
  400a48:	003d0900 	.word	0x003d0900
  400a4c:	007a1200 	.word	0x007a1200
  400a50:	00b71b00 	.word	0x00b71b00

00400a54 <osc_wait_ready>:
 * to become stable and ready to use as a clock source.
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
  400a54:	b580      	push	{r7, lr}
  400a56:	b082      	sub	sp, #8
  400a58:	af00      	add	r7, sp, #0
  400a5a:	4603      	mov	r3, r0
  400a5c:	71fb      	strb	r3, [r7, #7]
	while (!osc_is_ready(id)) {
  400a5e:	bf00      	nop
  400a60:	79fb      	ldrb	r3, [r7, #7]
  400a62:	4618      	mov	r0, r3
  400a64:	4b05      	ldr	r3, [pc, #20]	; (400a7c <osc_wait_ready+0x28>)
  400a66:	4798      	blx	r3
  400a68:	4603      	mov	r3, r0
  400a6a:	f083 0301 	eor.w	r3, r3, #1
  400a6e:	b2db      	uxtb	r3, r3
  400a70:	2b00      	cmp	r3, #0
  400a72:	d1f5      	bne.n	400a60 <osc_wait_ready+0xc>
		/* Do nothing */
	}
}
  400a74:	bf00      	nop
  400a76:	3708      	adds	r7, #8
  400a78:	46bd      	mov	sp, r7
  400a7a:	bd80      	pop	{r7, pc}
  400a7c:	00400971 	.word	0x00400971

00400a80 <pll_config_init>:
 * hardware mul+1 is hidden in this implementation. Use mul as mul effective
 * value.
 */
static inline void pll_config_init(struct pll_config *p_cfg,
		enum pll_source e_src, uint32_t ul_div, uint32_t ul_mul)
{
  400a80:	b580      	push	{r7, lr}
  400a82:	b086      	sub	sp, #24
  400a84:	af00      	add	r7, sp, #0
  400a86:	60f8      	str	r0, [r7, #12]
  400a88:	607a      	str	r2, [r7, #4]
  400a8a:	603b      	str	r3, [r7, #0]
  400a8c:	460b      	mov	r3, r1
  400a8e:	72fb      	strb	r3, [r7, #11]
	uint32_t vco_hz;

	Assert(e_src < PLL_NR_SOURCES);

	/* Calculate internal VCO frequency */
	vco_hz = osc_get_rate(e_src) / ul_div;
  400a90:	7afb      	ldrb	r3, [r7, #11]
  400a92:	4618      	mov	r0, r3
  400a94:	4b0d      	ldr	r3, [pc, #52]	; (400acc <pll_config_init+0x4c>)
  400a96:	4798      	blx	r3
  400a98:	4602      	mov	r2, r0
  400a9a:	687b      	ldr	r3, [r7, #4]
  400a9c:	fbb2 f3f3 	udiv	r3, r2, r3
  400aa0:	617b      	str	r3, [r7, #20]
	Assert(vco_hz >= PLL_INPUT_MIN_HZ);
	Assert(vco_hz <= PLL_INPUT_MAX_HZ);

	vco_hz *= ul_mul;
  400aa2:	697b      	ldr	r3, [r7, #20]
  400aa4:	683a      	ldr	r2, [r7, #0]
  400aa6:	fb02 f303 	mul.w	r3, r2, r3
  400aaa:	617b      	str	r3, [r7, #20]
	Assert(vco_hz >= PLL_OUTPUT_MIN_HZ);
	Assert(vco_hz <= PLL_OUTPUT_MAX_HZ);

	/* PMC hardware will automatically make it mul+1 */
	p_cfg->ctrl = CKGR_PLLAR_MULA(ul_mul - 1) | CKGR_PLLAR_DIVA(ul_div) | \
  400aac:	683b      	ldr	r3, [r7, #0]
  400aae:	3b01      	subs	r3, #1
  400ab0:	041a      	lsls	r2, r3, #16
  400ab2:	4b07      	ldr	r3, [pc, #28]	; (400ad0 <pll_config_init+0x50>)
  400ab4:	4013      	ands	r3, r2
  400ab6:	687a      	ldr	r2, [r7, #4]
  400ab8:	b2d2      	uxtb	r2, r2
  400aba:	4313      	orrs	r3, r2
  400abc:	f443 527c 	orr.w	r2, r3, #16128	; 0x3f00
  400ac0:	68fb      	ldr	r3, [r7, #12]
  400ac2:	601a      	str	r2, [r3, #0]
			CKGR_PLLAR_PLLACOUNT(PLL_COUNT);
}
  400ac4:	bf00      	nop
  400ac6:	3718      	adds	r7, #24
  400ac8:	46bd      	mov	sp, r7
  400aca:	bd80      	pop	{r7, pc}
  400acc:	004009e1 	.word	0x004009e1
  400ad0:	07ff0000 	.word	0x07ff0000

00400ad4 <pll_enable>:
		PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | p_cfg->ctrl;
	}
}

static inline void pll_enable(const struct pll_config *p_cfg, uint32_t ul_pll_id)
{
  400ad4:	b580      	push	{r7, lr}
  400ad6:	b082      	sub	sp, #8
  400ad8:	af00      	add	r7, sp, #0
  400ada:	6078      	str	r0, [r7, #4]
  400adc:	6039      	str	r1, [r7, #0]
	Assert(ul_pll_id < NR_PLLS);

	if (ul_pll_id == PLLA_ID) {
  400ade:	683b      	ldr	r3, [r7, #0]
  400ae0:	2b00      	cmp	r3, #0
  400ae2:	d107      	bne.n	400af4 <pll_enable+0x20>
		pmc_disable_pllack(); // Always stop PLL first!
  400ae4:	4b05      	ldr	r3, [pc, #20]	; (400afc <pll_enable+0x28>)
  400ae6:	4798      	blx	r3
		PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | p_cfg->ctrl;
  400ae8:	4a05      	ldr	r2, [pc, #20]	; (400b00 <pll_enable+0x2c>)
  400aea:	687b      	ldr	r3, [r7, #4]
  400aec:	681b      	ldr	r3, [r3, #0]
  400aee:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
  400af2:	6293      	str	r3, [r2, #40]	; 0x28
	}
}
  400af4:	bf00      	nop
  400af6:	3708      	adds	r7, #8
  400af8:	46bd      	mov	sp, r7
  400afa:	bd80      	pop	{r7, pc}
  400afc:	00404305 	.word	0x00404305
  400b00:	400e0400 	.word	0x400e0400

00400b04 <pll_is_locked>:
		pmc_disable_pllack();
	}
}

static inline uint32_t pll_is_locked(uint32_t ul_pll_id)
{
  400b04:	b580      	push	{r7, lr}
  400b06:	b082      	sub	sp, #8
  400b08:	af00      	add	r7, sp, #0
  400b0a:	6078      	str	r0, [r7, #4]
	Assert(ul_pll_id < NR_PLLS);

	UNUSED(ul_pll_id);
	return pmc_is_locked_pllack();
  400b0c:	4b03      	ldr	r3, [pc, #12]	; (400b1c <pll_is_locked+0x18>)
  400b0e:	4798      	blx	r3
  400b10:	4603      	mov	r3, r0
}
  400b12:	4618      	mov	r0, r3
  400b14:	3708      	adds	r7, #8
  400b16:	46bd      	mov	sp, r7
  400b18:	bd80      	pop	{r7, pc}
  400b1a:	bf00      	nop
  400b1c:	00404321 	.word	0x00404321

00400b20 <pll_enable_source>:

static inline void pll_enable_source(enum pll_source e_src)
{
  400b20:	b580      	push	{r7, lr}
  400b22:	b082      	sub	sp, #8
  400b24:	af00      	add	r7, sp, #0
  400b26:	4603      	mov	r3, r0
  400b28:	71fb      	strb	r3, [r7, #7]
	switch (e_src) {
  400b2a:	79fb      	ldrb	r3, [r7, #7]
  400b2c:	3b03      	subs	r3, #3
  400b2e:	2b04      	cmp	r3, #4
  400b30:	d808      	bhi.n	400b44 <pll_enable_source+0x24>
	case PLL_SRC_MAINCK_4M_RC:
	case PLL_SRC_MAINCK_8M_RC:
	case PLL_SRC_MAINCK_12M_RC:
	case PLL_SRC_MAINCK_XTAL:
	case PLL_SRC_MAINCK_BYPASS:
		osc_enable(e_src);
  400b32:	79fb      	ldrb	r3, [r7, #7]
  400b34:	4618      	mov	r0, r3
  400b36:	4b06      	ldr	r3, [pc, #24]	; (400b50 <pll_enable_source+0x30>)
  400b38:	4798      	blx	r3
		osc_wait_ready(e_src);
  400b3a:	79fb      	ldrb	r3, [r7, #7]
  400b3c:	4618      	mov	r0, r3
  400b3e:	4b05      	ldr	r3, [pc, #20]	; (400b54 <pll_enable_source+0x34>)
  400b40:	4798      	blx	r3
		break;
  400b42:	e000      	b.n	400b46 <pll_enable_source+0x26>

	default:
		Assert(false);
		break;
  400b44:	bf00      	nop
	}
}
  400b46:	bf00      	nop
  400b48:	3708      	adds	r7, #8
  400b4a:	46bd      	mov	sp, r7
  400b4c:	bd80      	pop	{r7, pc}
  400b4e:	bf00      	nop
  400b50:	004008e9 	.word	0x004008e9
  400b54:	00400a55 	.word	0x00400a55

00400b58 <pll_wait_for_lock>:
 *
 * \retval STATUS_OK The PLL is now locked.
 * \retval ERR_TIMEOUT Timed out waiting for PLL to become locked.
 */
static inline int pll_wait_for_lock(unsigned int pll_id)
{
  400b58:	b580      	push	{r7, lr}
  400b5a:	b082      	sub	sp, #8
  400b5c:	af00      	add	r7, sp, #0
  400b5e:	6078      	str	r0, [r7, #4]
	Assert(pll_id < NR_PLLS);

	while (!pll_is_locked(pll_id)) {
  400b60:	bf00      	nop
  400b62:	6878      	ldr	r0, [r7, #4]
  400b64:	4b04      	ldr	r3, [pc, #16]	; (400b78 <pll_wait_for_lock+0x20>)
  400b66:	4798      	blx	r3
  400b68:	4603      	mov	r3, r0
  400b6a:	2b00      	cmp	r3, #0
  400b6c:	d0f9      	beq.n	400b62 <pll_wait_for_lock+0xa>
		/* Do nothing */
	}

	return 0;
  400b6e:	2300      	movs	r3, #0
}
  400b70:	4618      	mov	r0, r3
  400b72:	3708      	adds	r7, #8
  400b74:	46bd      	mov	sp, r7
  400b76:	bd80      	pop	{r7, pc}
  400b78:	00400b05 	.word	0x00400b05

00400b7c <sysclk_get_main_hz>:
{
  400b7c:	b580      	push	{r7, lr}
  400b7e:	af00      	add	r7, sp, #0
		return pll_get_default_rate(0);
  400b80:	2006      	movs	r0, #6
  400b82:	4b03      	ldr	r3, [pc, #12]	; (400b90 <sysclk_get_main_hz+0x14>)
  400b84:	4798      	blx	r3
  400b86:	4603      	mov	r3, r0
  400b88:	011b      	lsls	r3, r3, #4
}
  400b8a:	4618      	mov	r0, r3
  400b8c:	bd80      	pop	{r7, pc}
  400b8e:	bf00      	nop
  400b90:	004009e1 	.word	0x004009e1

00400b94 <sysclk_get_cpu_hz>:
{
  400b94:	b580      	push	{r7, lr}
  400b96:	af00      	add	r7, sp, #0
	return sysclk_get_main_hz() /
  400b98:	4b02      	ldr	r3, [pc, #8]	; (400ba4 <sysclk_get_cpu_hz+0x10>)
  400b9a:	4798      	blx	r3
  400b9c:	4603      	mov	r3, r0
  400b9e:	085b      	lsrs	r3, r3, #1
}
  400ba0:	4618      	mov	r0, r3
  400ba2:	bd80      	pop	{r7, pc}
  400ba4:	00400b7d 	.word	0x00400b7d

00400ba8 <sysclk_init>:
	pmc_disable_udpck();
}
#endif // CONFIG_USBCLK_SOURCE

void sysclk_init(void)
{
  400ba8:	b590      	push	{r4, r7, lr}
  400baa:	b083      	sub	sp, #12
  400bac:	af00      	add	r7, sp, #0
	/* Set flash wait state to max in case the below clock switching. */
	system_init_flash(CHIP_FREQ_CPU_MAX);
  400bae:	4811      	ldr	r0, [pc, #68]	; (400bf4 <sysclk_init+0x4c>)
  400bb0:	4b11      	ldr	r3, [pc, #68]	; (400bf8 <sysclk_init+0x50>)
  400bb2:	4798      	blx	r3

#ifdef CONFIG_PLL0_SOURCE
	else if (CONFIG_SYSCLK_SOURCE == SYSCLK_SRC_PLLACK) {
		struct pll_config pllcfg;

		pll_enable_source(CONFIG_PLL0_SOURCE);
  400bb4:	2006      	movs	r0, #6
  400bb6:	4b11      	ldr	r3, [pc, #68]	; (400bfc <sysclk_init+0x54>)
  400bb8:	4798      	blx	r3
		pll_config_defaults(&pllcfg, 0);
  400bba:	1d38      	adds	r0, r7, #4
  400bbc:	2310      	movs	r3, #16
  400bbe:	2201      	movs	r2, #1
  400bc0:	2106      	movs	r1, #6
  400bc2:	4c0f      	ldr	r4, [pc, #60]	; (400c00 <sysclk_init+0x58>)
  400bc4:	47a0      	blx	r4
		pll_enable(&pllcfg, 0);
  400bc6:	1d3b      	adds	r3, r7, #4
  400bc8:	2100      	movs	r1, #0
  400bca:	4618      	mov	r0, r3
  400bcc:	4b0d      	ldr	r3, [pc, #52]	; (400c04 <sysclk_init+0x5c>)
  400bce:	4798      	blx	r3
		pll_wait_for_lock(0);
  400bd0:	2000      	movs	r0, #0
  400bd2:	4b0d      	ldr	r3, [pc, #52]	; (400c08 <sysclk_init+0x60>)
  400bd4:	4798      	blx	r3
		pmc_switch_mck_to_pllack(CONFIG_SYSCLK_PRES);
  400bd6:	2010      	movs	r0, #16
  400bd8:	4b0c      	ldr	r3, [pc, #48]	; (400c0c <sysclk_init+0x64>)
  400bda:	4798      	blx	r3
	}
#endif

	/* Update the SystemFrequency variable */
	SystemCoreClockUpdate();
  400bdc:	4b0c      	ldr	r3, [pc, #48]	; (400c10 <sysclk_init+0x68>)
  400bde:	4798      	blx	r3

	/* Set a flash wait state depending on the new cpu frequency */
	system_init_flash(sysclk_get_cpu_hz());
  400be0:	4b0c      	ldr	r3, [pc, #48]	; (400c14 <sysclk_init+0x6c>)
  400be2:	4798      	blx	r3
  400be4:	4603      	mov	r3, r0
  400be6:	4618      	mov	r0, r3
  400be8:	4b03      	ldr	r3, [pc, #12]	; (400bf8 <sysclk_init+0x50>)
  400bea:	4798      	blx	r3

#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
	/* Signal that the internal frequencies are setup */
	sysclk_initialized = 1;
#endif
}
  400bec:	bf00      	nop
  400bee:	370c      	adds	r7, #12
  400bf0:	46bd      	mov	sp, r7
  400bf2:	bd90      	pop	{r4, r7, pc}
  400bf4:	07270e00 	.word	0x07270e00
  400bf8:	00406f01 	.word	0x00406f01
  400bfc:	00400b21 	.word	0x00400b21
  400c00:	00400a81 	.word	0x00400a81
  400c04:	00400ad5 	.word	0x00400ad5
  400c08:	00400b59 	.word	0x00400b59
  400c0c:	00404111 	.word	0x00404111
  400c10:	00406d99 	.word	0x00406d99
  400c14:	00400b95 	.word	0x00400b95

00400c18 <ctrl_access_init>:


#ifdef FREERTOS_USED

bool ctrl_access_init(void)
{
  400c18:	b598      	push	{r3, r4, r7, lr}
  400c1a:	af00      	add	r7, sp, #0
  // If the handle to the protecting semaphore is not valid,
  if (!ctrl_access_semphr)
  400c1c:	4b0f      	ldr	r3, [pc, #60]	; (400c5c <ctrl_access_init+0x44>)
  400c1e:	681b      	ldr	r3, [r3, #0]
  400c20:	2b00      	cmp	r3, #0
  400c22:	d118      	bne.n	400c56 <ctrl_access_init+0x3e>
  {
    // try to create the semaphore.
    vSemaphoreCreateBinary(ctrl_access_semphr);
  400c24:	2203      	movs	r2, #3
  400c26:	2100      	movs	r1, #0
  400c28:	2001      	movs	r0, #1
  400c2a:	4b0d      	ldr	r3, [pc, #52]	; (400c60 <ctrl_access_init+0x48>)
  400c2c:	4798      	blx	r3
  400c2e:	4602      	mov	r2, r0
  400c30:	4b0a      	ldr	r3, [pc, #40]	; (400c5c <ctrl_access_init+0x44>)
  400c32:	601a      	str	r2, [r3, #0]
  400c34:	4b09      	ldr	r3, [pc, #36]	; (400c5c <ctrl_access_init+0x44>)
  400c36:	681b      	ldr	r3, [r3, #0]
  400c38:	2b00      	cmp	r3, #0
  400c3a:	d006      	beq.n	400c4a <ctrl_access_init+0x32>
  400c3c:	4b07      	ldr	r3, [pc, #28]	; (400c5c <ctrl_access_init+0x44>)
  400c3e:	6818      	ldr	r0, [r3, #0]
  400c40:	2300      	movs	r3, #0
  400c42:	2200      	movs	r2, #0
  400c44:	2100      	movs	r1, #0
  400c46:	4c07      	ldr	r4, [pc, #28]	; (400c64 <ctrl_access_init+0x4c>)
  400c48:	47a0      	blx	r4

    // If the semaphore could not be created, there is no backup solution.
    if (!ctrl_access_semphr) return false;
  400c4a:	4b04      	ldr	r3, [pc, #16]	; (400c5c <ctrl_access_init+0x44>)
  400c4c:	681b      	ldr	r3, [r3, #0]
  400c4e:	2b00      	cmp	r3, #0
  400c50:	d101      	bne.n	400c56 <ctrl_access_init+0x3e>
  400c52:	2300      	movs	r3, #0
  400c54:	e000      	b.n	400c58 <ctrl_access_init+0x40>
  }

  return true;
  400c56:	2301      	movs	r3, #1
}
  400c58:	4618      	mov	r0, r3
  400c5a:	bd98      	pop	{r3, r4, r7, pc}
  400c5c:	20006b48 	.word	0x20006b48
  400c60:	00411711 	.word	0x00411711
  400c64:	00411831 	.word	0x00411831

00400c68 <ctrl_access_lock>:
/*! \brief Locks accesses to LUNs.
 *
 * \return \c true if the access was successfully locked, else \c false.
 */
static bool ctrl_access_lock(void)
{
  400c68:	b580      	push	{r7, lr}
  400c6a:	af00      	add	r7, sp, #0
  // If the semaphore could not be created, there is no backup solution.
  if (!ctrl_access_semphr) return false;
  400c6c:	4b09      	ldr	r3, [pc, #36]	; (400c94 <ctrl_access_lock+0x2c>)
  400c6e:	681b      	ldr	r3, [r3, #0]
  400c70:	2b00      	cmp	r3, #0
  400c72:	d101      	bne.n	400c78 <ctrl_access_lock+0x10>
  400c74:	2300      	movs	r3, #0
  400c76:	e00b      	b.n	400c90 <ctrl_access_lock+0x28>

  // Wait for the semaphore.
  while (!xSemaphoreTake(ctrl_access_semphr, portMAX_DELAY));
  400c78:	bf00      	nop
  400c7a:	4b06      	ldr	r3, [pc, #24]	; (400c94 <ctrl_access_lock+0x2c>)
  400c7c:	681b      	ldr	r3, [r3, #0]
  400c7e:	f04f 31ff 	mov.w	r1, #4294967295
  400c82:	4618      	mov	r0, r3
  400c84:	4b04      	ldr	r3, [pc, #16]	; (400c98 <ctrl_access_lock+0x30>)
  400c86:	4798      	blx	r3
  400c88:	4603      	mov	r3, r0
  400c8a:	2b00      	cmp	r3, #0
  400c8c:	d0f5      	beq.n	400c7a <ctrl_access_lock+0x12>

  return true;
  400c8e:	2301      	movs	r3, #1
}
  400c90:	4618      	mov	r0, r3
  400c92:	bd80      	pop	{r7, pc}
  400c94:	20006b48 	.word	0x20006b48
  400c98:	00411db1 	.word	0x00411db1

00400c9c <get_nb_lun>:

#endif  // FREERTOS_USED


U8 get_nb_lun(void)
{
  400c9c:	b480      	push	{r7}
  400c9e:	af00      	add	r7, sp, #0

  Ctrl_access_unlock();

  return nb_lun;
#else
  return MAX_LUN;
  400ca0:	2301      	movs	r3, #1
#endif
}
  400ca2:	4618      	mov	r0, r3
  400ca4:	46bd      	mov	sp, r7
  400ca6:	f85d 7b04 	ldr.w	r7, [sp], #4
  400caa:	4770      	bx	lr

00400cac <mem_test_unit_ready>:
  return LUN_ID_0;
}


Ctrl_status mem_test_unit_ready(U8 lun)
{
  400cac:	b590      	push	{r4, r7, lr}
  400cae:	b085      	sub	sp, #20
  400cb0:	af00      	add	r7, sp, #0
  400cb2:	4603      	mov	r3, r0
  400cb4:	71fb      	strb	r3, [r7, #7]
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;
  400cb6:	4b11      	ldr	r3, [pc, #68]	; (400cfc <mem_test_unit_ready+0x50>)
  400cb8:	4798      	blx	r3
  400cba:	4603      	mov	r3, r0
  400cbc:	f083 0301 	eor.w	r3, r3, #1
  400cc0:	b2db      	uxtb	r3, r3
  400cc2:	2b00      	cmp	r3, #0
  400cc4:	d001      	beq.n	400cca <mem_test_unit_ready+0x1e>
  400cc6:	2301      	movs	r3, #1
  400cc8:	e014      	b.n	400cf4 <mem_test_unit_ready+0x48>

  status =
#if MAX_LUN
         (lun < MAX_LUN) ? lun_desc[lun].test_unit_ready() :
  400cca:	79fb      	ldrb	r3, [r7, #7]
  400ccc:	2b00      	cmp	r3, #0
  400cce:	d107      	bne.n	400ce0 <mem_test_unit_ready+0x34>
  400cd0:	79fb      	ldrb	r3, [r7, #7]
  400cd2:	4a0b      	ldr	r2, [pc, #44]	; (400d00 <mem_test_unit_ready+0x54>)
  400cd4:	015b      	lsls	r3, r3, #5
  400cd6:	4413      	add	r3, r2
  400cd8:	681b      	ldr	r3, [r3, #0]
  400cda:	4798      	blx	r3
  400cdc:	4603      	mov	r3, r0
  400cde:	e000      	b.n	400ce2 <mem_test_unit_ready+0x36>
  400ce0:	2301      	movs	r3, #1
  status =
  400ce2:	73fb      	strb	r3, [r7, #15]
                             Lun_usb_test_unit_ready(lun - LUN_ID_USB);
#else
                             CTRL_FAIL;
#endif

  Ctrl_access_unlock();
  400ce4:	4b07      	ldr	r3, [pc, #28]	; (400d04 <mem_test_unit_ready+0x58>)
  400ce6:	6818      	ldr	r0, [r3, #0]
  400ce8:	2300      	movs	r3, #0
  400cea:	2200      	movs	r2, #0
  400cec:	2100      	movs	r1, #0
  400cee:	4c06      	ldr	r4, [pc, #24]	; (400d08 <mem_test_unit_ready+0x5c>)
  400cf0:	47a0      	blx	r4

  return status;
  400cf2:	7bfb      	ldrb	r3, [r7, #15]
}
  400cf4:	4618      	mov	r0, r3
  400cf6:	3714      	adds	r7, #20
  400cf8:	46bd      	mov	sp, r7
  400cfa:	bd90      	pop	{r4, r7, pc}
  400cfc:	00400c69 	.word	0x00400c69
  400d00:	0041c8fc 	.word	0x0041c8fc
  400d04:	20006b48 	.word	0x20006b48
  400d08:	00411831 	.word	0x00411831

00400d0c <mem_read_capacity>:


Ctrl_status mem_read_capacity(U8 lun, U32 *u32_nb_sector)
{
  400d0c:	b590      	push	{r4, r7, lr}
  400d0e:	b085      	sub	sp, #20
  400d10:	af00      	add	r7, sp, #0
  400d12:	4603      	mov	r3, r0
  400d14:	6039      	str	r1, [r7, #0]
  400d16:	71fb      	strb	r3, [r7, #7]
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;
  400d18:	4b12      	ldr	r3, [pc, #72]	; (400d64 <mem_read_capacity+0x58>)
  400d1a:	4798      	blx	r3
  400d1c:	4603      	mov	r3, r0
  400d1e:	f083 0301 	eor.w	r3, r3, #1
  400d22:	b2db      	uxtb	r3, r3
  400d24:	2b00      	cmp	r3, #0
  400d26:	d001      	beq.n	400d2c <mem_read_capacity+0x20>
  400d28:	2301      	movs	r3, #1
  400d2a:	e016      	b.n	400d5a <mem_read_capacity+0x4e>

  status =
#if MAX_LUN
         (lun < MAX_LUN) ? lun_desc[lun].read_capacity(u32_nb_sector) :
  400d2c:	79fb      	ldrb	r3, [r7, #7]
  400d2e:	2b00      	cmp	r3, #0
  400d30:	d109      	bne.n	400d46 <mem_read_capacity+0x3a>
  400d32:	79fb      	ldrb	r3, [r7, #7]
  400d34:	4a0c      	ldr	r2, [pc, #48]	; (400d68 <mem_read_capacity+0x5c>)
  400d36:	015b      	lsls	r3, r3, #5
  400d38:	4413      	add	r3, r2
  400d3a:	3304      	adds	r3, #4
  400d3c:	681b      	ldr	r3, [r3, #0]
  400d3e:	6838      	ldr	r0, [r7, #0]
  400d40:	4798      	blx	r3
  400d42:	4603      	mov	r3, r0
  400d44:	e000      	b.n	400d48 <mem_read_capacity+0x3c>
  400d46:	2301      	movs	r3, #1
  status =
  400d48:	73fb      	strb	r3, [r7, #15]
                             Lun_usb_read_capacity(lun - LUN_ID_USB, u32_nb_sector);
#else
                             CTRL_FAIL;
#endif

  Ctrl_access_unlock();
  400d4a:	4b08      	ldr	r3, [pc, #32]	; (400d6c <mem_read_capacity+0x60>)
  400d4c:	6818      	ldr	r0, [r3, #0]
  400d4e:	2300      	movs	r3, #0
  400d50:	2200      	movs	r2, #0
  400d52:	2100      	movs	r1, #0
  400d54:	4c06      	ldr	r4, [pc, #24]	; (400d70 <mem_read_capacity+0x64>)
  400d56:	47a0      	blx	r4

  return status;
  400d58:	7bfb      	ldrb	r3, [r7, #15]
}
  400d5a:	4618      	mov	r0, r3
  400d5c:	3714      	adds	r7, #20
  400d5e:	46bd      	mov	sp, r7
  400d60:	bd90      	pop	{r4, r7, pc}
  400d62:	bf00      	nop
  400d64:	00400c69 	.word	0x00400c69
  400d68:	0041c8fc 	.word	0x0041c8fc
  400d6c:	20006b48 	.word	0x20006b48
  400d70:	00411831 	.word	0x00411831

00400d74 <mem_unload>:
  return sector_size;
}


bool mem_unload(U8 lun, bool unload)
{
  400d74:	b590      	push	{r4, r7, lr}
  400d76:	b085      	sub	sp, #20
  400d78:	af00      	add	r7, sp, #0
  400d7a:	4603      	mov	r3, r0
  400d7c:	460a      	mov	r2, r1
  400d7e:	71fb      	strb	r3, [r7, #7]
  400d80:	4613      	mov	r3, r2
  400d82:	71bb      	strb	r3, [r7, #6]
  bool unloaded;
#if !MAX_LUN || !defined(Lun_usb_unload)
  UNUSED(lun);
#endif

  if (!Ctrl_access_lock()) return false;
  400d84:	4b1f      	ldr	r3, [pc, #124]	; (400e04 <mem_unload+0x90>)
  400d86:	4798      	blx	r3
  400d88:	4603      	mov	r3, r0
  400d8a:	f083 0301 	eor.w	r3, r3, #1
  400d8e:	b2db      	uxtb	r3, r3
  400d90:	2b00      	cmp	r3, #0
  400d92:	d001      	beq.n	400d98 <mem_unload+0x24>
  400d94:	2300      	movs	r3, #0
  400d96:	e031      	b.n	400dfc <mem_unload+0x88>

  unloaded =
#if MAX_LUN
          (lun < MAX_LUN) ?
              (lun_desc[lun].unload ?
                  lun_desc[lun].unload(unload) : !unload) :
  400d98:	79fb      	ldrb	r3, [r7, #7]
  400d9a:	2b00      	cmp	r3, #0
  400d9c:	d124      	bne.n	400de8 <mem_unload+0x74>
              (lun_desc[lun].unload ?
  400d9e:	79fb      	ldrb	r3, [r7, #7]
  400da0:	4a19      	ldr	r2, [pc, #100]	; (400e08 <mem_unload+0x94>)
  400da2:	015b      	lsls	r3, r3, #5
  400da4:	4413      	add	r3, r2
  400da6:	3308      	adds	r3, #8
  400da8:	681b      	ldr	r3, [r3, #0]
                  lun_desc[lun].unload(unload) : !unload) :
  400daa:	2b00      	cmp	r3, #0
  400dac:	d00f      	beq.n	400dce <mem_unload+0x5a>
  400dae:	79fb      	ldrb	r3, [r7, #7]
  400db0:	4a15      	ldr	r2, [pc, #84]	; (400e08 <mem_unload+0x94>)
  400db2:	015b      	lsls	r3, r3, #5
  400db4:	4413      	add	r3, r2
  400db6:	3308      	adds	r3, #8
  400db8:	681b      	ldr	r3, [r3, #0]
  400dba:	79ba      	ldrb	r2, [r7, #6]
  400dbc:	4610      	mov	r0, r2
  400dbe:	4798      	blx	r3
  400dc0:	4603      	mov	r3, r0
  400dc2:	2b00      	cmp	r3, #0
  400dc4:	bf14      	ite	ne
  400dc6:	2301      	movne	r3, #1
  400dc8:	2300      	moveq	r3, #0
  400dca:	b2db      	uxtb	r3, r3
  400dcc:	e00d      	b.n	400dea <mem_unload+0x76>
              Lun_usb_unload(lun - LUN_ID_USB, unload);
# else
              !unload; /* Can not unload: load success, unload fail */
# endif
#else
              false; /* No mem, unload/load fail */
  400dce:	79bb      	ldrb	r3, [r7, #6]
  400dd0:	2b00      	cmp	r3, #0
  400dd2:	bf14      	ite	ne
  400dd4:	2301      	movne	r3, #1
  400dd6:	2300      	moveq	r3, #0
  400dd8:	b2db      	uxtb	r3, r3
  400dda:	f083 0301 	eor.w	r3, r3, #1
  400dde:	b2db      	uxtb	r3, r3
                  lun_desc[lun].unload(unload) : !unload) :
  400de0:	f003 0301 	and.w	r3, r3, #1
  400de4:	b2db      	uxtb	r3, r3
  400de6:	e000      	b.n	400dea <mem_unload+0x76>
  400de8:	2300      	movs	r3, #0
  unloaded =
  400dea:	73fb      	strb	r3, [r7, #15]
#endif

  Ctrl_access_unlock();
  400dec:	4b07      	ldr	r3, [pc, #28]	; (400e0c <mem_unload+0x98>)
  400dee:	6818      	ldr	r0, [r3, #0]
  400df0:	2300      	movs	r3, #0
  400df2:	2200      	movs	r2, #0
  400df4:	2100      	movs	r1, #0
  400df6:	4c06      	ldr	r4, [pc, #24]	; (400e10 <mem_unload+0x9c>)
  400df8:	47a0      	blx	r4

  return unloaded;
  400dfa:	7bfb      	ldrb	r3, [r7, #15]
}
  400dfc:	4618      	mov	r0, r3
  400dfe:	3714      	adds	r7, #20
  400e00:	46bd      	mov	sp, r7
  400e02:	bd90      	pop	{r4, r7, pc}
  400e04:	00400c69 	.word	0x00400c69
  400e08:	0041c8fc 	.word	0x0041c8fc
  400e0c:	20006b48 	.word	0x20006b48
  400e10:	00411831 	.word	0x00411831

00400e14 <mem_wr_protect>:

bool mem_wr_protect(U8 lun)
{
  400e14:	b590      	push	{r4, r7, lr}
  400e16:	b085      	sub	sp, #20
  400e18:	af00      	add	r7, sp, #0
  400e1a:	4603      	mov	r3, r0
  400e1c:	71fb      	strb	r3, [r7, #7]
  bool wr_protect;

  if (!Ctrl_access_lock()) return true;
  400e1e:	4b13      	ldr	r3, [pc, #76]	; (400e6c <mem_wr_protect+0x58>)
  400e20:	4798      	blx	r3
  400e22:	4603      	mov	r3, r0
  400e24:	f083 0301 	eor.w	r3, r3, #1
  400e28:	b2db      	uxtb	r3, r3
  400e2a:	2b00      	cmp	r3, #0
  400e2c:	d001      	beq.n	400e32 <mem_wr_protect+0x1e>
  400e2e:	2301      	movs	r3, #1
  400e30:	e018      	b.n	400e64 <mem_wr_protect+0x50>

  wr_protect =
#if MAX_LUN
             (lun < MAX_LUN) ? lun_desc[lun].wr_protect() :
  400e32:	79fb      	ldrb	r3, [r7, #7]
  400e34:	2b00      	cmp	r3, #0
  400e36:	d109      	bne.n	400e4c <mem_wr_protect+0x38>
  400e38:	79fb      	ldrb	r3, [r7, #7]
  400e3a:	4a0d      	ldr	r2, [pc, #52]	; (400e70 <mem_wr_protect+0x5c>)
  400e3c:	015b      	lsls	r3, r3, #5
  400e3e:	4413      	add	r3, r2
  400e40:	330c      	adds	r3, #12
  400e42:	681b      	ldr	r3, [r3, #0]
  400e44:	4798      	blx	r3
  400e46:	4603      	mov	r3, r0
  400e48:	2b00      	cmp	r3, #0
  400e4a:	d001      	beq.n	400e50 <mem_wr_protect+0x3c>
  400e4c:	2301      	movs	r3, #1
  400e4e:	e000      	b.n	400e52 <mem_wr_protect+0x3e>
  400e50:	2300      	movs	r3, #0
  wr_protect =
  400e52:	73fb      	strb	r3, [r7, #15]
                                 Lun_usb_wr_protect(lun - LUN_ID_USB);
#else
                                 true;
#endif

  Ctrl_access_unlock();
  400e54:	4b07      	ldr	r3, [pc, #28]	; (400e74 <mem_wr_protect+0x60>)
  400e56:	6818      	ldr	r0, [r3, #0]
  400e58:	2300      	movs	r3, #0
  400e5a:	2200      	movs	r2, #0
  400e5c:	2100      	movs	r1, #0
  400e5e:	4c06      	ldr	r4, [pc, #24]	; (400e78 <mem_wr_protect+0x64>)
  400e60:	47a0      	blx	r4

  return wr_protect;
  400e62:	7bfb      	ldrb	r3, [r7, #15]
}
  400e64:	4618      	mov	r0, r3
  400e66:	3714      	adds	r7, #20
  400e68:	46bd      	mov	sp, r7
  400e6a:	bd90      	pop	{r4, r7, pc}
  400e6c:	00400c69 	.word	0x00400c69
  400e70:	0041c8fc 	.word	0x0041c8fc
  400e74:	20006b48 	.word	0x20006b48
  400e78:	00411831 	.word	0x00411831

00400e7c <mem_removal>:


bool mem_removal(U8 lun)
{
  400e7c:	b590      	push	{r4, r7, lr}
  400e7e:	b085      	sub	sp, #20
  400e80:	af00      	add	r7, sp, #0
  400e82:	4603      	mov	r3, r0
  400e84:	71fb      	strb	r3, [r7, #7]
  bool removal;
#if MAX_LUN==0
  UNUSED(lun);
#endif

  if (!Ctrl_access_lock()) return true;
  400e86:	4b13      	ldr	r3, [pc, #76]	; (400ed4 <mem_removal+0x58>)
  400e88:	4798      	blx	r3
  400e8a:	4603      	mov	r3, r0
  400e8c:	f083 0301 	eor.w	r3, r3, #1
  400e90:	b2db      	uxtb	r3, r3
  400e92:	2b00      	cmp	r3, #0
  400e94:	d001      	beq.n	400e9a <mem_removal+0x1e>
  400e96:	2301      	movs	r3, #1
  400e98:	e018      	b.n	400ecc <mem_removal+0x50>

  removal =
#if MAX_LUN
          (lun < MAX_LUN) ? lun_desc[lun].removal() :
  400e9a:	79fb      	ldrb	r3, [r7, #7]
  400e9c:	2b00      	cmp	r3, #0
  400e9e:	d109      	bne.n	400eb4 <mem_removal+0x38>
  400ea0:	79fb      	ldrb	r3, [r7, #7]
  400ea2:	4a0d      	ldr	r2, [pc, #52]	; (400ed8 <mem_removal+0x5c>)
  400ea4:	015b      	lsls	r3, r3, #5
  400ea6:	4413      	add	r3, r2
  400ea8:	3310      	adds	r3, #16
  400eaa:	681b      	ldr	r3, [r3, #0]
  400eac:	4798      	blx	r3
  400eae:	4603      	mov	r3, r0
  400eb0:	2b00      	cmp	r3, #0
  400eb2:	d001      	beq.n	400eb8 <mem_removal+0x3c>
  400eb4:	2301      	movs	r3, #1
  400eb6:	e000      	b.n	400eba <mem_removal+0x3e>
  400eb8:	2300      	movs	r3, #0
  removal =
  400eba:	73fb      	strb	r3, [r7, #15]
                              Lun_usb_removal();
#else
                              true;
#endif

  Ctrl_access_unlock();
  400ebc:	4b07      	ldr	r3, [pc, #28]	; (400edc <mem_removal+0x60>)
  400ebe:	6818      	ldr	r0, [r3, #0]
  400ec0:	2300      	movs	r3, #0
  400ec2:	2200      	movs	r2, #0
  400ec4:	2100      	movs	r1, #0
  400ec6:	4c06      	ldr	r4, [pc, #24]	; (400ee0 <mem_removal+0x64>)
  400ec8:	47a0      	blx	r4

  return removal;
  400eca:	7bfb      	ldrb	r3, [r7, #15]
}
  400ecc:	4618      	mov	r0, r3
  400ece:	3714      	adds	r7, #20
  400ed0:	46bd      	mov	sp, r7
  400ed2:	bd90      	pop	{r4, r7, pc}
  400ed4:	00400c69 	.word	0x00400c69
  400ed8:	0041c8fc 	.word	0x0041c8fc
  400edc:	20006b48 	.word	0x20006b48
  400ee0:	00411831 	.word	0x00411831

00400ee4 <mem_name>:


const char *mem_name(U8 lun)
{
  400ee4:	b480      	push	{r7}
  400ee6:	b083      	sub	sp, #12
  400ee8:	af00      	add	r7, sp, #0
  400eea:	4603      	mov	r3, r0
  400eec:	71fb      	strb	r3, [r7, #7]
#if MAX_LUN==0
  UNUSED(lun);
#endif
  return
#if MAX_LUN
       (lun < MAX_LUN) ? lun_desc[lun].name :
  400eee:	79fb      	ldrb	r3, [r7, #7]
  400ef0:	2b00      	cmp	r3, #0
  400ef2:	d101      	bne.n	400ef8 <mem_name+0x14>
  400ef4:	4b04      	ldr	r3, [pc, #16]	; (400f08 <mem_name+0x24>)
  400ef6:	e000      	b.n	400efa <mem_name+0x16>
  400ef8:	2300      	movs	r3, #0
#if LUN_USB == ENABLE
                           LUN_USB_NAME;
#else
                           NULL;
#endif
}
  400efa:	4618      	mov	r0, r3
  400efc:	370c      	adds	r7, #12
  400efe:	46bd      	mov	sp, r7
  400f00:	f85d 7b04 	ldr.w	r7, [sp], #4
  400f04:	4770      	bx	lr
  400f06:	bf00      	nop
  400f08:	0041c8e0 	.word	0x0041c8e0

00400f0c <udi_msc_enable>:

//@}


bool udi_msc_enable(void)
{
  400f0c:	b580      	push	{r7, lr}
  400f0e:	b082      	sub	sp, #8
  400f10:	af00      	add	r7, sp, #0
	uint8_t lun;
	udi_msc_b_trans_req = false;
  400f12:	4b1f      	ldr	r3, [pc, #124]	; (400f90 <udi_msc_enable+0x84>)
  400f14:	2200      	movs	r2, #0
  400f16:	701a      	strb	r2, [r3, #0]
	udi_msc_b_cbw_invalid = false;
  400f18:	4b1e      	ldr	r3, [pc, #120]	; (400f94 <udi_msc_enable+0x88>)
  400f1a:	2200      	movs	r2, #0
  400f1c:	701a      	strb	r2, [r3, #0]
	udi_msc_b_ack_trans = true;
  400f1e:	4b1e      	ldr	r3, [pc, #120]	; (400f98 <udi_msc_enable+0x8c>)
  400f20:	2201      	movs	r2, #1
  400f22:	701a      	strb	r2, [r3, #0]
	udi_msc_b_reset_trans = true;
  400f24:	4b1d      	ldr	r3, [pc, #116]	; (400f9c <udi_msc_enable+0x90>)
  400f26:	2201      	movs	r2, #1
  400f28:	701a      	strb	r2, [r3, #0]
	udi_msc_nb_lun = get_nb_lun();
  400f2a:	4b1d      	ldr	r3, [pc, #116]	; (400fa0 <udi_msc_enable+0x94>)
  400f2c:	4798      	blx	r3
  400f2e:	4603      	mov	r3, r0
  400f30:	461a      	mov	r2, r3
  400f32:	4b1c      	ldr	r3, [pc, #112]	; (400fa4 <udi_msc_enable+0x98>)
  400f34:	701a      	strb	r2, [r3, #0]
	if (0 == udi_msc_nb_lun)
  400f36:	4b1b      	ldr	r3, [pc, #108]	; (400fa4 <udi_msc_enable+0x98>)
  400f38:	781b      	ldrb	r3, [r3, #0]
  400f3a:	2b00      	cmp	r3, #0
  400f3c:	d101      	bne.n	400f42 <udi_msc_enable+0x36>
		return false; // No lun available, then not authorize to enable interface
  400f3e:	2300      	movs	r3, #0
  400f40:	e022      	b.n	400f88 <udi_msc_enable+0x7c>
	udi_msc_nb_lun--;
  400f42:	4b18      	ldr	r3, [pc, #96]	; (400fa4 <udi_msc_enable+0x98>)
  400f44:	781b      	ldrb	r3, [r3, #0]
  400f46:	3b01      	subs	r3, #1
  400f48:	b2da      	uxtb	r2, r3
  400f4a:	4b16      	ldr	r3, [pc, #88]	; (400fa4 <udi_msc_enable+0x98>)
  400f4c:	701a      	strb	r2, [r3, #0]
	// Call application callback
	// to initialize memories or signal that interface is enabled
	if (!UDI_MSC_ENABLE_EXT())
  400f4e:	4b16      	ldr	r3, [pc, #88]	; (400fa8 <udi_msc_enable+0x9c>)
  400f50:	4798      	blx	r3
  400f52:	4603      	mov	r3, r0
  400f54:	f083 0301 	eor.w	r3, r3, #1
  400f58:	b2db      	uxtb	r3, r3
  400f5a:	2b00      	cmp	r3, #0
  400f5c:	d001      	beq.n	400f62 <udi_msc_enable+0x56>
		return false;
  400f5e:	2300      	movs	r3, #0
  400f60:	e012      	b.n	400f88 <udi_msc_enable+0x7c>
	// Load the medium on each LUN
	for (lun = 0; lun <= udi_msc_nb_lun; lun ++) {
  400f62:	2300      	movs	r3, #0
  400f64:	71fb      	strb	r3, [r7, #7]
  400f66:	e007      	b.n	400f78 <udi_msc_enable+0x6c>
		mem_unload(lun, false);
  400f68:	79fb      	ldrb	r3, [r7, #7]
  400f6a:	2100      	movs	r1, #0
  400f6c:	4618      	mov	r0, r3
  400f6e:	4b0f      	ldr	r3, [pc, #60]	; (400fac <udi_msc_enable+0xa0>)
  400f70:	4798      	blx	r3
	for (lun = 0; lun <= udi_msc_nb_lun; lun ++) {
  400f72:	79fb      	ldrb	r3, [r7, #7]
  400f74:	3301      	adds	r3, #1
  400f76:	71fb      	strb	r3, [r7, #7]
  400f78:	4b0a      	ldr	r3, [pc, #40]	; (400fa4 <udi_msc_enable+0x98>)
  400f7a:	781b      	ldrb	r3, [r3, #0]
  400f7c:	79fa      	ldrb	r2, [r7, #7]
  400f7e:	429a      	cmp	r2, r3
  400f80:	d9f2      	bls.n	400f68 <udi_msc_enable+0x5c>
	}
	// Start MSC process by CBW reception
	udi_msc_cbw_wait();
  400f82:	4b0b      	ldr	r3, [pc, #44]	; (400fb0 <udi_msc_enable+0xa4>)
  400f84:	4798      	blx	r3
	return true;
  400f86:	2301      	movs	r3, #1
}
  400f88:	4618      	mov	r0, r3
  400f8a:	3708      	adds	r7, #8
  400f8c:	46bd      	mov	sp, r7
  400f8e:	bd80      	pop	{r7, pc}
  400f90:	20006b83 	.word	0x20006b83
  400f94:	20006b82 	.word	0x20006b82
  400f98:	20000021 	.word	0x20000021
  400f9c:	20000022 	.word	0x20000022
  400fa0:	00400c9d 	.word	0x00400c9d
  400fa4:	20006b6c 	.word	0x20006b6c
  400fa8:	00416315 	.word	0x00416315
  400fac:	00400d75 	.word	0x00400d75
  400fb0:	00401125 	.word	0x00401125

00400fb4 <udi_msc_disable>:


void udi_msc_disable(void)
{
  400fb4:	b580      	push	{r7, lr}
  400fb6:	af00      	add	r7, sp, #0
	udi_msc_b_trans_req = false;
  400fb8:	4b06      	ldr	r3, [pc, #24]	; (400fd4 <udi_msc_disable+0x20>)
  400fba:	2200      	movs	r2, #0
  400fbc:	701a      	strb	r2, [r3, #0]
	udi_msc_b_ack_trans = true;
  400fbe:	4b06      	ldr	r3, [pc, #24]	; (400fd8 <udi_msc_disable+0x24>)
  400fc0:	2201      	movs	r2, #1
  400fc2:	701a      	strb	r2, [r3, #0]
	udi_msc_b_reset_trans = true;
  400fc4:	4b05      	ldr	r3, [pc, #20]	; (400fdc <udi_msc_disable+0x28>)
  400fc6:	2201      	movs	r2, #1
  400fc8:	701a      	strb	r2, [r3, #0]
	UDI_MSC_DISABLE_EXT();
  400fca:	4b05      	ldr	r3, [pc, #20]	; (400fe0 <udi_msc_disable+0x2c>)
  400fcc:	4798      	blx	r3
}
  400fce:	bf00      	nop
  400fd0:	bd80      	pop	{r7, pc}
  400fd2:	bf00      	nop
  400fd4:	20006b83 	.word	0x20006b83
  400fd8:	20000021 	.word	0x20000021
  400fdc:	20000022 	.word	0x20000022
  400fe0:	00416331 	.word	0x00416331

00400fe4 <udi_msc_setup>:


bool udi_msc_setup(void)
{
  400fe4:	b580      	push	{r7, lr}
  400fe6:	af00      	add	r7, sp, #0
	if (Udd_setup_is_in()) {
  400fe8:	4b28      	ldr	r3, [pc, #160]	; (40108c <udi_msc_setup+0xa8>)
  400fea:	781b      	ldrb	r3, [r3, #0]
  400fec:	b25b      	sxtb	r3, r3
  400fee:	2b00      	cmp	r3, #0
  400ff0:	da1d      	bge.n	40102e <udi_msc_setup+0x4a>
		// Requests Interface GET
		if (Udd_setup_type() == USB_REQ_TYPE_CLASS) {
  400ff2:	4b26      	ldr	r3, [pc, #152]	; (40108c <udi_msc_setup+0xa8>)
  400ff4:	781b      	ldrb	r3, [r3, #0]
  400ff6:	f003 0360 	and.w	r3, r3, #96	; 0x60
  400ffa:	2b20      	cmp	r3, #32
  400ffc:	d117      	bne.n	40102e <udi_msc_setup+0x4a>
			// Requests Class Interface Get
			switch (udd_g_ctrlreq.req.bRequest) {
  400ffe:	4b23      	ldr	r3, [pc, #140]	; (40108c <udi_msc_setup+0xa8>)
  401000:	785b      	ldrb	r3, [r3, #1]
  401002:	2bfe      	cmp	r3, #254	; 0xfe
  401004:	d113      	bne.n	40102e <udi_msc_setup+0x4a>
			case USB_REQ_MSC_GET_MAX_LUN:
				// Give the number of memories available
				if (1 != udd_g_ctrlreq.req.wLength)
  401006:	4b21      	ldr	r3, [pc, #132]	; (40108c <udi_msc_setup+0xa8>)
  401008:	88db      	ldrh	r3, [r3, #6]
  40100a:	2b01      	cmp	r3, #1
  40100c:	d001      	beq.n	401012 <udi_msc_setup+0x2e>
					return false;	// Error for USB host
  40100e:	2300      	movs	r3, #0
  401010:	e039      	b.n	401086 <udi_msc_setup+0xa2>
				if (0 != udd_g_ctrlreq.req.wValue)
  401012:	4b1e      	ldr	r3, [pc, #120]	; (40108c <udi_msc_setup+0xa8>)
  401014:	885b      	ldrh	r3, [r3, #2]
  401016:	2b00      	cmp	r3, #0
  401018:	d001      	beq.n	40101e <udi_msc_setup+0x3a>
					return false;
  40101a:	2300      	movs	r3, #0
  40101c:	e033      	b.n	401086 <udi_msc_setup+0xa2>
				udd_g_ctrlreq.payload = &udi_msc_nb_lun;
  40101e:	4b1b      	ldr	r3, [pc, #108]	; (40108c <udi_msc_setup+0xa8>)
  401020:	4a1b      	ldr	r2, [pc, #108]	; (401090 <udi_msc_setup+0xac>)
  401022:	609a      	str	r2, [r3, #8]
				udd_g_ctrlreq.payload_size = 1;
  401024:	4b19      	ldr	r3, [pc, #100]	; (40108c <udi_msc_setup+0xa8>)
  401026:	2201      	movs	r2, #1
  401028:	819a      	strh	r2, [r3, #12]
				return true;
  40102a:	2301      	movs	r3, #1
  40102c:	e02b      	b.n	401086 <udi_msc_setup+0xa2>
			}
		}
	}
	if (Udd_setup_is_out()) {
  40102e:	4b17      	ldr	r3, [pc, #92]	; (40108c <udi_msc_setup+0xa8>)
  401030:	781b      	ldrb	r3, [r3, #0]
  401032:	b25b      	sxtb	r3, r3
  401034:	2b00      	cmp	r3, #0
  401036:	db25      	blt.n	401084 <udi_msc_setup+0xa0>
		// Requests Interface SET
		if (Udd_setup_type() == USB_REQ_TYPE_CLASS) {
  401038:	4b14      	ldr	r3, [pc, #80]	; (40108c <udi_msc_setup+0xa8>)
  40103a:	781b      	ldrb	r3, [r3, #0]
  40103c:	f003 0360 	and.w	r3, r3, #96	; 0x60
  401040:	2b20      	cmp	r3, #32
  401042:	d11f      	bne.n	401084 <udi_msc_setup+0xa0>
			// Requests Class Interface Set
			switch (udd_g_ctrlreq.req.bRequest) {
  401044:	4b11      	ldr	r3, [pc, #68]	; (40108c <udi_msc_setup+0xa8>)
  401046:	785b      	ldrb	r3, [r3, #1]
  401048:	2bff      	cmp	r3, #255	; 0xff
  40104a:	d11b      	bne.n	401084 <udi_msc_setup+0xa0>
			case USB_REQ_MSC_BULK_RESET:
				// Reset MSC interface
				if (0 != udd_g_ctrlreq.req.wLength)
  40104c:	4b0f      	ldr	r3, [pc, #60]	; (40108c <udi_msc_setup+0xa8>)
  40104e:	88db      	ldrh	r3, [r3, #6]
  401050:	2b00      	cmp	r3, #0
  401052:	d001      	beq.n	401058 <udi_msc_setup+0x74>
					return false;
  401054:	2300      	movs	r3, #0
  401056:	e016      	b.n	401086 <udi_msc_setup+0xa2>
				if (0 != udd_g_ctrlreq.req.wValue)
  401058:	4b0c      	ldr	r3, [pc, #48]	; (40108c <udi_msc_setup+0xa8>)
  40105a:	885b      	ldrh	r3, [r3, #2]
  40105c:	2b00      	cmp	r3, #0
  40105e:	d001      	beq.n	401064 <udi_msc_setup+0x80>
					return false;
  401060:	2300      	movs	r3, #0
  401062:	e010      	b.n	401086 <udi_msc_setup+0xa2>
				udi_msc_b_cbw_invalid = false;
  401064:	4b0b      	ldr	r3, [pc, #44]	; (401094 <udi_msc_setup+0xb0>)
  401066:	2200      	movs	r2, #0
  401068:	701a      	strb	r2, [r3, #0]
				udi_msc_b_trans_req = false;
  40106a:	4b0b      	ldr	r3, [pc, #44]	; (401098 <udi_msc_setup+0xb4>)
  40106c:	2200      	movs	r2, #0
  40106e:	701a      	strb	r2, [r3, #0]
				// Abort all tasks (transfer or clear stall wait) on endpoints
				udd_ep_abort(UDI_MSC_EP_OUT);
  401070:	2002      	movs	r0, #2
  401072:	4b0a      	ldr	r3, [pc, #40]	; (40109c <udi_msc_setup+0xb8>)
  401074:	4798      	blx	r3
				udd_ep_abort(UDI_MSC_EP_IN);
  401076:	2081      	movs	r0, #129	; 0x81
  401078:	4b08      	ldr	r3, [pc, #32]	; (40109c <udi_msc_setup+0xb8>)
  40107a:	4798      	blx	r3
				// Restart by CBW wait
				udi_msc_cbw_wait();
  40107c:	4b08      	ldr	r3, [pc, #32]	; (4010a0 <udi_msc_setup+0xbc>)
  40107e:	4798      	blx	r3
				return true;
  401080:	2301      	movs	r3, #1
  401082:	e000      	b.n	401086 <udi_msc_setup+0xa2>
			}
		}
	}
	return false;	// Not supported request
  401084:	2300      	movs	r3, #0
}
  401086:	4618      	mov	r0, r3
  401088:	bd80      	pop	{r7, pc}
  40108a:	bf00      	nop
  40108c:	2000b598 	.word	0x2000b598
  401090:	20006b6c 	.word	0x20006b6c
  401094:	20006b82 	.word	0x20006b82
  401098:	20006b83 	.word	0x20006b83
  40109c:	004052cd 	.word	0x004052cd
  4010a0:	00401125 	.word	0x00401125

004010a4 <udi_msc_getsetting>:

uint8_t udi_msc_getsetting(void)
{
  4010a4:	b480      	push	{r7}
  4010a6:	af00      	add	r7, sp, #0
	return 0;	// MSC don't have multiple alternate setting
  4010a8:	2300      	movs	r3, #0
}
  4010aa:	4618      	mov	r0, r3
  4010ac:	46bd      	mov	sp, r7
  4010ae:	f85d 7b04 	ldr.w	r7, [sp], #4
  4010b2:	4770      	bx	lr

004010b4 <udi_msc_cbw_invalid>:

//---------------------------------------------
//------- Routines to process CBW packet

static void udi_msc_cbw_invalid(void)
{
  4010b4:	b580      	push	{r7, lr}
  4010b6:	af00      	add	r7, sp, #0
	if (!udi_msc_b_cbw_invalid)
  4010b8:	4b08      	ldr	r3, [pc, #32]	; (4010dc <udi_msc_cbw_invalid+0x28>)
  4010ba:	781b      	ldrb	r3, [r3, #0]
  4010bc:	f083 0301 	eor.w	r3, r3, #1
  4010c0:	b2db      	uxtb	r3, r3
  4010c2:	2b00      	cmp	r3, #0
  4010c4:	d107      	bne.n	4010d6 <udi_msc_cbw_invalid+0x22>
		return;	// Don't re-stall endpoint if error reseted by setup
	udd_ep_set_halt(UDI_MSC_EP_OUT);
  4010c6:	2002      	movs	r0, #2
  4010c8:	4b05      	ldr	r3, [pc, #20]	; (4010e0 <udi_msc_cbw_invalid+0x2c>)
  4010ca:	4798      	blx	r3
	// If stall cleared then re-stall it. Only Setup MSC Reset can clear it
	udd_ep_wait_stall_clear(UDI_MSC_EP_OUT, udi_msc_cbw_invalid);
  4010cc:	4905      	ldr	r1, [pc, #20]	; (4010e4 <udi_msc_cbw_invalid+0x30>)
  4010ce:	2002      	movs	r0, #2
  4010d0:	4b05      	ldr	r3, [pc, #20]	; (4010e8 <udi_msc_cbw_invalid+0x34>)
  4010d2:	4798      	blx	r3
  4010d4:	e000      	b.n	4010d8 <udi_msc_cbw_invalid+0x24>
		return;	// Don't re-stall endpoint if error reseted by setup
  4010d6:	bf00      	nop
}
  4010d8:	bd80      	pop	{r7, pc}
  4010da:	bf00      	nop
  4010dc:	20006b82 	.word	0x20006b82
  4010e0:	00404f55 	.word	0x00404f55
  4010e4:	004010b5 	.word	0x004010b5
  4010e8:	004054e9 	.word	0x004054e9

004010ec <udi_msc_csw_invalid>:

static void udi_msc_csw_invalid(void)
{
  4010ec:	b580      	push	{r7, lr}
  4010ee:	af00      	add	r7, sp, #0
	if (!udi_msc_b_cbw_invalid)
  4010f0:	4b08      	ldr	r3, [pc, #32]	; (401114 <udi_msc_csw_invalid+0x28>)
  4010f2:	781b      	ldrb	r3, [r3, #0]
  4010f4:	f083 0301 	eor.w	r3, r3, #1
  4010f8:	b2db      	uxtb	r3, r3
  4010fa:	2b00      	cmp	r3, #0
  4010fc:	d107      	bne.n	40110e <udi_msc_csw_invalid+0x22>
		return;	// Don't re-stall endpoint if error reseted by setup
	udd_ep_set_halt(UDI_MSC_EP_IN);
  4010fe:	2081      	movs	r0, #129	; 0x81
  401100:	4b05      	ldr	r3, [pc, #20]	; (401118 <udi_msc_csw_invalid+0x2c>)
  401102:	4798      	blx	r3
	// If stall cleared then re-stall it. Only Setup MSC Reset can clear it
	udd_ep_wait_stall_clear(UDI_MSC_EP_IN, udi_msc_csw_invalid);
  401104:	4905      	ldr	r1, [pc, #20]	; (40111c <udi_msc_csw_invalid+0x30>)
  401106:	2081      	movs	r0, #129	; 0x81
  401108:	4b05      	ldr	r3, [pc, #20]	; (401120 <udi_msc_csw_invalid+0x34>)
  40110a:	4798      	blx	r3
  40110c:	e000      	b.n	401110 <udi_msc_csw_invalid+0x24>
		return;	// Don't re-stall endpoint if error reseted by setup
  40110e:	bf00      	nop
}
  401110:	bd80      	pop	{r7, pc}
  401112:	bf00      	nop
  401114:	20006b82 	.word	0x20006b82
  401118:	00404f55 	.word	0x00404f55
  40111c:	004010ed 	.word	0x004010ed
  401120:	004054e9 	.word	0x004054e9

00401124 <udi_msc_cbw_wait>:

static void udi_msc_cbw_wait(void)
{
  401124:	b590      	push	{r4, r7, lr}
  401126:	b083      	sub	sp, #12
  401128:	af02      	add	r7, sp, #8
	// Register buffer and callback on OUT endpoint
	if (!udd_ep_run(UDI_MSC_EP_OUT, true,
  40112a:	4b0b      	ldr	r3, [pc, #44]	; (401158 <udi_msc_cbw_wait+0x34>)
  40112c:	9300      	str	r3, [sp, #0]
  40112e:	231f      	movs	r3, #31
  401130:	4a0a      	ldr	r2, [pc, #40]	; (40115c <udi_msc_cbw_wait+0x38>)
  401132:	2101      	movs	r1, #1
  401134:	2002      	movs	r0, #2
  401136:	4c0a      	ldr	r4, [pc, #40]	; (401160 <udi_msc_cbw_wait+0x3c>)
  401138:	47a0      	blx	r4
  40113a:	4603      	mov	r3, r0
  40113c:	f083 0301 	eor.w	r3, r3, #1
  401140:	b2db      	uxtb	r3, r3
  401142:	2b00      	cmp	r3, #0
  401144:	d003      	beq.n	40114e <udi_msc_cbw_wait+0x2a>
					(uint8_t *) & udi_msc_cbw,
					sizeof(udi_msc_cbw),
					udi_msc_cbw_received)) {
		// OUT endpoint not available (halted), then wait a clear of halt.
		udd_ep_wait_stall_clear(UDI_MSC_EP_OUT, udi_msc_cbw_wait);
  401146:	4907      	ldr	r1, [pc, #28]	; (401164 <udi_msc_cbw_wait+0x40>)
  401148:	2002      	movs	r0, #2
  40114a:	4b07      	ldr	r3, [pc, #28]	; (401168 <udi_msc_cbw_wait+0x44>)
  40114c:	4798      	blx	r3
	}
}
  40114e:	bf00      	nop
  401150:	3704      	adds	r7, #4
  401152:	46bd      	mov	sp, r7
  401154:	bd90      	pop	{r4, r7, pc}
  401156:	bf00      	nop
  401158:	0040116d 	.word	0x0040116d
  40115c:	20006b4c 	.word	0x20006b4c
  401160:	00405175 	.word	0x00405175
  401164:	00401125 	.word	0x00401125
  401168:	004054e9 	.word	0x004054e9

0040116c <udi_msc_cbw_received>:


static void udi_msc_cbw_received(udd_ep_status_t status,
		iram_size_t nb_received, udd_ep_id_t ep)
{
  40116c:	b580      	push	{r7, lr}
  40116e:	b082      	sub	sp, #8
  401170:	af00      	add	r7, sp, #0
  401172:	4603      	mov	r3, r0
  401174:	6039      	str	r1, [r7, #0]
  401176:	71fb      	strb	r3, [r7, #7]
  401178:	4613      	mov	r3, r2
  40117a:	71bb      	strb	r3, [r7, #6]
	UNUSED(ep);
	// Check status of transfer
	if (UDD_EP_TRANSFER_OK != status) {
  40117c:	79fb      	ldrb	r3, [r7, #7]
  40117e:	2b00      	cmp	r3, #0
  401180:	f040 8111 	bne.w	4013a6 <udi_msc_cbw_received+0x23a>
		// Now wait MSC setup reset to relaunch CBW reception
		return;
	}
	// Check CBW integrity:
	// transfer status/CBW length/CBW signature
	if ((sizeof(udi_msc_cbw) != nb_received)
  401184:	683b      	ldr	r3, [r7, #0]
  401186:	2b1f      	cmp	r3, #31
  401188:	d104      	bne.n	401194 <udi_msc_cbw_received+0x28>
			|| (udi_msc_cbw.dCBWSignature !=
  40118a:	4b89      	ldr	r3, [pc, #548]	; (4013b0 <udi_msc_cbw_received+0x244>)
  40118c:	681b      	ldr	r3, [r3, #0]
  40118e:	4a89      	ldr	r2, [pc, #548]	; (4013b4 <udi_msc_cbw_received+0x248>)
  401190:	4293      	cmp	r3, r2
  401192:	d007      	beq.n	4011a4 <udi_msc_cbw_received+0x38>
					CPU_TO_BE32(USB_CBW_SIGNATURE))) {
		// (5.2.1) Devices receiving a CBW with an invalid signature should stall
		// further traffic on the Bulk In pipe, and either stall further traffic
		// or accept and discard further traffic on the Bulk Out pipe, until
		// reset recovery.
		udi_msc_b_cbw_invalid = true;
  401194:	4b88      	ldr	r3, [pc, #544]	; (4013b8 <udi_msc_cbw_received+0x24c>)
  401196:	2201      	movs	r2, #1
  401198:	701a      	strb	r2, [r3, #0]
		udi_msc_cbw_invalid();
  40119a:	4b88      	ldr	r3, [pc, #544]	; (4013bc <udi_msc_cbw_received+0x250>)
  40119c:	4798      	blx	r3
		udi_msc_csw_invalid();
  40119e:	4b88      	ldr	r3, [pc, #544]	; (4013c0 <udi_msc_cbw_received+0x254>)
  4011a0:	4798      	blx	r3
		return;
  4011a2:	e101      	b.n	4013a8 <udi_msc_cbw_received+0x23c>
	}
	// Check LUN asked
	udi_msc_cbw.bCBWLUN &= USB_CBW_LUN_MASK;
  4011a4:	4b82      	ldr	r3, [pc, #520]	; (4013b0 <udi_msc_cbw_received+0x244>)
  4011a6:	7b5b      	ldrb	r3, [r3, #13]
  4011a8:	f003 030f 	and.w	r3, r3, #15
  4011ac:	b2da      	uxtb	r2, r3
  4011ae:	4b80      	ldr	r3, [pc, #512]	; (4013b0 <udi_msc_cbw_received+0x244>)
  4011b0:	735a      	strb	r2, [r3, #13]
	if (udi_msc_cbw.bCBWLUN > udi_msc_nb_lun) {
  4011b2:	4b7f      	ldr	r3, [pc, #508]	; (4013b0 <udi_msc_cbw_received+0x244>)
  4011b4:	7b5a      	ldrb	r2, [r3, #13]
  4011b6:	4b83      	ldr	r3, [pc, #524]	; (4013c4 <udi_msc_cbw_received+0x258>)
  4011b8:	781b      	ldrb	r3, [r3, #0]
  4011ba:	429a      	cmp	r2, r3
  4011bc:	d904      	bls.n	4011c8 <udi_msc_cbw_received+0x5c>
		// Bad LUN, then stop command process
		udi_msc_sense_fail_cdb_invalid();
  4011be:	4b82      	ldr	r3, [pc, #520]	; (4013c8 <udi_msc_cbw_received+0x25c>)
  4011c0:	4798      	blx	r3
		udi_msc_csw_process();
  4011c2:	4b82      	ldr	r3, [pc, #520]	; (4013cc <udi_msc_cbw_received+0x260>)
  4011c4:	4798      	blx	r3
		return;
  4011c6:	e0ef      	b.n	4013a8 <udi_msc_cbw_received+0x23c>
	}
	// Prepare CSW residue field with the size requested
	udi_msc_csw.dCSWDataResidue =
			le32_to_cpu(udi_msc_cbw.dCBWDataTransferLength);
  4011c8:	4b79      	ldr	r3, [pc, #484]	; (4013b0 <udi_msc_cbw_received+0x244>)
  4011ca:	689b      	ldr	r3, [r3, #8]
	udi_msc_csw.dCSWDataResidue =
  4011cc:	4a80      	ldr	r2, [pc, #512]	; (4013d0 <udi_msc_cbw_received+0x264>)
  4011ce:	6093      	str	r3, [r2, #8]

	// Decode opcode
	switch (udi_msc_cbw.CDB[0]) {
  4011d0:	4b77      	ldr	r3, [pc, #476]	; (4013b0 <udi_msc_cbw_received+0x244>)
  4011d2:	7bdb      	ldrb	r3, [r3, #15]
  4011d4:	2b5a      	cmp	r3, #90	; 0x5a
  4011d6:	f200 80e0 	bhi.w	40139a <udi_msc_cbw_received+0x22e>
  4011da:	a201      	add	r2, pc, #4	; (adr r2, 4011e0 <udi_msc_cbw_received+0x74>)
  4011dc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  4011e0:	00401369 	.word	0x00401369
  4011e4:	0040139b 	.word	0x0040139b
  4011e8:	0040139b 	.word	0x0040139b
  4011ec:	0040134d 	.word	0x0040134d
  4011f0:	0040139b 	.word	0x0040139b
  4011f4:	0040139b 	.word	0x0040139b
  4011f8:	0040139b 	.word	0x0040139b
  4011fc:	0040139b 	.word	0x0040139b
  401200:	0040139b 	.word	0x0040139b
  401204:	0040139b 	.word	0x0040139b
  401208:	0040139b 	.word	0x0040139b
  40120c:	0040139b 	.word	0x0040139b
  401210:	0040139b 	.word	0x0040139b
  401214:	0040139b 	.word	0x0040139b
  401218:	0040139b 	.word	0x0040139b
  40121c:	0040139b 	.word	0x0040139b
  401220:	0040139b 	.word	0x0040139b
  401224:	0040139b 	.word	0x0040139b
  401228:	00401353 	.word	0x00401353
  40122c:	0040139b 	.word	0x0040139b
  401230:	0040139b 	.word	0x0040139b
  401234:	0040139b 	.word	0x0040139b
  401238:	0040139b 	.word	0x0040139b
  40123c:	0040139b 	.word	0x0040139b
  401240:	0040139b 	.word	0x0040139b
  401244:	0040139b 	.word	0x0040139b
  401248:	00401359 	.word	0x00401359
  40124c:	00401375 	.word	0x00401375
  401250:	0040139b 	.word	0x0040139b
  401254:	0040139b 	.word	0x0040139b
  401258:	0040137b 	.word	0x0040137b
  40125c:	0040139b 	.word	0x0040139b
  401260:	0040139b 	.word	0x0040139b
  401264:	0040139b 	.word	0x0040139b
  401268:	0040139b 	.word	0x0040139b
  40126c:	0040139b 	.word	0x0040139b
  401270:	0040139b 	.word	0x0040139b
  401274:	0040136f 	.word	0x0040136f
  401278:	0040139b 	.word	0x0040139b
  40127c:	0040139b 	.word	0x0040139b
  401280:	0040138b 	.word	0x0040138b
  401284:	0040139b 	.word	0x0040139b
  401288:	00401393 	.word	0x00401393
  40128c:	0040139b 	.word	0x0040139b
  401290:	0040139b 	.word	0x0040139b
  401294:	0040139b 	.word	0x0040139b
  401298:	0040139b 	.word	0x0040139b
  40129c:	00401381 	.word	0x00401381
  4012a0:	0040139b 	.word	0x0040139b
  4012a4:	0040139b 	.word	0x0040139b
  4012a8:	0040139b 	.word	0x0040139b
  4012ac:	0040139b 	.word	0x0040139b
  4012b0:	0040139b 	.word	0x0040139b
  4012b4:	0040139b 	.word	0x0040139b
  4012b8:	0040139b 	.word	0x0040139b
  4012bc:	0040139b 	.word	0x0040139b
  4012c0:	0040139b 	.word	0x0040139b
  4012c4:	0040139b 	.word	0x0040139b
  4012c8:	0040139b 	.word	0x0040139b
  4012cc:	0040139b 	.word	0x0040139b
  4012d0:	0040139b 	.word	0x0040139b
  4012d4:	0040139b 	.word	0x0040139b
  4012d8:	0040139b 	.word	0x0040139b
  4012dc:	0040139b 	.word	0x0040139b
  4012e0:	0040139b 	.word	0x0040139b
  4012e4:	0040139b 	.word	0x0040139b
  4012e8:	0040139b 	.word	0x0040139b
  4012ec:	0040139b 	.word	0x0040139b
  4012f0:	0040139b 	.word	0x0040139b
  4012f4:	0040139b 	.word	0x0040139b
  4012f8:	0040139b 	.word	0x0040139b
  4012fc:	0040139b 	.word	0x0040139b
  401300:	0040139b 	.word	0x0040139b
  401304:	0040139b 	.word	0x0040139b
  401308:	0040139b 	.word	0x0040139b
  40130c:	0040139b 	.word	0x0040139b
  401310:	0040139b 	.word	0x0040139b
  401314:	0040139b 	.word	0x0040139b
  401318:	0040139b 	.word	0x0040139b
  40131c:	0040139b 	.word	0x0040139b
  401320:	0040139b 	.word	0x0040139b
  401324:	0040139b 	.word	0x0040139b
  401328:	0040139b 	.word	0x0040139b
  40132c:	0040139b 	.word	0x0040139b
  401330:	0040139b 	.word	0x0040139b
  401334:	0040139b 	.word	0x0040139b
  401338:	0040139b 	.word	0x0040139b
  40133c:	0040139b 	.word	0x0040139b
  401340:	0040139b 	.word	0x0040139b
  401344:	0040139b 	.word	0x0040139b
  401348:	00401361 	.word	0x00401361
	case SPC_REQUEST_SENSE:
		udi_msc_spc_requestsense();
  40134c:	4b21      	ldr	r3, [pc, #132]	; (4013d4 <udi_msc_cbw_received+0x268>)
  40134e:	4798      	blx	r3
		break;
  401350:	e02a      	b.n	4013a8 <udi_msc_cbw_received+0x23c>

	case SPC_INQUIRY:
		udi_msc_spc_inquiry();
  401352:	4b21      	ldr	r3, [pc, #132]	; (4013d8 <udi_msc_cbw_received+0x26c>)
  401354:	4798      	blx	r3
		break;
  401356:	e027      	b.n	4013a8 <udi_msc_cbw_received+0x23c>

	case SPC_MODE_SENSE6:
		udi_msc_spc_mode_sense(false);
  401358:	2000      	movs	r0, #0
  40135a:	4b20      	ldr	r3, [pc, #128]	; (4013dc <udi_msc_cbw_received+0x270>)
  40135c:	4798      	blx	r3
		break;
  40135e:	e023      	b.n	4013a8 <udi_msc_cbw_received+0x23c>
	case SPC_MODE_SENSE10:
		udi_msc_spc_mode_sense(true);
  401360:	2001      	movs	r0, #1
  401362:	4b1e      	ldr	r3, [pc, #120]	; (4013dc <udi_msc_cbw_received+0x270>)
  401364:	4798      	blx	r3
		break;
  401366:	e01f      	b.n	4013a8 <udi_msc_cbw_received+0x23c>

	case SPC_TEST_UNIT_READY:
		udi_msc_spc_testunitready();
  401368:	4b1d      	ldr	r3, [pc, #116]	; (4013e0 <udi_msc_cbw_received+0x274>)
  40136a:	4798      	blx	r3
		break;
  40136c:	e01c      	b.n	4013a8 <udi_msc_cbw_received+0x23c>

	case SBC_READ_CAPACITY10:
		udi_msc_sbc_read_capacity();
  40136e:	4b1d      	ldr	r3, [pc, #116]	; (4013e4 <udi_msc_cbw_received+0x278>)
  401370:	4798      	blx	r3
		break;
  401372:	e019      	b.n	4013a8 <udi_msc_cbw_received+0x23c>

	case SBC_START_STOP_UNIT:
		udi_msc_sbc_start_stop();
  401374:	4b1c      	ldr	r3, [pc, #112]	; (4013e8 <udi_msc_cbw_received+0x27c>)
  401376:	4798      	blx	r3
		break;
  401378:	e016      	b.n	4013a8 <udi_msc_cbw_received+0x23c>

		// Accepts request to support plug/plug in case of card reader
	case SPC_PREVENT_ALLOW_MEDIUM_REMOVAL:
		udi_msc_spc_prevent_allow_medium_removal();
  40137a:	4b1c      	ldr	r3, [pc, #112]	; (4013ec <udi_msc_cbw_received+0x280>)
  40137c:	4798      	blx	r3
		break;
  40137e:	e013      	b.n	4013a8 <udi_msc_cbw_received+0x23c>

		// Accepts request to support full format from Windows
	case SBC_VERIFY10:
		udi_msc_sense_pass();
  401380:	4b1b      	ldr	r3, [pc, #108]	; (4013f0 <udi_msc_cbw_received+0x284>)
  401382:	4798      	blx	r3
		udi_msc_csw_process();
  401384:	4b11      	ldr	r3, [pc, #68]	; (4013cc <udi_msc_cbw_received+0x260>)
  401386:	4798      	blx	r3
		break;
  401388:	e00e      	b.n	4013a8 <udi_msc_cbw_received+0x23c>

	case SBC_READ10:
		udi_msc_sbc_trans(true);
  40138a:	2001      	movs	r0, #1
  40138c:	4b19      	ldr	r3, [pc, #100]	; (4013f4 <udi_msc_cbw_received+0x288>)
  40138e:	4798      	blx	r3
		break;
  401390:	e00a      	b.n	4013a8 <udi_msc_cbw_received+0x23c>

	case SBC_WRITE10:
		udi_msc_sbc_trans(false);
  401392:	2000      	movs	r0, #0
  401394:	4b17      	ldr	r3, [pc, #92]	; (4013f4 <udi_msc_cbw_received+0x288>)
  401396:	4798      	blx	r3
		break;
  401398:	e006      	b.n	4013a8 <udi_msc_cbw_received+0x23c>

	default:
		udi_msc_sense_command_invalid();
  40139a:	4b17      	ldr	r3, [pc, #92]	; (4013f8 <udi_msc_cbw_received+0x28c>)
  40139c:	4798      	blx	r3
		udi_msc_csw_process();
  40139e:	4b0b      	ldr	r3, [pc, #44]	; (4013cc <udi_msc_cbw_received+0x260>)
  4013a0:	4798      	blx	r3
		break;
  4013a2:	bf00      	nop
  4013a4:	e000      	b.n	4013a8 <udi_msc_cbw_received+0x23c>
		return;
  4013a6:	bf00      	nop
	}
}
  4013a8:	3708      	adds	r7, #8
  4013aa:	46bd      	mov	sp, r7
  4013ac:	bd80      	pop	{r7, pc}
  4013ae:	bf00      	nop
  4013b0:	20006b4c 	.word	0x20006b4c
  4013b4:	43425355 	.word	0x43425355
  4013b8:	20006b82 	.word	0x20006b82
  4013bc:	004010b5 	.word	0x004010b5
  4013c0:	004010ed 	.word	0x004010ed
  4013c4:	20006b6c 	.word	0x20006b6c
  4013c8:	0040169d 	.word	0x0040169d
  4013cc:	004014d5 	.word	0x004014d5
  4013d0:	20000014 	.word	0x20000014
  4013d4:	004016cd 	.word	0x004016cd
  4013d8:	0040171d 	.word	0x0040171d
  4013dc:	0040188d 	.word	0x0040188d
  4013e0:	00401865 	.word	0x00401865
  4013e4:	00401a51 	.word	0x00401a51
  4013e8:	004019dd 	.word	0x004019dd
  4013ec:	004019a5 	.word	0x004019a5
  4013f0:	00401621 	.word	0x00401621
  4013f4:	00401ae9 	.word	0x00401ae9
  4013f8:	004016b5 	.word	0x004016b5

004013fc <udi_msc_cbw_validate>:


static bool udi_msc_cbw_validate(uint32_t alloc_len, uint8_t dir_flag)
{
  4013fc:	b580      	push	{r7, lr}
  4013fe:	b082      	sub	sp, #8
  401400:	af00      	add	r7, sp, #0
  401402:	6078      	str	r0, [r7, #4]
  401404:	460b      	mov	r3, r1
  401406:	70fb      	strb	r3, [r7, #3]
	 *  - Case  7: Hi < Di
	 *  - Case  8: Hi <> Do
	 *  - Case 10: Ho <> Di
	 *  - Case 13: Ho < Do
	 */
	if (((udi_msc_cbw.bmCBWFlags ^ dir_flag) & USB_CBW_DIRECTION_IN)
  401408:	4b0b      	ldr	r3, [pc, #44]	; (401438 <udi_msc_cbw_validate+0x3c>)
  40140a:	7b1a      	ldrb	r2, [r3, #12]
  40140c:	78fb      	ldrb	r3, [r7, #3]
  40140e:	4053      	eors	r3, r2
  401410:	b2db      	uxtb	r3, r3
  401412:	b25b      	sxtb	r3, r3
  401414:	2b00      	cmp	r3, #0
  401416:	db04      	blt.n	401422 <udi_msc_cbw_validate+0x26>
			|| (udi_msc_csw.dCSWDataResidue < alloc_len)) {
  401418:	4b08      	ldr	r3, [pc, #32]	; (40143c <udi_msc_cbw_validate+0x40>)
  40141a:	689a      	ldr	r2, [r3, #8]
  40141c:	687b      	ldr	r3, [r7, #4]
  40141e:	429a      	cmp	r2, r3
  401420:	d205      	bcs.n	40142e <udi_msc_cbw_validate+0x32>
		udi_msc_sense_fail_cdb_invalid();
  401422:	4b07      	ldr	r3, [pc, #28]	; (401440 <udi_msc_cbw_validate+0x44>)
  401424:	4798      	blx	r3
		udi_msc_csw_process();
  401426:	4b07      	ldr	r3, [pc, #28]	; (401444 <udi_msc_cbw_validate+0x48>)
  401428:	4798      	blx	r3
		return false;
  40142a:	2300      	movs	r3, #0
  40142c:	e000      	b.n	401430 <udi_msc_cbw_validate+0x34>
	 *  - Case  4: Hi > Dn
	 *  - Case  5: Hi > Di
	 *  - Case  9: Ho > Dn
	 *  - Case 11: Ho > Do
	 */
	return true;
  40142e:	2301      	movs	r3, #1
}
  401430:	4618      	mov	r0, r3
  401432:	3708      	adds	r7, #8
  401434:	46bd      	mov	sp, r7
  401436:	bd80      	pop	{r7, pc}
  401438:	20006b4c 	.word	0x20006b4c
  40143c:	20000014 	.word	0x20000014
  401440:	0040169d 	.word	0x0040169d
  401444:	004014d5 	.word	0x004014d5

00401448 <udi_msc_data_send>:

//---------------------------------------------
//------- Routines to process small data packet

static void udi_msc_data_send(uint8_t * buffer, uint8_t buf_size)
{
  401448:	b590      	push	{r4, r7, lr}
  40144a:	b085      	sub	sp, #20
  40144c:	af02      	add	r7, sp, #8
  40144e:	6078      	str	r0, [r7, #4]
  401450:	460b      	mov	r3, r1
  401452:	70fb      	strb	r3, [r7, #3]
	// Sends data on IN endpoint
	if (!udd_ep_run(UDI_MSC_EP_IN, true,
  401454:	78fa      	ldrb	r2, [r7, #3]
  401456:	4b0b      	ldr	r3, [pc, #44]	; (401484 <udi_msc_data_send+0x3c>)
  401458:	9300      	str	r3, [sp, #0]
  40145a:	4613      	mov	r3, r2
  40145c:	687a      	ldr	r2, [r7, #4]
  40145e:	2101      	movs	r1, #1
  401460:	2081      	movs	r0, #129	; 0x81
  401462:	4c09      	ldr	r4, [pc, #36]	; (401488 <udi_msc_data_send+0x40>)
  401464:	47a0      	blx	r4
  401466:	4603      	mov	r3, r0
  401468:	f083 0301 	eor.w	r3, r3, #1
  40146c:	b2db      	uxtb	r3, r3
  40146e:	2b00      	cmp	r3, #0
  401470:	d003      	beq.n	40147a <udi_msc_data_send+0x32>
					buffer, buf_size, udi_msc_data_sent)) {
		// If endpoint not available, then exit process command
		udi_msc_sense_fail_hardware();
  401472:	4b06      	ldr	r3, [pc, #24]	; (40148c <udi_msc_data_send+0x44>)
  401474:	4798      	blx	r3
		udi_msc_csw_process();
  401476:	4b06      	ldr	r3, [pc, #24]	; (401490 <udi_msc_data_send+0x48>)
  401478:	4798      	blx	r3
	}
}
  40147a:	bf00      	nop
  40147c:	370c      	adds	r7, #12
  40147e:	46bd      	mov	sp, r7
  401480:	bd90      	pop	{r4, r7, pc}
  401482:	bf00      	nop
  401484:	00401495 	.word	0x00401495
  401488:	00405175 	.word	0x00405175
  40148c:	0040166d 	.word	0x0040166d
  401490:	004014d5 	.word	0x004014d5

00401494 <udi_msc_data_sent>:


static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,
		udd_ep_id_t ep)
{
  401494:	b580      	push	{r7, lr}
  401496:	b082      	sub	sp, #8
  401498:	af00      	add	r7, sp, #0
  40149a:	4603      	mov	r3, r0
  40149c:	6039      	str	r1, [r7, #0]
  40149e:	71fb      	strb	r3, [r7, #7]
  4014a0:	4613      	mov	r3, r2
  4014a2:	71bb      	strb	r3, [r7, #6]
	UNUSED(ep);
	if (UDD_EP_TRANSFER_OK != status) {
  4014a4:	79fb      	ldrb	r3, [r7, #7]
  4014a6:	2b00      	cmp	r3, #0
  4014a8:	d10a      	bne.n	4014c0 <udi_msc_data_sent+0x2c>
		// Error protocol
		// Now wait MSC setup reset to relaunch CBW reception
		return;
	}
	// Update sense data
	udi_msc_sense_pass();
  4014aa:	4b07      	ldr	r3, [pc, #28]	; (4014c8 <udi_msc_data_sent+0x34>)
  4014ac:	4798      	blx	r3
	// Update CSW
	udi_msc_csw.dCSWDataResidue -= nb_sent;
  4014ae:	4b07      	ldr	r3, [pc, #28]	; (4014cc <udi_msc_data_sent+0x38>)
  4014b0:	689a      	ldr	r2, [r3, #8]
  4014b2:	683b      	ldr	r3, [r7, #0]
  4014b4:	1ad3      	subs	r3, r2, r3
  4014b6:	4a05      	ldr	r2, [pc, #20]	; (4014cc <udi_msc_data_sent+0x38>)
  4014b8:	6093      	str	r3, [r2, #8]
	udi_msc_csw_process();
  4014ba:	4b05      	ldr	r3, [pc, #20]	; (4014d0 <udi_msc_data_sent+0x3c>)
  4014bc:	4798      	blx	r3
  4014be:	e000      	b.n	4014c2 <udi_msc_data_sent+0x2e>
		return;
  4014c0:	bf00      	nop
}
  4014c2:	3708      	adds	r7, #8
  4014c4:	46bd      	mov	sp, r7
  4014c6:	bd80      	pop	{r7, pc}
  4014c8:	00401621 	.word	0x00401621
  4014cc:	20000014 	.word	0x20000014
  4014d0:	004014d5 	.word	0x004014d5

004014d4 <udi_msc_csw_process>:

//---------------------------------------------
//------- Routines to process CSW packet

static void udi_msc_csw_process(void)
{
  4014d4:	b580      	push	{r7, lr}
  4014d6:	af00      	add	r7, sp, #0
	if (0 != udi_msc_csw.dCSWDataResidue) {
  4014d8:	4b0d      	ldr	r3, [pc, #52]	; (401510 <udi_msc_csw_process+0x3c>)
  4014da:	689b      	ldr	r3, [r3, #8]
  4014dc:	2b00      	cmp	r3, #0
  4014de:	d00b      	beq.n	4014f8 <udi_msc_csw_process+0x24>
		// Residue not NULL
		// then STALL next request from USB host on corresponding endpoint
		if (udi_msc_cbw.bmCBWFlags & USB_CBW_DIRECTION_IN)
  4014e0:	4b0c      	ldr	r3, [pc, #48]	; (401514 <udi_msc_csw_process+0x40>)
  4014e2:	7b1b      	ldrb	r3, [r3, #12]
  4014e4:	b25b      	sxtb	r3, r3
  4014e6:	2b00      	cmp	r3, #0
  4014e8:	da03      	bge.n	4014f2 <udi_msc_csw_process+0x1e>
			udd_ep_set_halt(UDI_MSC_EP_IN);
  4014ea:	2081      	movs	r0, #129	; 0x81
  4014ec:	4b0a      	ldr	r3, [pc, #40]	; (401518 <udi_msc_csw_process+0x44>)
  4014ee:	4798      	blx	r3
  4014f0:	e002      	b.n	4014f8 <udi_msc_csw_process+0x24>
		else
			udd_ep_set_halt(UDI_MSC_EP_OUT);
  4014f2:	2002      	movs	r0, #2
  4014f4:	4b08      	ldr	r3, [pc, #32]	; (401518 <udi_msc_csw_process+0x44>)
  4014f6:	4798      	blx	r3
	}
	// Prepare and send CSW
	udi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;
  4014f8:	4b06      	ldr	r3, [pc, #24]	; (401514 <udi_msc_csw_process+0x40>)
  4014fa:	685b      	ldr	r3, [r3, #4]
  4014fc:	4a04      	ldr	r2, [pc, #16]	; (401510 <udi_msc_csw_process+0x3c>)
  4014fe:	6053      	str	r3, [r2, #4]
	udi_msc_csw.dCSWDataResidue = cpu_to_le32(udi_msc_csw.dCSWDataResidue);
  401500:	4b03      	ldr	r3, [pc, #12]	; (401510 <udi_msc_csw_process+0x3c>)
  401502:	689b      	ldr	r3, [r3, #8]
  401504:	4a02      	ldr	r2, [pc, #8]	; (401510 <udi_msc_csw_process+0x3c>)
  401506:	6093      	str	r3, [r2, #8]
	udi_msc_csw_send();
  401508:	4b04      	ldr	r3, [pc, #16]	; (40151c <udi_msc_csw_process+0x48>)
  40150a:	4798      	blx	r3
}
  40150c:	bf00      	nop
  40150e:	bd80      	pop	{r7, pc}
  401510:	20000014 	.word	0x20000014
  401514:	20006b4c 	.word	0x20006b4c
  401518:	00404f55 	.word	0x00404f55
  40151c:	00401521 	.word	0x00401521

00401520 <udi_msc_csw_send>:


void udi_msc_csw_send(void)
{
  401520:	b590      	push	{r4, r7, lr}
  401522:	b083      	sub	sp, #12
  401524:	af02      	add	r7, sp, #8
	// Sends CSW on IN endpoint
	if (!udd_ep_run(UDI_MSC_EP_IN, false,
  401526:	4b0b      	ldr	r3, [pc, #44]	; (401554 <udi_msc_csw_send+0x34>)
  401528:	9300      	str	r3, [sp, #0]
  40152a:	230d      	movs	r3, #13
  40152c:	4a0a      	ldr	r2, [pc, #40]	; (401558 <udi_msc_csw_send+0x38>)
  40152e:	2100      	movs	r1, #0
  401530:	2081      	movs	r0, #129	; 0x81
  401532:	4c0a      	ldr	r4, [pc, #40]	; (40155c <udi_msc_csw_send+0x3c>)
  401534:	47a0      	blx	r4
  401536:	4603      	mov	r3, r0
  401538:	f083 0301 	eor.w	r3, r3, #1
  40153c:	b2db      	uxtb	r3, r3
  40153e:	2b00      	cmp	r3, #0
  401540:	d003      	beq.n	40154a <udi_msc_csw_send+0x2a>
					(uint8_t *) & udi_msc_csw,
					sizeof(udi_msc_csw),
					udi_msc_csw_sent)) {
		// Endpoint not available
		// then restart CSW sent when endpoint IN STALL will be cleared
		udd_ep_wait_stall_clear(UDI_MSC_EP_IN, udi_msc_csw_send);
  401542:	4907      	ldr	r1, [pc, #28]	; (401560 <udi_msc_csw_send+0x40>)
  401544:	2081      	movs	r0, #129	; 0x81
  401546:	4b07      	ldr	r3, [pc, #28]	; (401564 <udi_msc_csw_send+0x44>)
  401548:	4798      	blx	r3
	}
}
  40154a:	bf00      	nop
  40154c:	3704      	adds	r7, #4
  40154e:	46bd      	mov	sp, r7
  401550:	bd90      	pop	{r4, r7, pc}
  401552:	bf00      	nop
  401554:	00401569 	.word	0x00401569
  401558:	20000014 	.word	0x20000014
  40155c:	00405175 	.word	0x00405175
  401560:	00401521 	.word	0x00401521
  401564:	004054e9 	.word	0x004054e9

00401568 <udi_msc_csw_sent>:


static void udi_msc_csw_sent(udd_ep_status_t status, iram_size_t nb_sent,
		udd_ep_id_t ep)
{
  401568:	b580      	push	{r7, lr}
  40156a:	b082      	sub	sp, #8
  40156c:	af00      	add	r7, sp, #0
  40156e:	4603      	mov	r3, r0
  401570:	6039      	str	r1, [r7, #0]
  401572:	71fb      	strb	r3, [r7, #7]
  401574:	4613      	mov	r3, r2
  401576:	71bb      	strb	r3, [r7, #6]
	UNUSED(ep);
	UNUSED(status);
	UNUSED(nb_sent);
	// CSW is sent or not
	// In all case, restart process and wait CBW
	udi_msc_cbw_wait();
  401578:	4b02      	ldr	r3, [pc, #8]	; (401584 <udi_msc_csw_sent+0x1c>)
  40157a:	4798      	blx	r3
}
  40157c:	bf00      	nop
  40157e:	3708      	adds	r7, #8
  401580:	46bd      	mov	sp, r7
  401582:	bd80      	pop	{r7, pc}
  401584:	00401125 	.word	0x00401125

00401588 <udi_msc_clear_sense>:

//---------------------------------------------
//------- Routines manage sense data

static void udi_msc_clear_sense(void)
{
  401588:	b580      	push	{r7, lr}
  40158a:	af00      	add	r7, sp, #0
	memset((uint8_t*)&udi_msc_sense, 0, sizeof(struct scsi_request_sense_data));
  40158c:	2212      	movs	r2, #18
  40158e:	2100      	movs	r1, #0
  401590:	4805      	ldr	r0, [pc, #20]	; (4015a8 <udi_msc_clear_sense+0x20>)
  401592:	4b06      	ldr	r3, [pc, #24]	; (4015ac <udi_msc_clear_sense+0x24>)
  401594:	4798      	blx	r3
	udi_msc_sense.valid_reponse_code = SCSI_SENSE_VALID | SCSI_SENSE_CURRENT;
  401596:	4b04      	ldr	r3, [pc, #16]	; (4015a8 <udi_msc_clear_sense+0x20>)
  401598:	22f0      	movs	r2, #240	; 0xf0
  40159a:	701a      	strb	r2, [r3, #0]
	udi_msc_sense.AddSenseLen = SCSI_SENSE_ADDL_LEN(sizeof(udi_msc_sense));
  40159c:	4b02      	ldr	r3, [pc, #8]	; (4015a8 <udi_msc_clear_sense+0x20>)
  40159e:	220a      	movs	r2, #10
  4015a0:	71da      	strb	r2, [r3, #7]
}
  4015a2:	bf00      	nop
  4015a4:	bd80      	pop	{r7, pc}
  4015a6:	bf00      	nop
  4015a8:	20006b70 	.word	0x20006b70
  4015ac:	00416f01 	.word	0x00416f01

004015b0 <udi_msc_sense_fail>:

static void udi_msc_sense_fail(uint8_t sense_key, uint16_t add_sense,
		uint32_t lba)
{
  4015b0:	b580      	push	{r7, lr}
  4015b2:	b082      	sub	sp, #8
  4015b4:	af00      	add	r7, sp, #0
  4015b6:	4603      	mov	r3, r0
  4015b8:	603a      	str	r2, [r7, #0]
  4015ba:	71fb      	strb	r3, [r7, #7]
  4015bc:	460b      	mov	r3, r1
  4015be:	80bb      	strh	r3, [r7, #4]
	udi_msc_clear_sense();
  4015c0:	4b14      	ldr	r3, [pc, #80]	; (401614 <udi_msc_sense_fail+0x64>)
  4015c2:	4798      	blx	r3
	udi_msc_csw.bCSWStatus = USB_CSW_STATUS_FAIL;
  4015c4:	4b14      	ldr	r3, [pc, #80]	; (401618 <udi_msc_sense_fail+0x68>)
  4015c6:	2201      	movs	r2, #1
  4015c8:	731a      	strb	r2, [r3, #12]
	udi_msc_sense.sense_flag_key = sense_key;
  4015ca:	4a14      	ldr	r2, [pc, #80]	; (40161c <udi_msc_sense_fail+0x6c>)
  4015cc:	79fb      	ldrb	r3, [r7, #7]
  4015ce:	7093      	strb	r3, [r2, #2]
	udi_msc_sense.information[0] = lba >> 24;
  4015d0:	683b      	ldr	r3, [r7, #0]
  4015d2:	0e1b      	lsrs	r3, r3, #24
  4015d4:	b2da      	uxtb	r2, r3
  4015d6:	4b11      	ldr	r3, [pc, #68]	; (40161c <udi_msc_sense_fail+0x6c>)
  4015d8:	70da      	strb	r2, [r3, #3]
	udi_msc_sense.information[1] = lba >> 16;
  4015da:	683b      	ldr	r3, [r7, #0]
  4015dc:	0c1b      	lsrs	r3, r3, #16
  4015de:	b2da      	uxtb	r2, r3
  4015e0:	4b0e      	ldr	r3, [pc, #56]	; (40161c <udi_msc_sense_fail+0x6c>)
  4015e2:	711a      	strb	r2, [r3, #4]
	udi_msc_sense.information[2] = lba >> 8;
  4015e4:	683b      	ldr	r3, [r7, #0]
  4015e6:	0a1b      	lsrs	r3, r3, #8
  4015e8:	b2da      	uxtb	r2, r3
  4015ea:	4b0c      	ldr	r3, [pc, #48]	; (40161c <udi_msc_sense_fail+0x6c>)
  4015ec:	715a      	strb	r2, [r3, #5]
	udi_msc_sense.information[3] = lba;
  4015ee:	683b      	ldr	r3, [r7, #0]
  4015f0:	b2da      	uxtb	r2, r3
  4015f2:	4b0a      	ldr	r3, [pc, #40]	; (40161c <udi_msc_sense_fail+0x6c>)
  4015f4:	719a      	strb	r2, [r3, #6]
	udi_msc_sense.AddSenseCode = add_sense >> 8;
  4015f6:	88bb      	ldrh	r3, [r7, #4]
  4015f8:	0a1b      	lsrs	r3, r3, #8
  4015fa:	b29b      	uxth	r3, r3
  4015fc:	b2da      	uxtb	r2, r3
  4015fe:	4b07      	ldr	r3, [pc, #28]	; (40161c <udi_msc_sense_fail+0x6c>)
  401600:	731a      	strb	r2, [r3, #12]
	udi_msc_sense.AddSnsCodeQlfr = add_sense;
  401602:	88bb      	ldrh	r3, [r7, #4]
  401604:	b2da      	uxtb	r2, r3
  401606:	4b05      	ldr	r3, [pc, #20]	; (40161c <udi_msc_sense_fail+0x6c>)
  401608:	735a      	strb	r2, [r3, #13]
}
  40160a:	bf00      	nop
  40160c:	3708      	adds	r7, #8
  40160e:	46bd      	mov	sp, r7
  401610:	bd80      	pop	{r7, pc}
  401612:	bf00      	nop
  401614:	00401589 	.word	0x00401589
  401618:	20000014 	.word	0x20000014
  40161c:	20006b70 	.word	0x20006b70

00401620 <udi_msc_sense_pass>:

static void udi_msc_sense_pass(void)
{
  401620:	b580      	push	{r7, lr}
  401622:	af00      	add	r7, sp, #0
	udi_msc_clear_sense();
  401624:	4b03      	ldr	r3, [pc, #12]	; (401634 <udi_msc_sense_pass+0x14>)
  401626:	4798      	blx	r3
	udi_msc_csw.bCSWStatus = USB_CSW_STATUS_PASS;
  401628:	4b03      	ldr	r3, [pc, #12]	; (401638 <udi_msc_sense_pass+0x18>)
  40162a:	2200      	movs	r2, #0
  40162c:	731a      	strb	r2, [r3, #12]
}
  40162e:	bf00      	nop
  401630:	bd80      	pop	{r7, pc}
  401632:	bf00      	nop
  401634:	00401589 	.word	0x00401589
  401638:	20000014 	.word	0x20000014

0040163c <udi_msc_sense_fail_not_present>:


static void udi_msc_sense_fail_not_present(void)
{
  40163c:	b580      	push	{r7, lr}
  40163e:	af00      	add	r7, sp, #0
	udi_msc_sense_fail(SCSI_SK_NOT_READY, SCSI_ASC_MEDIUM_NOT_PRESENT, 0);
  401640:	2200      	movs	r2, #0
  401642:	f44f 5168 	mov.w	r1, #14848	; 0x3a00
  401646:	2002      	movs	r0, #2
  401648:	4b01      	ldr	r3, [pc, #4]	; (401650 <udi_msc_sense_fail_not_present+0x14>)
  40164a:	4798      	blx	r3
}
  40164c:	bf00      	nop
  40164e:	bd80      	pop	{r7, pc}
  401650:	004015b1 	.word	0x004015b1

00401654 <udi_msc_sense_fail_busy_or_change>:

static void udi_msc_sense_fail_busy_or_change(void)
{
  401654:	b580      	push	{r7, lr}
  401656:	af00      	add	r7, sp, #0
	udi_msc_sense_fail(SCSI_SK_UNIT_ATTENTION,
  401658:	2200      	movs	r2, #0
  40165a:	f44f 5120 	mov.w	r1, #10240	; 0x2800
  40165e:	2006      	movs	r0, #6
  401660:	4b01      	ldr	r3, [pc, #4]	; (401668 <udi_msc_sense_fail_busy_or_change+0x14>)
  401662:	4798      	blx	r3
			SCSI_ASC_NOT_READY_TO_READY_CHANGE, 0);
}
  401664:	bf00      	nop
  401666:	bd80      	pop	{r7, pc}
  401668:	004015b1 	.word	0x004015b1

0040166c <udi_msc_sense_fail_hardware>:

static void udi_msc_sense_fail_hardware(void)
{
  40166c:	b580      	push	{r7, lr}
  40166e:	af00      	add	r7, sp, #0
	udi_msc_sense_fail(SCSI_SK_HARDWARE_ERROR,
  401670:	2200      	movs	r2, #0
  401672:	2100      	movs	r1, #0
  401674:	2004      	movs	r0, #4
  401676:	4b02      	ldr	r3, [pc, #8]	; (401680 <udi_msc_sense_fail_hardware+0x14>)
  401678:	4798      	blx	r3
			SCSI_ASC_NO_ADDITIONAL_SENSE_INFO, 0);
}
  40167a:	bf00      	nop
  40167c:	bd80      	pop	{r7, pc}
  40167e:	bf00      	nop
  401680:	004015b1 	.word	0x004015b1

00401684 <udi_msc_sense_fail_protected>:

static void udi_msc_sense_fail_protected(void)
{
  401684:	b580      	push	{r7, lr}
  401686:	af00      	add	r7, sp, #0
	udi_msc_sense_fail(SCSI_SK_DATA_PROTECT, SCSI_ASC_WRITE_PROTECTED, 0);
  401688:	2200      	movs	r2, #0
  40168a:	f44f 511c 	mov.w	r1, #9984	; 0x2700
  40168e:	2007      	movs	r0, #7
  401690:	4b01      	ldr	r3, [pc, #4]	; (401698 <udi_msc_sense_fail_protected+0x14>)
  401692:	4798      	blx	r3
}
  401694:	bf00      	nop
  401696:	bd80      	pop	{r7, pc}
  401698:	004015b1 	.word	0x004015b1

0040169c <udi_msc_sense_fail_cdb_invalid>:

static void udi_msc_sense_fail_cdb_invalid(void)
{
  40169c:	b580      	push	{r7, lr}
  40169e:	af00      	add	r7, sp, #0
	udi_msc_sense_fail(SCSI_SK_ILLEGAL_REQUEST,
  4016a0:	2200      	movs	r2, #0
  4016a2:	f44f 5110 	mov.w	r1, #9216	; 0x2400
  4016a6:	2005      	movs	r0, #5
  4016a8:	4b01      	ldr	r3, [pc, #4]	; (4016b0 <udi_msc_sense_fail_cdb_invalid+0x14>)
  4016aa:	4798      	blx	r3
			SCSI_ASC_INVALID_FIELD_IN_CDB, 0);
}
  4016ac:	bf00      	nop
  4016ae:	bd80      	pop	{r7, pc}
  4016b0:	004015b1 	.word	0x004015b1

004016b4 <udi_msc_sense_command_invalid>:

static void udi_msc_sense_command_invalid(void)
{
  4016b4:	b580      	push	{r7, lr}
  4016b6:	af00      	add	r7, sp, #0
	udi_msc_sense_fail(SCSI_SK_ILLEGAL_REQUEST,
  4016b8:	2200      	movs	r2, #0
  4016ba:	f44f 5100 	mov.w	r1, #8192	; 0x2000
  4016be:	2005      	movs	r0, #5
  4016c0:	4b01      	ldr	r3, [pc, #4]	; (4016c8 <udi_msc_sense_command_invalid+0x14>)
  4016c2:	4798      	blx	r3
			SCSI_ASC_INVALID_COMMAND_OPERATION_CODE, 0);
}
  4016c4:	bf00      	nop
  4016c6:	bd80      	pop	{r7, pc}
  4016c8:	004015b1 	.word	0x004015b1

004016cc <udi_msc_spc_requestsense>:

//---------------------------------------------
//------- Routines manage SCSI Commands

static void udi_msc_spc_requestsense(void)
{
  4016cc:	b580      	push	{r7, lr}
  4016ce:	b082      	sub	sp, #8
  4016d0:	af00      	add	r7, sp, #0
	uint8_t length = udi_msc_cbw.CDB[4];
  4016d2:	4b0e      	ldr	r3, [pc, #56]	; (40170c <udi_msc_spc_requestsense+0x40>)
  4016d4:	7cdb      	ldrb	r3, [r3, #19]
  4016d6:	71fb      	strb	r3, [r7, #7]

	// Can't send more than sense data length
	if (length > sizeof(udi_msc_sense))
  4016d8:	79fb      	ldrb	r3, [r7, #7]
  4016da:	2b12      	cmp	r3, #18
  4016dc:	d901      	bls.n	4016e2 <udi_msc_spc_requestsense+0x16>
		length = sizeof(udi_msc_sense);
  4016de:	2312      	movs	r3, #18
  4016e0:	71fb      	strb	r3, [r7, #7]

	if (!udi_msc_cbw_validate(length, USB_CBW_DIRECTION_IN))
  4016e2:	79fb      	ldrb	r3, [r7, #7]
  4016e4:	2180      	movs	r1, #128	; 0x80
  4016e6:	4618      	mov	r0, r3
  4016e8:	4b09      	ldr	r3, [pc, #36]	; (401710 <udi_msc_spc_requestsense+0x44>)
  4016ea:	4798      	blx	r3
  4016ec:	4603      	mov	r3, r0
  4016ee:	f083 0301 	eor.w	r3, r3, #1
  4016f2:	b2db      	uxtb	r3, r3
  4016f4:	2b00      	cmp	r3, #0
  4016f6:	d105      	bne.n	401704 <udi_msc_spc_requestsense+0x38>
		return;
	// Send sense data
	udi_msc_data_send((uint8_t*)&udi_msc_sense, length);
  4016f8:	79fb      	ldrb	r3, [r7, #7]
  4016fa:	4619      	mov	r1, r3
  4016fc:	4805      	ldr	r0, [pc, #20]	; (401714 <udi_msc_spc_requestsense+0x48>)
  4016fe:	4b06      	ldr	r3, [pc, #24]	; (401718 <udi_msc_spc_requestsense+0x4c>)
  401700:	4798      	blx	r3
  401702:	e000      	b.n	401706 <udi_msc_spc_requestsense+0x3a>
		return;
  401704:	bf00      	nop
}
  401706:	3708      	adds	r7, #8
  401708:	46bd      	mov	sp, r7
  40170a:	bd80      	pop	{r7, pc}
  40170c:	20006b4c 	.word	0x20006b4c
  401710:	004013fd 	.word	0x004013fd
  401714:	20006b70 	.word	0x20006b70
  401718:	00401449 	.word	0x00401449

0040171c <udi_msc_spc_inquiry>:


static void udi_msc_spc_inquiry(void)
{
  40171c:	b590      	push	{r4, r7, lr}
  40171e:	b083      	sub	sp, #12
  401720:	af00      	add	r7, sp, #0
		.addl_len = SCSI_INQ_ADDL_LEN(sizeof(struct scsi_inquiry_data)),
		.vendor_id = {UDI_MSC_GLOBAL_VENDOR_ID},
		.product_rev = {UDI_MSC_GLOBAL_PRODUCT_VERSION},
	};

	length = udi_msc_cbw.CDB[4];
  401722:	4b35      	ldr	r3, [pc, #212]	; (4017f8 <udi_msc_spc_inquiry+0xdc>)
  401724:	7cdb      	ldrb	r3, [r3, #19]
  401726:	71fb      	strb	r3, [r7, #7]

	// Can't send more than inquiry data length
	if (length > sizeof(udi_msc_inquiry_data))
  401728:	79fb      	ldrb	r3, [r7, #7]
  40172a:	2b24      	cmp	r3, #36	; 0x24
  40172c:	d901      	bls.n	401732 <udi_msc_spc_inquiry+0x16>
		length = sizeof(udi_msc_inquiry_data);
  40172e:	2324      	movs	r3, #36	; 0x24
  401730:	71fb      	strb	r3, [r7, #7]

	if (!udi_msc_cbw_validate(length, USB_CBW_DIRECTION_IN))
  401732:	79fb      	ldrb	r3, [r7, #7]
  401734:	2180      	movs	r1, #128	; 0x80
  401736:	4618      	mov	r0, r3
  401738:	4b30      	ldr	r3, [pc, #192]	; (4017fc <udi_msc_spc_inquiry+0xe0>)
  40173a:	4798      	blx	r3
  40173c:	4603      	mov	r3, r0
  40173e:	f083 0301 	eor.w	r3, r3, #1
  401742:	b2db      	uxtb	r3, r3
  401744:	2b00      	cmp	r3, #0
  401746:	d152      	bne.n	4017ee <udi_msc_spc_inquiry+0xd2>
		return;
	if ((0 != (udi_msc_cbw.CDB[1] & (SCSI_INQ_REQ_EVPD | SCSI_INQ_REQ_CMDT)))
  401748:	4b2b      	ldr	r3, [pc, #172]	; (4017f8 <udi_msc_spc_inquiry+0xdc>)
  40174a:	7c1b      	ldrb	r3, [r3, #16]
  40174c:	f003 0303 	and.w	r3, r3, #3
  401750:	2b00      	cmp	r3, #0
  401752:	d103      	bne.n	40175c <udi_msc_spc_inquiry+0x40>
			|| (0 != udi_msc_cbw.CDB[2])) {
  401754:	4b28      	ldr	r3, [pc, #160]	; (4017f8 <udi_msc_spc_inquiry+0xdc>)
  401756:	7c5b      	ldrb	r3, [r3, #17]
  401758:	2b00      	cmp	r3, #0
  40175a:	d004      	beq.n	401766 <udi_msc_spc_inquiry+0x4a>
		// CMDT and EPVD bits are not at 0
		// PAGE or OPERATION CODE fields are not empty
		//  = No standard inquiry asked
		udi_msc_sense_fail_cdb_invalid(); // Command is unsupported
  40175c:	4b28      	ldr	r3, [pc, #160]	; (401800 <udi_msc_spc_inquiry+0xe4>)
  40175e:	4798      	blx	r3
		udi_msc_csw_process();
  401760:	4b28      	ldr	r3, [pc, #160]	; (401804 <udi_msc_spc_inquiry+0xe8>)
  401762:	4798      	blx	r3
		return;
  401764:	e044      	b.n	4017f0 <udi_msc_spc_inquiry+0xd4>
	}

	udi_msc_inquiry_data.flags1 = mem_removal(udi_msc_cbw.bCBWLUN) ?
  401766:	4b24      	ldr	r3, [pc, #144]	; (4017f8 <udi_msc_spc_inquiry+0xdc>)
  401768:	7b5b      	ldrb	r3, [r3, #13]
  40176a:	4618      	mov	r0, r3
  40176c:	4b26      	ldr	r3, [pc, #152]	; (401808 <udi_msc_spc_inquiry+0xec>)
  40176e:	4798      	blx	r3
  401770:	4603      	mov	r3, r0
  401772:	2b00      	cmp	r3, #0
  401774:	d001      	beq.n	40177a <udi_msc_spc_inquiry+0x5e>
  401776:	2280      	movs	r2, #128	; 0x80
  401778:	e000      	b.n	40177c <udi_msc_spc_inquiry+0x60>
  40177a:	2200      	movs	r2, #0
  40177c:	4b23      	ldr	r3, [pc, #140]	; (40180c <udi_msc_spc_inquiry+0xf0>)
  40177e:	705a      	strb	r2, [r3, #1]
			SCSI_INQ_RMB : 0;

	//* Fill product ID field
	// Copy name in product id field
	memcpy(udi_msc_inquiry_data.product_id,
			mem_name(udi_msc_cbw.bCBWLUN)+1, // To remove first '"'
  401780:	4b1d      	ldr	r3, [pc, #116]	; (4017f8 <udi_msc_spc_inquiry+0xdc>)
  401782:	7b5b      	ldrb	r3, [r3, #13]
  401784:	4618      	mov	r0, r3
  401786:	4b22      	ldr	r3, [pc, #136]	; (401810 <udi_msc_spc_inquiry+0xf4>)
  401788:	4798      	blx	r3
  40178a:	4603      	mov	r3, r0
  40178c:	1c5a      	adds	r2, r3, #1
	memcpy(udi_msc_inquiry_data.product_id,
  40178e:	4b1f      	ldr	r3, [pc, #124]	; (40180c <udi_msc_spc_inquiry+0xf0>)
  401790:	f103 0410 	add.w	r4, r3, #16
  401794:	4613      	mov	r3, r2
  401796:	6818      	ldr	r0, [r3, #0]
  401798:	6859      	ldr	r1, [r3, #4]
  40179a:	689a      	ldr	r2, [r3, #8]
  40179c:	68db      	ldr	r3, [r3, #12]
  40179e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
			sizeof(udi_msc_inquiry_data.product_id));

	// Search end of name '/0' or '"'
	i = 0;
  4017a0:	2300      	movs	r3, #0
  4017a2:	71bb      	strb	r3, [r7, #6]
	while (sizeof(udi_msc_inquiry_data.product_id) != i) {
  4017a4:	e00e      	b.n	4017c4 <udi_msc_spc_inquiry+0xa8>
		if ((0 == udi_msc_inquiry_data.product_id[i])
  4017a6:	79bb      	ldrb	r3, [r7, #6]
  4017a8:	4a18      	ldr	r2, [pc, #96]	; (40180c <udi_msc_spc_inquiry+0xf0>)
  4017aa:	4413      	add	r3, r2
  4017ac:	7c1b      	ldrb	r3, [r3, #16]
  4017ae:	2b00      	cmp	r3, #0
  4017b0:	d014      	beq.n	4017dc <udi_msc_spc_inquiry+0xc0>
				|| ('"' == udi_msc_inquiry_data.product_id[i])) {
  4017b2:	79bb      	ldrb	r3, [r7, #6]
  4017b4:	4a15      	ldr	r2, [pc, #84]	; (40180c <udi_msc_spc_inquiry+0xf0>)
  4017b6:	4413      	add	r3, r2
  4017b8:	7c1b      	ldrb	r3, [r3, #16]
  4017ba:	2b22      	cmp	r3, #34	; 0x22
  4017bc:	d00e      	beq.n	4017dc <udi_msc_spc_inquiry+0xc0>
			break;
		}
		i++;
  4017be:	79bb      	ldrb	r3, [r7, #6]
  4017c0:	3301      	adds	r3, #1
  4017c2:	71bb      	strb	r3, [r7, #6]
	while (sizeof(udi_msc_inquiry_data.product_id) != i) {
  4017c4:	79bb      	ldrb	r3, [r7, #6]
  4017c6:	2b10      	cmp	r3, #16
  4017c8:	d1ed      	bne.n	4017a6 <udi_msc_spc_inquiry+0x8a>
	}
	// Padding with space char
	while (sizeof(udi_msc_inquiry_data.product_id) != i) {
  4017ca:	e007      	b.n	4017dc <udi_msc_spc_inquiry+0xc0>
		udi_msc_inquiry_data.product_id[i] = ' ';
  4017cc:	79bb      	ldrb	r3, [r7, #6]
  4017ce:	4a0f      	ldr	r2, [pc, #60]	; (40180c <udi_msc_spc_inquiry+0xf0>)
  4017d0:	4413      	add	r3, r2
  4017d2:	2220      	movs	r2, #32
  4017d4:	741a      	strb	r2, [r3, #16]
		i++;
  4017d6:	79bb      	ldrb	r3, [r7, #6]
  4017d8:	3301      	adds	r3, #1
  4017da:	71bb      	strb	r3, [r7, #6]
	while (sizeof(udi_msc_inquiry_data.product_id) != i) {
  4017dc:	79bb      	ldrb	r3, [r7, #6]
  4017de:	2b10      	cmp	r3, #16
  4017e0:	d1f4      	bne.n	4017cc <udi_msc_spc_inquiry+0xb0>
	}

	// Send inquiry data
	udi_msc_data_send((uint8_t *) & udi_msc_inquiry_data, length);
  4017e2:	79fb      	ldrb	r3, [r7, #7]
  4017e4:	4619      	mov	r1, r3
  4017e6:	4809      	ldr	r0, [pc, #36]	; (40180c <udi_msc_spc_inquiry+0xf0>)
  4017e8:	4b0a      	ldr	r3, [pc, #40]	; (401814 <udi_msc_spc_inquiry+0xf8>)
  4017ea:	4798      	blx	r3
  4017ec:	e000      	b.n	4017f0 <udi_msc_spc_inquiry+0xd4>
		return;
  4017ee:	bf00      	nop
}
  4017f0:	370c      	adds	r7, #12
  4017f2:	46bd      	mov	sp, r7
  4017f4:	bd90      	pop	{r4, r7, pc}
  4017f6:	bf00      	nop
  4017f8:	20006b4c 	.word	0x20006b4c
  4017fc:	004013fd 	.word	0x004013fd
  401800:	0040169d 	.word	0x0040169d
  401804:	004014d5 	.word	0x004014d5
  401808:	00400e7d 	.word	0x00400e7d
  40180c:	20000024 	.word	0x20000024
  401810:	00400ee5 	.word	0x00400ee5
  401814:	00401449 	.word	0x00401449

00401818 <udi_msc_spc_testunitready_global>:


static bool udi_msc_spc_testunitready_global(void)
{
  401818:	b580      	push	{r7, lr}
  40181a:	af00      	add	r7, sp, #0
	switch (mem_test_unit_ready(udi_msc_cbw.bCBWLUN)) {
  40181c:	4b0c      	ldr	r3, [pc, #48]	; (401850 <udi_msc_spc_testunitready_global+0x38>)
  40181e:	7b5b      	ldrb	r3, [r3, #13]
  401820:	4618      	mov	r0, r3
  401822:	4b0c      	ldr	r3, [pc, #48]	; (401854 <udi_msc_spc_testunitready_global+0x3c>)
  401824:	4798      	blx	r3
  401826:	4603      	mov	r3, r0
  401828:	2b02      	cmp	r3, #2
  40182a:	d008      	beq.n	40183e <udi_msc_spc_testunitready_global+0x26>
  40182c:	2b03      	cmp	r3, #3
  40182e:	d003      	beq.n	401838 <udi_msc_spc_testunitready_global+0x20>
  401830:	2b00      	cmp	r3, #0
  401832:	d107      	bne.n	401844 <udi_msc_spc_testunitready_global+0x2c>
	case CTRL_GOOD:
		return true;	// Don't change sense data
  401834:	2301      	movs	r3, #1
  401836:	e009      	b.n	40184c <udi_msc_spc_testunitready_global+0x34>
	case CTRL_BUSY:
		udi_msc_sense_fail_busy_or_change();
  401838:	4b07      	ldr	r3, [pc, #28]	; (401858 <udi_msc_spc_testunitready_global+0x40>)
  40183a:	4798      	blx	r3
		break;
  40183c:	e005      	b.n	40184a <udi_msc_spc_testunitready_global+0x32>
	case CTRL_NO_PRESENT:
		udi_msc_sense_fail_not_present();
  40183e:	4b07      	ldr	r3, [pc, #28]	; (40185c <udi_msc_spc_testunitready_global+0x44>)
  401840:	4798      	blx	r3
		break;
  401842:	e002      	b.n	40184a <udi_msc_spc_testunitready_global+0x32>
	case CTRL_FAIL:
	default:
		udi_msc_sense_fail_hardware();
  401844:	4b06      	ldr	r3, [pc, #24]	; (401860 <udi_msc_spc_testunitready_global+0x48>)
  401846:	4798      	blx	r3
		break;
  401848:	bf00      	nop
	}
	return false;
  40184a:	2300      	movs	r3, #0
}
  40184c:	4618      	mov	r0, r3
  40184e:	bd80      	pop	{r7, pc}
  401850:	20006b4c 	.word	0x20006b4c
  401854:	00400cad 	.word	0x00400cad
  401858:	00401655 	.word	0x00401655
  40185c:	0040163d 	.word	0x0040163d
  401860:	0040166d 	.word	0x0040166d

00401864 <udi_msc_spc_testunitready>:


static void udi_msc_spc_testunitready(void)
{
  401864:	b580      	push	{r7, lr}
  401866:	af00      	add	r7, sp, #0
	if (udi_msc_spc_testunitready_global()) {
  401868:	4b05      	ldr	r3, [pc, #20]	; (401880 <udi_msc_spc_testunitready+0x1c>)
  40186a:	4798      	blx	r3
  40186c:	4603      	mov	r3, r0
  40186e:	2b00      	cmp	r3, #0
  401870:	d001      	beq.n	401876 <udi_msc_spc_testunitready+0x12>
		// LUN ready, then update sense data with status pass
		udi_msc_sense_pass();
  401872:	4b04      	ldr	r3, [pc, #16]	; (401884 <udi_msc_spc_testunitready+0x20>)
  401874:	4798      	blx	r3
	}
	// Send status in CSW packet
	udi_msc_csw_process();
  401876:	4b04      	ldr	r3, [pc, #16]	; (401888 <udi_msc_spc_testunitready+0x24>)
  401878:	4798      	blx	r3
}
  40187a:	bf00      	nop
  40187c:	bd80      	pop	{r7, pc}
  40187e:	bf00      	nop
  401880:	00401819 	.word	0x00401819
  401884:	00401621 	.word	0x00401621
  401888:	004014d5 	.word	0x004014d5

0040188c <udi_msc_spc_mode_sense>:


static void udi_msc_spc_mode_sense(bool b_sense10)
{
  40188c:	b580      	push	{r7, lr}
  40188e:	b086      	sub	sp, #24
  401890:	af00      	add	r7, sp, #0
  401892:	4603      	mov	r3, r0
  401894:	71fb      	strb	r3, [r7, #7]
	uint8_t wp;
	struct spc_control_page_info_execpt *ptr_mode;
	UDC_BSS(4)  static union sense_6_10 sense;

	// Clear all fields
	memset(&sense, 0, sizeof(sense));
  401896:	2214      	movs	r2, #20
  401898:	2100      	movs	r1, #0
  40189a:	483a      	ldr	r0, [pc, #232]	; (401984 <udi_msc_spc_mode_sense+0xf8>)
  40189c:	4b3a      	ldr	r3, [pc, #232]	; (401988 <udi_msc_spc_mode_sense+0xfc>)
  40189e:	4798      	blx	r3

	// Initialize process
	if (b_sense10) {
  4018a0:	79fb      	ldrb	r3, [r7, #7]
  4018a2:	2b00      	cmp	r3, #0
  4018a4:	d007      	beq.n	4018b6 <udi_msc_spc_mode_sense+0x2a>
		request_lgt = udi_msc_cbw.CDB[8];
  4018a6:	4b39      	ldr	r3, [pc, #228]	; (40198c <udi_msc_spc_mode_sense+0x100>)
  4018a8:	7ddb      	ldrb	r3, [r3, #23]
  4018aa:	75bb      	strb	r3, [r7, #22]
		ptr_mode = &sense.s10.sense_data;
  4018ac:	4b38      	ldr	r3, [pc, #224]	; (401990 <udi_msc_spc_mode_sense+0x104>)
  4018ae:	613b      	str	r3, [r7, #16]
		data_sense_lgt = sizeof(struct scsi_mode_param_header10);
  4018b0:	2308      	movs	r3, #8
  4018b2:	75fb      	strb	r3, [r7, #23]
  4018b4:	e006      	b.n	4018c4 <udi_msc_spc_mode_sense+0x38>
	} else {
		request_lgt = udi_msc_cbw.CDB[4];
  4018b6:	4b35      	ldr	r3, [pc, #212]	; (40198c <udi_msc_spc_mode_sense+0x100>)
  4018b8:	7cdb      	ldrb	r3, [r3, #19]
  4018ba:	75bb      	strb	r3, [r7, #22]
		ptr_mode = &sense.s6.sense_data;
  4018bc:	4b35      	ldr	r3, [pc, #212]	; (401994 <udi_msc_spc_mode_sense+0x108>)
  4018be:	613b      	str	r3, [r7, #16]
		data_sense_lgt = sizeof(struct scsi_mode_param_header6);
  4018c0:	2304      	movs	r3, #4
  4018c2:	75fb      	strb	r3, [r7, #23]
	}

	// No Block descriptor

	// Fill page(s)
	mode = udi_msc_cbw.CDB[2] & SCSI_MS_MODE_ALL;
  4018c4:	4b31      	ldr	r3, [pc, #196]	; (40198c <udi_msc_spc_mode_sense+0x100>)
  4018c6:	7c5b      	ldrb	r3, [r3, #17]
  4018c8:	f003 033f 	and.w	r3, r3, #63	; 0x3f
  4018cc:	73fb      	strb	r3, [r7, #15]
	if ((SCSI_MS_MODE_INFEXP == mode)
  4018ce:	7bfb      	ldrb	r3, [r7, #15]
  4018d0:	2b1c      	cmp	r3, #28
  4018d2:	d002      	beq.n	4018da <udi_msc_spc_mode_sense+0x4e>
			|| (SCSI_MS_MODE_ALL == mode)) {
  4018d4:	7bfb      	ldrb	r3, [r7, #15]
  4018d6:	2b3f      	cmp	r3, #63	; 0x3f
  4018d8:	d10b      	bne.n	4018f2 <udi_msc_spc_mode_sense+0x66>
		// Informational exceptions control page (from SPC)
		ptr_mode->page_code =
  4018da:	693b      	ldr	r3, [r7, #16]
  4018dc:	221c      	movs	r2, #28
  4018de:	701a      	strb	r2, [r3, #0]
				SCSI_MS_MODE_INFEXP;
		ptr_mode->page_length =
  4018e0:	693b      	ldr	r3, [r7, #16]
  4018e2:	220a      	movs	r2, #10
  4018e4:	705a      	strb	r2, [r3, #1]
				SPC_MP_INFEXP_PAGE_LENGTH;
		ptr_mode->mrie =
  4018e6:	693b      	ldr	r3, [r7, #16]
  4018e8:	2205      	movs	r2, #5
  4018ea:	70da      	strb	r2, [r3, #3]
				SPC_MP_INFEXP_MRIE_NO_SENSE;
		data_sense_lgt += sizeof(struct spc_control_page_info_execpt);
  4018ec:	7dfb      	ldrb	r3, [r7, #23]
  4018ee:	330c      	adds	r3, #12
  4018f0:	75fb      	strb	r3, [r7, #23]
	}
	// Can't send more than mode sense data length
	if (request_lgt > data_sense_lgt)
  4018f2:	7dba      	ldrb	r2, [r7, #22]
  4018f4:	7dfb      	ldrb	r3, [r7, #23]
  4018f6:	429a      	cmp	r2, r3
  4018f8:	d901      	bls.n	4018fe <udi_msc_spc_mode_sense+0x72>
		request_lgt = data_sense_lgt;
  4018fa:	7dfb      	ldrb	r3, [r7, #23]
  4018fc:	75bb      	strb	r3, [r7, #22]
	if (!udi_msc_cbw_validate(request_lgt, USB_CBW_DIRECTION_IN))
  4018fe:	7dbb      	ldrb	r3, [r7, #22]
  401900:	2180      	movs	r1, #128	; 0x80
  401902:	4618      	mov	r0, r3
  401904:	4b24      	ldr	r3, [pc, #144]	; (401998 <udi_msc_spc_mode_sense+0x10c>)
  401906:	4798      	blx	r3
  401908:	4603      	mov	r3, r0
  40190a:	f083 0301 	eor.w	r3, r3, #1
  40190e:	b2db      	uxtb	r3, r3
  401910:	2b00      	cmp	r3, #0
  401912:	d132      	bne.n	40197a <udi_msc_spc_mode_sense+0xee>
		return;

	// Fill mode parameter header length
	wp = (mem_wr_protect(udi_msc_cbw.bCBWLUN)) ? SCSI_MS_SBC_WP : 0;
  401914:	4b1d      	ldr	r3, [pc, #116]	; (40198c <udi_msc_spc_mode_sense+0x100>)
  401916:	7b5b      	ldrb	r3, [r3, #13]
  401918:	4618      	mov	r0, r3
  40191a:	4b20      	ldr	r3, [pc, #128]	; (40199c <udi_msc_spc_mode_sense+0x110>)
  40191c:	4798      	blx	r3
  40191e:	4603      	mov	r3, r0
  401920:	2b00      	cmp	r3, #0
  401922:	d001      	beq.n	401928 <udi_msc_spc_mode_sense+0x9c>
  401924:	2380      	movs	r3, #128	; 0x80
  401926:	e000      	b.n	40192a <udi_msc_spc_mode_sense+0x9e>
  401928:	2300      	movs	r3, #0
  40192a:	73bb      	strb	r3, [r7, #14]

	if (b_sense10) {
  40192c:	79fb      	ldrb	r3, [r7, #7]
  40192e:	2b00      	cmp	r3, #0
  401930:	d015      	beq.n	40195e <udi_msc_spc_mode_sense+0xd2>
		sense.s10.header.mode_data_length =
				cpu_to_be16((data_sense_lgt - 2));
  401932:	7dfb      	ldrb	r3, [r7, #23]
  401934:	b29b      	uxth	r3, r3
  401936:	3b02      	subs	r3, #2
  401938:	b29b      	uxth	r3, r3
  40193a:	0a1b      	lsrs	r3, r3, #8
  40193c:	b29b      	uxth	r3, r3
  40193e:	b21a      	sxth	r2, r3
  401940:	7dfb      	ldrb	r3, [r7, #23]
  401942:	b29b      	uxth	r3, r3
  401944:	3b02      	subs	r3, #2
  401946:	b29b      	uxth	r3, r3
  401948:	021b      	lsls	r3, r3, #8
  40194a:	b21b      	sxth	r3, r3
  40194c:	4313      	orrs	r3, r2
  40194e:	b21b      	sxth	r3, r3
  401950:	b29a      	uxth	r2, r3
		sense.s10.header.mode_data_length =
  401952:	4b0c      	ldr	r3, [pc, #48]	; (401984 <udi_msc_spc_mode_sense+0xf8>)
  401954:	801a      	strh	r2, [r3, #0]
		//sense.s10.header.medium_type                 = 0;
		sense.s10.header.device_specific_parameter = wp;
  401956:	4a0b      	ldr	r2, [pc, #44]	; (401984 <udi_msc_spc_mode_sense+0xf8>)
  401958:	7bbb      	ldrb	r3, [r7, #14]
  40195a:	70d3      	strb	r3, [r2, #3]
  40195c:	e007      	b.n	40196e <udi_msc_spc_mode_sense+0xe2>
		//sense.s10.header.block_descriptor_length     = 0;
	} else {
		sense.s6.header.mode_data_length = data_sense_lgt - 1;
  40195e:	7dfb      	ldrb	r3, [r7, #23]
  401960:	3b01      	subs	r3, #1
  401962:	b2da      	uxtb	r2, r3
  401964:	4b07      	ldr	r3, [pc, #28]	; (401984 <udi_msc_spc_mode_sense+0xf8>)
  401966:	701a      	strb	r2, [r3, #0]
		//sense.s6.header.medium_type                  = 0;
		sense.s6.header.device_specific_parameter = wp;
  401968:	4a06      	ldr	r2, [pc, #24]	; (401984 <udi_msc_spc_mode_sense+0xf8>)
  40196a:	7bbb      	ldrb	r3, [r7, #14]
  40196c:	7093      	strb	r3, [r2, #2]
		//sense.s6.header.block_descriptor_length      = 0;
	}

	// Send mode sense data
	udi_msc_data_send((uint8_t *) & sense, request_lgt);
  40196e:	7dbb      	ldrb	r3, [r7, #22]
  401970:	4619      	mov	r1, r3
  401972:	4804      	ldr	r0, [pc, #16]	; (401984 <udi_msc_spc_mode_sense+0xf8>)
  401974:	4b0a      	ldr	r3, [pc, #40]	; (4019a0 <udi_msc_spc_mode_sense+0x114>)
  401976:	4798      	blx	r3
  401978:	e000      	b.n	40197c <udi_msc_spc_mode_sense+0xf0>
		return;
  40197a:	bf00      	nop
}
  40197c:	3718      	adds	r7, #24
  40197e:	46bd      	mov	sp, r7
  401980:	bd80      	pop	{r7, pc}
  401982:	bf00      	nop
  401984:	20006b90 	.word	0x20006b90
  401988:	00416f01 	.word	0x00416f01
  40198c:	20006b4c 	.word	0x20006b4c
  401990:	20006b98 	.word	0x20006b98
  401994:	20006b94 	.word	0x20006b94
  401998:	004013fd 	.word	0x004013fd
  40199c:	00400e15 	.word	0x00400e15
  4019a0:	00401449 	.word	0x00401449

004019a4 <udi_msc_spc_prevent_allow_medium_removal>:


static void udi_msc_spc_prevent_allow_medium_removal(void)
{
  4019a4:	b580      	push	{r7, lr}
  4019a6:	b082      	sub	sp, #8
  4019a8:	af00      	add	r7, sp, #0
	uint8_t prevent = udi_msc_cbw.CDB[4];
  4019aa:	4b08      	ldr	r3, [pc, #32]	; (4019cc <udi_msc_spc_prevent_allow_medium_removal+0x28>)
  4019ac:	7cdb      	ldrb	r3, [r3, #19]
  4019ae:	71fb      	strb	r3, [r7, #7]
	if (0 == prevent) {
  4019b0:	79fb      	ldrb	r3, [r7, #7]
  4019b2:	2b00      	cmp	r3, #0
  4019b4:	d102      	bne.n	4019bc <udi_msc_spc_prevent_allow_medium_removal+0x18>
		udi_msc_sense_pass();
  4019b6:	4b06      	ldr	r3, [pc, #24]	; (4019d0 <udi_msc_spc_prevent_allow_medium_removal+0x2c>)
  4019b8:	4798      	blx	r3
  4019ba:	e001      	b.n	4019c0 <udi_msc_spc_prevent_allow_medium_removal+0x1c>
	} else {
		udi_msc_sense_fail_cdb_invalid(); // Command is unsupported
  4019bc:	4b05      	ldr	r3, [pc, #20]	; (4019d4 <udi_msc_spc_prevent_allow_medium_removal+0x30>)
  4019be:	4798      	blx	r3
	}
	udi_msc_csw_process();
  4019c0:	4b05      	ldr	r3, [pc, #20]	; (4019d8 <udi_msc_spc_prevent_allow_medium_removal+0x34>)
  4019c2:	4798      	blx	r3
}
  4019c4:	bf00      	nop
  4019c6:	3708      	adds	r7, #8
  4019c8:	46bd      	mov	sp, r7
  4019ca:	bd80      	pop	{r7, pc}
  4019cc:	20006b4c 	.word	0x20006b4c
  4019d0:	00401621 	.word	0x00401621
  4019d4:	0040169d 	.word	0x0040169d
  4019d8:	004014d5 	.word	0x004014d5

004019dc <udi_msc_sbc_start_stop>:


static void udi_msc_sbc_start_stop(void)
{
  4019dc:	b580      	push	{r7, lr}
  4019de:	b082      	sub	sp, #8
  4019e0:	af00      	add	r7, sp, #0
	bool start = 0x1 & udi_msc_cbw.CDB[4];
  4019e2:	4b17      	ldr	r3, [pc, #92]	; (401a40 <udi_msc_sbc_start_stop+0x64>)
  4019e4:	7cdb      	ldrb	r3, [r3, #19]
  4019e6:	f003 0301 	and.w	r3, r3, #1
  4019ea:	2b00      	cmp	r3, #0
  4019ec:	bf14      	ite	ne
  4019ee:	2301      	movne	r3, #1
  4019f0:	2300      	moveq	r3, #0
  4019f2:	71fb      	strb	r3, [r7, #7]
	bool loej = 0x2 & udi_msc_cbw.CDB[4];
  4019f4:	4b12      	ldr	r3, [pc, #72]	; (401a40 <udi_msc_sbc_start_stop+0x64>)
  4019f6:	7cdb      	ldrb	r3, [r3, #19]
  4019f8:	f003 0302 	and.w	r3, r3, #2
  4019fc:	2b00      	cmp	r3, #0
  4019fe:	bf14      	ite	ne
  401a00:	2301      	movne	r3, #1
  401a02:	2300      	moveq	r3, #0
  401a04:	71bb      	strb	r3, [r7, #6]
	if (loej) {
  401a06:	79bb      	ldrb	r3, [r7, #6]
  401a08:	2b00      	cmp	r3, #0
  401a0a:	d011      	beq.n	401a30 <udi_msc_sbc_start_stop+0x54>
		mem_unload(udi_msc_cbw.bCBWLUN, !start);
  401a0c:	4b0c      	ldr	r3, [pc, #48]	; (401a40 <udi_msc_sbc_start_stop+0x64>)
  401a0e:	7b5a      	ldrb	r2, [r3, #13]
  401a10:	79fb      	ldrb	r3, [r7, #7]
  401a12:	2b00      	cmp	r3, #0
  401a14:	bf14      	ite	ne
  401a16:	2301      	movne	r3, #1
  401a18:	2300      	moveq	r3, #0
  401a1a:	b2db      	uxtb	r3, r3
  401a1c:	f083 0301 	eor.w	r3, r3, #1
  401a20:	b2db      	uxtb	r3, r3
  401a22:	f003 0301 	and.w	r3, r3, #1
  401a26:	b2db      	uxtb	r3, r3
  401a28:	4619      	mov	r1, r3
  401a2a:	4610      	mov	r0, r2
  401a2c:	4b05      	ldr	r3, [pc, #20]	; (401a44 <udi_msc_sbc_start_stop+0x68>)
  401a2e:	4798      	blx	r3
	}
	udi_msc_sense_pass();
  401a30:	4b05      	ldr	r3, [pc, #20]	; (401a48 <udi_msc_sbc_start_stop+0x6c>)
  401a32:	4798      	blx	r3
	udi_msc_csw_process();
  401a34:	4b05      	ldr	r3, [pc, #20]	; (401a4c <udi_msc_sbc_start_stop+0x70>)
  401a36:	4798      	blx	r3
}
  401a38:	bf00      	nop
  401a3a:	3708      	adds	r7, #8
  401a3c:	46bd      	mov	sp, r7
  401a3e:	bd80      	pop	{r7, pc}
  401a40:	20006b4c 	.word	0x20006b4c
  401a44:	00400d75 	.word	0x00400d75
  401a48:	00401621 	.word	0x00401621
  401a4c:	004014d5 	.word	0x004014d5

00401a50 <udi_msc_sbc_read_capacity>:


static void udi_msc_sbc_read_capacity(void)
{
  401a50:	b580      	push	{r7, lr}
  401a52:	af00      	add	r7, sp, #0
	UDC_BSS(4) static struct sbc_read_capacity10_data udi_msc_capacity;

	if (!udi_msc_cbw_validate(sizeof(udi_msc_capacity),
  401a54:	2180      	movs	r1, #128	; 0x80
  401a56:	2008      	movs	r0, #8
  401a58:	4b1a      	ldr	r3, [pc, #104]	; (401ac4 <udi_msc_sbc_read_capacity+0x74>)
  401a5a:	4798      	blx	r3
  401a5c:	4603      	mov	r3, r0
  401a5e:	f083 0301 	eor.w	r3, r3, #1
  401a62:	b2db      	uxtb	r3, r3
  401a64:	2b00      	cmp	r3, #0
  401a66:	d12b      	bne.n	401ac0 <udi_msc_sbc_read_capacity+0x70>
					USB_CBW_DIRECTION_IN))
		return;

	// Get capacity of LUN
	switch (mem_read_capacity(udi_msc_cbw.bCBWLUN,
  401a68:	4b17      	ldr	r3, [pc, #92]	; (401ac8 <udi_msc_sbc_read_capacity+0x78>)
  401a6a:	7b5b      	ldrb	r3, [r3, #13]
  401a6c:	4917      	ldr	r1, [pc, #92]	; (401acc <udi_msc_sbc_read_capacity+0x7c>)
  401a6e:	4618      	mov	r0, r3
  401a70:	4b17      	ldr	r3, [pc, #92]	; (401ad0 <udi_msc_sbc_read_capacity+0x80>)
  401a72:	4798      	blx	r3
  401a74:	4603      	mov	r3, r0
  401a76:	2b02      	cmp	r3, #2
  401a78:	d009      	beq.n	401a8e <udi_msc_sbc_read_capacity+0x3e>
  401a7a:	2b03      	cmp	r3, #3
  401a7c:	d002      	beq.n	401a84 <udi_msc_sbc_read_capacity+0x34>
  401a7e:	2b00      	cmp	r3, #0
  401a80:	d00f      	beq.n	401aa2 <udi_msc_sbc_read_capacity+0x52>
  401a82:	e009      	b.n	401a98 <udi_msc_sbc_read_capacity+0x48>
					&udi_msc_capacity.max_lba)) {
	case CTRL_GOOD:
		break;
	case CTRL_BUSY:
		udi_msc_sense_fail_busy_or_change();
  401a84:	4b13      	ldr	r3, [pc, #76]	; (401ad4 <udi_msc_sbc_read_capacity+0x84>)
  401a86:	4798      	blx	r3
		udi_msc_csw_process();
  401a88:	4b13      	ldr	r3, [pc, #76]	; (401ad8 <udi_msc_sbc_read_capacity+0x88>)
  401a8a:	4798      	blx	r3
		return;
  401a8c:	e019      	b.n	401ac2 <udi_msc_sbc_read_capacity+0x72>
	case CTRL_NO_PRESENT:
		udi_msc_sense_fail_not_present();
  401a8e:	4b13      	ldr	r3, [pc, #76]	; (401adc <udi_msc_sbc_read_capacity+0x8c>)
  401a90:	4798      	blx	r3
		udi_msc_csw_process();
  401a92:	4b11      	ldr	r3, [pc, #68]	; (401ad8 <udi_msc_sbc_read_capacity+0x88>)
  401a94:	4798      	blx	r3
		return;
  401a96:	e014      	b.n	401ac2 <udi_msc_sbc_read_capacity+0x72>
	default:
		udi_msc_sense_fail_hardware();
  401a98:	4b11      	ldr	r3, [pc, #68]	; (401ae0 <udi_msc_sbc_read_capacity+0x90>)
  401a9a:	4798      	blx	r3
		udi_msc_csw_process();
  401a9c:	4b0e      	ldr	r3, [pc, #56]	; (401ad8 <udi_msc_sbc_read_capacity+0x88>)
  401a9e:	4798      	blx	r3
		return;
  401aa0:	e00f      	b.n	401ac2 <udi_msc_sbc_read_capacity+0x72>
		break;
  401aa2:	bf00      	nop
	}

	// Format capacity data
	udi_msc_capacity.block_len = CPU_TO_BE32(UDI_MSC_BLOCK_SIZE);
  401aa4:	4b09      	ldr	r3, [pc, #36]	; (401acc <udi_msc_sbc_read_capacity+0x7c>)
  401aa6:	f44f 3200 	mov.w	r2, #131072	; 0x20000
  401aaa:	605a      	str	r2, [r3, #4]
	udi_msc_capacity.max_lba = cpu_to_be32(udi_msc_capacity.max_lba);
  401aac:	4b07      	ldr	r3, [pc, #28]	; (401acc <udi_msc_sbc_read_capacity+0x7c>)
  401aae:	681b      	ldr	r3, [r3, #0]
  401ab0:	ba1b      	rev	r3, r3
  401ab2:	4a06      	ldr	r2, [pc, #24]	; (401acc <udi_msc_sbc_read_capacity+0x7c>)
  401ab4:	6013      	str	r3, [r2, #0]
	// Send the corresponding sense data
	udi_msc_data_send((uint8_t *) & udi_msc_capacity,
  401ab6:	2108      	movs	r1, #8
  401ab8:	4804      	ldr	r0, [pc, #16]	; (401acc <udi_msc_sbc_read_capacity+0x7c>)
  401aba:	4b0a      	ldr	r3, [pc, #40]	; (401ae4 <udi_msc_sbc_read_capacity+0x94>)
  401abc:	4798      	blx	r3
  401abe:	e000      	b.n	401ac2 <udi_msc_sbc_read_capacity+0x72>
		return;
  401ac0:	bf00      	nop
			sizeof(udi_msc_capacity));
}
  401ac2:	bd80      	pop	{r7, pc}
  401ac4:	004013fd 	.word	0x004013fd
  401ac8:	20006b4c 	.word	0x20006b4c
  401acc:	20006ba4 	.word	0x20006ba4
  401ad0:	00400d0d 	.word	0x00400d0d
  401ad4:	00401655 	.word	0x00401655
  401ad8:	004014d5 	.word	0x004014d5
  401adc:	0040163d 	.word	0x0040163d
  401ae0:	0040166d 	.word	0x0040166d
  401ae4:	00401449 	.word	0x00401449

00401ae8 <udi_msc_sbc_trans>:


static void udi_msc_sbc_trans(bool b_read)
{
  401ae8:	b580      	push	{r7, lr}
  401aea:	b084      	sub	sp, #16
  401aec:	af00      	add	r7, sp, #0
  401aee:	4603      	mov	r3, r0
  401af0:	71fb      	strb	r3, [r7, #7]
	uint32_t trans_size;

	if (!b_read) {
  401af2:	79fb      	ldrb	r3, [r7, #7]
  401af4:	f083 0301 	eor.w	r3, r3, #1
  401af8:	b2db      	uxtb	r3, r3
  401afa:	2b00      	cmp	r3, #0
  401afc:	d00c      	beq.n	401b18 <udi_msc_sbc_trans+0x30>
		// Write operation then check Write Protect
		if (mem_wr_protect(udi_msc_cbw.bCBWLUN)) {
  401afe:	4b23      	ldr	r3, [pc, #140]	; (401b8c <udi_msc_sbc_trans+0xa4>)
  401b00:	7b5b      	ldrb	r3, [r3, #13]
  401b02:	4618      	mov	r0, r3
  401b04:	4b22      	ldr	r3, [pc, #136]	; (401b90 <udi_msc_sbc_trans+0xa8>)
  401b06:	4798      	blx	r3
  401b08:	4603      	mov	r3, r0
  401b0a:	2b00      	cmp	r3, #0
  401b0c:	d004      	beq.n	401b18 <udi_msc_sbc_trans+0x30>
			// Write not authorized
			udi_msc_sense_fail_protected();
  401b0e:	4b21      	ldr	r3, [pc, #132]	; (401b94 <udi_msc_sbc_trans+0xac>)
  401b10:	4798      	blx	r3
			udi_msc_csw_process();
  401b12:	4b21      	ldr	r3, [pc, #132]	; (401b98 <udi_msc_sbc_trans+0xb0>)
  401b14:	4798      	blx	r3
			return;
  401b16:	e035      	b.n	401b84 <udi_msc_sbc_trans+0x9c>
		}
	}
	// Read/Write command fields (address and number of block)
	MSB0(udi_msc_addr) = udi_msc_cbw.CDB[2];
  401b18:	4b20      	ldr	r3, [pc, #128]	; (401b9c <udi_msc_sbc_trans+0xb4>)
  401b1a:	4a1c      	ldr	r2, [pc, #112]	; (401b8c <udi_msc_sbc_trans+0xa4>)
  401b1c:	7c52      	ldrb	r2, [r2, #17]
  401b1e:	701a      	strb	r2, [r3, #0]
	MSB1(udi_msc_addr) = udi_msc_cbw.CDB[3];
  401b20:	4b1f      	ldr	r3, [pc, #124]	; (401ba0 <udi_msc_sbc_trans+0xb8>)
  401b22:	4a1a      	ldr	r2, [pc, #104]	; (401b8c <udi_msc_sbc_trans+0xa4>)
  401b24:	7c92      	ldrb	r2, [r2, #18]
  401b26:	701a      	strb	r2, [r3, #0]
	MSB2(udi_msc_addr) = udi_msc_cbw.CDB[4];
  401b28:	4b1e      	ldr	r3, [pc, #120]	; (401ba4 <udi_msc_sbc_trans+0xbc>)
  401b2a:	4a18      	ldr	r2, [pc, #96]	; (401b8c <udi_msc_sbc_trans+0xa4>)
  401b2c:	7cd2      	ldrb	r2, [r2, #19]
  401b2e:	701a      	strb	r2, [r3, #0]
	MSB3(udi_msc_addr) = udi_msc_cbw.CDB[5];
  401b30:	4b1d      	ldr	r3, [pc, #116]	; (401ba8 <udi_msc_sbc_trans+0xc0>)
  401b32:	4a16      	ldr	r2, [pc, #88]	; (401b8c <udi_msc_sbc_trans+0xa4>)
  401b34:	7d12      	ldrb	r2, [r2, #20]
  401b36:	701a      	strb	r2, [r3, #0]
	MSB(udi_msc_nb_block) = udi_msc_cbw.CDB[7];
  401b38:	4b1c      	ldr	r3, [pc, #112]	; (401bac <udi_msc_sbc_trans+0xc4>)
  401b3a:	4a14      	ldr	r2, [pc, #80]	; (401b8c <udi_msc_sbc_trans+0xa4>)
  401b3c:	7d92      	ldrb	r2, [r2, #22]
  401b3e:	701a      	strb	r2, [r3, #0]
	LSB(udi_msc_nb_block) = udi_msc_cbw.CDB[8];
  401b40:	4b1b      	ldr	r3, [pc, #108]	; (401bb0 <udi_msc_sbc_trans+0xc8>)
  401b42:	4a12      	ldr	r2, [pc, #72]	; (401b8c <udi_msc_sbc_trans+0xa4>)
  401b44:	7dd2      	ldrb	r2, [r2, #23]
  401b46:	701a      	strb	r2, [r3, #0]

	// Compute number of byte to transfer and valid it
	trans_size = (uint32_t) udi_msc_nb_block *UDI_MSC_BLOCK_SIZE;
  401b48:	4b19      	ldr	r3, [pc, #100]	; (401bb0 <udi_msc_sbc_trans+0xc8>)
  401b4a:	881b      	ldrh	r3, [r3, #0]
  401b4c:	025b      	lsls	r3, r3, #9
  401b4e:	60fb      	str	r3, [r7, #12]
	if (!udi_msc_cbw_validate(trans_size,
  401b50:	79fb      	ldrb	r3, [r7, #7]
  401b52:	2b00      	cmp	r3, #0
  401b54:	d001      	beq.n	401b5a <udi_msc_sbc_trans+0x72>
  401b56:	2380      	movs	r3, #128	; 0x80
  401b58:	e000      	b.n	401b5c <udi_msc_sbc_trans+0x74>
  401b5a:	2300      	movs	r3, #0
  401b5c:	4619      	mov	r1, r3
  401b5e:	68f8      	ldr	r0, [r7, #12]
  401b60:	4b14      	ldr	r3, [pc, #80]	; (401bb4 <udi_msc_sbc_trans+0xcc>)
  401b62:	4798      	blx	r3
  401b64:	4603      	mov	r3, r0
  401b66:	f083 0301 	eor.w	r3, r3, #1
  401b6a:	b2db      	uxtb	r3, r3
  401b6c:	2b00      	cmp	r3, #0
  401b6e:	d108      	bne.n	401b82 <udi_msc_sbc_trans+0x9a>
					(b_read) ? USB_CBW_DIRECTION_IN :
					USB_CBW_DIRECTION_OUT))
		return;

	// Record transfer request to do it in a task and not under interrupt
	udi_msc_b_read = b_read;
  401b70:	4a11      	ldr	r2, [pc, #68]	; (401bb8 <udi_msc_sbc_trans+0xd0>)
  401b72:	79fb      	ldrb	r3, [r7, #7]
  401b74:	7013      	strb	r3, [r2, #0]
	udi_msc_b_trans_req = true;
  401b76:	4b11      	ldr	r3, [pc, #68]	; (401bbc <udi_msc_sbc_trans+0xd4>)
  401b78:	2201      	movs	r2, #1
  401b7a:	701a      	strb	r2, [r3, #0]
	UDI_MSC_NOTIFY_TRANS_EXT();
  401b7c:	4b10      	ldr	r3, [pc, #64]	; (401bc0 <udi_msc_sbc_trans+0xd8>)
  401b7e:	4798      	blx	r3
  401b80:	e000      	b.n	401b84 <udi_msc_sbc_trans+0x9c>
		return;
  401b82:	bf00      	nop
}
  401b84:	3710      	adds	r7, #16
  401b86:	46bd      	mov	sp, r7
  401b88:	bd80      	pop	{r7, pc}
  401b8a:	bf00      	nop
  401b8c:	20006b4c 	.word	0x20006b4c
  401b90:	00400e15 	.word	0x00400e15
  401b94:	00401685 	.word	0x00401685
  401b98:	004014d5 	.word	0x004014d5
  401b9c:	20006b8b 	.word	0x20006b8b
  401ba0:	20006b8a 	.word	0x20006b8a
  401ba4:	20006b89 	.word	0x20006b89
  401ba8:	20006b88 	.word	0x20006b88
  401bac:	20006b8d 	.word	0x20006b8d
  401bb0:	20006b8c 	.word	0x20006b8c
  401bb4:	004013fd 	.word	0x004013fd
  401bb8:	20006b84 	.word	0x20006b84
  401bbc:	20006b83 	.word	0x20006b83
  401bc0:	00416299 	.word	0x00416299

00401bc4 <udi_msc_trans_ack>:
}


static void udi_msc_trans_ack(udd_ep_status_t status, iram_size_t n,
		udd_ep_id_t ep)
{
  401bc4:	b480      	push	{r7}
  401bc6:	b083      	sub	sp, #12
  401bc8:	af00      	add	r7, sp, #0
  401bca:	4603      	mov	r3, r0
  401bcc:	6039      	str	r1, [r7, #0]
  401bce:	71fb      	strb	r3, [r7, #7]
  401bd0:	4613      	mov	r3, r2
  401bd2:	71bb      	strb	r3, [r7, #6]
	UNUSED(ep);
	UNUSED(n);
	// Update variable to signal the end of transfer
	udi_msc_b_abort_trans = (UDD_EP_TRANSFER_OK != status) ? true : false;
  401bd4:	79fb      	ldrb	r3, [r7, #7]
  401bd6:	2b00      	cmp	r3, #0
  401bd8:	bf14      	ite	ne
  401bda:	2301      	movne	r3, #1
  401bdc:	2300      	moveq	r3, #0
  401bde:	b2da      	uxtb	r2, r3
  401be0:	4b05      	ldr	r3, [pc, #20]	; (401bf8 <udi_msc_trans_ack+0x34>)
  401be2:	701a      	strb	r2, [r3, #0]
	udi_msc_b_ack_trans = true;
  401be4:	4b05      	ldr	r3, [pc, #20]	; (401bfc <udi_msc_trans_ack+0x38>)
  401be6:	2201      	movs	r2, #1
  401be8:	701a      	strb	r2, [r3, #0]
}
  401bea:	bf00      	nop
  401bec:	370c      	adds	r7, #12
  401bee:	46bd      	mov	sp, r7
  401bf0:	f85d 7b04 	ldr.w	r7, [sp], #4
  401bf4:	4770      	bx	lr
  401bf6:	bf00      	nop
  401bf8:	2000b586 	.word	0x2000b586
  401bfc:	20000021 	.word	0x20000021

00401c00 <udi_msc_trans_block>:


bool udi_msc_trans_block(bool b_read, uint8_t * block, iram_size_t block_size,
		void (*callback) (udd_ep_status_t status, iram_size_t n, udd_ep_id_t ep))
{
  401c00:	b590      	push	{r4, r7, lr}
  401c02:	b087      	sub	sp, #28
  401c04:	af02      	add	r7, sp, #8
  401c06:	60b9      	str	r1, [r7, #8]
  401c08:	607a      	str	r2, [r7, #4]
  401c0a:	603b      	str	r3, [r7, #0]
  401c0c:	4603      	mov	r3, r0
  401c0e:	73fb      	strb	r3, [r7, #15]
	if (!udi_msc_b_ack_trans)
  401c10:	4b2e      	ldr	r3, [pc, #184]	; (401ccc <udi_msc_trans_block+0xcc>)
  401c12:	781b      	ldrb	r3, [r3, #0]
  401c14:	b2db      	uxtb	r3, r3
  401c16:	f083 0301 	eor.w	r3, r3, #1
  401c1a:	b2db      	uxtb	r3, r3
  401c1c:	2b00      	cmp	r3, #0
  401c1e:	d001      	beq.n	401c24 <udi_msc_trans_block+0x24>
		return false;	// No possible, transfer on going
  401c20:	2300      	movs	r3, #0
  401c22:	e04e      	b.n	401cc2 <udi_msc_trans_block+0xc2>

	// Start transfer Internal RAM<->USB line
	udi_msc_b_ack_trans = false;
  401c24:	4b29      	ldr	r3, [pc, #164]	; (401ccc <udi_msc_trans_block+0xcc>)
  401c26:	2200      	movs	r2, #0
  401c28:	701a      	strb	r2, [r3, #0]
	if (!udd_ep_run((b_read) ? UDI_MSC_EP_IN : UDI_MSC_EP_OUT,
  401c2a:	7bfb      	ldrb	r3, [r7, #15]
  401c2c:	2b00      	cmp	r3, #0
  401c2e:	d001      	beq.n	401c34 <udi_msc_trans_block+0x34>
  401c30:	2081      	movs	r0, #129	; 0x81
  401c32:	e000      	b.n	401c36 <udi_msc_trans_block+0x36>
  401c34:	2002      	movs	r0, #2
  401c36:	683b      	ldr	r3, [r7, #0]
  401c38:	2b00      	cmp	r3, #0
  401c3a:	d001      	beq.n	401c40 <udi_msc_trans_block+0x40>
  401c3c:	683b      	ldr	r3, [r7, #0]
  401c3e:	e000      	b.n	401c42 <udi_msc_trans_block+0x42>
  401c40:	4b23      	ldr	r3, [pc, #140]	; (401cd0 <udi_msc_trans_block+0xd0>)
  401c42:	9300      	str	r3, [sp, #0]
  401c44:	687b      	ldr	r3, [r7, #4]
  401c46:	68ba      	ldr	r2, [r7, #8]
  401c48:	2100      	movs	r1, #0
  401c4a:	4c22      	ldr	r4, [pc, #136]	; (401cd4 <udi_msc_trans_block+0xd4>)
  401c4c:	47a0      	blx	r4
  401c4e:	4603      	mov	r3, r0
  401c50:	f083 0301 	eor.w	r3, r3, #1
  401c54:	b2db      	uxtb	r3, r3
  401c56:	2b00      	cmp	r3, #0
  401c58:	d004      	beq.n	401c64 <udi_msc_trans_block+0x64>
					false,
					block,
					block_size,
					(NULL == callback) ? udi_msc_trans_ack :
					callback)) {
		udi_msc_b_ack_trans = true;
  401c5a:	4b1c      	ldr	r3, [pc, #112]	; (401ccc <udi_msc_trans_block+0xcc>)
  401c5c:	2201      	movs	r2, #1
  401c5e:	701a      	strb	r2, [r3, #0]
		return false;
  401c60:	2300      	movs	r3, #0
  401c62:	e02e      	b.n	401cc2 <udi_msc_trans_block+0xc2>
	}
	if (NULL == callback) {
  401c64:	683b      	ldr	r3, [r7, #0]
  401c66:	2b00      	cmp	r3, #0
  401c68:	d124      	bne.n	401cb4 <udi_msc_trans_block+0xb4>
		while (!udi_msc_b_ack_trans);
  401c6a:	bf00      	nop
  401c6c:	4b17      	ldr	r3, [pc, #92]	; (401ccc <udi_msc_trans_block+0xcc>)
  401c6e:	781b      	ldrb	r3, [r3, #0]
  401c70:	b2db      	uxtb	r3, r3
  401c72:	f083 0301 	eor.w	r3, r3, #1
  401c76:	b2db      	uxtb	r3, r3
  401c78:	2b00      	cmp	r3, #0
  401c7a:	d1f7      	bne.n	401c6c <udi_msc_trans_block+0x6c>
		if (udi_msc_b_abort_trans) {
  401c7c:	4b16      	ldr	r3, [pc, #88]	; (401cd8 <udi_msc_trans_block+0xd8>)
  401c7e:	781b      	ldrb	r3, [r3, #0]
  401c80:	b2db      	uxtb	r3, r3
  401c82:	2b00      	cmp	r3, #0
  401c84:	d001      	beq.n	401c8a <udi_msc_trans_block+0x8a>
			return false;
  401c86:	2300      	movs	r3, #0
  401c88:	e01b      	b.n	401cc2 <udi_msc_trans_block+0xc2>
		}
		udi_msc_csw.dCSWDataResidue -= block_size;
  401c8a:	4b14      	ldr	r3, [pc, #80]	; (401cdc <udi_msc_trans_block+0xdc>)
  401c8c:	689a      	ldr	r2, [r3, #8]
  401c8e:	687b      	ldr	r3, [r7, #4]
  401c90:	1ad3      	subs	r3, r2, r3
  401c92:	4a12      	ldr	r2, [pc, #72]	; (401cdc <udi_msc_trans_block+0xdc>)
  401c94:	6093      	str	r3, [r2, #8]
		return (!udi_msc_b_abort_trans);
  401c96:	4b10      	ldr	r3, [pc, #64]	; (401cd8 <udi_msc_trans_block+0xd8>)
  401c98:	781b      	ldrb	r3, [r3, #0]
  401c9a:	b2db      	uxtb	r3, r3
  401c9c:	2b00      	cmp	r3, #0
  401c9e:	bf14      	ite	ne
  401ca0:	2301      	movne	r3, #1
  401ca2:	2300      	moveq	r3, #0
  401ca4:	b2db      	uxtb	r3, r3
  401ca6:	f083 0301 	eor.w	r3, r3, #1
  401caa:	b2db      	uxtb	r3, r3
  401cac:	f003 0301 	and.w	r3, r3, #1
  401cb0:	b2db      	uxtb	r3, r3
  401cb2:	e006      	b.n	401cc2 <udi_msc_trans_block+0xc2>
	}
	udi_msc_csw.dCSWDataResidue -= block_size;
  401cb4:	4b09      	ldr	r3, [pc, #36]	; (401cdc <udi_msc_trans_block+0xdc>)
  401cb6:	689a      	ldr	r2, [r3, #8]
  401cb8:	687b      	ldr	r3, [r7, #4]
  401cba:	1ad3      	subs	r3, r2, r3
  401cbc:	4a07      	ldr	r2, [pc, #28]	; (401cdc <udi_msc_trans_block+0xdc>)
  401cbe:	6093      	str	r3, [r2, #8]
	return true;
  401cc0:	2301      	movs	r3, #1
}
  401cc2:	4618      	mov	r0, r3
  401cc4:	3714      	adds	r7, #20
  401cc6:	46bd      	mov	sp, r7
  401cc8:	bd90      	pop	{r4, r7, pc}
  401cca:	bf00      	nop
  401ccc:	20000021 	.word	0x20000021
  401cd0:	00401bc5 	.word	0x00401bc5
  401cd4:	00405175 	.word	0x00405175
  401cd8:	2000b586 	.word	0x2000b586
  401cdc:	20000014 	.word	0x20000014

00401ce0 <udc_get_string_serial_name>:
	}
#  define USB_DEVICE_SERIAL_NAME_SIZE \
	USB_DEVICE_GET_SERIAL_NAME_LENGTH
#elif defined USB_DEVICE_SERIAL_NAME
	static const uint8_t *udc_get_string_serial_name(void)
	{
  401ce0:	b480      	push	{r7}
  401ce2:	af00      	add	r7, sp, #0
		return (const uint8_t *)USB_DEVICE_SERIAL_NAME;
  401ce4:	4b02      	ldr	r3, [pc, #8]	; (401cf0 <udc_get_string_serial_name+0x10>)
	}
  401ce6:	4618      	mov	r0, r3
  401ce8:	46bd      	mov	sp, r7
  401cea:	f85d 7b04 	ldr.w	r7, [sp], #4
  401cee:	4770      	bx	lr
  401cf0:	0041c91c 	.word	0x0041c91c

00401cf4 <udc_get_eof_conf>:
 * \brief Returns a value to check the end of USB Configuration descriptor
 *
 * \return address after the last byte of USB Configuration descriptor
 */
static usb_conf_desc_t UDC_DESC_STORAGE *udc_get_eof_conf(void)
{
  401cf4:	b480      	push	{r7}
  401cf6:	af00      	add	r7, sp, #0
	return (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *)
			udc_ptr_conf->desc +
  401cf8:	4b06      	ldr	r3, [pc, #24]	; (401d14 <udc_get_eof_conf+0x20>)
  401cfa:	681b      	ldr	r3, [r3, #0]
  401cfc:	681b      	ldr	r3, [r3, #0]
			le16_to_cpu(udc_ptr_conf->desc->wTotalLength));
  401cfe:	4a05      	ldr	r2, [pc, #20]	; (401d14 <udc_get_eof_conf+0x20>)
  401d00:	6812      	ldr	r2, [r2, #0]
  401d02:	6812      	ldr	r2, [r2, #0]
  401d04:	8852      	ldrh	r2, [r2, #2]
  401d06:	b292      	uxth	r2, r2
	return (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *)
  401d08:	4413      	add	r3, r2
}
  401d0a:	4618      	mov	r0, r3
  401d0c:	46bd      	mov	sp, r7
  401d0e:	f85d 7b04 	ldr.w	r7, [sp], #4
  401d12:	4770      	bx	lr
  401d14:	20006bb8 	.word	0x20006bb8

00401d18 <udc_next_desc_in_iface>:
 * \return address of specific descriptor found
 * \return NULL if it is the end of global interface descriptor
 */
static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t
		UDC_DESC_STORAGE * desc, uint8_t desc_id)
{
  401d18:	b580      	push	{r7, lr}
  401d1a:	b084      	sub	sp, #16
  401d1c:	af00      	add	r7, sp, #0
  401d1e:	6078      	str	r0, [r7, #4]
  401d20:	460b      	mov	r3, r1
  401d22:	70fb      	strb	r3, [r7, #3]
	usb_conf_desc_t UDC_DESC_STORAGE *ptr_eof_desc;

	ptr_eof_desc = udc_get_eof_conf();
  401d24:	4b12      	ldr	r3, [pc, #72]	; (401d70 <udc_next_desc_in_iface+0x58>)
  401d26:	4798      	blx	r3
  401d28:	60f8      	str	r0, [r7, #12]
	// Go to next descriptor
	desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
			desc->bLength);
  401d2a:	687b      	ldr	r3, [r7, #4]
  401d2c:	781b      	ldrb	r3, [r3, #0]
  401d2e:	461a      	mov	r2, r3
	desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
  401d30:	687b      	ldr	r3, [r7, #4]
  401d32:	4413      	add	r3, r2
  401d34:	607b      	str	r3, [r7, #4]
	// Check the end of configuration descriptor
	while (ptr_eof_desc > desc) {
  401d36:	e010      	b.n	401d5a <udc_next_desc_in_iface+0x42>
		// If new interface descriptor is found,
		// then it is the end of the current global interface descriptor
		if (USB_DT_INTERFACE == desc->bDescriptorType) {
  401d38:	687b      	ldr	r3, [r7, #4]
  401d3a:	785b      	ldrb	r3, [r3, #1]
  401d3c:	2b04      	cmp	r3, #4
  401d3e:	d011      	beq.n	401d64 <udc_next_desc_in_iface+0x4c>
			break; // End of global interface descriptor
		}
		if (desc_id == desc->bDescriptorType) {
  401d40:	687b      	ldr	r3, [r7, #4]
  401d42:	785b      	ldrb	r3, [r3, #1]
  401d44:	78fa      	ldrb	r2, [r7, #3]
  401d46:	429a      	cmp	r2, r3
  401d48:	d101      	bne.n	401d4e <udc_next_desc_in_iface+0x36>
			return desc; // Specific descriptor found
  401d4a:	687b      	ldr	r3, [r7, #4]
  401d4c:	e00c      	b.n	401d68 <udc_next_desc_in_iface+0x50>
		}
		// Go to next descriptor
		desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
				desc->bLength);
  401d4e:	687b      	ldr	r3, [r7, #4]
  401d50:	781b      	ldrb	r3, [r3, #0]
  401d52:	461a      	mov	r2, r3
		desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
  401d54:	687b      	ldr	r3, [r7, #4]
  401d56:	4413      	add	r3, r2
  401d58:	607b      	str	r3, [r7, #4]
	while (ptr_eof_desc > desc) {
  401d5a:	68fa      	ldr	r2, [r7, #12]
  401d5c:	687b      	ldr	r3, [r7, #4]
  401d5e:	429a      	cmp	r2, r3
  401d60:	d8ea      	bhi.n	401d38 <udc_next_desc_in_iface+0x20>
  401d62:	e000      	b.n	401d66 <udc_next_desc_in_iface+0x4e>
			break; // End of global interface descriptor
  401d64:	bf00      	nop
	}
	return NULL; // No specific descriptor found
  401d66:	2300      	movs	r3, #0
}
  401d68:	4618      	mov	r0, r3
  401d6a:	3710      	adds	r7, #16
  401d6c:	46bd      	mov	sp, r7
  401d6e:	bd80      	pop	{r7, pc}
  401d70:	00401cf5 	.word	0x00401cf5

00401d74 <udc_update_iface_desc>:
 * \param setting_num   Setting number of interface to find
 *
 * \return 1 if found or 0 if not found
 */
static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num)
{
  401d74:	b580      	push	{r7, lr}
  401d76:	b084      	sub	sp, #16
  401d78:	af00      	add	r7, sp, #0
  401d7a:	4603      	mov	r3, r0
  401d7c:	460a      	mov	r2, r1
  401d7e:	71fb      	strb	r3, [r7, #7]
  401d80:	4613      	mov	r3, r2
  401d82:	71bb      	strb	r3, [r7, #6]
	usb_conf_desc_t UDC_DESC_STORAGE *ptr_end_desc;

	if (0 == udc_num_configuration) {
  401d84:	4b1e      	ldr	r3, [pc, #120]	; (401e00 <udc_update_iface_desc+0x8c>)
  401d86:	781b      	ldrb	r3, [r3, #0]
  401d88:	2b00      	cmp	r3, #0
  401d8a:	d101      	bne.n	401d90 <udc_update_iface_desc+0x1c>
		return false;
  401d8c:	2300      	movs	r3, #0
  401d8e:	e032      	b.n	401df6 <udc_update_iface_desc+0x82>
	}

	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {
  401d90:	4b1c      	ldr	r3, [pc, #112]	; (401e04 <udc_update_iface_desc+0x90>)
  401d92:	681b      	ldr	r3, [r3, #0]
  401d94:	681b      	ldr	r3, [r3, #0]
  401d96:	791b      	ldrb	r3, [r3, #4]
  401d98:	79fa      	ldrb	r2, [r7, #7]
  401d9a:	429a      	cmp	r2, r3
  401d9c:	d301      	bcc.n	401da2 <udc_update_iface_desc+0x2e>
		return false;
  401d9e:	2300      	movs	r3, #0
  401da0:	e029      	b.n	401df6 <udc_update_iface_desc+0x82>
	}

	// Start at the beginning of configuration descriptor
	udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *)
			udc_ptr_conf->desc;
  401da2:	4b18      	ldr	r3, [pc, #96]	; (401e04 <udc_update_iface_desc+0x90>)
  401da4:	681b      	ldr	r3, [r3, #0]
  401da6:	681b      	ldr	r3, [r3, #0]
	udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *)
  401da8:	4a17      	ldr	r2, [pc, #92]	; (401e08 <udc_update_iface_desc+0x94>)
  401daa:	6013      	str	r3, [r2, #0]

	// Check the end of configuration descriptor
	ptr_end_desc = udc_get_eof_conf();
  401dac:	4b17      	ldr	r3, [pc, #92]	; (401e0c <udc_update_iface_desc+0x98>)
  401dae:	4798      	blx	r3
  401db0:	60f8      	str	r0, [r7, #12]
	while (ptr_end_desc >
  401db2:	e01a      	b.n	401dea <udc_update_iface_desc+0x76>
			(UDC_DESC_STORAGE usb_conf_desc_t *) udc_ptr_iface) {
		if (USB_DT_INTERFACE == udc_ptr_iface->bDescriptorType) {
  401db4:	4b14      	ldr	r3, [pc, #80]	; (401e08 <udc_update_iface_desc+0x94>)
  401db6:	681b      	ldr	r3, [r3, #0]
  401db8:	785b      	ldrb	r3, [r3, #1]
  401dba:	2b04      	cmp	r3, #4
  401dbc:	d10d      	bne.n	401dda <udc_update_iface_desc+0x66>
			// A interface descriptor is found
			// Check interface and alternate setting number
			if ((iface_num == udc_ptr_iface->bInterfaceNumber) &&
  401dbe:	4b12      	ldr	r3, [pc, #72]	; (401e08 <udc_update_iface_desc+0x94>)
  401dc0:	681b      	ldr	r3, [r3, #0]
  401dc2:	789b      	ldrb	r3, [r3, #2]
  401dc4:	79fa      	ldrb	r2, [r7, #7]
  401dc6:	429a      	cmp	r2, r3
  401dc8:	d107      	bne.n	401dda <udc_update_iface_desc+0x66>
					(setting_num ==
					udc_ptr_iface->bAlternateSetting)) {
  401dca:	4b0f      	ldr	r3, [pc, #60]	; (401e08 <udc_update_iface_desc+0x94>)
  401dcc:	681b      	ldr	r3, [r3, #0]
  401dce:	78db      	ldrb	r3, [r3, #3]
			if ((iface_num == udc_ptr_iface->bInterfaceNumber) &&
  401dd0:	79ba      	ldrb	r2, [r7, #6]
  401dd2:	429a      	cmp	r2, r3
  401dd4:	d101      	bne.n	401dda <udc_update_iface_desc+0x66>
				return true; // Interface found
  401dd6:	2301      	movs	r3, #1
  401dd8:	e00d      	b.n	401df6 <udc_update_iface_desc+0x82>
			}
		}
		// Go to next descriptor
		udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *) (
  401dda:	4b0b      	ldr	r3, [pc, #44]	; (401e08 <udc_update_iface_desc+0x94>)
  401ddc:	681b      	ldr	r3, [r3, #0]
				(uint8_t *) udc_ptr_iface +
				udc_ptr_iface->bLength);
  401dde:	4a0a      	ldr	r2, [pc, #40]	; (401e08 <udc_update_iface_desc+0x94>)
  401de0:	6812      	ldr	r2, [r2, #0]
  401de2:	7812      	ldrb	r2, [r2, #0]
		udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *) (
  401de4:	4413      	add	r3, r2
  401de6:	4a08      	ldr	r2, [pc, #32]	; (401e08 <udc_update_iface_desc+0x94>)
  401de8:	6013      	str	r3, [r2, #0]
			(UDC_DESC_STORAGE usb_conf_desc_t *) udc_ptr_iface) {
  401dea:	4b07      	ldr	r3, [pc, #28]	; (401e08 <udc_update_iface_desc+0x94>)
  401dec:	681b      	ldr	r3, [r3, #0]
	while (ptr_end_desc >
  401dee:	68fa      	ldr	r2, [r7, #12]
  401df0:	429a      	cmp	r2, r3
  401df2:	d8df      	bhi.n	401db4 <udc_update_iface_desc+0x40>
	}
	return false; // Interface not found
  401df4:	2300      	movs	r3, #0
}
  401df6:	4618      	mov	r0, r3
  401df8:	3710      	adds	r7, #16
  401dfa:	46bd      	mov	sp, r7
  401dfc:	bd80      	pop	{r7, pc}
  401dfe:	bf00      	nop
  401e00:	20006bb4 	.word	0x20006bb4
  401e04:	20006bb8 	.word	0x20006bb8
  401e08:	20006bbc 	.word	0x20006bbc
  401e0c:	00401cf5 	.word	0x00401cf5

00401e10 <udc_iface_disable>:
 * \param iface_num     Interface number to disable
 *
 * \return 1 if it is done or 0 if interface is not found
 */
static bool udc_iface_disable(uint8_t iface_num)
{
  401e10:	b580      	push	{r7, lr}
  401e12:	b084      	sub	sp, #16
  401e14:	af00      	add	r7, sp, #0
  401e16:	4603      	mov	r3, r0
  401e18:	71fb      	strb	r3, [r7, #7]
	udi_api_t UDC_DESC_STORAGE *udi_api;

	// Select first alternate setting of the interface
	// to update udc_ptr_iface before call iface->getsetting()
	if (!udc_update_iface_desc(iface_num, 0)) {
  401e1a:	79fb      	ldrb	r3, [r7, #7]
  401e1c:	2100      	movs	r1, #0
  401e1e:	4618      	mov	r0, r3
  401e20:	4b1e      	ldr	r3, [pc, #120]	; (401e9c <udc_iface_disable+0x8c>)
  401e22:	4798      	blx	r3
  401e24:	4603      	mov	r3, r0
  401e26:	f083 0301 	eor.w	r3, r3, #1
  401e2a:	b2db      	uxtb	r3, r3
  401e2c:	2b00      	cmp	r3, #0
  401e2e:	d001      	beq.n	401e34 <udc_iface_disable+0x24>
		return false;
  401e30:	2300      	movs	r3, #0
  401e32:	e02f      	b.n	401e94 <udc_iface_disable+0x84>
	}

	// Select the interface with the current alternate setting
	udi_api = udc_ptr_conf->udi_apis[iface_num];
  401e34:	4b1a      	ldr	r3, [pc, #104]	; (401ea0 <udc_iface_disable+0x90>)
  401e36:	681b      	ldr	r3, [r3, #0]
  401e38:	685a      	ldr	r2, [r3, #4]
  401e3a:	79fb      	ldrb	r3, [r7, #7]
  401e3c:	009b      	lsls	r3, r3, #2
  401e3e:	4413      	add	r3, r2
  401e40:	681b      	ldr	r3, [r3, #0]
  401e42:	60bb      	str	r3, [r7, #8]

#if (0!=USB_DEVICE_MAX_EP)
	if (!udc_update_iface_desc(iface_num, udi_api->getsetting())) {
  401e44:	68bb      	ldr	r3, [r7, #8]
  401e46:	68db      	ldr	r3, [r3, #12]
  401e48:	4798      	blx	r3
  401e4a:	4603      	mov	r3, r0
  401e4c:	461a      	mov	r2, r3
  401e4e:	79fb      	ldrb	r3, [r7, #7]
  401e50:	4611      	mov	r1, r2
  401e52:	4618      	mov	r0, r3
  401e54:	4b11      	ldr	r3, [pc, #68]	; (401e9c <udc_iface_disable+0x8c>)
  401e56:	4798      	blx	r3
  401e58:	4603      	mov	r3, r0
  401e5a:	f083 0301 	eor.w	r3, r3, #1
  401e5e:	b2db      	uxtb	r3, r3
  401e60:	2b00      	cmp	r3, #0
  401e62:	d001      	beq.n	401e68 <udc_iface_disable+0x58>
		return false;
  401e64:	2300      	movs	r3, #0
  401e66:	e015      	b.n	401e94 <udc_iface_disable+0x84>
	}

	// Start at the beginning of interface descriptor
	{
		usb_ep_desc_t UDC_DESC_STORAGE *ep_desc;
		ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *) udc_ptr_iface;
  401e68:	4b0e      	ldr	r3, [pc, #56]	; (401ea4 <udc_iface_disable+0x94>)
  401e6a:	681b      	ldr	r3, [r3, #0]
  401e6c:	60fb      	str	r3, [r7, #12]
		while (1) {
			// Search Endpoint descriptor included in global interface descriptor
			ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *)
  401e6e:	2105      	movs	r1, #5
  401e70:	68f8      	ldr	r0, [r7, #12]
  401e72:	4b0d      	ldr	r3, [pc, #52]	; (401ea8 <udc_iface_disable+0x98>)
  401e74:	4798      	blx	r3
  401e76:	60f8      	str	r0, [r7, #12]
					udc_next_desc_in_iface((UDC_DESC_STORAGE
					usb_conf_desc_t *)
					ep_desc, USB_DT_ENDPOINT);
			if (NULL == ep_desc) {
  401e78:	68fb      	ldr	r3, [r7, #12]
  401e7a:	2b00      	cmp	r3, #0
  401e7c:	d005      	beq.n	401e8a <udc_iface_disable+0x7a>
				break;
			}
			// Free the endpoint used by the interface
			udd_ep_free(ep_desc->bEndpointAddress);
  401e7e:	68fb      	ldr	r3, [r7, #12]
  401e80:	789b      	ldrb	r3, [r3, #2]
  401e82:	4618      	mov	r0, r3
  401e84:	4b09      	ldr	r3, [pc, #36]	; (401eac <udc_iface_disable+0x9c>)
  401e86:	4798      	blx	r3
			ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *)
  401e88:	e7f1      	b.n	401e6e <udc_iface_disable+0x5e>
				break;
  401e8a:	bf00      	nop
		}
	}
#endif

	// Disable interface
	udi_api->disable();
  401e8c:	68bb      	ldr	r3, [r7, #8]
  401e8e:	685b      	ldr	r3, [r3, #4]
  401e90:	4798      	blx	r3
	return true;
  401e92:	2301      	movs	r3, #1
}
  401e94:	4618      	mov	r0, r3
  401e96:	3710      	adds	r7, #16
  401e98:	46bd      	mov	sp, r7
  401e9a:	bd80      	pop	{r7, pc}
  401e9c:	00401d75 	.word	0x00401d75
  401ea0:	20006bb8 	.word	0x20006bb8
  401ea4:	20006bbc 	.word	0x20006bbc
  401ea8:	00401d19 	.word	0x00401d19
  401eac:	00404e71 	.word	0x00404e71

00401eb0 <udc_iface_enable>:
 * \param setting_num   Setting number to enable
 *
 * \return 1 if it is done or 0 if interface is not found
 */
static bool udc_iface_enable(uint8_t iface_num, uint8_t setting_num)
{
  401eb0:	b580      	push	{r7, lr}
  401eb2:	b084      	sub	sp, #16
  401eb4:	af00      	add	r7, sp, #0
  401eb6:	4603      	mov	r3, r0
  401eb8:	460a      	mov	r2, r1
  401eba:	71fb      	strb	r3, [r7, #7]
  401ebc:	4613      	mov	r3, r2
  401ebe:	71bb      	strb	r3, [r7, #6]
	// Select the interface descriptor
	if (!udc_update_iface_desc(iface_num, setting_num)) {
  401ec0:	79ba      	ldrb	r2, [r7, #6]
  401ec2:	79fb      	ldrb	r3, [r7, #7]
  401ec4:	4611      	mov	r1, r2
  401ec6:	4618      	mov	r0, r3
  401ec8:	4b1a      	ldr	r3, [pc, #104]	; (401f34 <udc_iface_enable+0x84>)
  401eca:	4798      	blx	r3
  401ecc:	4603      	mov	r3, r0
  401ece:	f083 0301 	eor.w	r3, r3, #1
  401ed2:	b2db      	uxtb	r3, r3
  401ed4:	2b00      	cmp	r3, #0
  401ed6:	d001      	beq.n	401edc <udc_iface_enable+0x2c>
		return false;
  401ed8:	2300      	movs	r3, #0
  401eda:	e027      	b.n	401f2c <udc_iface_enable+0x7c>

#if (0!=USB_DEVICE_MAX_EP)
	usb_ep_desc_t UDC_DESC_STORAGE *ep_desc;

	// Start at the beginning of the global interface descriptor
	ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *) udc_ptr_iface;
  401edc:	4b16      	ldr	r3, [pc, #88]	; (401f38 <udc_iface_enable+0x88>)
  401ede:	681b      	ldr	r3, [r3, #0]
  401ee0:	60fb      	str	r3, [r7, #12]
	while (1) {
		// Search Endpoint descriptor included in the global interface descriptor
		ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *)
  401ee2:	2105      	movs	r1, #5
  401ee4:	68f8      	ldr	r0, [r7, #12]
  401ee6:	4b15      	ldr	r3, [pc, #84]	; (401f3c <udc_iface_enable+0x8c>)
  401ee8:	4798      	blx	r3
  401eea:	60f8      	str	r0, [r7, #12]
				udc_next_desc_in_iface((UDC_DESC_STORAGE
						usb_conf_desc_t *) ep_desc,
				USB_DT_ENDPOINT);
		if (NULL == ep_desc)
  401eec:	68fb      	ldr	r3, [r7, #12]
  401eee:	2b00      	cmp	r3, #0
  401ef0:	d011      	beq.n	401f16 <udc_iface_enable+0x66>
			break;
		// Alloc the endpoint used by the interface
		if (!udd_ep_alloc(ep_desc->bEndpointAddress,
  401ef2:	68fb      	ldr	r3, [r7, #12]
  401ef4:	7898      	ldrb	r0, [r3, #2]
  401ef6:	68fb      	ldr	r3, [r7, #12]
  401ef8:	78d9      	ldrb	r1, [r3, #3]
  401efa:	68fb      	ldr	r3, [r7, #12]
  401efc:	889b      	ldrh	r3, [r3, #4]
  401efe:	b29b      	uxth	r3, r3
  401f00:	461a      	mov	r2, r3
  401f02:	4b0f      	ldr	r3, [pc, #60]	; (401f40 <udc_iface_enable+0x90>)
  401f04:	4798      	blx	r3
  401f06:	4603      	mov	r3, r0
  401f08:	f083 0301 	eor.w	r3, r3, #1
  401f0c:	b2db      	uxtb	r3, r3
  401f0e:	2b00      	cmp	r3, #0
  401f10:	d0e7      	beq.n	401ee2 <udc_iface_enable+0x32>
				ep_desc->bmAttributes,
				le16_to_cpu
				(ep_desc->wMaxPacketSize))) {
			return false;
  401f12:	2300      	movs	r3, #0
  401f14:	e00a      	b.n	401f2c <udc_iface_enable+0x7c>
			break;
  401f16:	bf00      	nop
		}
	}
#endif
	// Enable the interface
	return udc_ptr_conf->udi_apis[iface_num]->enable();
  401f18:	4b0a      	ldr	r3, [pc, #40]	; (401f44 <udc_iface_enable+0x94>)
  401f1a:	681b      	ldr	r3, [r3, #0]
  401f1c:	685a      	ldr	r2, [r3, #4]
  401f1e:	79fb      	ldrb	r3, [r7, #7]
  401f20:	009b      	lsls	r3, r3, #2
  401f22:	4413      	add	r3, r2
  401f24:	681b      	ldr	r3, [r3, #0]
  401f26:	681b      	ldr	r3, [r3, #0]
  401f28:	4798      	blx	r3
  401f2a:	4603      	mov	r3, r0
}
  401f2c:	4618      	mov	r0, r3
  401f2e:	3710      	adds	r7, #16
  401f30:	46bd      	mov	sp, r7
  401f32:	bd80      	pop	{r7, pc}
  401f34:	00401d75 	.word	0x00401d75
  401f38:	20006bbc 	.word	0x20006bbc
  401f3c:	00401d19 	.word	0x00401d19
  401f40:	00404c81 	.word	0x00404c81
  401f44:	20006bb8 	.word	0x20006bb8

00401f48 <udc_reset>:
/**
 * \brief Reset the current configuration of the USB device,
 * This routines can be called by UDD when a RESET on the USB line occurs.
 */
void udc_reset(void)
{
  401f48:	b580      	push	{r7, lr}
  401f4a:	b082      	sub	sp, #8
  401f4c:	af00      	add	r7, sp, #0
	uint8_t iface_num;

	if (udc_num_configuration) {
  401f4e:	4b0f      	ldr	r3, [pc, #60]	; (401f8c <udc_reset+0x44>)
  401f50:	781b      	ldrb	r3, [r3, #0]
  401f52:	2b00      	cmp	r3, #0
  401f54:	d010      	beq.n	401f78 <udc_reset+0x30>
		for (iface_num = 0;
  401f56:	2300      	movs	r3, #0
  401f58:	71fb      	strb	r3, [r7, #7]
  401f5a:	e006      	b.n	401f6a <udc_reset+0x22>
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
				iface_num++) {
			udc_iface_disable(iface_num);
  401f5c:	79fb      	ldrb	r3, [r7, #7]
  401f5e:	4618      	mov	r0, r3
  401f60:	4b0b      	ldr	r3, [pc, #44]	; (401f90 <udc_reset+0x48>)
  401f62:	4798      	blx	r3
				iface_num++) {
  401f64:	79fb      	ldrb	r3, [r7, #7]
  401f66:	3301      	adds	r3, #1
  401f68:	71fb      	strb	r3, [r7, #7]
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
  401f6a:	4b0a      	ldr	r3, [pc, #40]	; (401f94 <udc_reset+0x4c>)
  401f6c:	681b      	ldr	r3, [r3, #0]
  401f6e:	681b      	ldr	r3, [r3, #0]
  401f70:	791b      	ldrb	r3, [r3, #4]
		for (iface_num = 0;
  401f72:	79fa      	ldrb	r2, [r7, #7]
  401f74:	429a      	cmp	r2, r3
  401f76:	d3f1      	bcc.n	401f5c <udc_reset+0x14>
		}
	}
	udc_num_configuration = 0;
  401f78:	4b04      	ldr	r3, [pc, #16]	; (401f8c <udc_reset+0x44>)
  401f7a:	2200      	movs	r2, #0
  401f7c:	701a      	strb	r2, [r3, #0]
	if (CPU_TO_LE16(USB_DEV_STATUS_REMOTEWAKEUP) & udc_device_status) {
		// Remote wakeup is enabled then disable it
		UDC_REMOTEWAKEUP_DISABLE();
	}
#endif
	udc_device_status =
  401f7e:	4b06      	ldr	r3, [pc, #24]	; (401f98 <udc_reset+0x50>)
  401f80:	2201      	movs	r2, #1
  401f82:	801a      	strh	r2, [r3, #0]
#if (USB_DEVICE_ATTR & USB_CONFIG_ATTR_SELF_POWERED)
			CPU_TO_LE16(USB_DEV_STATUS_SELF_POWERED);
#else
			CPU_TO_LE16(USB_DEV_STATUS_BUS_POWERED);
#endif
}
  401f84:	bf00      	nop
  401f86:	3708      	adds	r7, #8
  401f88:	46bd      	mov	sp, r7
  401f8a:	bd80      	pop	{r7, pc}
  401f8c:	20006bb4 	.word	0x20006bb4
  401f90:	00401e11 	.word	0x00401e11
  401f94:	20006bb8 	.word	0x20006bb8
  401f98:	20006bac 	.word	0x20006bac

00401f9c <udc_sof_notify>:

void udc_sof_notify(void)
{
  401f9c:	b580      	push	{r7, lr}
  401f9e:	b082      	sub	sp, #8
  401fa0:	af00      	add	r7, sp, #0
	uint8_t iface_num;

	if (udc_num_configuration) {
  401fa2:	4b14      	ldr	r3, [pc, #80]	; (401ff4 <udc_sof_notify+0x58>)
  401fa4:	781b      	ldrb	r3, [r3, #0]
  401fa6:	2b00      	cmp	r3, #0
  401fa8:	d01f      	beq.n	401fea <udc_sof_notify+0x4e>
		for (iface_num = 0;
  401faa:	2300      	movs	r3, #0
  401fac:	71fb      	strb	r3, [r7, #7]
  401fae:	e015      	b.n	401fdc <udc_sof_notify+0x40>
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
				iface_num++) {
			if (udc_ptr_conf->udi_apis[iface_num]->sof_notify != NULL) {
  401fb0:	4b11      	ldr	r3, [pc, #68]	; (401ff8 <udc_sof_notify+0x5c>)
  401fb2:	681b      	ldr	r3, [r3, #0]
  401fb4:	685a      	ldr	r2, [r3, #4]
  401fb6:	79fb      	ldrb	r3, [r7, #7]
  401fb8:	009b      	lsls	r3, r3, #2
  401fba:	4413      	add	r3, r2
  401fbc:	681b      	ldr	r3, [r3, #0]
  401fbe:	691b      	ldr	r3, [r3, #16]
  401fc0:	2b00      	cmp	r3, #0
  401fc2:	d008      	beq.n	401fd6 <udc_sof_notify+0x3a>
				udc_ptr_conf->udi_apis[iface_num]->sof_notify();
  401fc4:	4b0c      	ldr	r3, [pc, #48]	; (401ff8 <udc_sof_notify+0x5c>)
  401fc6:	681b      	ldr	r3, [r3, #0]
  401fc8:	685a      	ldr	r2, [r3, #4]
  401fca:	79fb      	ldrb	r3, [r7, #7]
  401fcc:	009b      	lsls	r3, r3, #2
  401fce:	4413      	add	r3, r2
  401fd0:	681b      	ldr	r3, [r3, #0]
  401fd2:	691b      	ldr	r3, [r3, #16]
  401fd4:	4798      	blx	r3
				iface_num++) {
  401fd6:	79fb      	ldrb	r3, [r7, #7]
  401fd8:	3301      	adds	r3, #1
  401fda:	71fb      	strb	r3, [r7, #7]
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
  401fdc:	4b06      	ldr	r3, [pc, #24]	; (401ff8 <udc_sof_notify+0x5c>)
  401fde:	681b      	ldr	r3, [r3, #0]
  401fe0:	681b      	ldr	r3, [r3, #0]
  401fe2:	791b      	ldrb	r3, [r3, #4]
		for (iface_num = 0;
  401fe4:	79fa      	ldrb	r2, [r7, #7]
  401fe6:	429a      	cmp	r2, r3
  401fe8:	d3e2      	bcc.n	401fb0 <udc_sof_notify+0x14>
			}
		}
	}
}
  401fea:	bf00      	nop
  401fec:	3708      	adds	r7, #8
  401fee:	46bd      	mov	sp, r7
  401ff0:	bd80      	pop	{r7, pc}
  401ff2:	bf00      	nop
  401ff4:	20006bb4 	.word	0x20006bb4
  401ff8:	20006bb8 	.word	0x20006bb8

00401ffc <udc_req_std_dev_get_status>:
 * \brief Standard device request to get device status
 *
 * \return true if success
 */
static bool udc_req_std_dev_get_status(void)
{
  401ffc:	b580      	push	{r7, lr}
  401ffe:	af00      	add	r7, sp, #0
	if (udd_g_ctrlreq.req.wLength != sizeof(udc_device_status)) {
  402000:	4b06      	ldr	r3, [pc, #24]	; (40201c <udc_req_std_dev_get_status+0x20>)
  402002:	88db      	ldrh	r3, [r3, #6]
  402004:	2b02      	cmp	r3, #2
  402006:	d001      	beq.n	40200c <udc_req_std_dev_get_status+0x10>
		return false;
  402008:	2300      	movs	r3, #0
  40200a:	e004      	b.n	402016 <udc_req_std_dev_get_status+0x1a>
	}

	udd_set_setup_payload( (uint8_t *) & udc_device_status,
  40200c:	2102      	movs	r1, #2
  40200e:	4804      	ldr	r0, [pc, #16]	; (402020 <udc_req_std_dev_get_status+0x24>)
  402010:	4b04      	ldr	r3, [pc, #16]	; (402024 <udc_req_std_dev_get_status+0x28>)
  402012:	4798      	blx	r3
			sizeof(udc_device_status));
	return true;
  402014:	2301      	movs	r3, #1
}
  402016:	4618      	mov	r0, r3
  402018:	bd80      	pop	{r7, pc}
  40201a:	bf00      	nop
  40201c:	2000b598 	.word	0x2000b598
  402020:	20006bac 	.word	0x20006bac
  402024:	00404c59 	.word	0x00404c59

00402028 <udc_req_std_ep_get_status>:
 * \brief Standard endpoint request to get endpoint status
 *
 * \return true if success
 */
static bool udc_req_std_ep_get_status(void)
{
  402028:	b580      	push	{r7, lr}
  40202a:	af00      	add	r7, sp, #0
	static le16_t udc_ep_status;

	if (udd_g_ctrlreq.req.wLength != sizeof(udc_ep_status)) {
  40202c:	4b0b      	ldr	r3, [pc, #44]	; (40205c <udc_req_std_ep_get_status+0x34>)
  40202e:	88db      	ldrh	r3, [r3, #6]
  402030:	2b02      	cmp	r3, #2
  402032:	d001      	beq.n	402038 <udc_req_std_ep_get_status+0x10>
		return false;
  402034:	2300      	movs	r3, #0
  402036:	e00e      	b.n	402056 <udc_req_std_ep_get_status+0x2e>
	}

	udc_ep_status = udd_ep_is_halted(udd_g_ctrlreq.req.
  402038:	4b08      	ldr	r3, [pc, #32]	; (40205c <udc_req_std_ep_get_status+0x34>)
  40203a:	889b      	ldrh	r3, [r3, #4]
  40203c:	b2db      	uxtb	r3, r3
  40203e:	4618      	mov	r0, r3
  402040:	4b07      	ldr	r3, [pc, #28]	; (402060 <udc_req_std_ep_get_status+0x38>)
  402042:	4798      	blx	r3
  402044:	4603      	mov	r3, r0
			wIndex & 0xFF) ? CPU_TO_LE16(USB_EP_STATUS_HALTED) : 0;
  402046:	b29a      	uxth	r2, r3
	udc_ep_status = udd_ep_is_halted(udd_g_ctrlreq.req.
  402048:	4b06      	ldr	r3, [pc, #24]	; (402064 <udc_req_std_ep_get_status+0x3c>)
  40204a:	801a      	strh	r2, [r3, #0]

	udd_set_setup_payload( (uint8_t *) & udc_ep_status,
  40204c:	2102      	movs	r1, #2
  40204e:	4805      	ldr	r0, [pc, #20]	; (402064 <udc_req_std_ep_get_status+0x3c>)
  402050:	4b05      	ldr	r3, [pc, #20]	; (402068 <udc_req_std_ep_get_status+0x40>)
  402052:	4798      	blx	r3
			sizeof(udc_ep_status));
	return true;
  402054:	2301      	movs	r3, #1
}
  402056:	4618      	mov	r0, r3
  402058:	bd80      	pop	{r7, pc}
  40205a:	bf00      	nop
  40205c:	2000b598 	.word	0x2000b598
  402060:	00404ee1 	.word	0x00404ee1
  402064:	20006bc0 	.word	0x20006bc0
  402068:	00404c59 	.word	0x00404c59

0040206c <udc_req_std_dev_clear_feature>:
 * \brief Standard device request to change device status
 *
 * \return true if success
 */
static bool udc_req_std_dev_clear_feature(void)
{
  40206c:	b480      	push	{r7}
  40206e:	af00      	add	r7, sp, #0
	if (udd_g_ctrlreq.req.wLength) {
  402070:	4b0c      	ldr	r3, [pc, #48]	; (4020a4 <udc_req_std_dev_clear_feature+0x38>)
  402072:	88db      	ldrh	r3, [r3, #6]
  402074:	2b00      	cmp	r3, #0
  402076:	d001      	beq.n	40207c <udc_req_std_dev_clear_feature+0x10>
		return false;
  402078:	2300      	movs	r3, #0
  40207a:	e00d      	b.n	402098 <udc_req_std_dev_clear_feature+0x2c>
	}

	if (udd_g_ctrlreq.req.wValue == USB_DEV_FEATURE_REMOTE_WAKEUP) {
  40207c:	4b09      	ldr	r3, [pc, #36]	; (4020a4 <udc_req_std_dev_clear_feature+0x38>)
  40207e:	885b      	ldrh	r3, [r3, #2]
  402080:	2b01      	cmp	r3, #1
  402082:	d108      	bne.n	402096 <udc_req_std_dev_clear_feature+0x2a>
		udc_device_status &= CPU_TO_LE16(~(uint32_t)USB_DEV_STATUS_REMOTEWAKEUP);
  402084:	4b08      	ldr	r3, [pc, #32]	; (4020a8 <udc_req_std_dev_clear_feature+0x3c>)
  402086:	881b      	ldrh	r3, [r3, #0]
  402088:	f023 0302 	bic.w	r3, r3, #2
  40208c:	b29a      	uxth	r2, r3
  40208e:	4b06      	ldr	r3, [pc, #24]	; (4020a8 <udc_req_std_dev_clear_feature+0x3c>)
  402090:	801a      	strh	r2, [r3, #0]
#if (USB_CONFIG_ATTR_REMOTE_WAKEUP \
	== (USB_DEVICE_ATTR & USB_CONFIG_ATTR_REMOTE_WAKEUP))
		UDC_REMOTEWAKEUP_DISABLE();
#endif
		return true;
  402092:	2301      	movs	r3, #1
  402094:	e000      	b.n	402098 <udc_req_std_dev_clear_feature+0x2c>
	}
	return false;
  402096:	2300      	movs	r3, #0
}
  402098:	4618      	mov	r0, r3
  40209a:	46bd      	mov	sp, r7
  40209c:	f85d 7b04 	ldr.w	r7, [sp], #4
  4020a0:	4770      	bx	lr
  4020a2:	bf00      	nop
  4020a4:	2000b598 	.word	0x2000b598
  4020a8:	20006bac 	.word	0x20006bac

004020ac <udc_req_std_ep_clear_feature>:
 * \brief Standard endpoint request to clear endpoint feature
 *
 * \return true if success
 */
static bool udc_req_std_ep_clear_feature(void)
{
  4020ac:	b580      	push	{r7, lr}
  4020ae:	af00      	add	r7, sp, #0
	if (udd_g_ctrlreq.req.wLength) {
  4020b0:	4b0a      	ldr	r3, [pc, #40]	; (4020dc <udc_req_std_ep_clear_feature+0x30>)
  4020b2:	88db      	ldrh	r3, [r3, #6]
  4020b4:	2b00      	cmp	r3, #0
  4020b6:	d001      	beq.n	4020bc <udc_req_std_ep_clear_feature+0x10>
		return false;
  4020b8:	2300      	movs	r3, #0
  4020ba:	e00c      	b.n	4020d6 <udc_req_std_ep_clear_feature+0x2a>
	}

	if (udd_g_ctrlreq.req.wValue == USB_EP_FEATURE_HALT) {
  4020bc:	4b07      	ldr	r3, [pc, #28]	; (4020dc <udc_req_std_ep_clear_feature+0x30>)
  4020be:	885b      	ldrh	r3, [r3, #2]
  4020c0:	2b00      	cmp	r3, #0
  4020c2:	d107      	bne.n	4020d4 <udc_req_std_ep_clear_feature+0x28>
		return udd_ep_clear_halt(udd_g_ctrlreq.req.wIndex & 0xFF);
  4020c4:	4b05      	ldr	r3, [pc, #20]	; (4020dc <udc_req_std_ep_clear_feature+0x30>)
  4020c6:	889b      	ldrh	r3, [r3, #4]
  4020c8:	b2db      	uxtb	r3, r3
  4020ca:	4618      	mov	r0, r3
  4020cc:	4b04      	ldr	r3, [pc, #16]	; (4020e0 <udc_req_std_ep_clear_feature+0x34>)
  4020ce:	4798      	blx	r3
  4020d0:	4603      	mov	r3, r0
  4020d2:	e000      	b.n	4020d6 <udc_req_std_ep_clear_feature+0x2a>
	}
	return false;
  4020d4:	2300      	movs	r3, #0
}
  4020d6:	4618      	mov	r0, r3
  4020d8:	bd80      	pop	{r7, pc}
  4020da:	bf00      	nop
  4020dc:	2000b598 	.word	0x2000b598
  4020e0:	00405049 	.word	0x00405049

004020e4 <udc_req_std_dev_set_feature>:
 * \brief Standard device request to set a feature
 *
 * \return true if success
 */
static bool udc_req_std_dev_set_feature(void)
{
  4020e4:	b480      	push	{r7}
  4020e6:	af00      	add	r7, sp, #0
	if (udd_g_ctrlreq.req.wLength) {
  4020e8:	4b09      	ldr	r3, [pc, #36]	; (402110 <udc_req_std_dev_set_feature+0x2c>)
  4020ea:	88db      	ldrh	r3, [r3, #6]
  4020ec:	2b00      	cmp	r3, #0
  4020ee:	d001      	beq.n	4020f4 <udc_req_std_dev_set_feature+0x10>
		return false;
  4020f0:	2300      	movs	r3, #0
  4020f2:	e007      	b.n	402104 <udc_req_std_dev_set_feature+0x20>
	}

	switch (udd_g_ctrlreq.req.wValue) {
  4020f4:	4b06      	ldr	r3, [pc, #24]	; (402110 <udc_req_std_dev_set_feature+0x2c>)
  4020f6:	885b      	ldrh	r3, [r3, #2]
  4020f8:	2b01      	cmp	r3, #1
  4020fa:	d002      	beq.n	402102 <udc_req_std_dev_set_feature+0x1e>
			break;
		}
		break;
#endif
	default:
		break;
  4020fc:	bf00      	nop
	}
	return false;
  4020fe:	2300      	movs	r3, #0
  402100:	e000      	b.n	402104 <udc_req_std_dev_set_feature+0x20>
		return false;
  402102:	2300      	movs	r3, #0
}
  402104:	4618      	mov	r0, r3
  402106:	46bd      	mov	sp, r7
  402108:	f85d 7b04 	ldr.w	r7, [sp], #4
  40210c:	4770      	bx	lr
  40210e:	bf00      	nop
  402110:	2000b598 	.word	0x2000b598

00402114 <udc_req_std_ep_set_feature>:
 *
 * \return true if success
 */
#if (0!=USB_DEVICE_MAX_EP)
static bool udc_req_std_ep_set_feature(void)
{
  402114:	b580      	push	{r7, lr}
  402116:	af00      	add	r7, sp, #0
	if (udd_g_ctrlreq.req.wLength) {
  402118:	4b0d      	ldr	r3, [pc, #52]	; (402150 <udc_req_std_ep_set_feature+0x3c>)
  40211a:	88db      	ldrh	r3, [r3, #6]
  40211c:	2b00      	cmp	r3, #0
  40211e:	d001      	beq.n	402124 <udc_req_std_ep_set_feature+0x10>
		return false;
  402120:	2300      	movs	r3, #0
  402122:	e012      	b.n	40214a <udc_req_std_ep_set_feature+0x36>
	}
	if (udd_g_ctrlreq.req.wValue == USB_EP_FEATURE_HALT) {
  402124:	4b0a      	ldr	r3, [pc, #40]	; (402150 <udc_req_std_ep_set_feature+0x3c>)
  402126:	885b      	ldrh	r3, [r3, #2]
  402128:	2b00      	cmp	r3, #0
  40212a:	d10d      	bne.n	402148 <udc_req_std_ep_set_feature+0x34>
		udd_ep_abort(udd_g_ctrlreq.req.wIndex & 0xFF);
  40212c:	4b08      	ldr	r3, [pc, #32]	; (402150 <udc_req_std_ep_set_feature+0x3c>)
  40212e:	889b      	ldrh	r3, [r3, #4]
  402130:	b2db      	uxtb	r3, r3
  402132:	4618      	mov	r0, r3
  402134:	4b07      	ldr	r3, [pc, #28]	; (402154 <udc_req_std_ep_set_feature+0x40>)
  402136:	4798      	blx	r3
		return udd_ep_set_halt(udd_g_ctrlreq.req.wIndex & 0xFF);
  402138:	4b05      	ldr	r3, [pc, #20]	; (402150 <udc_req_std_ep_set_feature+0x3c>)
  40213a:	889b      	ldrh	r3, [r3, #4]
  40213c:	b2db      	uxtb	r3, r3
  40213e:	4618      	mov	r0, r3
  402140:	4b05      	ldr	r3, [pc, #20]	; (402158 <udc_req_std_ep_set_feature+0x44>)
  402142:	4798      	blx	r3
  402144:	4603      	mov	r3, r0
  402146:	e000      	b.n	40214a <udc_req_std_ep_set_feature+0x36>
	}
	return false;
  402148:	2300      	movs	r3, #0
}
  40214a:	4618      	mov	r0, r3
  40214c:	bd80      	pop	{r7, pc}
  40214e:	bf00      	nop
  402150:	2000b598 	.word	0x2000b598
  402154:	004052cd 	.word	0x004052cd
  402158:	00404f55 	.word	0x00404f55

0040215c <udc_valid_address>:
/**
 * \brief Change the address of device
 * Callback called at the end of request set address
 */
static void udc_valid_address(void)
{
  40215c:	b580      	push	{r7, lr}
  40215e:	af00      	add	r7, sp, #0
	udd_set_address(udd_g_ctrlreq.req.wValue & 0x7F);
  402160:	4b05      	ldr	r3, [pc, #20]	; (402178 <udc_valid_address+0x1c>)
  402162:	885b      	ldrh	r3, [r3, #2]
  402164:	b2db      	uxtb	r3, r3
  402166:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  40216a:	b2db      	uxtb	r3, r3
  40216c:	4618      	mov	r0, r3
  40216e:	4b03      	ldr	r3, [pc, #12]	; (40217c <udc_valid_address+0x20>)
  402170:	4798      	blx	r3
}
  402172:	bf00      	nop
  402174:	bd80      	pop	{r7, pc}
  402176:	bf00      	nop
  402178:	2000b598 	.word	0x2000b598
  40217c:	00404ba5 	.word	0x00404ba5

00402180 <udc_req_std_dev_set_address>:
 * \brief Standard device request to set device address
 *
 * \return true if success
 */
static bool udc_req_std_dev_set_address(void)
{
  402180:	b480      	push	{r7}
  402182:	af00      	add	r7, sp, #0
	if (udd_g_ctrlreq.req.wLength) {
  402184:	4b07      	ldr	r3, [pc, #28]	; (4021a4 <udc_req_std_dev_set_address+0x24>)
  402186:	88db      	ldrh	r3, [r3, #6]
  402188:	2b00      	cmp	r3, #0
  40218a:	d001      	beq.n	402190 <udc_req_std_dev_set_address+0x10>
		return false;
  40218c:	2300      	movs	r3, #0
  40218e:	e003      	b.n	402198 <udc_req_std_dev_set_address+0x18>
	}

	// The address must be changed at the end of setup request after the handshake
	// then we use a callback to change address
	udd_g_ctrlreq.callback = udc_valid_address;
  402190:	4b04      	ldr	r3, [pc, #16]	; (4021a4 <udc_req_std_dev_set_address+0x24>)
  402192:	4a05      	ldr	r2, [pc, #20]	; (4021a8 <udc_req_std_dev_set_address+0x28>)
  402194:	611a      	str	r2, [r3, #16]
	return true;
  402196:	2301      	movs	r3, #1
}
  402198:	4618      	mov	r0, r3
  40219a:	46bd      	mov	sp, r7
  40219c:	f85d 7b04 	ldr.w	r7, [sp], #4
  4021a0:	4770      	bx	lr
  4021a2:	bf00      	nop
  4021a4:	2000b598 	.word	0x2000b598
  4021a8:	0040215d 	.word	0x0040215d

004021ac <udc_req_std_dev_get_str_desc>:
 * \brief Standard device request to get device string descriptor
 *
 * \return true if success
 */
static bool udc_req_std_dev_get_str_desc(void)
{
  4021ac:	b580      	push	{r7, lr}
  4021ae:	b084      	sub	sp, #16
  4021b0:	af00      	add	r7, sp, #0
	uint8_t i;
	const uint8_t *str;
	uint8_t str_length = 0;
  4021b2:	2300      	movs	r3, #0
  4021b4:	71fb      	strb	r3, [r7, #7]

	// Link payload pointer to the string corresponding at request
	switch (udd_g_ctrlreq.req.wValue & 0xff) {
  4021b6:	4b29      	ldr	r3, [pc, #164]	; (40225c <udc_req_std_dev_get_str_desc+0xb0>)
  4021b8:	885b      	ldrh	r3, [r3, #2]
  4021ba:	b2db      	uxtb	r3, r3
  4021bc:	2b03      	cmp	r3, #3
  4021be:	d820      	bhi.n	402202 <udc_req_std_dev_get_str_desc+0x56>
  4021c0:	a201      	add	r2, pc, #4	; (adr r2, 4021c8 <udc_req_std_dev_get_str_desc+0x1c>)
  4021c2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  4021c6:	bf00      	nop
  4021c8:	004021d9 	.word	0x004021d9
  4021cc:	004021e3 	.word	0x004021e3
  4021d0:	004021ed 	.word	0x004021ed
  4021d4:	004021f7 	.word	0x004021f7
	case 0:
		udd_set_setup_payload((uint8_t *) &udc_string_desc_languageid,
  4021d8:	2104      	movs	r1, #4
  4021da:	4821      	ldr	r0, [pc, #132]	; (402260 <udc_req_std_dev_get_str_desc+0xb4>)
  4021dc:	4b21      	ldr	r3, [pc, #132]	; (402264 <udc_req_std_dev_get_str_desc+0xb8>)
  4021de:	4798      	blx	r3
				sizeof(udc_string_desc_languageid));
		break;
  4021e0:	e011      	b.n	402206 <udc_req_std_dev_get_str_desc+0x5a>

#ifdef USB_DEVICE_MANUFACTURE_NAME
	case 1:
		str_length = USB_DEVICE_MANUFACTURE_NAME_SIZE;
  4021e2:	2309      	movs	r3, #9
  4021e4:	71fb      	strb	r3, [r7, #7]
		str = udc_string_manufacturer_name;
  4021e6:	4b20      	ldr	r3, [pc, #128]	; (402268 <udc_req_std_dev_get_str_desc+0xbc>)
  4021e8:	60bb      	str	r3, [r7, #8]
		break;
  4021ea:	e00c      	b.n	402206 <udc_req_std_dev_get_str_desc+0x5a>
#endif
#ifdef USB_DEVICE_PRODUCT_NAME
	case 2:
		str_length = USB_DEVICE_PRODUCT_NAME_SIZE;
  4021ec:	2303      	movs	r3, #3
  4021ee:	71fb      	strb	r3, [r7, #7]
		str = udc_string_product_name;
  4021f0:	4b1e      	ldr	r3, [pc, #120]	; (40226c <udc_req_std_dev_get_str_desc+0xc0>)
  4021f2:	60bb      	str	r3, [r7, #8]
		break;
  4021f4:	e007      	b.n	402206 <udc_req_std_dev_get_str_desc+0x5a>
#endif
#if defined USB_DEVICE_SERIAL_NAME || defined USB_DEVICE_GET_SERIAL_NAME_POINTER
	case 3:
		str_length = USB_DEVICE_SERIAL_NAME_SIZE;
  4021f6:	230c      	movs	r3, #12
  4021f8:	71fb      	strb	r3, [r7, #7]
		str = udc_get_string_serial_name();
  4021fa:	4b1d      	ldr	r3, [pc, #116]	; (402270 <udc_req_std_dev_get_str_desc+0xc4>)
  4021fc:	4798      	blx	r3
  4021fe:	60b8      	str	r0, [r7, #8]
		break;
  402200:	e001      	b.n	402206 <udc_req_std_dev_get_str_desc+0x5a>
#ifdef UDC_GET_EXTRA_STRING
		if (UDC_GET_EXTRA_STRING()) {
			break;
		}
#endif
		return false;
  402202:	2300      	movs	r3, #0
  402204:	e026      	b.n	402254 <udc_req_std_dev_get_str_desc+0xa8>
	}

	if (str_length) {
  402206:	79fb      	ldrb	r3, [r7, #7]
  402208:	2b00      	cmp	r3, #0
  40220a:	d022      	beq.n	402252 <udc_req_std_dev_get_str_desc+0xa6>
		for(i = 0; i < str_length; i++) {
  40220c:	2300      	movs	r3, #0
  40220e:	73fb      	strb	r3, [r7, #15]
  402210:	e00d      	b.n	40222e <udc_req_std_dev_get_str_desc+0x82>
			udc_string_desc.string[i] = cpu_to_le16((le16_t)str[i]);
  402212:	7bfb      	ldrb	r3, [r7, #15]
  402214:	7bfa      	ldrb	r2, [r7, #15]
  402216:	68b9      	ldr	r1, [r7, #8]
  402218:	440a      	add	r2, r1
  40221a:	7812      	ldrb	r2, [r2, #0]
  40221c:	b291      	uxth	r1, r2
  40221e:	4a15      	ldr	r2, [pc, #84]	; (402274 <udc_req_std_dev_get_str_desc+0xc8>)
  402220:	005b      	lsls	r3, r3, #1
  402222:	4413      	add	r3, r2
  402224:	460a      	mov	r2, r1
  402226:	805a      	strh	r2, [r3, #2]
		for(i = 0; i < str_length; i++) {
  402228:	7bfb      	ldrb	r3, [r7, #15]
  40222a:	3301      	adds	r3, #1
  40222c:	73fb      	strb	r3, [r7, #15]
  40222e:	7bfa      	ldrb	r2, [r7, #15]
  402230:	79fb      	ldrb	r3, [r7, #7]
  402232:	429a      	cmp	r2, r3
  402234:	d3ed      	bcc.n	402212 <udc_req_std_dev_get_str_desc+0x66>
		}

		udc_string_desc.header.bLength = 2 + (str_length) * 2;
  402236:	79fb      	ldrb	r3, [r7, #7]
  402238:	3301      	adds	r3, #1
  40223a:	b2db      	uxtb	r3, r3
  40223c:	005b      	lsls	r3, r3, #1
  40223e:	b2da      	uxtb	r2, r3
  402240:	4b0c      	ldr	r3, [pc, #48]	; (402274 <udc_req_std_dev_get_str_desc+0xc8>)
  402242:	701a      	strb	r2, [r3, #0]
		udd_set_setup_payload(
			(uint8_t *) &udc_string_desc,
			udc_string_desc.header.bLength);
  402244:	4b0b      	ldr	r3, [pc, #44]	; (402274 <udc_req_std_dev_get_str_desc+0xc8>)
  402246:	781b      	ldrb	r3, [r3, #0]
		udd_set_setup_payload(
  402248:	b29b      	uxth	r3, r3
  40224a:	4619      	mov	r1, r3
  40224c:	4809      	ldr	r0, [pc, #36]	; (402274 <udc_req_std_dev_get_str_desc+0xc8>)
  40224e:	4b05      	ldr	r3, [pc, #20]	; (402264 <udc_req_std_dev_get_str_desc+0xb8>)
  402250:	4798      	blx	r3
	}

	return true;
  402252:	2301      	movs	r3, #1
}
  402254:	4618      	mov	r0, r3
  402256:	3710      	adds	r7, #16
  402258:	46bd      	mov	sp, r7
  40225a:	bd80      	pop	{r7, pc}
  40225c:	2000b598 	.word	0x2000b598
  402260:	20000094 	.word	0x20000094
  402264:	00404c59 	.word	0x00404c59
  402268:	20000098 	.word	0x20000098
  40226c:	200000a4 	.word	0x200000a4
  402270:	00401ce1 	.word	0x00401ce1
  402274:	200000a8 	.word	0x200000a8

00402278 <udc_req_std_dev_get_descriptor>:
 * \brief Standard device request to get descriptors about USB device
 *
 * \return true if success
 */
static bool udc_req_std_dev_get_descriptor(void)
{
  402278:	b580      	push	{r7, lr}
  40227a:	b082      	sub	sp, #8
  40227c:	af00      	add	r7, sp, #0
	uint8_t conf_num;

	conf_num = udd_g_ctrlreq.req.wValue & 0xff;
  40227e:	4b41      	ldr	r3, [pc, #260]	; (402384 <udc_req_std_dev_get_descriptor+0x10c>)
  402280:	885b      	ldrh	r3, [r3, #2]
  402282:	71fb      	strb	r3, [r7, #7]

	// Check descriptor ID
	switch ((uint8_t) (udd_g_ctrlreq.req.wValue >> 8)) {
  402284:	4b3f      	ldr	r3, [pc, #252]	; (402384 <udc_req_std_dev_get_descriptor+0x10c>)
  402286:	885b      	ldrh	r3, [r3, #2]
  402288:	0a1b      	lsrs	r3, r3, #8
  40228a:	b29b      	uxth	r3, r3
  40228c:	b2db      	uxtb	r3, r3
  40228e:	3b01      	subs	r3, #1
  402290:	2b0e      	cmp	r3, #14
  402292:	d865      	bhi.n	402360 <udc_req_std_dev_get_descriptor+0xe8>
  402294:	a201      	add	r2, pc, #4	; (adr r2, 40229c <udc_req_std_dev_get_descriptor+0x24>)
  402296:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40229a:	bf00      	nop
  40229c:	004022d9 	.word	0x004022d9
  4022a0:	004022ef 	.word	0x004022ef
  4022a4:	0040234d 	.word	0x0040234d
  4022a8:	00402361 	.word	0x00402361
  4022ac:	00402361 	.word	0x00402361
  4022b0:	00402361 	.word	0x00402361
  4022b4:	00402361 	.word	0x00402361
  4022b8:	00402361 	.word	0x00402361
  4022bc:	00402361 	.word	0x00402361
  4022c0:	00402361 	.word	0x00402361
  4022c4:	00402361 	.word	0x00402361
  4022c8:	00402361 	.word	0x00402361
  4022cc:	00402361 	.word	0x00402361
  4022d0:	00402361 	.word	0x00402361
  4022d4:	0040232b 	.word	0x0040232b
				udc_config.confdev_hs->bLength);
		} else
#endif
		{
			udd_set_setup_payload(
				(uint8_t *) udc_config.confdev_lsfs,
  4022d8:	4b2b      	ldr	r3, [pc, #172]	; (402388 <udc_req_std_dev_get_descriptor+0x110>)
  4022da:	681a      	ldr	r2, [r3, #0]
				udc_config.confdev_lsfs->bLength);
  4022dc:	4b2a      	ldr	r3, [pc, #168]	; (402388 <udc_req_std_dev_get_descriptor+0x110>)
  4022de:	681b      	ldr	r3, [r3, #0]
  4022e0:	781b      	ldrb	r3, [r3, #0]
			udd_set_setup_payload(
  4022e2:	b29b      	uxth	r3, r3
  4022e4:	4619      	mov	r1, r3
  4022e6:	4610      	mov	r0, r2
  4022e8:	4b28      	ldr	r3, [pc, #160]	; (40238c <udc_req_std_dev_get_descriptor+0x114>)
  4022ea:	4798      	blx	r3
		}
		break;
  4022ec:	e03b      	b.n	402366 <udc_req_std_dev_get_descriptor+0xee>
				le16_to_cpu(udc_config.conf_hs[conf_num].desc->wTotalLength));
		} else
#endif
		{
			// FS descriptor
			if (conf_num >= udc_config.confdev_lsfs->
  4022ee:	4b26      	ldr	r3, [pc, #152]	; (402388 <udc_req_std_dev_get_descriptor+0x110>)
  4022f0:	681b      	ldr	r3, [r3, #0]
  4022f2:	7c5b      	ldrb	r3, [r3, #17]
  4022f4:	79fa      	ldrb	r2, [r7, #7]
  4022f6:	429a      	cmp	r2, r3
  4022f8:	d301      	bcc.n	4022fe <udc_req_std_dev_get_descriptor+0x86>
					bNumConfigurations) {
				return false;
  4022fa:	2300      	movs	r3, #0
  4022fc:	e03e      	b.n	40237c <udc_req_std_dev_get_descriptor+0x104>
			}
			udd_set_setup_payload(
				(uint8_t *)udc_config.conf_lsfs[conf_num].desc,
  4022fe:	4b22      	ldr	r3, [pc, #136]	; (402388 <udc_req_std_dev_get_descriptor+0x110>)
  402300:	685a      	ldr	r2, [r3, #4]
  402302:	79fb      	ldrb	r3, [r7, #7]
  402304:	00db      	lsls	r3, r3, #3
  402306:	4413      	add	r3, r2
  402308:	6818      	ldr	r0, [r3, #0]
				le16_to_cpu(udc_config.conf_lsfs[conf_num].desc->wTotalLength));
  40230a:	4b1f      	ldr	r3, [pc, #124]	; (402388 <udc_req_std_dev_get_descriptor+0x110>)
  40230c:	685a      	ldr	r2, [r3, #4]
  40230e:	79fb      	ldrb	r3, [r7, #7]
  402310:	00db      	lsls	r3, r3, #3
  402312:	4413      	add	r3, r2
  402314:	681b      	ldr	r3, [r3, #0]
			udd_set_setup_payload(
  402316:	885b      	ldrh	r3, [r3, #2]
  402318:	b29b      	uxth	r3, r3
  40231a:	4619      	mov	r1, r3
  40231c:	4b1b      	ldr	r3, [pc, #108]	; (40238c <udc_req_std_dev_get_descriptor+0x114>)
  40231e:	4798      	blx	r3
		}
		((usb_conf_desc_t *) udd_g_ctrlreq.payload)->bDescriptorType =
  402320:	4b18      	ldr	r3, [pc, #96]	; (402384 <udc_req_std_dev_get_descriptor+0x10c>)
  402322:	689b      	ldr	r3, [r3, #8]
  402324:	2202      	movs	r2, #2
  402326:	705a      	strb	r2, [r3, #1]
				USB_DT_CONFIGURATION;
		break;
  402328:	e01d      	b.n	402366 <udc_req_std_dev_get_descriptor+0xee>
		break;
#endif

	case USB_DT_BOS:
		// Device BOS descriptor requested
		if (udc_config.conf_bos == NULL) {
  40232a:	4b17      	ldr	r3, [pc, #92]	; (402388 <udc_req_std_dev_get_descriptor+0x110>)
  40232c:	689b      	ldr	r3, [r3, #8]
  40232e:	2b00      	cmp	r3, #0
  402330:	d101      	bne.n	402336 <udc_req_std_dev_get_descriptor+0xbe>
			return false;
  402332:	2300      	movs	r3, #0
  402334:	e022      	b.n	40237c <udc_req_std_dev_get_descriptor+0x104>
		}
		udd_set_setup_payload( (uint8_t *) udc_config.conf_bos,
  402336:	4b14      	ldr	r3, [pc, #80]	; (402388 <udc_req_std_dev_get_descriptor+0x110>)
  402338:	689a      	ldr	r2, [r3, #8]
				udc_config.conf_bos->wTotalLength);
  40233a:	4b13      	ldr	r3, [pc, #76]	; (402388 <udc_req_std_dev_get_descriptor+0x110>)
  40233c:	689b      	ldr	r3, [r3, #8]
		udd_set_setup_payload( (uint8_t *) udc_config.conf_bos,
  40233e:	885b      	ldrh	r3, [r3, #2]
  402340:	b29b      	uxth	r3, r3
  402342:	4619      	mov	r1, r3
  402344:	4610      	mov	r0, r2
  402346:	4b11      	ldr	r3, [pc, #68]	; (40238c <udc_req_std_dev_get_descriptor+0x114>)
  402348:	4798      	blx	r3
		break;
  40234a:	e00c      	b.n	402366 <udc_req_std_dev_get_descriptor+0xee>

	case USB_DT_STRING:
		// String descriptor requested
		if (!udc_req_std_dev_get_str_desc()) {
  40234c:	4b10      	ldr	r3, [pc, #64]	; (402390 <udc_req_std_dev_get_descriptor+0x118>)
  40234e:	4798      	blx	r3
  402350:	4603      	mov	r3, r0
  402352:	f083 0301 	eor.w	r3, r3, #1
  402356:	b2db      	uxtb	r3, r3
  402358:	2b00      	cmp	r3, #0
  40235a:	d003      	beq.n	402364 <udc_req_std_dev_get_descriptor+0xec>
			return false;
  40235c:	2300      	movs	r3, #0
  40235e:	e00d      	b.n	40237c <udc_req_std_dev_get_descriptor+0x104>
		}
		break;

	default:
		// Unknown descriptor requested
		return false;
  402360:	2300      	movs	r3, #0
  402362:	e00b      	b.n	40237c <udc_req_std_dev_get_descriptor+0x104>
		break;
  402364:	bf00      	nop
	}
	// if the descriptor is larger than length requested, then reduce it
	if (udd_g_ctrlreq.req.wLength < udd_g_ctrlreq.payload_size) {
  402366:	4b07      	ldr	r3, [pc, #28]	; (402384 <udc_req_std_dev_get_descriptor+0x10c>)
  402368:	88da      	ldrh	r2, [r3, #6]
  40236a:	4b06      	ldr	r3, [pc, #24]	; (402384 <udc_req_std_dev_get_descriptor+0x10c>)
  40236c:	899b      	ldrh	r3, [r3, #12]
  40236e:	429a      	cmp	r2, r3
  402370:	d203      	bcs.n	40237a <udc_req_std_dev_get_descriptor+0x102>
		udd_g_ctrlreq.payload_size = udd_g_ctrlreq.req.wLength;
  402372:	4b04      	ldr	r3, [pc, #16]	; (402384 <udc_req_std_dev_get_descriptor+0x10c>)
  402374:	88da      	ldrh	r2, [r3, #6]
  402376:	4b03      	ldr	r3, [pc, #12]	; (402384 <udc_req_std_dev_get_descriptor+0x10c>)
  402378:	819a      	strh	r2, [r3, #12]
	}
	return true;
  40237a:	2301      	movs	r3, #1
}
  40237c:	4618      	mov	r0, r3
  40237e:	3708      	adds	r7, #8
  402380:	46bd      	mov	sp, r7
  402382:	bd80      	pop	{r7, pc}
  402384:	2000b598 	.word	0x2000b598
  402388:	20000088 	.word	0x20000088
  40238c:	00404c59 	.word	0x00404c59
  402390:	004021ad 	.word	0x004021ad

00402394 <udc_req_std_dev_get_configuration>:
 * \brief Standard device request to get configuration number
 *
 * \return true if success
 */
static bool udc_req_std_dev_get_configuration(void)
{
  402394:	b580      	push	{r7, lr}
  402396:	af00      	add	r7, sp, #0
	if (udd_g_ctrlreq.req.wLength != 1) {
  402398:	4b06      	ldr	r3, [pc, #24]	; (4023b4 <udc_req_std_dev_get_configuration+0x20>)
  40239a:	88db      	ldrh	r3, [r3, #6]
  40239c:	2b01      	cmp	r3, #1
  40239e:	d001      	beq.n	4023a4 <udc_req_std_dev_get_configuration+0x10>
		return false;
  4023a0:	2300      	movs	r3, #0
  4023a2:	e004      	b.n	4023ae <udc_req_std_dev_get_configuration+0x1a>
	}

	udd_set_setup_payload(&udc_num_configuration,1);
  4023a4:	2101      	movs	r1, #1
  4023a6:	4804      	ldr	r0, [pc, #16]	; (4023b8 <udc_req_std_dev_get_configuration+0x24>)
  4023a8:	4b04      	ldr	r3, [pc, #16]	; (4023bc <udc_req_std_dev_get_configuration+0x28>)
  4023aa:	4798      	blx	r3
	return true;
  4023ac:	2301      	movs	r3, #1
}
  4023ae:	4618      	mov	r0, r3
  4023b0:	bd80      	pop	{r7, pc}
  4023b2:	bf00      	nop
  4023b4:	2000b598 	.word	0x2000b598
  4023b8:	20006bb4 	.word	0x20006bb4
  4023bc:	00404c59 	.word	0x00404c59

004023c0 <udc_req_std_dev_set_configuration>:
 * \brief Standard device request to enable a configuration
 *
 * \return true if success
 */
static bool udc_req_std_dev_set_configuration(void)
{
  4023c0:	b580      	push	{r7, lr}
  4023c2:	b082      	sub	sp, #8
  4023c4:	af00      	add	r7, sp, #0
	uint8_t iface_num;

	// Check request length
	if (udd_g_ctrlreq.req.wLength) {
  4023c6:	4b27      	ldr	r3, [pc, #156]	; (402464 <udc_req_std_dev_set_configuration+0xa4>)
  4023c8:	88db      	ldrh	r3, [r3, #6]
  4023ca:	2b00      	cmp	r3, #0
  4023cc:	d001      	beq.n	4023d2 <udc_req_std_dev_set_configuration+0x12>
		return false;
  4023ce:	2300      	movs	r3, #0
  4023d0:	e043      	b.n	40245a <udc_req_std_dev_set_configuration+0x9a>
	}
	// Authorize configuration only if the address is valid
	if (!udd_getaddress()) {
  4023d2:	4b25      	ldr	r3, [pc, #148]	; (402468 <udc_req_std_dev_set_configuration+0xa8>)
  4023d4:	4798      	blx	r3
  4023d6:	4603      	mov	r3, r0
  4023d8:	2b00      	cmp	r3, #0
  4023da:	d101      	bne.n	4023e0 <udc_req_std_dev_set_configuration+0x20>
		return false;
  4023dc:	2300      	movs	r3, #0
  4023de:	e03c      	b.n	40245a <udc_req_std_dev_set_configuration+0x9a>
		}
	} else
#endif
	{
		// FS descriptor
		if ((udd_g_ctrlreq.req.wValue & 0xFF) >
  4023e0:	4b20      	ldr	r3, [pc, #128]	; (402464 <udc_req_std_dev_set_configuration+0xa4>)
  4023e2:	885b      	ldrh	r3, [r3, #2]
  4023e4:	b2db      	uxtb	r3, r3
				udc_config.confdev_lsfs->bNumConfigurations) {
  4023e6:	4a21      	ldr	r2, [pc, #132]	; (40246c <udc_req_std_dev_set_configuration+0xac>)
  4023e8:	6812      	ldr	r2, [r2, #0]
  4023ea:	7c52      	ldrb	r2, [r2, #17]
		if ((udd_g_ctrlreq.req.wValue & 0xFF) >
  4023ec:	4293      	cmp	r3, r2
  4023ee:	dd01      	ble.n	4023f4 <udc_req_std_dev_set_configuration+0x34>
			return false;
  4023f0:	2300      	movs	r3, #0
  4023f2:	e032      	b.n	40245a <udc_req_std_dev_set_configuration+0x9a>
		}
	}

	// Reset current configuration
	udc_reset();
  4023f4:	4b1e      	ldr	r3, [pc, #120]	; (402470 <udc_req_std_dev_set_configuration+0xb0>)
  4023f6:	4798      	blx	r3

	// Enable new configuration
	udc_num_configuration = udd_g_ctrlreq.req.wValue & 0xFF;
  4023f8:	4b1a      	ldr	r3, [pc, #104]	; (402464 <udc_req_std_dev_set_configuration+0xa4>)
  4023fa:	885b      	ldrh	r3, [r3, #2]
  4023fc:	b2da      	uxtb	r2, r3
  4023fe:	4b1d      	ldr	r3, [pc, #116]	; (402474 <udc_req_std_dev_set_configuration+0xb4>)
  402400:	701a      	strb	r2, [r3, #0]
	if (udc_num_configuration == 0) {
  402402:	4b1c      	ldr	r3, [pc, #112]	; (402474 <udc_req_std_dev_set_configuration+0xb4>)
  402404:	781b      	ldrb	r3, [r3, #0]
  402406:	2b00      	cmp	r3, #0
  402408:	d101      	bne.n	40240e <udc_req_std_dev_set_configuration+0x4e>
		return true; // Default empty configuration requested
  40240a:	2301      	movs	r3, #1
  40240c:	e025      	b.n	40245a <udc_req_std_dev_set_configuration+0x9a>
		udc_ptr_conf = &udc_config.conf_hs[udc_num_configuration - 1];
	} else
#endif
	{
		// FS descriptor
		udc_ptr_conf = &udc_config.conf_lsfs[udc_num_configuration - 1];
  40240e:	4b17      	ldr	r3, [pc, #92]	; (40246c <udc_req_std_dev_set_configuration+0xac>)
  402410:	685a      	ldr	r2, [r3, #4]
  402412:	4b18      	ldr	r3, [pc, #96]	; (402474 <udc_req_std_dev_set_configuration+0xb4>)
  402414:	781b      	ldrb	r3, [r3, #0]
  402416:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
  40241a:	3b01      	subs	r3, #1
  40241c:	00db      	lsls	r3, r3, #3
  40241e:	4413      	add	r3, r2
  402420:	4a15      	ldr	r2, [pc, #84]	; (402478 <udc_req_std_dev_set_configuration+0xb8>)
  402422:	6013      	str	r3, [r2, #0]
	}
	// Enable all interfaces of the selected configuration
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
  402424:	2300      	movs	r3, #0
  402426:	71fb      	strb	r3, [r7, #7]
  402428:	e00f      	b.n	40244a <udc_req_std_dev_set_configuration+0x8a>
			iface_num++) {
		if (!udc_iface_enable(iface_num, 0)) {
  40242a:	79fb      	ldrb	r3, [r7, #7]
  40242c:	2100      	movs	r1, #0
  40242e:	4618      	mov	r0, r3
  402430:	4b12      	ldr	r3, [pc, #72]	; (40247c <udc_req_std_dev_set_configuration+0xbc>)
  402432:	4798      	blx	r3
  402434:	4603      	mov	r3, r0
  402436:	f083 0301 	eor.w	r3, r3, #1
  40243a:	b2db      	uxtb	r3, r3
  40243c:	2b00      	cmp	r3, #0
  40243e:	d001      	beq.n	402444 <udc_req_std_dev_set_configuration+0x84>
			return false;
  402440:	2300      	movs	r3, #0
  402442:	e00a      	b.n	40245a <udc_req_std_dev_set_configuration+0x9a>
			iface_num++) {
  402444:	79fb      	ldrb	r3, [r7, #7]
  402446:	3301      	adds	r3, #1
  402448:	71fb      	strb	r3, [r7, #7]
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
  40244a:	4b0b      	ldr	r3, [pc, #44]	; (402478 <udc_req_std_dev_set_configuration+0xb8>)
  40244c:	681b      	ldr	r3, [r3, #0]
  40244e:	681b      	ldr	r3, [r3, #0]
  402450:	791b      	ldrb	r3, [r3, #4]
  402452:	79fa      	ldrb	r2, [r7, #7]
  402454:	429a      	cmp	r2, r3
  402456:	d3e8      	bcc.n	40242a <udc_req_std_dev_set_configuration+0x6a>
		}
	}
	return true;
  402458:	2301      	movs	r3, #1
}
  40245a:	4618      	mov	r0, r3
  40245c:	3708      	adds	r7, #8
  40245e:	46bd      	mov	sp, r7
  402460:	bd80      	pop	{r7, pc}
  402462:	bf00      	nop
  402464:	2000b598 	.word	0x2000b598
  402468:	00404c09 	.word	0x00404c09
  40246c:	20000088 	.word	0x20000088
  402470:	00401f49 	.word	0x00401f49
  402474:	20006bb4 	.word	0x20006bb4
  402478:	20006bb8 	.word	0x20006bb8
  40247c:	00401eb1 	.word	0x00401eb1

00402480 <udc_req_std_iface_get_setting>:
 * to get the alternate setting number of an interface
 *
 * \return true if success
 */
static bool udc_req_std_iface_get_setting(void)
{
  402480:	b580      	push	{r7, lr}
  402482:	b082      	sub	sp, #8
  402484:	af00      	add	r7, sp, #0
	uint8_t iface_num;
	udi_api_t UDC_DESC_STORAGE *udi_api;

	if (udd_g_ctrlreq.req.wLength != 1) {
  402486:	4b1e      	ldr	r3, [pc, #120]	; (402500 <udc_req_std_iface_get_setting+0x80>)
  402488:	88db      	ldrh	r3, [r3, #6]
  40248a:	2b01      	cmp	r3, #1
  40248c:	d001      	beq.n	402492 <udc_req_std_iface_get_setting+0x12>
		return false; // Error in request
  40248e:	2300      	movs	r3, #0
  402490:	e032      	b.n	4024f8 <udc_req_std_iface_get_setting+0x78>
	}
	if (!udc_num_configuration) {
  402492:	4b1c      	ldr	r3, [pc, #112]	; (402504 <udc_req_std_iface_get_setting+0x84>)
  402494:	781b      	ldrb	r3, [r3, #0]
  402496:	2b00      	cmp	r3, #0
  402498:	d101      	bne.n	40249e <udc_req_std_iface_get_setting+0x1e>
		return false; // The device is not is configured state yet
  40249a:	2300      	movs	r3, #0
  40249c:	e02c      	b.n	4024f8 <udc_req_std_iface_get_setting+0x78>
	}

	// Check the interface number included in the request
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
  40249e:	4b18      	ldr	r3, [pc, #96]	; (402500 <udc_req_std_iface_get_setting+0x80>)
  4024a0:	889b      	ldrh	r3, [r3, #4]
  4024a2:	71fb      	strb	r3, [r7, #7]
	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {
  4024a4:	4b18      	ldr	r3, [pc, #96]	; (402508 <udc_req_std_iface_get_setting+0x88>)
  4024a6:	681b      	ldr	r3, [r3, #0]
  4024a8:	681b      	ldr	r3, [r3, #0]
  4024aa:	791b      	ldrb	r3, [r3, #4]
  4024ac:	79fa      	ldrb	r2, [r7, #7]
  4024ae:	429a      	cmp	r2, r3
  4024b0:	d301      	bcc.n	4024b6 <udc_req_std_iface_get_setting+0x36>
		return false;
  4024b2:	2300      	movs	r3, #0
  4024b4:	e020      	b.n	4024f8 <udc_req_std_iface_get_setting+0x78>
	}

	// Select first alternate setting of the interface to update udc_ptr_iface
	// before call iface->getsetting()
	if (!udc_update_iface_desc(iface_num, 0)) {
  4024b6:	79fb      	ldrb	r3, [r7, #7]
  4024b8:	2100      	movs	r1, #0
  4024ba:	4618      	mov	r0, r3
  4024bc:	4b13      	ldr	r3, [pc, #76]	; (40250c <udc_req_std_iface_get_setting+0x8c>)
  4024be:	4798      	blx	r3
  4024c0:	4603      	mov	r3, r0
  4024c2:	f083 0301 	eor.w	r3, r3, #1
  4024c6:	b2db      	uxtb	r3, r3
  4024c8:	2b00      	cmp	r3, #0
  4024ca:	d001      	beq.n	4024d0 <udc_req_std_iface_get_setting+0x50>
		return false;
  4024cc:	2300      	movs	r3, #0
  4024ce:	e013      	b.n	4024f8 <udc_req_std_iface_get_setting+0x78>
	}
	// Get alternate setting from UDI
	udi_api = udc_ptr_conf->udi_apis[iface_num];
  4024d0:	4b0d      	ldr	r3, [pc, #52]	; (402508 <udc_req_std_iface_get_setting+0x88>)
  4024d2:	681b      	ldr	r3, [r3, #0]
  4024d4:	685a      	ldr	r2, [r3, #4]
  4024d6:	79fb      	ldrb	r3, [r7, #7]
  4024d8:	009b      	lsls	r3, r3, #2
  4024da:	4413      	add	r3, r2
  4024dc:	681b      	ldr	r3, [r3, #0]
  4024de:	603b      	str	r3, [r7, #0]
	udc_iface_setting = udi_api->getsetting();
  4024e0:	683b      	ldr	r3, [r7, #0]
  4024e2:	68db      	ldr	r3, [r3, #12]
  4024e4:	4798      	blx	r3
  4024e6:	4603      	mov	r3, r0
  4024e8:	461a      	mov	r2, r3
  4024ea:	4b09      	ldr	r3, [pc, #36]	; (402510 <udc_req_std_iface_get_setting+0x90>)
  4024ec:	701a      	strb	r2, [r3, #0]

	// Link value to payload pointer of request
	udd_set_setup_payload(&udc_iface_setting,1);
  4024ee:	2101      	movs	r1, #1
  4024f0:	4807      	ldr	r0, [pc, #28]	; (402510 <udc_req_std_iface_get_setting+0x90>)
  4024f2:	4b08      	ldr	r3, [pc, #32]	; (402514 <udc_req_std_iface_get_setting+0x94>)
  4024f4:	4798      	blx	r3
	return true;
  4024f6:	2301      	movs	r3, #1
}
  4024f8:	4618      	mov	r0, r3
  4024fa:	3708      	adds	r7, #8
  4024fc:	46bd      	mov	sp, r7
  4024fe:	bd80      	pop	{r7, pc}
  402500:	2000b598 	.word	0x2000b598
  402504:	20006bb4 	.word	0x20006bb4
  402508:	20006bb8 	.word	0x20006bb8
  40250c:	00401d75 	.word	0x00401d75
  402510:	20006bb0 	.word	0x20006bb0
  402514:	00404c59 	.word	0x00404c59

00402518 <udc_req_std_iface_set_setting>:
 * to set an alternate setting of an interface
 *
 * \return true if success
 */
static bool udc_req_std_iface_set_setting(void)
{
  402518:	b580      	push	{r7, lr}
  40251a:	b082      	sub	sp, #8
  40251c:	af00      	add	r7, sp, #0
	uint8_t iface_num, setting_num;

	if (udd_g_ctrlreq.req.wLength) {
  40251e:	4b14      	ldr	r3, [pc, #80]	; (402570 <udc_req_std_iface_set_setting+0x58>)
  402520:	88db      	ldrh	r3, [r3, #6]
  402522:	2b00      	cmp	r3, #0
  402524:	d001      	beq.n	40252a <udc_req_std_iface_set_setting+0x12>
		return false; // Error in request
  402526:	2300      	movs	r3, #0
  402528:	e01e      	b.n	402568 <udc_req_std_iface_set_setting+0x50>
	}
	if (!udc_num_configuration) {
  40252a:	4b12      	ldr	r3, [pc, #72]	; (402574 <udc_req_std_iface_set_setting+0x5c>)
  40252c:	781b      	ldrb	r3, [r3, #0]
  40252e:	2b00      	cmp	r3, #0
  402530:	d101      	bne.n	402536 <udc_req_std_iface_set_setting+0x1e>
		return false; // The device is not is configured state yet
  402532:	2300      	movs	r3, #0
  402534:	e018      	b.n	402568 <udc_req_std_iface_set_setting+0x50>
	}

	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
  402536:	4b0e      	ldr	r3, [pc, #56]	; (402570 <udc_req_std_iface_set_setting+0x58>)
  402538:	889b      	ldrh	r3, [r3, #4]
  40253a:	71fb      	strb	r3, [r7, #7]
	setting_num = udd_g_ctrlreq.req.wValue & 0xFF;
  40253c:	4b0c      	ldr	r3, [pc, #48]	; (402570 <udc_req_std_iface_set_setting+0x58>)
  40253e:	885b      	ldrh	r3, [r3, #2]
  402540:	71bb      	strb	r3, [r7, #6]

	// Disable current setting
	if (!udc_iface_disable(iface_num)) {
  402542:	79fb      	ldrb	r3, [r7, #7]
  402544:	4618      	mov	r0, r3
  402546:	4b0c      	ldr	r3, [pc, #48]	; (402578 <udc_req_std_iface_set_setting+0x60>)
  402548:	4798      	blx	r3
  40254a:	4603      	mov	r3, r0
  40254c:	f083 0301 	eor.w	r3, r3, #1
  402550:	b2db      	uxtb	r3, r3
  402552:	2b00      	cmp	r3, #0
  402554:	d001      	beq.n	40255a <udc_req_std_iface_set_setting+0x42>
		return false;
  402556:	2300      	movs	r3, #0
  402558:	e006      	b.n	402568 <udc_req_std_iface_set_setting+0x50>
	}

	// Enable new setting
	return udc_iface_enable(iface_num, setting_num);
  40255a:	79ba      	ldrb	r2, [r7, #6]
  40255c:	79fb      	ldrb	r3, [r7, #7]
  40255e:	4611      	mov	r1, r2
  402560:	4618      	mov	r0, r3
  402562:	4b06      	ldr	r3, [pc, #24]	; (40257c <udc_req_std_iface_set_setting+0x64>)
  402564:	4798      	blx	r3
  402566:	4603      	mov	r3, r0
}
  402568:	4618      	mov	r0, r3
  40256a:	3708      	adds	r7, #8
  40256c:	46bd      	mov	sp, r7
  40256e:	bd80      	pop	{r7, pc}
  402570:	2000b598 	.word	0x2000b598
  402574:	20006bb4 	.word	0x20006bb4
  402578:	00401e11 	.word	0x00401e11
  40257c:	00401eb1 	.word	0x00401eb1

00402580 <udc_reqstd>:
 * \brief Main routine to manage the standard USB SETUP request
 *
 * \return true if the request is supported
 */
static bool udc_reqstd(void)
{
  402580:	b580      	push	{r7, lr}
  402582:	af00      	add	r7, sp, #0
	if (Udd_setup_is_in()) {
  402584:	4b4d      	ldr	r3, [pc, #308]	; (4026bc <udc_reqstd+0x13c>)
  402586:	781b      	ldrb	r3, [r3, #0]
  402588:	b25b      	sxtb	r3, r3
  40258a:	2b00      	cmp	r3, #0
  40258c:	da3e      	bge.n	40260c <udc_reqstd+0x8c>
		// GET Standard Requests
		if (udd_g_ctrlreq.req.wLength == 0) {
  40258e:	4b4b      	ldr	r3, [pc, #300]	; (4026bc <udc_reqstd+0x13c>)
  402590:	88db      	ldrh	r3, [r3, #6]
  402592:	2b00      	cmp	r3, #0
  402594:	d101      	bne.n	40259a <udc_reqstd+0x1a>
			return false; // Error for USB host
  402596:	2300      	movs	r3, #0
  402598:	e08e      	b.n	4026b8 <udc_reqstd+0x138>
		}

		if (USB_REQ_RECIP_DEVICE == Udd_setup_recipient()) {
  40259a:	4b48      	ldr	r3, [pc, #288]	; (4026bc <udc_reqstd+0x13c>)
  40259c:	781b      	ldrb	r3, [r3, #0]
  40259e:	f003 031f 	and.w	r3, r3, #31
  4025a2:	2b00      	cmp	r3, #0
  4025a4:	d114      	bne.n	4025d0 <udc_reqstd+0x50>
			// Standard Get Device request
			switch (udd_g_ctrlreq.req.bRequest) {
  4025a6:	4b45      	ldr	r3, [pc, #276]	; (4026bc <udc_reqstd+0x13c>)
  4025a8:	785b      	ldrb	r3, [r3, #1]
  4025aa:	2b06      	cmp	r3, #6
  4025ac:	d008      	beq.n	4025c0 <udc_reqstd+0x40>
  4025ae:	2b08      	cmp	r3, #8
  4025b0:	d00a      	beq.n	4025c8 <udc_reqstd+0x48>
  4025b2:	2b00      	cmp	r3, #0
  4025b4:	d000      	beq.n	4025b8 <udc_reqstd+0x38>
			case USB_REQ_GET_DESCRIPTOR:
				return udc_req_std_dev_get_descriptor();
			case USB_REQ_GET_CONFIGURATION:
				return udc_req_std_dev_get_configuration();
			default:
				break;
  4025b6:	e00b      	b.n	4025d0 <udc_reqstd+0x50>
				return udc_req_std_dev_get_status();
  4025b8:	4b41      	ldr	r3, [pc, #260]	; (4026c0 <udc_reqstd+0x140>)
  4025ba:	4798      	blx	r3
  4025bc:	4603      	mov	r3, r0
  4025be:	e07b      	b.n	4026b8 <udc_reqstd+0x138>
				return udc_req_std_dev_get_descriptor();
  4025c0:	4b40      	ldr	r3, [pc, #256]	; (4026c4 <udc_reqstd+0x144>)
  4025c2:	4798      	blx	r3
  4025c4:	4603      	mov	r3, r0
  4025c6:	e077      	b.n	4026b8 <udc_reqstd+0x138>
				return udc_req_std_dev_get_configuration();
  4025c8:	4b3f      	ldr	r3, [pc, #252]	; (4026c8 <udc_reqstd+0x148>)
  4025ca:	4798      	blx	r3
  4025cc:	4603      	mov	r3, r0
  4025ce:	e073      	b.n	4026b8 <udc_reqstd+0x138>
			}
		}

		if (USB_REQ_RECIP_INTERFACE == Udd_setup_recipient()) {
  4025d0:	4b3a      	ldr	r3, [pc, #232]	; (4026bc <udc_reqstd+0x13c>)
  4025d2:	781b      	ldrb	r3, [r3, #0]
  4025d4:	f003 031f 	and.w	r3, r3, #31
  4025d8:	2b01      	cmp	r3, #1
  4025da:	d108      	bne.n	4025ee <udc_reqstd+0x6e>
			// Standard Get Interface request
			switch (udd_g_ctrlreq.req.bRequest) {
  4025dc:	4b37      	ldr	r3, [pc, #220]	; (4026bc <udc_reqstd+0x13c>)
  4025de:	785b      	ldrb	r3, [r3, #1]
  4025e0:	2b0a      	cmp	r3, #10
  4025e2:	d000      	beq.n	4025e6 <udc_reqstd+0x66>
			case USB_REQ_GET_INTERFACE:
				return udc_req_std_iface_get_setting();
			default:
				break;
  4025e4:	e003      	b.n	4025ee <udc_reqstd+0x6e>
				return udc_req_std_iface_get_setting();
  4025e6:	4b39      	ldr	r3, [pc, #228]	; (4026cc <udc_reqstd+0x14c>)
  4025e8:	4798      	blx	r3
  4025ea:	4603      	mov	r3, r0
  4025ec:	e064      	b.n	4026b8 <udc_reqstd+0x138>
			}
		}
#if (0!=USB_DEVICE_MAX_EP)
		if (USB_REQ_RECIP_ENDPOINT == Udd_setup_recipient()) {
  4025ee:	4b33      	ldr	r3, [pc, #204]	; (4026bc <udc_reqstd+0x13c>)
  4025f0:	781b      	ldrb	r3, [r3, #0]
  4025f2:	f003 031f 	and.w	r3, r3, #31
  4025f6:	2b02      	cmp	r3, #2
  4025f8:	d15d      	bne.n	4026b6 <udc_reqstd+0x136>
			// Standard Get Endpoint request
			switch (udd_g_ctrlreq.req.bRequest) {
  4025fa:	4b30      	ldr	r3, [pc, #192]	; (4026bc <udc_reqstd+0x13c>)
  4025fc:	785b      	ldrb	r3, [r3, #1]
  4025fe:	2b00      	cmp	r3, #0
  402600:	d000      	beq.n	402604 <udc_reqstd+0x84>
			case USB_REQ_GET_STATUS:
				return udc_req_std_ep_get_status();
			default:
				break;
  402602:	e058      	b.n	4026b6 <udc_reqstd+0x136>
				return udc_req_std_ep_get_status();
  402604:	4b32      	ldr	r3, [pc, #200]	; (4026d0 <udc_reqstd+0x150>)
  402606:	4798      	blx	r3
  402608:	4603      	mov	r3, r0
  40260a:	e055      	b.n	4026b8 <udc_reqstd+0x138>
			}
		}
#endif
	} else {
		// SET Standard Requests
		if (USB_REQ_RECIP_DEVICE == Udd_setup_recipient()) {
  40260c:	4b2b      	ldr	r3, [pc, #172]	; (4026bc <udc_reqstd+0x13c>)
  40260e:	781b      	ldrb	r3, [r3, #0]
  402610:	f003 031f 	and.w	r3, r3, #31
  402614:	2b00      	cmp	r3, #0
  402616:	d12a      	bne.n	40266e <udc_reqstd+0xee>
			// Standard Set Device request
			switch (udd_g_ctrlreq.req.bRequest) {
  402618:	4b28      	ldr	r3, [pc, #160]	; (4026bc <udc_reqstd+0x13c>)
  40261a:	785b      	ldrb	r3, [r3, #1]
  40261c:	3b01      	subs	r3, #1
  40261e:	2b08      	cmp	r3, #8
  402620:	d824      	bhi.n	40266c <udc_reqstd+0xec>
  402622:	a201      	add	r2, pc, #4	; (adr r2, 402628 <udc_reqstd+0xa8>)
  402624:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  402628:	00402655 	.word	0x00402655
  40262c:	0040266d 	.word	0x0040266d
  402630:	0040265d 	.word	0x0040265d
  402634:	0040266d 	.word	0x0040266d
  402638:	0040264d 	.word	0x0040264d
  40263c:	0040266d 	.word	0x0040266d
  402640:	0040266d 	.word	0x0040266d
  402644:	0040266d 	.word	0x0040266d
  402648:	00402665 	.word	0x00402665
			case USB_REQ_SET_ADDRESS:
				return udc_req_std_dev_set_address();
  40264c:	4b21      	ldr	r3, [pc, #132]	; (4026d4 <udc_reqstd+0x154>)
  40264e:	4798      	blx	r3
  402650:	4603      	mov	r3, r0
  402652:	e031      	b.n	4026b8 <udc_reqstd+0x138>
			case USB_REQ_CLEAR_FEATURE:
				return udc_req_std_dev_clear_feature();
  402654:	4b20      	ldr	r3, [pc, #128]	; (4026d8 <udc_reqstd+0x158>)
  402656:	4798      	blx	r3
  402658:	4603      	mov	r3, r0
  40265a:	e02d      	b.n	4026b8 <udc_reqstd+0x138>
			case USB_REQ_SET_FEATURE:
				return udc_req_std_dev_set_feature();
  40265c:	4b1f      	ldr	r3, [pc, #124]	; (4026dc <udc_reqstd+0x15c>)
  40265e:	4798      	blx	r3
  402660:	4603      	mov	r3, r0
  402662:	e029      	b.n	4026b8 <udc_reqstd+0x138>
			case USB_REQ_SET_CONFIGURATION:
				return udc_req_std_dev_set_configuration();
  402664:	4b1e      	ldr	r3, [pc, #120]	; (4026e0 <udc_reqstd+0x160>)
  402666:	4798      	blx	r3
  402668:	4603      	mov	r3, r0
  40266a:	e025      	b.n	4026b8 <udc_reqstd+0x138>
			case USB_REQ_SET_DESCRIPTOR:
				/* Not supported (defined as optional by the USB 2.0 spec) */
				break;
			default:
				break;
  40266c:	bf00      	nop
			}
		}

		if (USB_REQ_RECIP_INTERFACE == Udd_setup_recipient()) {
  40266e:	4b13      	ldr	r3, [pc, #76]	; (4026bc <udc_reqstd+0x13c>)
  402670:	781b      	ldrb	r3, [r3, #0]
  402672:	f003 031f 	and.w	r3, r3, #31
  402676:	2b01      	cmp	r3, #1
  402678:	d108      	bne.n	40268c <udc_reqstd+0x10c>
			// Standard Set Interface request
			switch (udd_g_ctrlreq.req.bRequest) {
  40267a:	4b10      	ldr	r3, [pc, #64]	; (4026bc <udc_reqstd+0x13c>)
  40267c:	785b      	ldrb	r3, [r3, #1]
  40267e:	2b0b      	cmp	r3, #11
  402680:	d000      	beq.n	402684 <udc_reqstd+0x104>
			case USB_REQ_SET_INTERFACE:
				return udc_req_std_iface_set_setting();
			default:
				break;
  402682:	e003      	b.n	40268c <udc_reqstd+0x10c>
				return udc_req_std_iface_set_setting();
  402684:	4b17      	ldr	r3, [pc, #92]	; (4026e4 <udc_reqstd+0x164>)
  402686:	4798      	blx	r3
  402688:	4603      	mov	r3, r0
  40268a:	e015      	b.n	4026b8 <udc_reqstd+0x138>
			}
		}
#if (0!=USB_DEVICE_MAX_EP)
		if (USB_REQ_RECIP_ENDPOINT == Udd_setup_recipient()) {
  40268c:	4b0b      	ldr	r3, [pc, #44]	; (4026bc <udc_reqstd+0x13c>)
  40268e:	781b      	ldrb	r3, [r3, #0]
  402690:	f003 031f 	and.w	r3, r3, #31
  402694:	2b02      	cmp	r3, #2
  402696:	d10e      	bne.n	4026b6 <udc_reqstd+0x136>
			// Standard Set Endpoint request
			switch (udd_g_ctrlreq.req.bRequest) {
  402698:	4b08      	ldr	r3, [pc, #32]	; (4026bc <udc_reqstd+0x13c>)
  40269a:	785b      	ldrb	r3, [r3, #1]
  40269c:	2b01      	cmp	r3, #1
  40269e:	d002      	beq.n	4026a6 <udc_reqstd+0x126>
  4026a0:	2b03      	cmp	r3, #3
  4026a2:	d004      	beq.n	4026ae <udc_reqstd+0x12e>
			case USB_REQ_CLEAR_FEATURE:
				return udc_req_std_ep_clear_feature();
			case USB_REQ_SET_FEATURE:
				return udc_req_std_ep_set_feature();
			default:
				break;
  4026a4:	e007      	b.n	4026b6 <udc_reqstd+0x136>
				return udc_req_std_ep_clear_feature();
  4026a6:	4b10      	ldr	r3, [pc, #64]	; (4026e8 <udc_reqstd+0x168>)
  4026a8:	4798      	blx	r3
  4026aa:	4603      	mov	r3, r0
  4026ac:	e004      	b.n	4026b8 <udc_reqstd+0x138>
				return udc_req_std_ep_set_feature();
  4026ae:	4b0f      	ldr	r3, [pc, #60]	; (4026ec <udc_reqstd+0x16c>)
  4026b0:	4798      	blx	r3
  4026b2:	4603      	mov	r3, r0
  4026b4:	e000      	b.n	4026b8 <udc_reqstd+0x138>
			}
		}
#endif
	}
	return false;
  4026b6:	2300      	movs	r3, #0
}
  4026b8:	4618      	mov	r0, r3
  4026ba:	bd80      	pop	{r7, pc}
  4026bc:	2000b598 	.word	0x2000b598
  4026c0:	00401ffd 	.word	0x00401ffd
  4026c4:	00402279 	.word	0x00402279
  4026c8:	00402395 	.word	0x00402395
  4026cc:	00402481 	.word	0x00402481
  4026d0:	00402029 	.word	0x00402029
  4026d4:	00402181 	.word	0x00402181
  4026d8:	0040206d 	.word	0x0040206d
  4026dc:	004020e5 	.word	0x004020e5
  4026e0:	004023c1 	.word	0x004023c1
  4026e4:	00402519 	.word	0x00402519
  4026e8:	004020ad 	.word	0x004020ad
  4026ec:	00402115 	.word	0x00402115

004026f0 <udc_req_iface>:
 * \brief Send the SETUP interface request to UDI
 *
 * \return true if the request is supported
 */
static bool udc_req_iface(void)
{
  4026f0:	b580      	push	{r7, lr}
  4026f2:	b082      	sub	sp, #8
  4026f4:	af00      	add	r7, sp, #0
	uint8_t iface_num;
	udi_api_t UDC_DESC_STORAGE *udi_api;

	if (0 == udc_num_configuration) {
  4026f6:	4b20      	ldr	r3, [pc, #128]	; (402778 <udc_req_iface+0x88>)
  4026f8:	781b      	ldrb	r3, [r3, #0]
  4026fa:	2b00      	cmp	r3, #0
  4026fc:	d101      	bne.n	402702 <udc_req_iface+0x12>
		return false; // The device is not is configured state yet
  4026fe:	2300      	movs	r3, #0
  402700:	e036      	b.n	402770 <udc_req_iface+0x80>
	}
	// Check interface number
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
  402702:	4b1e      	ldr	r3, [pc, #120]	; (40277c <udc_req_iface+0x8c>)
  402704:	889b      	ldrh	r3, [r3, #4]
  402706:	71fb      	strb	r3, [r7, #7]
	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {
  402708:	4b1d      	ldr	r3, [pc, #116]	; (402780 <udc_req_iface+0x90>)
  40270a:	681b      	ldr	r3, [r3, #0]
  40270c:	681b      	ldr	r3, [r3, #0]
  40270e:	791b      	ldrb	r3, [r3, #4]
  402710:	79fa      	ldrb	r2, [r7, #7]
  402712:	429a      	cmp	r2, r3
  402714:	d301      	bcc.n	40271a <udc_req_iface+0x2a>
		return false;
  402716:	2300      	movs	r3, #0
  402718:	e02a      	b.n	402770 <udc_req_iface+0x80>
	}

	//* To update udc_ptr_iface with the selected interface in request
	// Select first alternate setting of interface to update udc_ptr_iface
	// before calling udi_api->getsetting()
	if (!udc_update_iface_desc(iface_num, 0)) {
  40271a:	79fb      	ldrb	r3, [r7, #7]
  40271c:	2100      	movs	r1, #0
  40271e:	4618      	mov	r0, r3
  402720:	4b18      	ldr	r3, [pc, #96]	; (402784 <udc_req_iface+0x94>)
  402722:	4798      	blx	r3
  402724:	4603      	mov	r3, r0
  402726:	f083 0301 	eor.w	r3, r3, #1
  40272a:	b2db      	uxtb	r3, r3
  40272c:	2b00      	cmp	r3, #0
  40272e:	d001      	beq.n	402734 <udc_req_iface+0x44>
		return false;
  402730:	2300      	movs	r3, #0
  402732:	e01d      	b.n	402770 <udc_req_iface+0x80>
	}
	// Select the interface with the current alternate setting
	udi_api = udc_ptr_conf->udi_apis[iface_num];
  402734:	4b12      	ldr	r3, [pc, #72]	; (402780 <udc_req_iface+0x90>)
  402736:	681b      	ldr	r3, [r3, #0]
  402738:	685a      	ldr	r2, [r3, #4]
  40273a:	79fb      	ldrb	r3, [r7, #7]
  40273c:	009b      	lsls	r3, r3, #2
  40273e:	4413      	add	r3, r2
  402740:	681b      	ldr	r3, [r3, #0]
  402742:	603b      	str	r3, [r7, #0]
	if (!udc_update_iface_desc(iface_num, udi_api->getsetting())) {
  402744:	683b      	ldr	r3, [r7, #0]
  402746:	68db      	ldr	r3, [r3, #12]
  402748:	4798      	blx	r3
  40274a:	4603      	mov	r3, r0
  40274c:	461a      	mov	r2, r3
  40274e:	79fb      	ldrb	r3, [r7, #7]
  402750:	4611      	mov	r1, r2
  402752:	4618      	mov	r0, r3
  402754:	4b0b      	ldr	r3, [pc, #44]	; (402784 <udc_req_iface+0x94>)
  402756:	4798      	blx	r3
  402758:	4603      	mov	r3, r0
  40275a:	f083 0301 	eor.w	r3, r3, #1
  40275e:	b2db      	uxtb	r3, r3
  402760:	2b00      	cmp	r3, #0
  402762:	d001      	beq.n	402768 <udc_req_iface+0x78>
		return false;
  402764:	2300      	movs	r3, #0
  402766:	e003      	b.n	402770 <udc_req_iface+0x80>
	}

	// Send the SETUP request to the UDI corresponding to the interface number
	return udi_api->setup();
  402768:	683b      	ldr	r3, [r7, #0]
  40276a:	689b      	ldr	r3, [r3, #8]
  40276c:	4798      	blx	r3
  40276e:	4603      	mov	r3, r0
}
  402770:	4618      	mov	r0, r3
  402772:	3708      	adds	r7, #8
  402774:	46bd      	mov	sp, r7
  402776:	bd80      	pop	{r7, pc}
  402778:	20006bb4 	.word	0x20006bb4
  40277c:	2000b598 	.word	0x2000b598
  402780:	20006bb8 	.word	0x20006bb8
  402784:	00401d75 	.word	0x00401d75

00402788 <udc_req_ep>:
 * \brief Send the SETUP interface request to UDI
 *
 * \return true if the request is supported
 */
static bool udc_req_ep(void)
{
  402788:	b580      	push	{r7, lr}
  40278a:	b082      	sub	sp, #8
  40278c:	af00      	add	r7, sp, #0
	uint8_t iface_num;
	udi_api_t UDC_DESC_STORAGE *udi_api;

	if (0 == udc_num_configuration) {
  40278e:	4b1e      	ldr	r3, [pc, #120]	; (402808 <udc_req_ep+0x80>)
  402790:	781b      	ldrb	r3, [r3, #0]
  402792:	2b00      	cmp	r3, #0
  402794:	d101      	bne.n	40279a <udc_req_ep+0x12>
		return false; // The device is not is configured state yet
  402796:	2300      	movs	r3, #0
  402798:	e032      	b.n	402800 <udc_req_ep+0x78>
	}
	// Send this request on all enabled interfaces
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
  40279a:	4b1c      	ldr	r3, [pc, #112]	; (40280c <udc_req_ep+0x84>)
  40279c:	889b      	ldrh	r3, [r3, #4]
  40279e:	71fb      	strb	r3, [r7, #7]
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
  4027a0:	2300      	movs	r3, #0
  4027a2:	71fb      	strb	r3, [r7, #7]
  4027a4:	e024      	b.n	4027f0 <udc_req_ep+0x68>
			iface_num++) {
		// Select the interface with the current alternate setting
		udi_api = udc_ptr_conf->udi_apis[iface_num];
  4027a6:	4b1a      	ldr	r3, [pc, #104]	; (402810 <udc_req_ep+0x88>)
  4027a8:	681b      	ldr	r3, [r3, #0]
  4027aa:	685a      	ldr	r2, [r3, #4]
  4027ac:	79fb      	ldrb	r3, [r7, #7]
  4027ae:	009b      	lsls	r3, r3, #2
  4027b0:	4413      	add	r3, r2
  4027b2:	681b      	ldr	r3, [r3, #0]
  4027b4:	603b      	str	r3, [r7, #0]
		if (!udc_update_iface_desc(iface_num, udi_api->getsetting())) {
  4027b6:	683b      	ldr	r3, [r7, #0]
  4027b8:	68db      	ldr	r3, [r3, #12]
  4027ba:	4798      	blx	r3
  4027bc:	4603      	mov	r3, r0
  4027be:	461a      	mov	r2, r3
  4027c0:	79fb      	ldrb	r3, [r7, #7]
  4027c2:	4611      	mov	r1, r2
  4027c4:	4618      	mov	r0, r3
  4027c6:	4b13      	ldr	r3, [pc, #76]	; (402814 <udc_req_ep+0x8c>)
  4027c8:	4798      	blx	r3
  4027ca:	4603      	mov	r3, r0
  4027cc:	f083 0301 	eor.w	r3, r3, #1
  4027d0:	b2db      	uxtb	r3, r3
  4027d2:	2b00      	cmp	r3, #0
  4027d4:	d001      	beq.n	4027da <udc_req_ep+0x52>
			return false;
  4027d6:	2300      	movs	r3, #0
  4027d8:	e012      	b.n	402800 <udc_req_ep+0x78>
		}

		// Send the SETUP request to the UDI
		if (udi_api->setup()) {
  4027da:	683b      	ldr	r3, [r7, #0]
  4027dc:	689b      	ldr	r3, [r3, #8]
  4027de:	4798      	blx	r3
  4027e0:	4603      	mov	r3, r0
  4027e2:	2b00      	cmp	r3, #0
  4027e4:	d001      	beq.n	4027ea <udc_req_ep+0x62>
			return true;
  4027e6:	2301      	movs	r3, #1
  4027e8:	e00a      	b.n	402800 <udc_req_ep+0x78>
			iface_num++) {
  4027ea:	79fb      	ldrb	r3, [r7, #7]
  4027ec:	3301      	adds	r3, #1
  4027ee:	71fb      	strb	r3, [r7, #7]
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
  4027f0:	4b07      	ldr	r3, [pc, #28]	; (402810 <udc_req_ep+0x88>)
  4027f2:	681b      	ldr	r3, [r3, #0]
  4027f4:	681b      	ldr	r3, [r3, #0]
  4027f6:	791b      	ldrb	r3, [r3, #4]
  4027f8:	79fa      	ldrb	r2, [r7, #7]
  4027fa:	429a      	cmp	r2, r3
  4027fc:	d3d3      	bcc.n	4027a6 <udc_req_ep+0x1e>
		}
	}
	return false;
  4027fe:	2300      	movs	r3, #0
}
  402800:	4618      	mov	r0, r3
  402802:	3708      	adds	r7, #8
  402804:	46bd      	mov	sp, r7
  402806:	bd80      	pop	{r7, pc}
  402808:	20006bb4 	.word	0x20006bb4
  40280c:	2000b598 	.word	0x2000b598
  402810:	20006bb8 	.word	0x20006bb8
  402814:	00401d75 	.word	0x00401d75

00402818 <udc_process_setup>:
 * sent to a specific application callback.
 *
 * \return true if the request is supported, else the request is stalled by UDD
 */
bool udc_process_setup(void)
{
  402818:	b580      	push	{r7, lr}
  40281a:	af00      	add	r7, sp, #0
	// By default no data (receive/send) and no callbacks registered
	udd_g_ctrlreq.payload_size = 0;
  40281c:	4b1e      	ldr	r3, [pc, #120]	; (402898 <udc_process_setup+0x80>)
  40281e:	2200      	movs	r2, #0
  402820:	819a      	strh	r2, [r3, #12]
	udd_g_ctrlreq.callback = NULL;
  402822:	4b1d      	ldr	r3, [pc, #116]	; (402898 <udc_process_setup+0x80>)
  402824:	2200      	movs	r2, #0
  402826:	611a      	str	r2, [r3, #16]
	udd_g_ctrlreq.over_under_run = NULL;
  402828:	4b1b      	ldr	r3, [pc, #108]	; (402898 <udc_process_setup+0x80>)
  40282a:	2200      	movs	r2, #0
  40282c:	615a      	str	r2, [r3, #20]

	if (Udd_setup_is_in()) {
  40282e:	4b1a      	ldr	r3, [pc, #104]	; (402898 <udc_process_setup+0x80>)
  402830:	781b      	ldrb	r3, [r3, #0]
  402832:	b25b      	sxtb	r3, r3
  402834:	2b00      	cmp	r3, #0
  402836:	da05      	bge.n	402844 <udc_process_setup+0x2c>
		if (udd_g_ctrlreq.req.wLength == 0) {
  402838:	4b17      	ldr	r3, [pc, #92]	; (402898 <udc_process_setup+0x80>)
  40283a:	88db      	ldrh	r3, [r3, #6]
  40283c:	2b00      	cmp	r3, #0
  40283e:	d101      	bne.n	402844 <udc_process_setup+0x2c>
			return false; // Error from USB host
  402840:	2300      	movs	r3, #0
  402842:	e027      	b.n	402894 <udc_process_setup+0x7c>
		}
	}

	// If standard request then try to decode it in UDC
	if (Udd_setup_type() == USB_REQ_TYPE_STANDARD) {
  402844:	4b14      	ldr	r3, [pc, #80]	; (402898 <udc_process_setup+0x80>)
  402846:	781b      	ldrb	r3, [r3, #0]
  402848:	f003 0360 	and.w	r3, r3, #96	; 0x60
  40284c:	2b00      	cmp	r3, #0
  40284e:	d106      	bne.n	40285e <udc_process_setup+0x46>
		if (udc_reqstd()) {
  402850:	4b12      	ldr	r3, [pc, #72]	; (40289c <udc_process_setup+0x84>)
  402852:	4798      	blx	r3
  402854:	4603      	mov	r3, r0
  402856:	2b00      	cmp	r3, #0
  402858:	d001      	beq.n	40285e <udc_process_setup+0x46>
			return true;
  40285a:	2301      	movs	r3, #1
  40285c:	e01a      	b.n	402894 <udc_process_setup+0x7c>
		}
	}

	// If interface request then try to decode it in UDI
	if (Udd_setup_recipient() == USB_REQ_RECIP_INTERFACE) {
  40285e:	4b0e      	ldr	r3, [pc, #56]	; (402898 <udc_process_setup+0x80>)
  402860:	781b      	ldrb	r3, [r3, #0]
  402862:	f003 031f 	and.w	r3, r3, #31
  402866:	2b01      	cmp	r3, #1
  402868:	d106      	bne.n	402878 <udc_process_setup+0x60>
		if (udc_req_iface()) {
  40286a:	4b0d      	ldr	r3, [pc, #52]	; (4028a0 <udc_process_setup+0x88>)
  40286c:	4798      	blx	r3
  40286e:	4603      	mov	r3, r0
  402870:	2b00      	cmp	r3, #0
  402872:	d001      	beq.n	402878 <udc_process_setup+0x60>
			return true;
  402874:	2301      	movs	r3, #1
  402876:	e00d      	b.n	402894 <udc_process_setup+0x7c>
		}
	}

	// If endpoint request then try to decode it in UDI
	if (Udd_setup_recipient() == USB_REQ_RECIP_ENDPOINT) {
  402878:	4b07      	ldr	r3, [pc, #28]	; (402898 <udc_process_setup+0x80>)
  40287a:	781b      	ldrb	r3, [r3, #0]
  40287c:	f003 031f 	and.w	r3, r3, #31
  402880:	2b02      	cmp	r3, #2
  402882:	d106      	bne.n	402892 <udc_process_setup+0x7a>
		if (udc_req_ep()) {
  402884:	4b07      	ldr	r3, [pc, #28]	; (4028a4 <udc_process_setup+0x8c>)
  402886:	4798      	blx	r3
  402888:	4603      	mov	r3, r0
  40288a:	2b00      	cmp	r3, #0
  40288c:	d001      	beq.n	402892 <udc_process_setup+0x7a>
			return true;
  40288e:	2301      	movs	r3, #1
  402890:	e000      	b.n	402894 <udc_process_setup+0x7c>
	// Here SETUP request unknown by UDC and UDIs
#ifdef USB_DEVICE_SPECIFIC_REQUEST
	// Try to decode it in specific callback
	return USB_DEVICE_SPECIFIC_REQUEST(); // Ex: Vendor request,...
#else
	return false;
  402892:	2300      	movs	r3, #0
#endif
}
  402894:	4618      	mov	r0, r3
  402896:	bd80      	pop	{r7, pc}
  402898:	2000b598 	.word	0x2000b598
  40289c:	00402581 	.word	0x00402581
  4028a0:	004026f1 	.word	0x004026f1
  4028a4:	00402789 	.word	0x00402789

004028a8 <_read>:
int __attribute__((weak))
_read (int file, char * ptr, int len); // Remove GCC compiler warning

int __attribute__((weak))
_read (int file, char * ptr, int len)
{
  4028a8:	b580      	push	{r7, lr}
  4028aa:	b086      	sub	sp, #24
  4028ac:	af00      	add	r7, sp, #0
  4028ae:	60f8      	str	r0, [r7, #12]
  4028b0:	60b9      	str	r1, [r7, #8]
  4028b2:	607a      	str	r2, [r7, #4]
	int nChars = 0;
  4028b4:	2300      	movs	r3, #0
  4028b6:	617b      	str	r3, [r7, #20]

	if (file != 0) {
  4028b8:	68fb      	ldr	r3, [r7, #12]
  4028ba:	2b00      	cmp	r3, #0
  4028bc:	d012      	beq.n	4028e4 <_read+0x3c>
		return -1;
  4028be:	f04f 33ff 	mov.w	r3, #4294967295
  4028c2:	e013      	b.n	4028ec <_read+0x44>
	}

	for (; len > 0; --len) {
		ptr_get(stdio_base, ptr);
  4028c4:	4b0b      	ldr	r3, [pc, #44]	; (4028f4 <_read+0x4c>)
  4028c6:	681b      	ldr	r3, [r3, #0]
  4028c8:	4a0b      	ldr	r2, [pc, #44]	; (4028f8 <_read+0x50>)
  4028ca:	6812      	ldr	r2, [r2, #0]
  4028cc:	68b9      	ldr	r1, [r7, #8]
  4028ce:	4610      	mov	r0, r2
  4028d0:	4798      	blx	r3
		ptr++;
  4028d2:	68bb      	ldr	r3, [r7, #8]
  4028d4:	3301      	adds	r3, #1
  4028d6:	60bb      	str	r3, [r7, #8]
		nChars++;
  4028d8:	697b      	ldr	r3, [r7, #20]
  4028da:	3301      	adds	r3, #1
  4028dc:	617b      	str	r3, [r7, #20]
	for (; len > 0; --len) {
  4028de:	687b      	ldr	r3, [r7, #4]
  4028e0:	3b01      	subs	r3, #1
  4028e2:	607b      	str	r3, [r7, #4]
  4028e4:	687b      	ldr	r3, [r7, #4]
  4028e6:	2b00      	cmp	r3, #0
  4028e8:	dcec      	bgt.n	4028c4 <_read+0x1c>
	}
	return nChars;
  4028ea:	697b      	ldr	r3, [r7, #20]
}
  4028ec:	4618      	mov	r0, r3
  4028ee:	3718      	adds	r7, #24
  4028f0:	46bd      	mov	sp, r7
  4028f2:	bd80      	pop	{r7, pc}
  4028f4:	2000b588 	.word	0x2000b588
  4028f8:	2000b590 	.word	0x2000b590

004028fc <_write>:
int __attribute__((weak))
_write (int file, const char *ptr, int len);

int __attribute__((weak))
_write (int file, const char *ptr, int len)
{
  4028fc:	b580      	push	{r7, lr}
  4028fe:	b086      	sub	sp, #24
  402900:	af00      	add	r7, sp, #0
  402902:	60f8      	str	r0, [r7, #12]
  402904:	60b9      	str	r1, [r7, #8]
  402906:	607a      	str	r2, [r7, #4]
	int nChars = 0;
  402908:	2300      	movs	r3, #0
  40290a:	617b      	str	r3, [r7, #20]

	if ((file != 1) && (file != 2) && (file!=3)) {
  40290c:	68fb      	ldr	r3, [r7, #12]
  40290e:	2b01      	cmp	r3, #1
  402910:	d01e      	beq.n	402950 <_write+0x54>
  402912:	68fb      	ldr	r3, [r7, #12]
  402914:	2b02      	cmp	r3, #2
  402916:	d01b      	beq.n	402950 <_write+0x54>
  402918:	68fb      	ldr	r3, [r7, #12]
  40291a:	2b03      	cmp	r3, #3
  40291c:	d018      	beq.n	402950 <_write+0x54>
		return -1;
  40291e:	f04f 33ff 	mov.w	r3, #4294967295
  402922:	e019      	b.n	402958 <_write+0x5c>
	}

	for (; len != 0; --len) {
		if (ptr_put(stdio_base, *ptr++) < 0) {
  402924:	4b0e      	ldr	r3, [pc, #56]	; (402960 <_write+0x64>)
  402926:	681a      	ldr	r2, [r3, #0]
  402928:	4b0e      	ldr	r3, [pc, #56]	; (402964 <_write+0x68>)
  40292a:	6818      	ldr	r0, [r3, #0]
  40292c:	68bb      	ldr	r3, [r7, #8]
  40292e:	1c59      	adds	r1, r3, #1
  402930:	60b9      	str	r1, [r7, #8]
  402932:	781b      	ldrb	r3, [r3, #0]
  402934:	4619      	mov	r1, r3
  402936:	4790      	blx	r2
  402938:	4603      	mov	r3, r0
  40293a:	2b00      	cmp	r3, #0
  40293c:	da02      	bge.n	402944 <_write+0x48>
			return -1;
  40293e:	f04f 33ff 	mov.w	r3, #4294967295
  402942:	e009      	b.n	402958 <_write+0x5c>
		}
		++nChars;
  402944:	697b      	ldr	r3, [r7, #20]
  402946:	3301      	adds	r3, #1
  402948:	617b      	str	r3, [r7, #20]
	for (; len != 0; --len) {
  40294a:	687b      	ldr	r3, [r7, #4]
  40294c:	3b01      	subs	r3, #1
  40294e:	607b      	str	r3, [r7, #4]
  402950:	687b      	ldr	r3, [r7, #4]
  402952:	2b00      	cmp	r3, #0
  402954:	d1e6      	bne.n	402924 <_write+0x28>
	}
	return nChars;
  402956:	697b      	ldr	r3, [r7, #20]
}
  402958:	4618      	mov	r0, r3
  40295a:	3718      	adds	r7, #24
  40295c:	46bd      	mov	sp, r7
  40295e:	bd80      	pop	{r7, pc}
  402960:	2000b58c 	.word	0x2000b58c
  402964:	2000b590 	.word	0x2000b590

00402968 <sysclk_enable_peripheral_clock>:
 * \brief Enable a peripheral's clock.
 *
 * \param ul_id Id (number) of the peripheral clock.
 */
static inline void sysclk_enable_peripheral_clock(uint32_t ul_id)
{
  402968:	b580      	push	{r7, lr}
  40296a:	b082      	sub	sp, #8
  40296c:	af00      	add	r7, sp, #0
  40296e:	6078      	str	r0, [r7, #4]
	pmc_enable_periph_clk(ul_id);
  402970:	6878      	ldr	r0, [r7, #4]
  402972:	4b03      	ldr	r3, [pc, #12]	; (402980 <sysclk_enable_peripheral_clock+0x18>)
  402974:	4798      	blx	r3
}
  402976:	bf00      	nop
  402978:	3708      	adds	r7, #8
  40297a:	46bd      	mov	sp, r7
  40297c:	bd80      	pop	{r7, pc}
  40297e:	bf00      	nop
  402980:	0040433d 	.word	0x0040433d

00402984 <ioport_init>:
{
  402984:	b580      	push	{r7, lr}
  402986:	af00      	add	r7, sp, #0
	sysclk_enable_peripheral_clock(ID_PIOA);
  402988:	2009      	movs	r0, #9
  40298a:	4b08      	ldr	r3, [pc, #32]	; (4029ac <ioport_init+0x28>)
  40298c:	4798      	blx	r3
	sysclk_enable_peripheral_clock(ID_PIOB);
  40298e:	200a      	movs	r0, #10
  402990:	4b06      	ldr	r3, [pc, #24]	; (4029ac <ioport_init+0x28>)
  402992:	4798      	blx	r3
	sysclk_enable_peripheral_clock(ID_PIOC);
  402994:	200b      	movs	r0, #11
  402996:	4b05      	ldr	r3, [pc, #20]	; (4029ac <ioport_init+0x28>)
  402998:	4798      	blx	r3
	sysclk_enable_peripheral_clock(ID_PIOD);
  40299a:	200c      	movs	r0, #12
  40299c:	4b03      	ldr	r3, [pc, #12]	; (4029ac <ioport_init+0x28>)
  40299e:	4798      	blx	r3
	sysclk_enable_peripheral_clock(ID_PIOE);
  4029a0:	200d      	movs	r0, #13
  4029a2:	4b02      	ldr	r3, [pc, #8]	; (4029ac <ioport_init+0x28>)
  4029a4:	4798      	blx	r3
}
  4029a6:	bf00      	nop
  4029a8:	bd80      	pop	{r7, pc}
  4029aa:	bf00      	nop
  4029ac:	00402969 	.word	0x00402969

004029b0 <ioport_disable_pin>:
{
  4029b0:	b480      	push	{r7}
  4029b2:	b089      	sub	sp, #36	; 0x24
  4029b4:	af00      	add	r7, sp, #0
  4029b6:	6078      	str	r0, [r7, #4]
  4029b8:	687b      	ldr	r3, [r7, #4]
  4029ba:	61fb      	str	r3, [r7, #28]
  4029bc:	69fb      	ldr	r3, [r7, #28]
  4029be:	61bb      	str	r3, [r7, #24]
	return pin >> 5;
  4029c0:	69bb      	ldr	r3, [r7, #24]
  4029c2:	095a      	lsrs	r2, r3, #5
  4029c4:	69fb      	ldr	r3, [r7, #28]
  4029c6:	617b      	str	r3, [r7, #20]
	return 1U << (pin & 0x1F);
  4029c8:	697b      	ldr	r3, [r7, #20]
  4029ca:	f003 031f 	and.w	r3, r3, #31
  4029ce:	2101      	movs	r1, #1
  4029d0:	fa01 f303 	lsl.w	r3, r1, r3
  4029d4:	613a      	str	r2, [r7, #16]
  4029d6:	60fb      	str	r3, [r7, #12]
  4029d8:	693b      	ldr	r3, [r7, #16]
  4029da:	60bb      	str	r3, [r7, #8]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  4029dc:	68bb      	ldr	r3, [r7, #8]
  4029de:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  4029e2:	f203 7307 	addw	r3, r3, #1799	; 0x707
  4029e6:	025b      	lsls	r3, r3, #9
  4029e8:	461a      	mov	r2, r3
	arch_ioport_port_to_base(port)->PIO_PDR = mask;
  4029ea:	68fb      	ldr	r3, [r7, #12]
  4029ec:	6053      	str	r3, [r2, #4]
}
  4029ee:	bf00      	nop
  4029f0:	3724      	adds	r7, #36	; 0x24
  4029f2:	46bd      	mov	sp, r7
  4029f4:	f85d 7b04 	ldr.w	r7, [sp], #4
  4029f8:	4770      	bx	lr

004029fa <ioport_disable_port>:
{
  4029fa:	b480      	push	{r7}
  4029fc:	b087      	sub	sp, #28
  4029fe:	af00      	add	r7, sp, #0
  402a00:	6078      	str	r0, [r7, #4]
  402a02:	6039      	str	r1, [r7, #0]
  402a04:	687b      	ldr	r3, [r7, #4]
  402a06:	617b      	str	r3, [r7, #20]
  402a08:	683b      	ldr	r3, [r7, #0]
  402a0a:	613b      	str	r3, [r7, #16]
  402a0c:	697b      	ldr	r3, [r7, #20]
  402a0e:	60fb      	str	r3, [r7, #12]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  402a10:	68fb      	ldr	r3, [r7, #12]
  402a12:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  402a16:	f203 7307 	addw	r3, r3, #1799	; 0x707
  402a1a:	025b      	lsls	r3, r3, #9
  402a1c:	461a      	mov	r2, r3
	arch_ioport_port_to_base(port)->PIO_PDR = mask;
  402a1e:	693b      	ldr	r3, [r7, #16]
  402a20:	6053      	str	r3, [r2, #4]
}
  402a22:	bf00      	nop
  402a24:	371c      	adds	r7, #28
  402a26:	46bd      	mov	sp, r7
  402a28:	f85d 7b04 	ldr.w	r7, [sp], #4
  402a2c:	4770      	bx	lr

00402a2e <ioport_set_port_mode>:
{
  402a2e:	b480      	push	{r7}
  402a30:	b08b      	sub	sp, #44	; 0x2c
  402a32:	af00      	add	r7, sp, #0
  402a34:	60f8      	str	r0, [r7, #12]
  402a36:	60b9      	str	r1, [r7, #8]
  402a38:	607a      	str	r2, [r7, #4]
  402a3a:	68fb      	ldr	r3, [r7, #12]
  402a3c:	627b      	str	r3, [r7, #36]	; 0x24
  402a3e:	68bb      	ldr	r3, [r7, #8]
  402a40:	623b      	str	r3, [r7, #32]
  402a42:	687b      	ldr	r3, [r7, #4]
  402a44:	61fb      	str	r3, [r7, #28]
  402a46:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  402a48:	61bb      	str	r3, [r7, #24]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  402a4a:	69bb      	ldr	r3, [r7, #24]
  402a4c:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  402a50:	f203 7307 	addw	r3, r3, #1799	; 0x707
  402a54:	025b      	lsls	r3, r3, #9
	Pio *base = arch_ioport_port_to_base(port);
  402a56:	617b      	str	r3, [r7, #20]
	if (mode & IOPORT_MODE_PULLUP) {
  402a58:	69fb      	ldr	r3, [r7, #28]
  402a5a:	f003 0308 	and.w	r3, r3, #8
  402a5e:	2b00      	cmp	r3, #0
  402a60:	d003      	beq.n	402a6a <ioport_set_port_mode+0x3c>
		base->PIO_PUER = mask;
  402a62:	697b      	ldr	r3, [r7, #20]
  402a64:	6a3a      	ldr	r2, [r7, #32]
  402a66:	665a      	str	r2, [r3, #100]	; 0x64
  402a68:	e002      	b.n	402a70 <ioport_set_port_mode+0x42>
		base->PIO_PUDR = mask;
  402a6a:	697b      	ldr	r3, [r7, #20]
  402a6c:	6a3a      	ldr	r2, [r7, #32]
  402a6e:	661a      	str	r2, [r3, #96]	; 0x60
	if (mode & IOPORT_MODE_PULLDOWN) {
  402a70:	69fb      	ldr	r3, [r7, #28]
  402a72:	f003 0310 	and.w	r3, r3, #16
  402a76:	2b00      	cmp	r3, #0
  402a78:	d004      	beq.n	402a84 <ioport_set_port_mode+0x56>
		base->PIO_PPDER = mask;
  402a7a:	697b      	ldr	r3, [r7, #20]
  402a7c:	6a3a      	ldr	r2, [r7, #32]
  402a7e:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  402a82:	e003      	b.n	402a8c <ioport_set_port_mode+0x5e>
		base->PIO_PPDDR = mask;
  402a84:	697b      	ldr	r3, [r7, #20]
  402a86:	6a3a      	ldr	r2, [r7, #32]
  402a88:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
	if (mode & IOPORT_MODE_OPEN_DRAIN) {
  402a8c:	69fb      	ldr	r3, [r7, #28]
  402a8e:	f003 0320 	and.w	r3, r3, #32
  402a92:	2b00      	cmp	r3, #0
  402a94:	d003      	beq.n	402a9e <ioport_set_port_mode+0x70>
		base->PIO_MDER = mask;
  402a96:	697b      	ldr	r3, [r7, #20]
  402a98:	6a3a      	ldr	r2, [r7, #32]
  402a9a:	651a      	str	r2, [r3, #80]	; 0x50
  402a9c:	e002      	b.n	402aa4 <ioport_set_port_mode+0x76>
		base->PIO_MDDR = mask;
  402a9e:	697b      	ldr	r3, [r7, #20]
  402aa0:	6a3a      	ldr	r2, [r7, #32]
  402aa2:	655a      	str	r2, [r3, #84]	; 0x54
	if (mode & (IOPORT_MODE_GLITCH_FILTER | IOPORT_MODE_DEBOUNCE)) {
  402aa4:	69fb      	ldr	r3, [r7, #28]
  402aa6:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
  402aaa:	2b00      	cmp	r3, #0
  402aac:	d003      	beq.n	402ab6 <ioport_set_port_mode+0x88>
		base->PIO_IFER = mask;
  402aae:	697b      	ldr	r3, [r7, #20]
  402ab0:	6a3a      	ldr	r2, [r7, #32]
  402ab2:	621a      	str	r2, [r3, #32]
  402ab4:	e002      	b.n	402abc <ioport_set_port_mode+0x8e>
		base->PIO_IFDR = mask;
  402ab6:	697b      	ldr	r3, [r7, #20]
  402ab8:	6a3a      	ldr	r2, [r7, #32]
  402aba:	625a      	str	r2, [r3, #36]	; 0x24
	if (mode & IOPORT_MODE_DEBOUNCE) {
  402abc:	69fb      	ldr	r3, [r7, #28]
  402abe:	f003 0380 	and.w	r3, r3, #128	; 0x80
  402ac2:	2b00      	cmp	r3, #0
  402ac4:	d004      	beq.n	402ad0 <ioport_set_port_mode+0xa2>
		base->PIO_IFSCER = mask;
  402ac6:	697b      	ldr	r3, [r7, #20]
  402ac8:	6a3a      	ldr	r2, [r7, #32]
  402aca:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  402ace:	e003      	b.n	402ad8 <ioport_set_port_mode+0xaa>
		base->PIO_IFSCDR = mask;
  402ad0:	697b      	ldr	r3, [r7, #20]
  402ad2:	6a3a      	ldr	r2, [r7, #32]
  402ad4:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	if (mode & IOPORT_MODE_MUX_BIT0) {
  402ad8:	69fb      	ldr	r3, [r7, #28]
  402ada:	f003 0301 	and.w	r3, r3, #1
  402ade:	2b00      	cmp	r3, #0
  402ae0:	d006      	beq.n	402af0 <ioport_set_port_mode+0xc2>
		base->PIO_ABCDSR[0] |= mask;
  402ae2:	697b      	ldr	r3, [r7, #20]
  402ae4:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  402ae6:	6a3b      	ldr	r3, [r7, #32]
  402ae8:	431a      	orrs	r2, r3
  402aea:	697b      	ldr	r3, [r7, #20]
  402aec:	671a      	str	r2, [r3, #112]	; 0x70
  402aee:	e006      	b.n	402afe <ioport_set_port_mode+0xd0>
		base->PIO_ABCDSR[0] &= ~mask;
  402af0:	697b      	ldr	r3, [r7, #20]
  402af2:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  402af4:	6a3b      	ldr	r3, [r7, #32]
  402af6:	43db      	mvns	r3, r3
  402af8:	401a      	ands	r2, r3
  402afa:	697b      	ldr	r3, [r7, #20]
  402afc:	671a      	str	r2, [r3, #112]	; 0x70
	if (mode & IOPORT_MODE_MUX_BIT1) {
  402afe:	69fb      	ldr	r3, [r7, #28]
  402b00:	f003 0302 	and.w	r3, r3, #2
  402b04:	2b00      	cmp	r3, #0
  402b06:	d006      	beq.n	402b16 <ioport_set_port_mode+0xe8>
		base->PIO_ABCDSR[1] |= mask;
  402b08:	697b      	ldr	r3, [r7, #20]
  402b0a:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  402b0c:	6a3b      	ldr	r3, [r7, #32]
  402b0e:	431a      	orrs	r2, r3
  402b10:	697b      	ldr	r3, [r7, #20]
  402b12:	675a      	str	r2, [r3, #116]	; 0x74
}
  402b14:	e006      	b.n	402b24 <ioport_set_port_mode+0xf6>
		base->PIO_ABCDSR[1] &= ~mask;
  402b16:	697b      	ldr	r3, [r7, #20]
  402b18:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  402b1a:	6a3b      	ldr	r3, [r7, #32]
  402b1c:	43db      	mvns	r3, r3
  402b1e:	401a      	ands	r2, r3
  402b20:	697b      	ldr	r3, [r7, #20]
  402b22:	675a      	str	r2, [r3, #116]	; 0x74
  402b24:	bf00      	nop
  402b26:	372c      	adds	r7, #44	; 0x2c
  402b28:	46bd      	mov	sp, r7
  402b2a:	f85d 7b04 	ldr.w	r7, [sp], #4
  402b2e:	4770      	bx	lr

00402b30 <ioport_set_pin_mode>:
{
  402b30:	b480      	push	{r7}
  402b32:	b08d      	sub	sp, #52	; 0x34
  402b34:	af00      	add	r7, sp, #0
  402b36:	6078      	str	r0, [r7, #4]
  402b38:	6039      	str	r1, [r7, #0]
  402b3a:	687b      	ldr	r3, [r7, #4]
  402b3c:	62fb      	str	r3, [r7, #44]	; 0x2c
  402b3e:	683b      	ldr	r3, [r7, #0]
  402b40:	62bb      	str	r3, [r7, #40]	; 0x28
  402b42:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  402b44:	627b      	str	r3, [r7, #36]	; 0x24
	return pin >> 5;
  402b46:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  402b48:	095a      	lsrs	r2, r3, #5
  402b4a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  402b4c:	623b      	str	r3, [r7, #32]
	return 1U << (pin & 0x1F);
  402b4e:	6a3b      	ldr	r3, [r7, #32]
  402b50:	f003 031f 	and.w	r3, r3, #31
  402b54:	2101      	movs	r1, #1
  402b56:	fa01 f303 	lsl.w	r3, r1, r3
  402b5a:	61fa      	str	r2, [r7, #28]
  402b5c:	61bb      	str	r3, [r7, #24]
  402b5e:	6abb      	ldr	r3, [r7, #40]	; 0x28
  402b60:	617b      	str	r3, [r7, #20]
  402b62:	69fb      	ldr	r3, [r7, #28]
  402b64:	613b      	str	r3, [r7, #16]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  402b66:	693b      	ldr	r3, [r7, #16]
  402b68:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  402b6c:	f203 7307 	addw	r3, r3, #1799	; 0x707
  402b70:	025b      	lsls	r3, r3, #9
	Pio *base = arch_ioport_port_to_base(port);
  402b72:	60fb      	str	r3, [r7, #12]
	if (mode & IOPORT_MODE_PULLUP) {
  402b74:	697b      	ldr	r3, [r7, #20]
  402b76:	f003 0308 	and.w	r3, r3, #8
  402b7a:	2b00      	cmp	r3, #0
  402b7c:	d003      	beq.n	402b86 <ioport_set_pin_mode+0x56>
		base->PIO_PUER = mask;
  402b7e:	68fb      	ldr	r3, [r7, #12]
  402b80:	69ba      	ldr	r2, [r7, #24]
  402b82:	665a      	str	r2, [r3, #100]	; 0x64
  402b84:	e002      	b.n	402b8c <ioport_set_pin_mode+0x5c>
		base->PIO_PUDR = mask;
  402b86:	68fb      	ldr	r3, [r7, #12]
  402b88:	69ba      	ldr	r2, [r7, #24]
  402b8a:	661a      	str	r2, [r3, #96]	; 0x60
	if (mode & IOPORT_MODE_PULLDOWN) {
  402b8c:	697b      	ldr	r3, [r7, #20]
  402b8e:	f003 0310 	and.w	r3, r3, #16
  402b92:	2b00      	cmp	r3, #0
  402b94:	d004      	beq.n	402ba0 <ioport_set_pin_mode+0x70>
		base->PIO_PPDER = mask;
  402b96:	68fb      	ldr	r3, [r7, #12]
  402b98:	69ba      	ldr	r2, [r7, #24]
  402b9a:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  402b9e:	e003      	b.n	402ba8 <ioport_set_pin_mode+0x78>
		base->PIO_PPDDR = mask;
  402ba0:	68fb      	ldr	r3, [r7, #12]
  402ba2:	69ba      	ldr	r2, [r7, #24]
  402ba4:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
	if (mode & IOPORT_MODE_OPEN_DRAIN) {
  402ba8:	697b      	ldr	r3, [r7, #20]
  402baa:	f003 0320 	and.w	r3, r3, #32
  402bae:	2b00      	cmp	r3, #0
  402bb0:	d003      	beq.n	402bba <ioport_set_pin_mode+0x8a>
		base->PIO_MDER = mask;
  402bb2:	68fb      	ldr	r3, [r7, #12]
  402bb4:	69ba      	ldr	r2, [r7, #24]
  402bb6:	651a      	str	r2, [r3, #80]	; 0x50
  402bb8:	e002      	b.n	402bc0 <ioport_set_pin_mode+0x90>
		base->PIO_MDDR = mask;
  402bba:	68fb      	ldr	r3, [r7, #12]
  402bbc:	69ba      	ldr	r2, [r7, #24]
  402bbe:	655a      	str	r2, [r3, #84]	; 0x54
	if (mode & (IOPORT_MODE_GLITCH_FILTER | IOPORT_MODE_DEBOUNCE)) {
  402bc0:	697b      	ldr	r3, [r7, #20]
  402bc2:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
  402bc6:	2b00      	cmp	r3, #0
  402bc8:	d003      	beq.n	402bd2 <ioport_set_pin_mode+0xa2>
		base->PIO_IFER = mask;
  402bca:	68fb      	ldr	r3, [r7, #12]
  402bcc:	69ba      	ldr	r2, [r7, #24]
  402bce:	621a      	str	r2, [r3, #32]
  402bd0:	e002      	b.n	402bd8 <ioport_set_pin_mode+0xa8>
		base->PIO_IFDR = mask;
  402bd2:	68fb      	ldr	r3, [r7, #12]
  402bd4:	69ba      	ldr	r2, [r7, #24]
  402bd6:	625a      	str	r2, [r3, #36]	; 0x24
	if (mode & IOPORT_MODE_DEBOUNCE) {
  402bd8:	697b      	ldr	r3, [r7, #20]
  402bda:	f003 0380 	and.w	r3, r3, #128	; 0x80
  402bde:	2b00      	cmp	r3, #0
  402be0:	d004      	beq.n	402bec <ioport_set_pin_mode+0xbc>
		base->PIO_IFSCER = mask;
  402be2:	68fb      	ldr	r3, [r7, #12]
  402be4:	69ba      	ldr	r2, [r7, #24]
  402be6:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  402bea:	e003      	b.n	402bf4 <ioport_set_pin_mode+0xc4>
		base->PIO_IFSCDR = mask;
  402bec:	68fb      	ldr	r3, [r7, #12]
  402bee:	69ba      	ldr	r2, [r7, #24]
  402bf0:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	if (mode & IOPORT_MODE_MUX_BIT0) {
  402bf4:	697b      	ldr	r3, [r7, #20]
  402bf6:	f003 0301 	and.w	r3, r3, #1
  402bfa:	2b00      	cmp	r3, #0
  402bfc:	d006      	beq.n	402c0c <ioport_set_pin_mode+0xdc>
		base->PIO_ABCDSR[0] |= mask;
  402bfe:	68fb      	ldr	r3, [r7, #12]
  402c00:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  402c02:	69bb      	ldr	r3, [r7, #24]
  402c04:	431a      	orrs	r2, r3
  402c06:	68fb      	ldr	r3, [r7, #12]
  402c08:	671a      	str	r2, [r3, #112]	; 0x70
  402c0a:	e006      	b.n	402c1a <ioport_set_pin_mode+0xea>
		base->PIO_ABCDSR[0] &= ~mask;
  402c0c:	68fb      	ldr	r3, [r7, #12]
  402c0e:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  402c10:	69bb      	ldr	r3, [r7, #24]
  402c12:	43db      	mvns	r3, r3
  402c14:	401a      	ands	r2, r3
  402c16:	68fb      	ldr	r3, [r7, #12]
  402c18:	671a      	str	r2, [r3, #112]	; 0x70
	if (mode & IOPORT_MODE_MUX_BIT1) {
  402c1a:	697b      	ldr	r3, [r7, #20]
  402c1c:	f003 0302 	and.w	r3, r3, #2
  402c20:	2b00      	cmp	r3, #0
  402c22:	d006      	beq.n	402c32 <ioport_set_pin_mode+0x102>
		base->PIO_ABCDSR[1] |= mask;
  402c24:	68fb      	ldr	r3, [r7, #12]
  402c26:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  402c28:	69bb      	ldr	r3, [r7, #24]
  402c2a:	431a      	orrs	r2, r3
  402c2c:	68fb      	ldr	r3, [r7, #12]
  402c2e:	675a      	str	r2, [r3, #116]	; 0x74
}
  402c30:	e006      	b.n	402c40 <ioport_set_pin_mode+0x110>
		base->PIO_ABCDSR[1] &= ~mask;
  402c32:	68fb      	ldr	r3, [r7, #12]
  402c34:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  402c36:	69bb      	ldr	r3, [r7, #24]
  402c38:	43db      	mvns	r3, r3
  402c3a:	401a      	ands	r2, r3
  402c3c:	68fb      	ldr	r3, [r7, #12]
  402c3e:	675a      	str	r2, [r3, #116]	; 0x74
  402c40:	bf00      	nop
  402c42:	3734      	adds	r7, #52	; 0x34
  402c44:	46bd      	mov	sp, r7
  402c46:	f85d 7b04 	ldr.w	r7, [sp], #4
  402c4a:	4770      	bx	lr

00402c4c <ioport_set_pin_dir>:
{
  402c4c:	b480      	push	{r7}
  402c4e:	b08d      	sub	sp, #52	; 0x34
  402c50:	af00      	add	r7, sp, #0
  402c52:	6078      	str	r0, [r7, #4]
  402c54:	460b      	mov	r3, r1
  402c56:	70fb      	strb	r3, [r7, #3]
  402c58:	687b      	ldr	r3, [r7, #4]
  402c5a:	62fb      	str	r3, [r7, #44]	; 0x2c
  402c5c:	78fb      	ldrb	r3, [r7, #3]
  402c5e:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
  402c62:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  402c64:	627b      	str	r3, [r7, #36]	; 0x24
  402c66:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  402c68:	623b      	str	r3, [r7, #32]
	return pin >> 5;
  402c6a:	6a3b      	ldr	r3, [r7, #32]
  402c6c:	095b      	lsrs	r3, r3, #5
  402c6e:	61fb      	str	r3, [r7, #28]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  402c70:	69fb      	ldr	r3, [r7, #28]
  402c72:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  402c76:	f203 7307 	addw	r3, r3, #1799	; 0x707
  402c7a:	025b      	lsls	r3, r3, #9
	Pio *base = arch_ioport_pin_to_base(pin);
  402c7c:	61bb      	str	r3, [r7, #24]
	if (dir == IOPORT_DIR_OUTPUT) {
  402c7e:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
  402c82:	2b01      	cmp	r3, #1
  402c84:	d109      	bne.n	402c9a <ioport_set_pin_dir+0x4e>
  402c86:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  402c88:	617b      	str	r3, [r7, #20]
	return 1U << (pin & 0x1F);
  402c8a:	697b      	ldr	r3, [r7, #20]
  402c8c:	f003 031f 	and.w	r3, r3, #31
  402c90:	2201      	movs	r2, #1
  402c92:	409a      	lsls	r2, r3
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
  402c94:	69bb      	ldr	r3, [r7, #24]
  402c96:	611a      	str	r2, [r3, #16]
  402c98:	e00c      	b.n	402cb4 <ioport_set_pin_dir+0x68>
	} else if (dir == IOPORT_DIR_INPUT) {
  402c9a:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
  402c9e:	2b00      	cmp	r3, #0
  402ca0:	d108      	bne.n	402cb4 <ioport_set_pin_dir+0x68>
  402ca2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  402ca4:	613b      	str	r3, [r7, #16]
	return 1U << (pin & 0x1F);
  402ca6:	693b      	ldr	r3, [r7, #16]
  402ca8:	f003 031f 	and.w	r3, r3, #31
  402cac:	2201      	movs	r2, #1
  402cae:	409a      	lsls	r2, r3
		base->PIO_ODR = arch_ioport_pin_to_mask(pin);
  402cb0:	69bb      	ldr	r3, [r7, #24]
  402cb2:	615a      	str	r2, [r3, #20]
  402cb4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  402cb6:	60fb      	str	r3, [r7, #12]
	return 1U << (pin & 0x1F);
  402cb8:	68fb      	ldr	r3, [r7, #12]
  402cba:	f003 031f 	and.w	r3, r3, #31
  402cbe:	2201      	movs	r2, #1
  402cc0:	409a      	lsls	r2, r3
	base->PIO_OWER = arch_ioport_pin_to_mask(pin);
  402cc2:	69bb      	ldr	r3, [r7, #24]
  402cc4:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
}
  402cc8:	bf00      	nop
  402cca:	3734      	adds	r7, #52	; 0x34
  402ccc:	46bd      	mov	sp, r7
  402cce:	f85d 7b04 	ldr.w	r7, [sp], #4
  402cd2:	4770      	bx	lr

00402cd4 <ioport_set_pin_level>:
{
  402cd4:	b480      	push	{r7}
  402cd6:	b08b      	sub	sp, #44	; 0x2c
  402cd8:	af00      	add	r7, sp, #0
  402cda:	6078      	str	r0, [r7, #4]
  402cdc:	460b      	mov	r3, r1
  402cde:	70fb      	strb	r3, [r7, #3]
  402ce0:	687b      	ldr	r3, [r7, #4]
  402ce2:	627b      	str	r3, [r7, #36]	; 0x24
  402ce4:	78fb      	ldrb	r3, [r7, #3]
  402ce6:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
  402cea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  402cec:	61fb      	str	r3, [r7, #28]
  402cee:	69fb      	ldr	r3, [r7, #28]
  402cf0:	61bb      	str	r3, [r7, #24]
	return pin >> 5;
  402cf2:	69bb      	ldr	r3, [r7, #24]
  402cf4:	095b      	lsrs	r3, r3, #5
  402cf6:	617b      	str	r3, [r7, #20]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  402cf8:	697b      	ldr	r3, [r7, #20]
  402cfa:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  402cfe:	f203 7307 	addw	r3, r3, #1799	; 0x707
  402d02:	025b      	lsls	r3, r3, #9
	Pio *base = arch_ioport_pin_to_base(pin);
  402d04:	613b      	str	r3, [r7, #16]
	if (level) {
  402d06:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
  402d0a:	2b00      	cmp	r3, #0
  402d0c:	d009      	beq.n	402d22 <ioport_set_pin_level+0x4e>
  402d0e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  402d10:	60fb      	str	r3, [r7, #12]
	return 1U << (pin & 0x1F);
  402d12:	68fb      	ldr	r3, [r7, #12]
  402d14:	f003 031f 	and.w	r3, r3, #31
  402d18:	2201      	movs	r2, #1
  402d1a:	409a      	lsls	r2, r3
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  402d1c:	693b      	ldr	r3, [r7, #16]
  402d1e:	631a      	str	r2, [r3, #48]	; 0x30
}
  402d20:	e008      	b.n	402d34 <ioport_set_pin_level+0x60>
  402d22:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  402d24:	60bb      	str	r3, [r7, #8]
	return 1U << (pin & 0x1F);
  402d26:	68bb      	ldr	r3, [r7, #8]
  402d28:	f003 031f 	and.w	r3, r3, #31
  402d2c:	2201      	movs	r2, #1
  402d2e:	409a      	lsls	r2, r3
		base->PIO_CODR = arch_ioport_pin_to_mask(pin);
  402d30:	693b      	ldr	r3, [r7, #16]
  402d32:	635a      	str	r2, [r3, #52]	; 0x34
  402d34:	bf00      	nop
  402d36:	372c      	adds	r7, #44	; 0x2c
  402d38:	46bd      	mov	sp, r7
  402d3a:	f85d 7b04 	ldr.w	r7, [sp], #4
  402d3e:	4770      	bx	lr

00402d40 <ioport_set_pin_sense_mode>:
 * \param pin IOPORT pin to configure
 * \param pin_sense Edge to sense for the pin (\ref ioport_sense)
 */
static inline void ioport_set_pin_sense_mode(ioport_pin_t pin,
		enum ioport_sense pin_sense)
{
  402d40:	b480      	push	{r7}
  402d42:	b08d      	sub	sp, #52	; 0x34
  402d44:	af00      	add	r7, sp, #0
  402d46:	6078      	str	r0, [r7, #4]
  402d48:	460b      	mov	r3, r1
  402d4a:	70fb      	strb	r3, [r7, #3]
  402d4c:	687b      	ldr	r3, [r7, #4]
  402d4e:	62fb      	str	r3, [r7, #44]	; 0x2c
  402d50:	78fb      	ldrb	r3, [r7, #3]
  402d52:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
  402d56:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  402d58:	627b      	str	r3, [r7, #36]	; 0x24
	return pin >> 5;
  402d5a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  402d5c:	095a      	lsrs	r2, r3, #5
  402d5e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  402d60:	623b      	str	r3, [r7, #32]
	return 1U << (pin & 0x1F);
  402d62:	6a3b      	ldr	r3, [r7, #32]
  402d64:	f003 031f 	and.w	r3, r3, #31
  402d68:	2101      	movs	r1, #1
  402d6a:	fa01 f303 	lsl.w	r3, r1, r3
  402d6e:	61fa      	str	r2, [r7, #28]
  402d70:	61bb      	str	r3, [r7, #24]
  402d72:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
  402d76:	75fb      	strb	r3, [r7, #23]
  402d78:	69fb      	ldr	r3, [r7, #28]
  402d7a:	613b      	str	r3, [r7, #16]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  402d7c:	693b      	ldr	r3, [r7, #16]
  402d7e:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  402d82:	f203 7307 	addw	r3, r3, #1799	; 0x707
  402d86:	025b      	lsls	r3, r3, #9
}

__always_inline static void arch_ioport_set_port_sense_mode(ioport_port_t port,
		ioport_port_mask_t mask, enum ioport_sense pin_sense)
{
	Pio *base = arch_ioport_port_to_base(port);
  402d88:	60fb      	str	r3, [r7, #12]
	 *       1       0         0    IOPORT_SENSE_FALLING
	 *       1       0         1    IOPORT_SENSE_RISING
	 *       1       1         0    IOPORT_SENSE_LEVEL_LOW
	 *       1       1         1    IOPORT_SENSE_LEVEL_HIGH
	 */
	switch(pin_sense) {
  402d8a:	7dfb      	ldrb	r3, [r7, #23]
  402d8c:	3b01      	subs	r3, #1
  402d8e:	2b03      	cmp	r3, #3
  402d90:	d82e      	bhi.n	402df0 <ioport_set_pin_sense_mode+0xb0>
  402d92:	a201      	add	r2, pc, #4	; (adr r2, 402d98 <ioport_set_pin_sense_mode+0x58>)
  402d94:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  402d98:	00402dcd 	.word	0x00402dcd
  402d9c:	00402ddf 	.word	0x00402ddf
  402da0:	00402da9 	.word	0x00402da9
  402da4:	00402dbb 	.word	0x00402dbb
	case IOPORT_SENSE_LEVEL_LOW:
		base->PIO_LSR = mask;
  402da8:	68fb      	ldr	r3, [r7, #12]
  402daa:	69ba      	ldr	r2, [r7, #24]
  402dac:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
		base->PIO_FELLSR = mask;
  402db0:	68fb      	ldr	r3, [r7, #12]
  402db2:	69ba      	ldr	r2, [r7, #24]
  402db4:	f8c3 20d0 	str.w	r2, [r3, #208]	; 0xd0
  402db8:	e01f      	b.n	402dfa <ioport_set_pin_sense_mode+0xba>
		break;
	case IOPORT_SENSE_LEVEL_HIGH:
		base->PIO_LSR = mask;
  402dba:	68fb      	ldr	r3, [r7, #12]
  402dbc:	69ba      	ldr	r2, [r7, #24]
  402dbe:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
		base->PIO_REHLSR = mask;
  402dc2:	68fb      	ldr	r3, [r7, #12]
  402dc4:	69ba      	ldr	r2, [r7, #24]
  402dc6:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
  402dca:	e016      	b.n	402dfa <ioport_set_pin_sense_mode+0xba>
		break;
	case IOPORT_SENSE_FALLING:
		base->PIO_ESR = mask;
  402dcc:	68fb      	ldr	r3, [r7, #12]
  402dce:	69ba      	ldr	r2, [r7, #24]
  402dd0:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
		base->PIO_FELLSR = mask;
  402dd4:	68fb      	ldr	r3, [r7, #12]
  402dd6:	69ba      	ldr	r2, [r7, #24]
  402dd8:	f8c3 20d0 	str.w	r2, [r3, #208]	; 0xd0
  402ddc:	e00d      	b.n	402dfa <ioport_set_pin_sense_mode+0xba>
		break;
	case IOPORT_SENSE_RISING:
		base->PIO_ESR = mask;
  402dde:	68fb      	ldr	r3, [r7, #12]
  402de0:	69ba      	ldr	r2, [r7, #24]
  402de2:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
		base->PIO_REHLSR = mask;
  402de6:	68fb      	ldr	r3, [r7, #12]
  402de8:	69ba      	ldr	r2, [r7, #24]
  402dea:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
  402dee:	e004      	b.n	402dfa <ioport_set_pin_sense_mode+0xba>
		break;
	default:
		base->PIO_AIMDR = mask;
  402df0:	68fb      	ldr	r3, [r7, #12]
  402df2:	69ba      	ldr	r2, [r7, #24]
  402df4:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
	arch_ioport_set_pin_sense_mode(pin, pin_sense);
}
  402df8:	e003      	b.n	402e02 <ioport_set_pin_sense_mode+0xc2>
		return;
	}
	base->PIO_AIMER = mask;
  402dfa:	68fb      	ldr	r3, [r7, #12]
  402dfc:	69ba      	ldr	r2, [r7, #24]
  402dfe:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
  402e02:	bf00      	nop
  402e04:	3734      	adds	r7, #52	; 0x34
  402e06:	46bd      	mov	sp, r7
  402e08:	f85d 7b04 	ldr.w	r7, [sp], #4
  402e0c:	4770      	bx	lr
  402e0e:	bf00      	nop

00402e10 <board_init>:
		ioport_set_pin_sense_mode(pin, sense);\
	} while (0)


void board_init(void)
{
  402e10:	b580      	push	{r7, lr}
  402e12:	af00      	add	r7, sp, #0
	*/
	WDT->WDT_MR = WDT_MR_WDDIS;
#endif

	/* Initialize IOPORTs */
	ioport_init();
  402e14:	4ba3      	ldr	r3, [pc, #652]	; (4030a4 <board_init+0x294>)
  402e16:	4798      	blx	r3

	/* Configure the pins connected to LED as output and set their
	 * default initial state to high (LED off).
	 */
	ioport_set_pin_dir(LED0_GPIO, IOPORT_DIR_OUTPUT);
  402e18:	2101      	movs	r1, #1
  402e1a:	2076      	movs	r0, #118	; 0x76
  402e1c:	4ba2      	ldr	r3, [pc, #648]	; (4030a8 <board_init+0x298>)
  402e1e:	4798      	blx	r3
	ioport_set_pin_level(LED0_GPIO, LED0_INACTIVE_LEVEL);
  402e20:	2101      	movs	r1, #1
  402e22:	2076      	movs	r0, #118	; 0x76
  402e24:	4ba1      	ldr	r3, [pc, #644]	; (4030ac <board_init+0x29c>)
  402e26:	4798      	blx	r3

	/* Configure Push Button pins */
	ioport_set_pin_input_mode(GPIO_PUSH_BUTTON_1, GPIO_PUSH_BUTTON_1_FLAGS,
  402e28:	2100      	movs	r1, #0
  402e2a:	2002      	movs	r0, #2
  402e2c:	4b9e      	ldr	r3, [pc, #632]	; (4030a8 <board_init+0x298>)
  402e2e:	4798      	blx	r3
  402e30:	2188      	movs	r1, #136	; 0x88
  402e32:	2002      	movs	r0, #2
  402e34:	4b9e      	ldr	r3, [pc, #632]	; (4030b0 <board_init+0x2a0>)
  402e36:	4798      	blx	r3
  402e38:	2102      	movs	r1, #2
  402e3a:	2002      	movs	r0, #2
  402e3c:	4b9d      	ldr	r3, [pc, #628]	; (4030b4 <board_init+0x2a4>)
  402e3e:	4798      	blx	r3
			GPIO_PUSH_BUTTON_1_SENSE);

#ifdef CONF_BOARD_UART_CONSOLE
	/* Configure UART pins */
	ioport_set_port_peripheral_mode(PINS_UART0_PORT, PINS_UART0,
  402e40:	2200      	movs	r2, #0
  402e42:	f44f 61c0 	mov.w	r1, #1536	; 0x600
  402e46:	2000      	movs	r0, #0
  402e48:	4b9b      	ldr	r3, [pc, #620]	; (4030b8 <board_init+0x2a8>)
  402e4a:	4798      	blx	r3
  402e4c:	f44f 61c0 	mov.w	r1, #1536	; 0x600
  402e50:	2000      	movs	r0, #0
  402e52:	4b9a      	ldr	r3, [pc, #616]	; (4030bc <board_init+0x2ac>)
  402e54:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_HSMCI_MCDA2_GPIO, PIN_HSMCI_MCDA2_FLAGS);
	ioport_set_pin_peripheral_mode(PIN_HSMCI_MCDA3_GPIO, PIN_HSMCI_MCDA3_FLAGS);
#endif

#ifdef CONF_BOARD_KSZ8051MNL
	ioport_set_pin_peripheral_mode(PIN_KSZ8051MNL_RXC_IDX,
  402e56:	2100      	movs	r1, #0
  402e58:	206e      	movs	r0, #110	; 0x6e
  402e5a:	4b95      	ldr	r3, [pc, #596]	; (4030b0 <board_init+0x2a0>)
  402e5c:	4798      	blx	r3
  402e5e:	206e      	movs	r0, #110	; 0x6e
  402e60:	4b97      	ldr	r3, [pc, #604]	; (4030c0 <board_init+0x2b0>)
  402e62:	4798      	blx	r3
			PIN_KSZ8051MNL_RXC_FLAGS);
	ioport_set_pin_peripheral_mode(PIN_KSZ8051MNL_TXC_IDX,
  402e64:	2100      	movs	r1, #0
  402e66:	2060      	movs	r0, #96	; 0x60
  402e68:	4b91      	ldr	r3, [pc, #580]	; (4030b0 <board_init+0x2a0>)
  402e6a:	4798      	blx	r3
  402e6c:	2060      	movs	r0, #96	; 0x60
  402e6e:	4b94      	ldr	r3, [pc, #592]	; (4030c0 <board_init+0x2b0>)
  402e70:	4798      	blx	r3
			PIN_KSZ8051MNL_TXC_FLAGS);
	ioport_set_pin_peripheral_mode(PIN_KSZ8051MNL_TXEN_IDX,
  402e72:	2100      	movs	r1, #0
  402e74:	2061      	movs	r0, #97	; 0x61
  402e76:	4b8e      	ldr	r3, [pc, #568]	; (4030b0 <board_init+0x2a0>)
  402e78:	4798      	blx	r3
  402e7a:	2061      	movs	r0, #97	; 0x61
  402e7c:	4b90      	ldr	r3, [pc, #576]	; (4030c0 <board_init+0x2b0>)
  402e7e:	4798      	blx	r3
			PIN_KSZ8051MNL_TXEN_FLAGS);
	ioport_set_pin_peripheral_mode(PIN_KSZ8051MNL_TXD3_IDX,
  402e80:	2100      	movs	r1, #0
  402e82:	2070      	movs	r0, #112	; 0x70
  402e84:	4b8a      	ldr	r3, [pc, #552]	; (4030b0 <board_init+0x2a0>)
  402e86:	4798      	blx	r3
  402e88:	2070      	movs	r0, #112	; 0x70
  402e8a:	4b8d      	ldr	r3, [pc, #564]	; (4030c0 <board_init+0x2b0>)
  402e8c:	4798      	blx	r3
			PIN_KSZ8051MNL_TXD3_FLAGS);
	ioport_set_pin_peripheral_mode(PIN_KSZ8051MNL_TXD2_IDX,
  402e8e:	2100      	movs	r1, #0
  402e90:	206f      	movs	r0, #111	; 0x6f
  402e92:	4b87      	ldr	r3, [pc, #540]	; (4030b0 <board_init+0x2a0>)
  402e94:	4798      	blx	r3
  402e96:	206f      	movs	r0, #111	; 0x6f
  402e98:	4b89      	ldr	r3, [pc, #548]	; (4030c0 <board_init+0x2b0>)
  402e9a:	4798      	blx	r3
			PIN_KSZ8051MNL_TXD2_FLAGS);
	ioport_set_pin_peripheral_mode(PIN_KSZ8051MNL_TXD1_IDX,
  402e9c:	2100      	movs	r1, #0
  402e9e:	2063      	movs	r0, #99	; 0x63
  402ea0:	4b83      	ldr	r3, [pc, #524]	; (4030b0 <board_init+0x2a0>)
  402ea2:	4798      	blx	r3
  402ea4:	2063      	movs	r0, #99	; 0x63
  402ea6:	4b86      	ldr	r3, [pc, #536]	; (4030c0 <board_init+0x2b0>)
  402ea8:	4798      	blx	r3
			PIN_KSZ8051MNL_TXD1_FLAGS);
	ioport_set_pin_peripheral_mode(PIN_KSZ8051MNL_TXD0_IDX,
  402eaa:	2100      	movs	r1, #0
  402eac:	2062      	movs	r0, #98	; 0x62
  402eae:	4b80      	ldr	r3, [pc, #512]	; (4030b0 <board_init+0x2a0>)
  402eb0:	4798      	blx	r3
  402eb2:	2062      	movs	r0, #98	; 0x62
  402eb4:	4b82      	ldr	r3, [pc, #520]	; (4030c0 <board_init+0x2b0>)
  402eb6:	4798      	blx	r3
			PIN_KSZ8051MNL_TXD0_FLAGS);
	ioport_set_pin_peripheral_mode(PIN_KSZ8051MNL_RXD3_IDX,
  402eb8:	2100      	movs	r1, #0
  402eba:	206c      	movs	r0, #108	; 0x6c
  402ebc:	4b7c      	ldr	r3, [pc, #496]	; (4030b0 <board_init+0x2a0>)
  402ebe:	4798      	blx	r3
  402ec0:	206c      	movs	r0, #108	; 0x6c
  402ec2:	4b7f      	ldr	r3, [pc, #508]	; (4030c0 <board_init+0x2b0>)
  402ec4:	4798      	blx	r3
			PIN_KSZ8051MNL_RXD3_FLAGS);
	ioport_set_pin_peripheral_mode(PIN_KSZ8051MNL_RXD2_IDX,
  402ec6:	2100      	movs	r1, #0
  402ec8:	206b      	movs	r0, #107	; 0x6b
  402eca:	4b79      	ldr	r3, [pc, #484]	; (4030b0 <board_init+0x2a0>)
  402ecc:	4798      	blx	r3
  402ece:	206b      	movs	r0, #107	; 0x6b
  402ed0:	4b7b      	ldr	r3, [pc, #492]	; (4030c0 <board_init+0x2b0>)
  402ed2:	4798      	blx	r3
			PIN_KSZ8051MNL_RXD2_FLAGS);
	ioport_set_pin_peripheral_mode(PIN_KSZ8051MNL_RXD1_IDX,
  402ed4:	2100      	movs	r1, #0
  402ed6:	2066      	movs	r0, #102	; 0x66
  402ed8:	4b75      	ldr	r3, [pc, #468]	; (4030b0 <board_init+0x2a0>)
  402eda:	4798      	blx	r3
  402edc:	2066      	movs	r0, #102	; 0x66
  402ede:	4b78      	ldr	r3, [pc, #480]	; (4030c0 <board_init+0x2b0>)
  402ee0:	4798      	blx	r3
			PIN_KSZ8051MNL_RXD1_FLAGS);
	ioport_set_pin_peripheral_mode(PIN_KSZ8051MNL_RXD0_IDX,
  402ee2:	2100      	movs	r1, #0
  402ee4:	2065      	movs	r0, #101	; 0x65
  402ee6:	4b72      	ldr	r3, [pc, #456]	; (4030b0 <board_init+0x2a0>)
  402ee8:	4798      	blx	r3
  402eea:	2065      	movs	r0, #101	; 0x65
  402eec:	4b74      	ldr	r3, [pc, #464]	; (4030c0 <board_init+0x2b0>)
  402eee:	4798      	blx	r3
			PIN_KSZ8051MNL_RXD0_FLAGS);
	ioport_set_pin_peripheral_mode(PIN_KSZ8051MNL_RXER_IDX,
  402ef0:	2100      	movs	r1, #0
  402ef2:	2067      	movs	r0, #103	; 0x67
  402ef4:	4b6e      	ldr	r3, [pc, #440]	; (4030b0 <board_init+0x2a0>)
  402ef6:	4798      	blx	r3
  402ef8:	2067      	movs	r0, #103	; 0x67
  402efa:	4b71      	ldr	r3, [pc, #452]	; (4030c0 <board_init+0x2b0>)
  402efc:	4798      	blx	r3
			PIN_KSZ8051MNL_RXER_FLAGS);
	ioport_set_pin_peripheral_mode(PIN_KSZ8051MNL_RXDV_IDX,
  402efe:	2100      	movs	r1, #0
  402f00:	2064      	movs	r0, #100	; 0x64
  402f02:	4b6b      	ldr	r3, [pc, #428]	; (4030b0 <board_init+0x2a0>)
  402f04:	4798      	blx	r3
  402f06:	2064      	movs	r0, #100	; 0x64
  402f08:	4b6d      	ldr	r3, [pc, #436]	; (4030c0 <board_init+0x2b0>)
  402f0a:	4798      	blx	r3
			PIN_KSZ8051MNL_RXDV_FLAGS);
	ioport_set_pin_peripheral_mode(PIN_KSZ8051MNL_CRS_IDX,
  402f0c:	2100      	movs	r1, #0
  402f0e:	206a      	movs	r0, #106	; 0x6a
  402f10:	4b67      	ldr	r3, [pc, #412]	; (4030b0 <board_init+0x2a0>)
  402f12:	4798      	blx	r3
  402f14:	206a      	movs	r0, #106	; 0x6a
  402f16:	4b6a      	ldr	r3, [pc, #424]	; (4030c0 <board_init+0x2b0>)
  402f18:	4798      	blx	r3
			PIN_KSZ8051MNL_CRS_FLAGS);
	ioport_set_pin_peripheral_mode(PIN_KSZ8051MNL_COL_IDX,
  402f1a:	2100      	movs	r1, #0
  402f1c:	206d      	movs	r0, #109	; 0x6d
  402f1e:	4b64      	ldr	r3, [pc, #400]	; (4030b0 <board_init+0x2a0>)
  402f20:	4798      	blx	r3
  402f22:	206d      	movs	r0, #109	; 0x6d
  402f24:	4b66      	ldr	r3, [pc, #408]	; (4030c0 <board_init+0x2b0>)
  402f26:	4798      	blx	r3
			PIN_KSZ8051MNL_COL_FLAGS);
	ioport_set_pin_peripheral_mode(PIN_KSZ8051MNL_MDC_IDX,
  402f28:	2100      	movs	r1, #0
  402f2a:	2068      	movs	r0, #104	; 0x68
  402f2c:	4b60      	ldr	r3, [pc, #384]	; (4030b0 <board_init+0x2a0>)
  402f2e:	4798      	blx	r3
  402f30:	2068      	movs	r0, #104	; 0x68
  402f32:	4b63      	ldr	r3, [pc, #396]	; (4030c0 <board_init+0x2b0>)
  402f34:	4798      	blx	r3
			PIN_KSZ8051MNL_MDC_FLAGS);
	ioport_set_pin_peripheral_mode(PIN_KSZ8051MNL_MDIO_IDX,
  402f36:	2100      	movs	r1, #0
  402f38:	2069      	movs	r0, #105	; 0x69
  402f3a:	4b5d      	ldr	r3, [pc, #372]	; (4030b0 <board_init+0x2a0>)
  402f3c:	4798      	blx	r3
  402f3e:	2069      	movs	r0, #105	; 0x69
  402f40:	4b5f      	ldr	r3, [pc, #380]	; (4030c0 <board_init+0x2b0>)
  402f42:	4798      	blx	r3
			PIN_KSZ8051MNL_MDIO_FLAGS);
	ioport_set_pin_dir(PIN_KSZ8051MNL_INTRP_IDX, IOPORT_DIR_INPUT);
  402f44:	2100      	movs	r1, #0
  402f46:	207c      	movs	r0, #124	; 0x7c
  402f48:	4b57      	ldr	r3, [pc, #348]	; (4030a8 <board_init+0x298>)
  402f4a:	4798      	blx	r3
	ioport_set_pin_dir(PIN_NF_RB_IDX, IOPORT_DIR_INPUT);
	ioport_set_pin_mode(PIN_NF_RB_IDX, IOPORT_MODE_PULLUP);
#endif

#ifdef CONF_BOARD_SRAM
	ioport_set_pin_peripheral_mode(PIN_EBI_NCS1, PIN_EBI_NCS1_FLAGS);
  402f4c:	2100      	movs	r1, #0
  402f4e:	2072      	movs	r0, #114	; 0x72
  402f50:	4b57      	ldr	r3, [pc, #348]	; (4030b0 <board_init+0x2a0>)
  402f52:	4798      	blx	r3
  402f54:	2072      	movs	r0, #114	; 0x72
  402f56:	4b5a      	ldr	r3, [pc, #360]	; (4030c0 <board_init+0x2b0>)
  402f58:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_EBI_NCS3, PIN_EBI_NCS3_FLAGS);
  402f5a:	2100      	movs	r1, #0
  402f5c:	2073      	movs	r0, #115	; 0x73
  402f5e:	4b54      	ldr	r3, [pc, #336]	; (4030b0 <board_init+0x2a0>)
  402f60:	4798      	blx	r3
  402f62:	2073      	movs	r0, #115	; 0x73
  402f64:	4b56      	ldr	r3, [pc, #344]	; (4030c0 <board_init+0x2b0>)
  402f66:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_EBI_NRD, PIN_EBI_NRD_FLAGS);
  402f68:	2100      	movs	r1, #0
  402f6a:	204b      	movs	r0, #75	; 0x4b
  402f6c:	4b50      	ldr	r3, [pc, #320]	; (4030b0 <board_init+0x2a0>)
  402f6e:	4798      	blx	r3
  402f70:	204b      	movs	r0, #75	; 0x4b
  402f72:	4b53      	ldr	r3, [pc, #332]	; (4030c0 <board_init+0x2b0>)
  402f74:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_EBI_NWE, PIN_EBI_NWE_FLAGS);
  402f76:	2100      	movs	r1, #0
  402f78:	2048      	movs	r0, #72	; 0x48
  402f7a:	4b4d      	ldr	r3, [pc, #308]	; (4030b0 <board_init+0x2a0>)
  402f7c:	4798      	blx	r3
  402f7e:	2048      	movs	r0, #72	; 0x48
  402f80:	4b4f      	ldr	r3, [pc, #316]	; (4030c0 <board_init+0x2b0>)
  402f82:	4798      	blx	r3

	ioport_set_pin_peripheral_mode(PIN_EBI_DATA_BUS_D0, PIN_EBI_DATA_BUS_FLAGS);
  402f84:	2100      	movs	r1, #0
  402f86:	2040      	movs	r0, #64	; 0x40
  402f88:	4b49      	ldr	r3, [pc, #292]	; (4030b0 <board_init+0x2a0>)
  402f8a:	4798      	blx	r3
  402f8c:	2040      	movs	r0, #64	; 0x40
  402f8e:	4b4c      	ldr	r3, [pc, #304]	; (4030c0 <board_init+0x2b0>)
  402f90:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_EBI_DATA_BUS_D1, PIN_EBI_DATA_BUS_FLAGS);
  402f92:	2100      	movs	r1, #0
  402f94:	2041      	movs	r0, #65	; 0x41
  402f96:	4b46      	ldr	r3, [pc, #280]	; (4030b0 <board_init+0x2a0>)
  402f98:	4798      	blx	r3
  402f9a:	2041      	movs	r0, #65	; 0x41
  402f9c:	4b48      	ldr	r3, [pc, #288]	; (4030c0 <board_init+0x2b0>)
  402f9e:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_EBI_DATA_BUS_D2, PIN_EBI_DATA_BUS_FLAGS);
  402fa0:	2100      	movs	r1, #0
  402fa2:	2042      	movs	r0, #66	; 0x42
  402fa4:	4b42      	ldr	r3, [pc, #264]	; (4030b0 <board_init+0x2a0>)
  402fa6:	4798      	blx	r3
  402fa8:	2042      	movs	r0, #66	; 0x42
  402faa:	4b45      	ldr	r3, [pc, #276]	; (4030c0 <board_init+0x2b0>)
  402fac:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_EBI_DATA_BUS_D3, PIN_EBI_DATA_BUS_FLAGS);
  402fae:	2100      	movs	r1, #0
  402fb0:	2043      	movs	r0, #67	; 0x43
  402fb2:	4b3f      	ldr	r3, [pc, #252]	; (4030b0 <board_init+0x2a0>)
  402fb4:	4798      	blx	r3
  402fb6:	2043      	movs	r0, #67	; 0x43
  402fb8:	4b41      	ldr	r3, [pc, #260]	; (4030c0 <board_init+0x2b0>)
  402fba:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_EBI_DATA_BUS_D4, PIN_EBI_DATA_BUS_FLAGS);
  402fbc:	2100      	movs	r1, #0
  402fbe:	2044      	movs	r0, #68	; 0x44
  402fc0:	4b3b      	ldr	r3, [pc, #236]	; (4030b0 <board_init+0x2a0>)
  402fc2:	4798      	blx	r3
  402fc4:	2044      	movs	r0, #68	; 0x44
  402fc6:	4b3e      	ldr	r3, [pc, #248]	; (4030c0 <board_init+0x2b0>)
  402fc8:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_EBI_DATA_BUS_D5, PIN_EBI_DATA_BUS_FLAGS);
  402fca:	2100      	movs	r1, #0
  402fcc:	2045      	movs	r0, #69	; 0x45
  402fce:	4b38      	ldr	r3, [pc, #224]	; (4030b0 <board_init+0x2a0>)
  402fd0:	4798      	blx	r3
  402fd2:	2045      	movs	r0, #69	; 0x45
  402fd4:	4b3a      	ldr	r3, [pc, #232]	; (4030c0 <board_init+0x2b0>)
  402fd6:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_EBI_DATA_BUS_D6, PIN_EBI_DATA_BUS_FLAGS);
  402fd8:	2100      	movs	r1, #0
  402fda:	2046      	movs	r0, #70	; 0x46
  402fdc:	4b34      	ldr	r3, [pc, #208]	; (4030b0 <board_init+0x2a0>)
  402fde:	4798      	blx	r3
  402fe0:	2046      	movs	r0, #70	; 0x46
  402fe2:	4b37      	ldr	r3, [pc, #220]	; (4030c0 <board_init+0x2b0>)
  402fe4:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_EBI_DATA_BUS_D7, PIN_EBI_DATA_BUS_FLAGS);
  402fe6:	2100      	movs	r1, #0
  402fe8:	2047      	movs	r0, #71	; 0x47
  402fea:	4b31      	ldr	r3, [pc, #196]	; (4030b0 <board_init+0x2a0>)
  402fec:	4798      	blx	r3
  402fee:	2047      	movs	r0, #71	; 0x47
  402ff0:	4b33      	ldr	r3, [pc, #204]	; (4030c0 <board_init+0x2b0>)
  402ff2:	4798      	blx	r3

	ioport_set_pin_peripheral_mode(PIN_EBI_ADDR_BUS_A0, PIN_EBI_ADDR_BUS_FLAG1);
  402ff4:	2100      	movs	r1, #0
  402ff6:	2052      	movs	r0, #82	; 0x52
  402ff8:	4b2d      	ldr	r3, [pc, #180]	; (4030b0 <board_init+0x2a0>)
  402ffa:	4798      	blx	r3
  402ffc:	2052      	movs	r0, #82	; 0x52
  402ffe:	4b30      	ldr	r3, [pc, #192]	; (4030c0 <board_init+0x2b0>)
  403000:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_EBI_ADDR_BUS_A1, PIN_EBI_ADDR_BUS_FLAG1);
  403002:	2100      	movs	r1, #0
  403004:	2053      	movs	r0, #83	; 0x53
  403006:	4b2a      	ldr	r3, [pc, #168]	; (4030b0 <board_init+0x2a0>)
  403008:	4798      	blx	r3
  40300a:	2053      	movs	r0, #83	; 0x53
  40300c:	4b2c      	ldr	r3, [pc, #176]	; (4030c0 <board_init+0x2b0>)
  40300e:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_EBI_ADDR_BUS_A2, PIN_EBI_ADDR_BUS_FLAG1);
  403010:	2100      	movs	r1, #0
  403012:	2054      	movs	r0, #84	; 0x54
  403014:	4b26      	ldr	r3, [pc, #152]	; (4030b0 <board_init+0x2a0>)
  403016:	4798      	blx	r3
  403018:	2054      	movs	r0, #84	; 0x54
  40301a:	4b29      	ldr	r3, [pc, #164]	; (4030c0 <board_init+0x2b0>)
  40301c:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_EBI_ADDR_BUS_A3, PIN_EBI_ADDR_BUS_FLAG1);
  40301e:	2100      	movs	r1, #0
  403020:	2055      	movs	r0, #85	; 0x55
  403022:	4b23      	ldr	r3, [pc, #140]	; (4030b0 <board_init+0x2a0>)
  403024:	4798      	blx	r3
  403026:	2055      	movs	r0, #85	; 0x55
  403028:	4b25      	ldr	r3, [pc, #148]	; (4030c0 <board_init+0x2b0>)
  40302a:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_EBI_ADDR_BUS_A4, PIN_EBI_ADDR_BUS_FLAG1);
  40302c:	2100      	movs	r1, #0
  40302e:	2056      	movs	r0, #86	; 0x56
  403030:	4b1f      	ldr	r3, [pc, #124]	; (4030b0 <board_init+0x2a0>)
  403032:	4798      	blx	r3
  403034:	2056      	movs	r0, #86	; 0x56
  403036:	4b22      	ldr	r3, [pc, #136]	; (4030c0 <board_init+0x2b0>)
  403038:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_EBI_ADDR_BUS_A5, PIN_EBI_ADDR_BUS_FLAG1);
  40303a:	2100      	movs	r1, #0
  40303c:	2057      	movs	r0, #87	; 0x57
  40303e:	4b1c      	ldr	r3, [pc, #112]	; (4030b0 <board_init+0x2a0>)
  403040:	4798      	blx	r3
  403042:	2057      	movs	r0, #87	; 0x57
  403044:	4b1e      	ldr	r3, [pc, #120]	; (4030c0 <board_init+0x2b0>)
  403046:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_EBI_ADDR_BUS_A6, PIN_EBI_ADDR_BUS_FLAG1);
  403048:	2100      	movs	r1, #0
  40304a:	2058      	movs	r0, #88	; 0x58
  40304c:	4b18      	ldr	r3, [pc, #96]	; (4030b0 <board_init+0x2a0>)
  40304e:	4798      	blx	r3
  403050:	2058      	movs	r0, #88	; 0x58
  403052:	4b1b      	ldr	r3, [pc, #108]	; (4030c0 <board_init+0x2b0>)
  403054:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_EBI_ADDR_BUS_A7, PIN_EBI_ADDR_BUS_FLAG1);
  403056:	2100      	movs	r1, #0
  403058:	2059      	movs	r0, #89	; 0x59
  40305a:	4b15      	ldr	r3, [pc, #84]	; (4030b0 <board_init+0x2a0>)
  40305c:	4798      	blx	r3
  40305e:	2059      	movs	r0, #89	; 0x59
  403060:	4b17      	ldr	r3, [pc, #92]	; (4030c0 <board_init+0x2b0>)
  403062:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_EBI_ADDR_BUS_A8, PIN_EBI_ADDR_BUS_FLAG1);
  403064:	2100      	movs	r1, #0
  403066:	205a      	movs	r0, #90	; 0x5a
  403068:	4b11      	ldr	r3, [pc, #68]	; (4030b0 <board_init+0x2a0>)
  40306a:	4798      	blx	r3
  40306c:	205a      	movs	r0, #90	; 0x5a
  40306e:	4b14      	ldr	r3, [pc, #80]	; (4030c0 <board_init+0x2b0>)
  403070:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_EBI_ADDR_BUS_A9, PIN_EBI_ADDR_BUS_FLAG1);
  403072:	2100      	movs	r1, #0
  403074:	205b      	movs	r0, #91	; 0x5b
  403076:	4b0e      	ldr	r3, [pc, #56]	; (4030b0 <board_init+0x2a0>)
  403078:	4798      	blx	r3
  40307a:	205b      	movs	r0, #91	; 0x5b
  40307c:	4b10      	ldr	r3, [pc, #64]	; (4030c0 <board_init+0x2b0>)
  40307e:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_EBI_ADDR_BUS_A10,
  403080:	2100      	movs	r1, #0
  403082:	205c      	movs	r0, #92	; 0x5c
  403084:	4b0a      	ldr	r3, [pc, #40]	; (4030b0 <board_init+0x2a0>)
  403086:	4798      	blx	r3
  403088:	205c      	movs	r0, #92	; 0x5c
  40308a:	4b0d      	ldr	r3, [pc, #52]	; (4030c0 <board_init+0x2b0>)
  40308c:	4798      	blx	r3
			PIN_EBI_ADDR_BUS_FLAG1);
	ioport_set_pin_peripheral_mode(PIN_EBI_ADDR_BUS_A11,
  40308e:	2100      	movs	r1, #0
  403090:	205d      	movs	r0, #93	; 0x5d
  403092:	4b07      	ldr	r3, [pc, #28]	; (4030b0 <board_init+0x2a0>)
  403094:	4798      	blx	r3
  403096:	205d      	movs	r0, #93	; 0x5d
  403098:	4b09      	ldr	r3, [pc, #36]	; (4030c0 <board_init+0x2b0>)
  40309a:	4798      	blx	r3
			PIN_EBI_ADDR_BUS_FLAG1);
	ioport_set_pin_peripheral_mode(PIN_EBI_ADDR_BUS_A12,
  40309c:	2100      	movs	r1, #0
  40309e:	205e      	movs	r0, #94	; 0x5e
  4030a0:	e010      	b.n	4030c4 <board_init+0x2b4>
  4030a2:	bf00      	nop
  4030a4:	00402985 	.word	0x00402985
  4030a8:	00402c4d 	.word	0x00402c4d
  4030ac:	00402cd5 	.word	0x00402cd5
  4030b0:	00402b31 	.word	0x00402b31
  4030b4:	00402d41 	.word	0x00402d41
  4030b8:	00402a2f 	.word	0x00402a2f
  4030bc:	004029fb 	.word	0x004029fb
  4030c0:	004029b1 	.word	0x004029b1
  4030c4:	4b2a      	ldr	r3, [pc, #168]	; (403170 <board_init+0x360>)
  4030c6:	4798      	blx	r3
  4030c8:	205e      	movs	r0, #94	; 0x5e
  4030ca:	4b2a      	ldr	r3, [pc, #168]	; (403174 <board_init+0x364>)
  4030cc:	4798      	blx	r3
			PIN_EBI_ADDR_BUS_FLAG1);
	ioport_set_pin_peripheral_mode(PIN_EBI_ADDR_BUS_A13,
  4030ce:	2100      	movs	r1, #0
  4030d0:	205f      	movs	r0, #95	; 0x5f
  4030d2:	4b27      	ldr	r3, [pc, #156]	; (403170 <board_init+0x360>)
  4030d4:	4798      	blx	r3
  4030d6:	205f      	movs	r0, #95	; 0x5f
  4030d8:	4b26      	ldr	r3, [pc, #152]	; (403174 <board_init+0x364>)
  4030da:	4798      	blx	r3
			PIN_EBI_ADDR_BUS_FLAG1);
	ioport_set_pin_peripheral_mode(PIN_EBI_ADDR_BUS_A14,
  4030dc:	2102      	movs	r1, #2
  4030de:	2012      	movs	r0, #18
  4030e0:	4b23      	ldr	r3, [pc, #140]	; (403170 <board_init+0x360>)
  4030e2:	4798      	blx	r3
  4030e4:	2012      	movs	r0, #18
  4030e6:	4b23      	ldr	r3, [pc, #140]	; (403174 <board_init+0x364>)
  4030e8:	4798      	blx	r3
			PIN_EBI_ADDR_BUS_FLAG2);
	ioport_set_pin_peripheral_mode(PIN_EBI_ADDR_BUS_A15,
  4030ea:	2102      	movs	r1, #2
  4030ec:	2013      	movs	r0, #19
  4030ee:	4b20      	ldr	r3, [pc, #128]	; (403170 <board_init+0x360>)
  4030f0:	4798      	blx	r3
  4030f2:	2013      	movs	r0, #19
  4030f4:	4b1f      	ldr	r3, [pc, #124]	; (403174 <board_init+0x364>)
  4030f6:	4798      	blx	r3
			PIN_EBI_ADDR_BUS_FLAG2);
	ioport_set_pin_peripheral_mode(PIN_EBI_ADDR_BUS_A16,
  4030f8:	2102      	movs	r1, #2
  4030fa:	2014      	movs	r0, #20
  4030fc:	4b1c      	ldr	r3, [pc, #112]	; (403170 <board_init+0x360>)
  4030fe:	4798      	blx	r3
  403100:	2014      	movs	r0, #20
  403102:	4b1c      	ldr	r3, [pc, #112]	; (403174 <board_init+0x364>)
  403104:	4798      	blx	r3
			PIN_EBI_ADDR_BUS_FLAG2);
	ioport_set_pin_peripheral_mode(PIN_EBI_ADDR_BUS_A17,
  403106:	2102      	movs	r1, #2
  403108:	2000      	movs	r0, #0
  40310a:	4b19      	ldr	r3, [pc, #100]	; (403170 <board_init+0x360>)
  40310c:	4798      	blx	r3
  40310e:	2000      	movs	r0, #0
  403110:	4b18      	ldr	r3, [pc, #96]	; (403174 <board_init+0x364>)
  403112:	4798      	blx	r3
			PIN_EBI_ADDR_BUS_FLAG2);
	ioport_set_pin_peripheral_mode(PIN_EBI_ADDR_BUS_A18,
  403114:	2102      	movs	r1, #2
  403116:	2001      	movs	r0, #1
  403118:	4b15      	ldr	r3, [pc, #84]	; (403170 <board_init+0x360>)
  40311a:	4798      	blx	r3
  40311c:	2001      	movs	r0, #1
  40311e:	4b15      	ldr	r3, [pc, #84]	; (403174 <board_init+0x364>)
  403120:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(TWI0_DATA_GPIO, TWI0_DATA_FLAGS);
	ioport_set_pin_peripheral_mode(TWI0_CLK_GPIO, TWI0_CLK_FLAGS);
#endif

#ifdef CONF_BOARD_SPI	
	ioport_set_pin_peripheral_mode(SPI_MISO_GPIO, SPI_MISO_FLAGS);
  403122:	2100      	movs	r1, #0
  403124:	200c      	movs	r0, #12
  403126:	4b12      	ldr	r3, [pc, #72]	; (403170 <board_init+0x360>)
  403128:	4798      	blx	r3
  40312a:	200c      	movs	r0, #12
  40312c:	4b11      	ldr	r3, [pc, #68]	; (403174 <board_init+0x364>)
  40312e:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(SPI_MOSI_GPIO, SPI_MOSI_FLAGS);
  403130:	2100      	movs	r1, #0
  403132:	200d      	movs	r0, #13
  403134:	4b0e      	ldr	r3, [pc, #56]	; (403170 <board_init+0x360>)
  403136:	4798      	blx	r3
  403138:	200d      	movs	r0, #13
  40313a:	4b0e      	ldr	r3, [pc, #56]	; (403174 <board_init+0x364>)
  40313c:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(SPI_SPCK_GPIO,  SPI_SPCK_FLAGS);
  40313e:	2100      	movs	r1, #0
  403140:	200e      	movs	r0, #14
  403142:	4b0b      	ldr	r3, [pc, #44]	; (403170 <board_init+0x360>)
  403144:	4798      	blx	r3
  403146:	200e      	movs	r0, #14
  403148:	4b0a      	ldr	r3, [pc, #40]	; (403174 <board_init+0x364>)
  40314a:	4798      	blx	r3
	
	//ioport_set_pin_peripheral_mode(SPI_NPCS1_PB14_GPIO, SPI_NPCS1_PB14_FLAGS);

	//ioport_set_pin_peripheral_mode(SPI_NPCS0_GPIO, SPI_NPCS0_FLAGS);			// HICS (Conector EXT1)
	ioport_set_pin_peripheral_mode(SPI_NPCS3_PA5_GPIO, SPI_NPCS3_PA5_FLAGS);	// HICS	(Conector EXT3)
  40314c:	2101      	movs	r1, #1
  40314e:	2005      	movs	r0, #5
  403150:	4b07      	ldr	r3, [pc, #28]	; (403170 <board_init+0x360>)
  403152:	4798      	blx	r3
  403154:	2005      	movs	r0, #5
  403156:	4b07      	ldr	r3, [pc, #28]	; (403174 <board_init+0x364>)
  403158:	4798      	blx	r3

#endif	

	// HICS: Utilizar PA24 (conector EXT1-5) como sinal de teste da ISR ADC
	ioport_set_pin_dir(PIO_PA24_IDX, IOPORT_DIR_OUTPUT);
  40315a:	2101      	movs	r1, #1
  40315c:	2018      	movs	r0, #24
  40315e:	4b06      	ldr	r3, [pc, #24]	; (403178 <board_init+0x368>)
  403160:	4798      	blx	r3
	ioport_set_pin_level(PIO_PA24_IDX, IOPORT_PIN_LEVEL_LOW);
  403162:	2100      	movs	r1, #0
  403164:	2018      	movs	r0, #24
  403166:	4b05      	ldr	r3, [pc, #20]	; (40317c <board_init+0x36c>)
  403168:	4798      	blx	r3

}
  40316a:	bf00      	nop
  40316c:	bd80      	pop	{r7, pc}
  40316e:	bf00      	nop
  403170:	00402b31 	.word	0x00402b31
  403174:	004029b1 	.word	0x004029b1
  403178:	00402c4d 	.word	0x00402c4d
  40317c:	00402cd5 	.word	0x00402cd5

00403180 <gmac_enable_receive>:
 *
 * \param p_gmac   Pointer to the GMAC instance.
 * \param uc_enable   0 to disable GMAC receiver, else to enable it.
 */
static inline void gmac_enable_receive(Gmac* p_gmac, uint8_t uc_enable)
{
  403180:	b480      	push	{r7}
  403182:	b083      	sub	sp, #12
  403184:	af00      	add	r7, sp, #0
  403186:	6078      	str	r0, [r7, #4]
  403188:	460b      	mov	r3, r1
  40318a:	70fb      	strb	r3, [r7, #3]
	if (uc_enable) {
  40318c:	78fb      	ldrb	r3, [r7, #3]
  40318e:	2b00      	cmp	r3, #0
  403190:	d006      	beq.n	4031a0 <gmac_enable_receive+0x20>
		p_gmac->GMAC_NCR |= GMAC_NCR_RXEN;
  403192:	687b      	ldr	r3, [r7, #4]
  403194:	681b      	ldr	r3, [r3, #0]
  403196:	f043 0204 	orr.w	r2, r3, #4
  40319a:	687b      	ldr	r3, [r7, #4]
  40319c:	601a      	str	r2, [r3, #0]
	} else {
		p_gmac->GMAC_NCR &= ~GMAC_NCR_RXEN;
	}
}
  40319e:	e005      	b.n	4031ac <gmac_enable_receive+0x2c>
		p_gmac->GMAC_NCR &= ~GMAC_NCR_RXEN;
  4031a0:	687b      	ldr	r3, [r7, #4]
  4031a2:	681b      	ldr	r3, [r3, #0]
  4031a4:	f023 0204 	bic.w	r2, r3, #4
  4031a8:	687b      	ldr	r3, [r7, #4]
  4031aa:	601a      	str	r2, [r3, #0]
}
  4031ac:	bf00      	nop
  4031ae:	370c      	adds	r7, #12
  4031b0:	46bd      	mov	sp, r7
  4031b2:	f85d 7b04 	ldr.w	r7, [sp], #4
  4031b6:	4770      	bx	lr

004031b8 <gmac_enable_transmit>:
 *
 * \param p_gmac   Pointer to the GMAC instance.
 * \param uc_enable   0 to disable GMAC transmit, else to enable it.
 */
static inline void gmac_enable_transmit(Gmac* p_gmac, uint8_t uc_enable)
{
  4031b8:	b480      	push	{r7}
  4031ba:	b083      	sub	sp, #12
  4031bc:	af00      	add	r7, sp, #0
  4031be:	6078      	str	r0, [r7, #4]
  4031c0:	460b      	mov	r3, r1
  4031c2:	70fb      	strb	r3, [r7, #3]
	if (uc_enable) {
  4031c4:	78fb      	ldrb	r3, [r7, #3]
  4031c6:	2b00      	cmp	r3, #0
  4031c8:	d006      	beq.n	4031d8 <gmac_enable_transmit+0x20>
		p_gmac->GMAC_NCR |= GMAC_NCR_TXEN;
  4031ca:	687b      	ldr	r3, [r7, #4]
  4031cc:	681b      	ldr	r3, [r3, #0]
  4031ce:	f043 0208 	orr.w	r2, r3, #8
  4031d2:	687b      	ldr	r3, [r7, #4]
  4031d4:	601a      	str	r2, [r3, #0]
	} else {
		p_gmac->GMAC_NCR &= ~GMAC_NCR_TXEN;
	}
}
  4031d6:	e005      	b.n	4031e4 <gmac_enable_transmit+0x2c>
		p_gmac->GMAC_NCR &= ~GMAC_NCR_TXEN;
  4031d8:	687b      	ldr	r3, [r7, #4]
  4031da:	681b      	ldr	r3, [r3, #0]
  4031dc:	f023 0208 	bic.w	r2, r3, #8
  4031e0:	687b      	ldr	r3, [r7, #4]
  4031e2:	601a      	str	r2, [r3, #0]
}
  4031e4:	bf00      	nop
  4031e6:	370c      	adds	r7, #12
  4031e8:	46bd      	mov	sp, r7
  4031ea:	f85d 7b04 	ldr.w	r7, [sp], #4
  4031ee:	4770      	bx	lr

004031f0 <gmac_enable_management>:
 *
 * \param p_gmac   Pointer to the GMAC instance.
 * \param uc_enable   0 to disable GMAC management, else to enable it.
 */
static inline void gmac_enable_management(Gmac* p_gmac, uint8_t uc_enable)
{
  4031f0:	b480      	push	{r7}
  4031f2:	b083      	sub	sp, #12
  4031f4:	af00      	add	r7, sp, #0
  4031f6:	6078      	str	r0, [r7, #4]
  4031f8:	460b      	mov	r3, r1
  4031fa:	70fb      	strb	r3, [r7, #3]
	if (uc_enable) {
  4031fc:	78fb      	ldrb	r3, [r7, #3]
  4031fe:	2b00      	cmp	r3, #0
  403200:	d006      	beq.n	403210 <gmac_enable_management+0x20>
		p_gmac->GMAC_NCR |= GMAC_NCR_MPE;
  403202:	687b      	ldr	r3, [r7, #4]
  403204:	681b      	ldr	r3, [r3, #0]
  403206:	f043 0210 	orr.w	r2, r3, #16
  40320a:	687b      	ldr	r3, [r7, #4]
  40320c:	601a      	str	r2, [r3, #0]
	} else {
		p_gmac->GMAC_NCR &= ~GMAC_NCR_MPE;
	}
}
  40320e:	e005      	b.n	40321c <gmac_enable_management+0x2c>
		p_gmac->GMAC_NCR &= ~GMAC_NCR_MPE;
  403210:	687b      	ldr	r3, [r7, #4]
  403212:	681b      	ldr	r3, [r3, #0]
  403214:	f023 0210 	bic.w	r2, r3, #16
  403218:	687b      	ldr	r3, [r7, #4]
  40321a:	601a      	str	r2, [r3, #0]
}
  40321c:	bf00      	nop
  40321e:	370c      	adds	r7, #12
  403220:	46bd      	mov	sp, r7
  403222:	f85d 7b04 	ldr.w	r7, [sp], #4
  403226:	4770      	bx	lr

00403228 <gmac_set_speed>:
 *
 * \param p_gmac   Pointer to the GMAC instance.
 * \param uc_speed 1 to indicate 100Mbps, 0 to 10Mbps.
 */
static inline void gmac_set_speed(Gmac* p_gmac, uint8_t uc_speed)
{
  403228:	b480      	push	{r7}
  40322a:	b083      	sub	sp, #12
  40322c:	af00      	add	r7, sp, #0
  40322e:	6078      	str	r0, [r7, #4]
  403230:	460b      	mov	r3, r1
  403232:	70fb      	strb	r3, [r7, #3]
	if (uc_speed) {
  403234:	78fb      	ldrb	r3, [r7, #3]
  403236:	2b00      	cmp	r3, #0
  403238:	d006      	beq.n	403248 <gmac_set_speed+0x20>
		p_gmac->GMAC_NCFGR |= GMAC_NCFGR_SPD;
  40323a:	687b      	ldr	r3, [r7, #4]
  40323c:	685b      	ldr	r3, [r3, #4]
  40323e:	f043 0201 	orr.w	r2, r3, #1
  403242:	687b      	ldr	r3, [r7, #4]
  403244:	605a      	str	r2, [r3, #4]
	} else {
		p_gmac->GMAC_NCFGR &= ~GMAC_NCFGR_SPD;
	}
}
  403246:	e005      	b.n	403254 <gmac_set_speed+0x2c>
		p_gmac->GMAC_NCFGR &= ~GMAC_NCFGR_SPD;
  403248:	687b      	ldr	r3, [r7, #4]
  40324a:	685b      	ldr	r3, [r3, #4]
  40324c:	f023 0201 	bic.w	r2, r3, #1
  403250:	687b      	ldr	r3, [r7, #4]
  403252:	605a      	str	r2, [r3, #4]
}
  403254:	bf00      	nop
  403256:	370c      	adds	r7, #12
  403258:	46bd      	mov	sp, r7
  40325a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40325e:	4770      	bx	lr

00403260 <gmac_enable_full_duplex>:
 *
 * \param p_gmac   Pointer to the GMAC instance.
 * \param uc_enable   0 to disable the Full-Duplex mode, else to enable it.
 */
static inline void gmac_enable_full_duplex(Gmac* p_gmac, uint8_t uc_enable)
{
  403260:	b480      	push	{r7}
  403262:	b083      	sub	sp, #12
  403264:	af00      	add	r7, sp, #0
  403266:	6078      	str	r0, [r7, #4]
  403268:	460b      	mov	r3, r1
  40326a:	70fb      	strb	r3, [r7, #3]
	if (uc_enable) {
  40326c:	78fb      	ldrb	r3, [r7, #3]
  40326e:	2b00      	cmp	r3, #0
  403270:	d006      	beq.n	403280 <gmac_enable_full_duplex+0x20>
		p_gmac->GMAC_NCFGR |= GMAC_NCFGR_FD;
  403272:	687b      	ldr	r3, [r7, #4]
  403274:	685b      	ldr	r3, [r3, #4]
  403276:	f043 0202 	orr.w	r2, r3, #2
  40327a:	687b      	ldr	r3, [r7, #4]
  40327c:	605a      	str	r2, [r3, #4]
	} else {
		p_gmac->GMAC_NCFGR &= ~GMAC_NCFGR_FD;
	}
}
  40327e:	e005      	b.n	40328c <gmac_enable_full_duplex+0x2c>
		p_gmac->GMAC_NCFGR &= ~GMAC_NCFGR_FD;
  403280:	687b      	ldr	r3, [r7, #4]
  403282:	685b      	ldr	r3, [r3, #4]
  403284:	f023 0202 	bic.w	r2, r3, #2
  403288:	687b      	ldr	r3, [r7, #4]
  40328a:	605a      	str	r2, [r3, #4]
}
  40328c:	bf00      	nop
  40328e:	370c      	adds	r7, #12
  403290:	46bd      	mov	sp, r7
  403292:	f85d 7b04 	ldr.w	r7, [sp], #4
  403296:	4770      	bx	lr

00403298 <gmac_set_mdc_clock>:
 * \param ul_mck   GMAC MCK.
 *
 * \return GMAC_OK if successfully.
 */
static inline uint8_t gmac_set_mdc_clock(Gmac* p_gmac, uint32_t ul_mck)
{
  403298:	b480      	push	{r7}
  40329a:	b085      	sub	sp, #20
  40329c:	af00      	add	r7, sp, #0
  40329e:	6078      	str	r0, [r7, #4]
  4032a0:	6039      	str	r1, [r7, #0]
	uint32_t ul_clk;

	if (ul_mck > GMAC_MCK_SPEED_240MHZ) {
  4032a2:	683b      	ldr	r3, [r7, #0]
  4032a4:	4a20      	ldr	r2, [pc, #128]	; (403328 <gmac_set_mdc_clock+0x90>)
  4032a6:	4293      	cmp	r3, r2
  4032a8:	d901      	bls.n	4032ae <gmac_set_mdc_clock+0x16>
		return GMAC_INVALID;
  4032aa:	23ff      	movs	r3, #255	; 0xff
  4032ac:	e036      	b.n	40331c <gmac_set_mdc_clock+0x84>
	} else if (ul_mck > GMAC_MCK_SPEED_160MHZ) {
  4032ae:	683b      	ldr	r3, [r7, #0]
  4032b0:	4a1e      	ldr	r2, [pc, #120]	; (40332c <gmac_set_mdc_clock+0x94>)
  4032b2:	4293      	cmp	r3, r2
  4032b4:	d903      	bls.n	4032be <gmac_set_mdc_clock+0x26>
		ul_clk = GMAC_NCFGR_CLK_MCK_96;
  4032b6:	f44f 13a0 	mov.w	r3, #1310720	; 0x140000
  4032ba:	60fb      	str	r3, [r7, #12]
  4032bc:	e021      	b.n	403302 <gmac_set_mdc_clock+0x6a>
	} else if (ul_mck > GMAC_MCK_SPEED_120MHZ) {
  4032be:	683b      	ldr	r3, [r7, #0]
  4032c0:	4a1b      	ldr	r2, [pc, #108]	; (403330 <gmac_set_mdc_clock+0x98>)
  4032c2:	4293      	cmp	r3, r2
  4032c4:	d903      	bls.n	4032ce <gmac_set_mdc_clock+0x36>
		ul_clk = GMAC_NCFGR_CLK_MCK_64;
  4032c6:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
  4032ca:	60fb      	str	r3, [r7, #12]
  4032cc:	e019      	b.n	403302 <gmac_set_mdc_clock+0x6a>
	} else if (ul_mck > GMAC_MCK_SPEED_80MHZ) {
  4032ce:	683b      	ldr	r3, [r7, #0]
  4032d0:	4a18      	ldr	r2, [pc, #96]	; (403334 <gmac_set_mdc_clock+0x9c>)
  4032d2:	4293      	cmp	r3, r2
  4032d4:	d903      	bls.n	4032de <gmac_set_mdc_clock+0x46>
		ul_clk = GMAC_NCFGR_CLK_MCK_48;
  4032d6:	f44f 2340 	mov.w	r3, #786432	; 0xc0000
  4032da:	60fb      	str	r3, [r7, #12]
  4032dc:	e011      	b.n	403302 <gmac_set_mdc_clock+0x6a>
	} else if (ul_mck > GMAC_MCK_SPEED_40MHZ) {
  4032de:	683b      	ldr	r3, [r7, #0]
  4032e0:	4a15      	ldr	r2, [pc, #84]	; (403338 <gmac_set_mdc_clock+0xa0>)
  4032e2:	4293      	cmp	r3, r2
  4032e4:	d903      	bls.n	4032ee <gmac_set_mdc_clock+0x56>
		ul_clk = GMAC_NCFGR_CLK_MCK_32;
  4032e6:	f44f 2300 	mov.w	r3, #524288	; 0x80000
  4032ea:	60fb      	str	r3, [r7, #12]
  4032ec:	e009      	b.n	403302 <gmac_set_mdc_clock+0x6a>
	} else if (ul_mck > GMAC_MCK_SPEED_20MHZ) {
  4032ee:	683b      	ldr	r3, [r7, #0]
  4032f0:	4a12      	ldr	r2, [pc, #72]	; (40333c <gmac_set_mdc_clock+0xa4>)
  4032f2:	4293      	cmp	r3, r2
  4032f4:	d903      	bls.n	4032fe <gmac_set_mdc_clock+0x66>
		ul_clk = GMAC_NCFGR_CLK_MCK_16;
  4032f6:	f44f 2380 	mov.w	r3, #262144	; 0x40000
  4032fa:	60fb      	str	r3, [r7, #12]
  4032fc:	e001      	b.n	403302 <gmac_set_mdc_clock+0x6a>
	} else {
		ul_clk = GMAC_NCFGR_CLK_MCK_8;
  4032fe:	2300      	movs	r3, #0
  403300:	60fb      	str	r3, [r7, #12]
	}
	p_gmac->GMAC_NCFGR &= ~GMAC_NCFGR_CLK_Msk;
  403302:	687b      	ldr	r3, [r7, #4]
  403304:	685b      	ldr	r3, [r3, #4]
  403306:	f423 12e0 	bic.w	r2, r3, #1835008	; 0x1c0000
  40330a:	687b      	ldr	r3, [r7, #4]
  40330c:	605a      	str	r2, [r3, #4]
	p_gmac->GMAC_NCFGR |= ul_clk;
  40330e:	687b      	ldr	r3, [r7, #4]
  403310:	685a      	ldr	r2, [r3, #4]
  403312:	68fb      	ldr	r3, [r7, #12]
  403314:	431a      	orrs	r2, r3
  403316:	687b      	ldr	r3, [r7, #4]
  403318:	605a      	str	r2, [r3, #4]
	return GMAC_OK;
  40331a:	2300      	movs	r3, #0
}
  40331c:	4618      	mov	r0, r3
  40331e:	3714      	adds	r7, #20
  403320:	46bd      	mov	sp, r7
  403322:	f85d 7b04 	ldr.w	r7, [sp], #4
  403326:	4770      	bx	lr
  403328:	0e4e1c00 	.word	0x0e4e1c00
  40332c:	09896800 	.word	0x09896800
  403330:	07270e00 	.word	0x07270e00
  403334:	04c4b400 	.word	0x04c4b400
  403338:	02625a00 	.word	0x02625a00
  40333c:	01312d00 	.word	0x01312d00

00403340 <gmac_select_mii_mode>:
 * \param p_gmac   Pointer to the GMAC instance.
 * \param mode   Media independent interface mode.
 */
#if (SAM4E)
static inline void gmac_select_mii_mode(Gmac* p_gmac, gmac_mii_mode_t mode)
{
  403340:	b480      	push	{r7}
  403342:	b083      	sub	sp, #12
  403344:	af00      	add	r7, sp, #0
  403346:	6078      	str	r0, [r7, #4]
  403348:	460b      	mov	r3, r1
  40334a:	70fb      	strb	r3, [r7, #3]
	switch (mode) {
  40334c:	78fb      	ldrb	r3, [r7, #3]
  40334e:	3300      	adds	r3, #0
  403350:	2b01      	cmp	r3, #1
  403352:	d806      	bhi.n	403362 <gmac_select_mii_mode+0x22>
		case GMAC_PHY_MII:
		case GMAC_PHY_RMII:
			p_gmac->GMAC_UR |= GMAC_UR_MII;
  403354:	687b      	ldr	r3, [r7, #4]
  403356:	68db      	ldr	r3, [r3, #12]
  403358:	f043 0201 	orr.w	r2, r3, #1
  40335c:	687b      	ldr	r3, [r7, #4]
  40335e:	60da      	str	r2, [r3, #12]
		break;
  403360:	e006      	b.n	403370 <gmac_select_mii_mode+0x30>

		default:
			p_gmac->GMAC_UR &= ~GMAC_UR_MII;
  403362:	687b      	ldr	r3, [r7, #4]
  403364:	68db      	ldr	r3, [r3, #12]
  403366:	f023 0201 	bic.w	r2, r3, #1
  40336a:	687b      	ldr	r3, [r7, #4]
  40336c:	60da      	str	r2, [r3, #12]
		break;
  40336e:	bf00      	nop
	}
}
  403370:	bf00      	nop
  403372:	370c      	adds	r7, #12
  403374:	46bd      	mov	sp, r7
  403376:	f85d 7b04 	ldr.w	r7, [sp], #4
  40337a:	4770      	bx	lr

0040337c <ethernet_phy_find_valid>:
 * \return 0xFF when no valid PHY address is found.
 */
int ethernet_phy_addr = 0; // HICS: Para manter compatibilidade com FreeRTOS
static uint8_t ethernet_phy_find_valid(Gmac *p_gmac, uint8_t uc_phy_addr,
		uint8_t uc_start_addr)
{
  40337c:	b590      	push	{r4, r7, lr}
  40337e:	b085      	sub	sp, #20
  403380:	af00      	add	r7, sp, #0
  403382:	6078      	str	r0, [r7, #4]
  403384:	460b      	mov	r3, r1
  403386:	70fb      	strb	r3, [r7, #3]
  403388:	4613      	mov	r3, r2
  40338a:	70bb      	strb	r3, [r7, #2]
	uint32_t ul_value = 0;
  40338c:	2300      	movs	r3, #0
  40338e:	60bb      	str	r3, [r7, #8]
	uint8_t uc_rc = 0;
  403390:	2300      	movs	r3, #0
  403392:	73fb      	strb	r3, [r7, #15]
	uint8_t uc_cnt;
	uint8_t uc_phy_address = uc_phy_addr;
  403394:	78fb      	ldrb	r3, [r7, #3]
  403396:	737b      	strb	r3, [r7, #13]

	gmac_enable_management(p_gmac, true);
  403398:	2101      	movs	r1, #1
  40339a:	6878      	ldr	r0, [r7, #4]
  40339c:	4b21      	ldr	r3, [pc, #132]	; (403424 <ethernet_phy_find_valid+0xa8>)
  40339e:	4798      	blx	r3

	/* Check the current PHY address */
	gmac_phy_read(p_gmac, uc_phy_addr, GMII_PHYID1, &ul_value);
  4033a0:	f107 0308 	add.w	r3, r7, #8
  4033a4:	78f9      	ldrb	r1, [r7, #3]
  4033a6:	2202      	movs	r2, #2
  4033a8:	6878      	ldr	r0, [r7, #4]
  4033aa:	4c1f      	ldr	r4, [pc, #124]	; (403428 <ethernet_phy_find_valid+0xac>)
  4033ac:	47a0      	blx	r4

	/* Find another one */
	if (ul_value != GMII_OUI_LSB) {
  4033ae:	68bb      	ldr	r3, [r7, #8]
  4033b0:	2b05      	cmp	r3, #5
  4033b2:	d023      	beq.n	4033fc <ethernet_phy_find_valid+0x80>
		uc_rc = 0xFF;
  4033b4:	23ff      	movs	r3, #255	; 0xff
  4033b6:	73fb      	strb	r3, [r7, #15]
		ethernet_phy_addr = 0xFF; // HICS: Para manter compatibilidade com FreeRTOS
  4033b8:	4b1c      	ldr	r3, [pc, #112]	; (40342c <ethernet_phy_find_valid+0xb0>)
  4033ba:	22ff      	movs	r2, #255	; 0xff
  4033bc:	601a      	str	r2, [r3, #0]

		for (uc_cnt = uc_start_addr; uc_cnt <= ETH_PHY_MAX_ADDR; uc_cnt++) {
  4033be:	78bb      	ldrb	r3, [r7, #2]
  4033c0:	73bb      	strb	r3, [r7, #14]
  4033c2:	e018      	b.n	4033f6 <ethernet_phy_find_valid+0x7a>
			uc_phy_address = (uc_phy_address + 1) & 0x1F;
  4033c4:	7b7b      	ldrb	r3, [r7, #13]
  4033c6:	3301      	adds	r3, #1
  4033c8:	b2db      	uxtb	r3, r3
  4033ca:	f003 031f 	and.w	r3, r3, #31
  4033ce:	737b      	strb	r3, [r7, #13]
			gmac_phy_read(p_gmac, uc_phy_address, GMII_PHYID1, &ul_value);
  4033d0:	f107 0308 	add.w	r3, r7, #8
  4033d4:	7b79      	ldrb	r1, [r7, #13]
  4033d6:	2202      	movs	r2, #2
  4033d8:	6878      	ldr	r0, [r7, #4]
  4033da:	4c13      	ldr	r4, [pc, #76]	; (403428 <ethernet_phy_find_valid+0xac>)
  4033dc:	47a0      	blx	r4
			if (ul_value == GMII_OUI_MSB) {
  4033de:	68bb      	ldr	r3, [r7, #8]
  4033e0:	2b22      	cmp	r3, #34	; 0x22
  4033e2:	d105      	bne.n	4033f0 <ethernet_phy_find_valid+0x74>
				uc_rc = uc_phy_address;
  4033e4:	7b7b      	ldrb	r3, [r7, #13]
  4033e6:	73fb      	strb	r3, [r7, #15]
				ethernet_phy_addr = uc_phy_address; // HICS: Para manter compatibilidade com FreeRTOS
  4033e8:	7b7b      	ldrb	r3, [r7, #13]
  4033ea:	4a10      	ldr	r2, [pc, #64]	; (40342c <ethernet_phy_find_valid+0xb0>)
  4033ec:	6013      	str	r3, [r2, #0]
				break;
  4033ee:	e005      	b.n	4033fc <ethernet_phy_find_valid+0x80>
		for (uc_cnt = uc_start_addr; uc_cnt <= ETH_PHY_MAX_ADDR; uc_cnt++) {
  4033f0:	7bbb      	ldrb	r3, [r7, #14]
  4033f2:	3301      	adds	r3, #1
  4033f4:	73bb      	strb	r3, [r7, #14]
  4033f6:	7bbb      	ldrb	r3, [r7, #14]
  4033f8:	2b1f      	cmp	r3, #31
  4033fa:	d9e3      	bls.n	4033c4 <ethernet_phy_find_valid+0x48>
			}
		}
	}

	gmac_enable_management(p_gmac, false);
  4033fc:	2100      	movs	r1, #0
  4033fe:	6878      	ldr	r0, [r7, #4]
  403400:	4b08      	ldr	r3, [pc, #32]	; (403424 <ethernet_phy_find_valid+0xa8>)
  403402:	4798      	blx	r3

	if (uc_rc != 0xFF) {
  403404:	7bfb      	ldrb	r3, [r7, #15]
  403406:	2bff      	cmp	r3, #255	; 0xff
  403408:	d006      	beq.n	403418 <ethernet_phy_find_valid+0x9c>
		gmac_phy_read(p_gmac, uc_phy_address, GMII_BMSR, &ul_value);
  40340a:	f107 0308 	add.w	r3, r7, #8
  40340e:	7b79      	ldrb	r1, [r7, #13]
  403410:	2201      	movs	r2, #1
  403412:	6878      	ldr	r0, [r7, #4]
  403414:	4c04      	ldr	r4, [pc, #16]	; (403428 <ethernet_phy_find_valid+0xac>)
  403416:	47a0      	blx	r4
	}
	return uc_rc;
  403418:	7bfb      	ldrb	r3, [r7, #15]
}
  40341a:	4618      	mov	r0, r3
  40341c:	3714      	adds	r7, #20
  40341e:	46bd      	mov	sp, r7
  403420:	bd90      	pop	{r4, r7, pc}
  403422:	bf00      	nop
  403424:	004031f1 	.word	0x004031f1
  403428:	00403a5d 	.word	0x00403a5d
  40342c:	20006bc4 	.word	0x20006bc4

00403430 <ethernet_phy_init>:
 * \param ul_mck GMAC MCK.
 *
 * Return GMAC_OK if successfully, GMAC_TIMEOUT if timeout.
 */
uint8_t ethernet_phy_init(Gmac *p_gmac, uint8_t uc_phy_addr, uint32_t mck)
{
  403430:	b580      	push	{r7, lr}
  403432:	b086      	sub	sp, #24
  403434:	af00      	add	r7, sp, #0
  403436:	60f8      	str	r0, [r7, #12]
  403438:	460b      	mov	r3, r1
  40343a:	607a      	str	r2, [r7, #4]
  40343c:	72fb      	strb	r3, [r7, #11]
	uint8_t uc_rc;
	uint8_t uc_phy;

	ethernet_phy_reset(GMAC,uc_phy_addr);
  40343e:	7afb      	ldrb	r3, [r7, #11]
  403440:	4619      	mov	r1, r3
  403442:	4814      	ldr	r0, [pc, #80]	; (403494 <ethernet_phy_init+0x64>)
  403444:	4b14      	ldr	r3, [pc, #80]	; (403498 <ethernet_phy_init+0x68>)
  403446:	4798      	blx	r3

	/* Configure GMAC runtime clock */
	uc_rc = gmac_set_mdc_clock(p_gmac, mck);
  403448:	6879      	ldr	r1, [r7, #4]
  40344a:	68f8      	ldr	r0, [r7, #12]
  40344c:	4b13      	ldr	r3, [pc, #76]	; (40349c <ethernet_phy_init+0x6c>)
  40344e:	4798      	blx	r3
  403450:	4603      	mov	r3, r0
  403452:	75fb      	strb	r3, [r7, #23]
	if (uc_rc != GMAC_OK) {
  403454:	7dfb      	ldrb	r3, [r7, #23]
  403456:	2b00      	cmp	r3, #0
  403458:	d001      	beq.n	40345e <ethernet_phy_init+0x2e>
		return 0;
  40345a:	2300      	movs	r3, #0
  40345c:	e016      	b.n	40348c <ethernet_phy_init+0x5c>
	}

	/* Check PHY Address */
	uc_phy = ethernet_phy_find_valid(p_gmac, uc_phy_addr, 0);
  40345e:	7afb      	ldrb	r3, [r7, #11]
  403460:	2200      	movs	r2, #0
  403462:	4619      	mov	r1, r3
  403464:	68f8      	ldr	r0, [r7, #12]
  403466:	4b0e      	ldr	r3, [pc, #56]	; (4034a0 <ethernet_phy_init+0x70>)
  403468:	4798      	blx	r3
  40346a:	4603      	mov	r3, r0
  40346c:	75bb      	strb	r3, [r7, #22]
	if (uc_phy == 0xFF) {
  40346e:	7dbb      	ldrb	r3, [r7, #22]
  403470:	2bff      	cmp	r3, #255	; 0xff
  403472:	d101      	bne.n	403478 <ethernet_phy_init+0x48>
		return 0;
  403474:	2300      	movs	r3, #0
  403476:	e009      	b.n	40348c <ethernet_phy_init+0x5c>
	}
	if (uc_phy != uc_phy_addr) {
  403478:	7dba      	ldrb	r2, [r7, #22]
  40347a:	7afb      	ldrb	r3, [r7, #11]
  40347c:	429a      	cmp	r2, r3
  40347e:	d004      	beq.n	40348a <ethernet_phy_init+0x5a>
		ethernet_phy_reset(p_gmac, uc_phy_addr);
  403480:	7afb      	ldrb	r3, [r7, #11]
  403482:	4619      	mov	r1, r3
  403484:	68f8      	ldr	r0, [r7, #12]
  403486:	4b04      	ldr	r3, [pc, #16]	; (403498 <ethernet_phy_init+0x68>)
  403488:	4798      	blx	r3
	}

	return uc_rc;
  40348a:	7dfb      	ldrb	r3, [r7, #23]
}
  40348c:	4618      	mov	r0, r3
  40348e:	3718      	adds	r7, #24
  403490:	46bd      	mov	sp, r7
  403492:	bd80      	pop	{r7, pc}
  403494:	40034000 	.word	0x40034000
  403498:	00403855 	.word	0x00403855
  40349c:	00403299 	.word	0x00403299
  4034a0:	0040337d 	.word	0x0040337d

004034a4 <ethernet_phy_set_link>:
 *
 * Return GMAC_OK if successfully, GMAC_TIMEOUT if timeout.
 */
uint8_t ethernet_phy_set_link(Gmac *p_gmac, uint8_t uc_phy_addr,
		uint8_t uc_apply_setting_flag)
{
  4034a4:	b590      	push	{r4, r7, lr}
  4034a6:	b087      	sub	sp, #28
  4034a8:	af00      	add	r7, sp, #0
  4034aa:	6078      	str	r0, [r7, #4]
  4034ac:	460b      	mov	r3, r1
  4034ae:	70fb      	strb	r3, [r7, #3]
  4034b0:	4613      	mov	r3, r2
  4034b2:	70bb      	strb	r3, [r7, #2]
	uint32_t ul_stat1;
	uint32_t ul_stat2;
	uint8_t uc_phy_address, uc_speed, uc_fd;
	uint8_t uc_rc;

	gmac_enable_management(p_gmac, true);
  4034b4:	2101      	movs	r1, #1
  4034b6:	6878      	ldr	r0, [r7, #4]
  4034b8:	4b43      	ldr	r3, [pc, #268]	; (4035c8 <ethernet_phy_set_link+0x124>)
  4034ba:	4798      	blx	r3

	uc_phy_address = uc_phy_addr;
  4034bc:	78fb      	ldrb	r3, [r7, #3]
  4034be:	757b      	strb	r3, [r7, #21]

	uc_rc = gmac_phy_read(p_gmac, uc_phy_address, GMII_BMSR, &ul_stat1);
  4034c0:	f107 0310 	add.w	r3, r7, #16
  4034c4:	7d79      	ldrb	r1, [r7, #21]
  4034c6:	2201      	movs	r2, #1
  4034c8:	6878      	ldr	r0, [r7, #4]
  4034ca:	4c40      	ldr	r4, [pc, #256]	; (4035cc <ethernet_phy_set_link+0x128>)
  4034cc:	47a0      	blx	r4
  4034ce:	4603      	mov	r3, r0
  4034d0:	753b      	strb	r3, [r7, #20]
	if (uc_rc != GMAC_OK) {
  4034d2:	7d3b      	ldrb	r3, [r7, #20]
  4034d4:	2b00      	cmp	r3, #0
  4034d6:	d005      	beq.n	4034e4 <ethernet_phy_set_link+0x40>
		/* Disable PHY management and start the GMAC transfer */
		gmac_enable_management(p_gmac, false);
  4034d8:	2100      	movs	r1, #0
  4034da:	6878      	ldr	r0, [r7, #4]
  4034dc:	4b3a      	ldr	r3, [pc, #232]	; (4035c8 <ethernet_phy_set_link+0x124>)
  4034de:	4798      	blx	r3

		return uc_rc;
  4034e0:	7d3b      	ldrb	r3, [r7, #20]
  4034e2:	e06c      	b.n	4035be <ethernet_phy_set_link+0x11a>
	}

	if ((ul_stat1 & GMII_LINK_STATUS) == 0) {
  4034e4:	693b      	ldr	r3, [r7, #16]
  4034e6:	f003 0304 	and.w	r3, r3, #4
  4034ea:	2b00      	cmp	r3, #0
  4034ec:	d105      	bne.n	4034fa <ethernet_phy_set_link+0x56>
		/* Disable PHY management and start the GMAC transfer */
		gmac_enable_management(p_gmac, false);
  4034ee:	2100      	movs	r1, #0
  4034f0:	6878      	ldr	r0, [r7, #4]
  4034f2:	4b35      	ldr	r3, [pc, #212]	; (4035c8 <ethernet_phy_set_link+0x124>)
  4034f4:	4798      	blx	r3

		return GMAC_INVALID;
  4034f6:	23ff      	movs	r3, #255	; 0xff
  4034f8:	e061      	b.n	4035be <ethernet_phy_set_link+0x11a>
	}

	if (uc_apply_setting_flag == 0) {
  4034fa:	78bb      	ldrb	r3, [r7, #2]
  4034fc:	2b00      	cmp	r3, #0
  4034fe:	d105      	bne.n	40350c <ethernet_phy_set_link+0x68>
		/* Disable PHY management and start the GMAC transfer */
		gmac_enable_management(p_gmac, false);
  403500:	2100      	movs	r1, #0
  403502:	6878      	ldr	r0, [r7, #4]
  403504:	4b30      	ldr	r3, [pc, #192]	; (4035c8 <ethernet_phy_set_link+0x124>)
  403506:	4798      	blx	r3

		return uc_rc;
  403508:	7d3b      	ldrb	r3, [r7, #20]
  40350a:	e058      	b.n	4035be <ethernet_phy_set_link+0x11a>
	}

	/* Read advertisement */
	uc_rc = gmac_phy_read(p_gmac, uc_phy_address, GMII_PCR1, &ul_stat2);
  40350c:	f107 030c 	add.w	r3, r7, #12
  403510:	7d79      	ldrb	r1, [r7, #21]
  403512:	221e      	movs	r2, #30
  403514:	6878      	ldr	r0, [r7, #4]
  403516:	4c2d      	ldr	r4, [pc, #180]	; (4035cc <ethernet_phy_set_link+0x128>)
  403518:	47a0      	blx	r4
  40351a:	4603      	mov	r3, r0
  40351c:	753b      	strb	r3, [r7, #20]
	if (uc_rc != GMAC_OK) {
  40351e:	7d3b      	ldrb	r3, [r7, #20]
  403520:	2b00      	cmp	r3, #0
  403522:	d005      	beq.n	403530 <ethernet_phy_set_link+0x8c>
		/* Disable PHY management and start the GMAC transfer */
		gmac_enable_management(p_gmac, false);
  403524:	2100      	movs	r1, #0
  403526:	6878      	ldr	r0, [r7, #4]
  403528:	4b27      	ldr	r3, [pc, #156]	; (4035c8 <ethernet_phy_set_link+0x124>)
  40352a:	4798      	blx	r3

		return uc_rc;
  40352c:	7d3b      	ldrb	r3, [r7, #20]
  40352e:	e046      	b.n	4035be <ethernet_phy_set_link+0x11a>
	}

	if ((ul_stat1 & GMII_100BASE_TX_FD) && (ul_stat2 & GMII_OMI_100BASE_TX_FD)) {
  403530:	693b      	ldr	r3, [r7, #16]
  403532:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
  403536:	2b00      	cmp	r3, #0
  403538:	d008      	beq.n	40354c <ethernet_phy_set_link+0xa8>
  40353a:	68fb      	ldr	r3, [r7, #12]
  40353c:	f003 0306 	and.w	r3, r3, #6
  403540:	2b00      	cmp	r3, #0
  403542:	d003      	beq.n	40354c <ethernet_phy_set_link+0xa8>
		/* Set GMAC for 100BaseTX and Full Duplex */
		uc_speed = true;
  403544:	2301      	movs	r3, #1
  403546:	75fb      	strb	r3, [r7, #23]
		uc_fd = true;
  403548:	2301      	movs	r3, #1
  40354a:	75bb      	strb	r3, [r7, #22]
	}

	if ((ul_stat1 & GMII_10BASE_T_FD) && (ul_stat2 & GMII_OMI_10BASE_T_FD)) {
  40354c:	693b      	ldr	r3, [r7, #16]
  40354e:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
  403552:	2b00      	cmp	r3, #0
  403554:	d008      	beq.n	403568 <ethernet_phy_set_link+0xc4>
  403556:	68fb      	ldr	r3, [r7, #12]
  403558:	f003 0305 	and.w	r3, r3, #5
  40355c:	2b00      	cmp	r3, #0
  40355e:	d003      	beq.n	403568 <ethernet_phy_set_link+0xc4>
		/* Set MII for 10BaseT and Full Duplex */
		uc_speed = false;
  403560:	2300      	movs	r3, #0
  403562:	75fb      	strb	r3, [r7, #23]
		uc_fd = true;
  403564:	2301      	movs	r3, #1
  403566:	75bb      	strb	r3, [r7, #22]
	}

	if ((ul_stat1 & GMII_100BASE_TX_HD) && (ul_stat2 & GMII_OMI_100BASE_TX_HD)) {
  403568:	693b      	ldr	r3, [r7, #16]
  40356a:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
  40356e:	2b00      	cmp	r3, #0
  403570:	d008      	beq.n	403584 <ethernet_phy_set_link+0xe0>
  403572:	68fb      	ldr	r3, [r7, #12]
  403574:	f003 0302 	and.w	r3, r3, #2
  403578:	2b00      	cmp	r3, #0
  40357a:	d003      	beq.n	403584 <ethernet_phy_set_link+0xe0>
		/* Set MII for 100BaseTX and Half Duplex */
		uc_speed = true;
  40357c:	2301      	movs	r3, #1
  40357e:	75fb      	strb	r3, [r7, #23]
		uc_fd = false;
  403580:	2300      	movs	r3, #0
  403582:	75bb      	strb	r3, [r7, #22]
	}

	if ((ul_stat1 & GMII_10BASE_T_HD) && (ul_stat2 & GMII_OMI_10BASE_T_HD)) {
  403584:	693b      	ldr	r3, [r7, #16]
  403586:	f403 6300 	and.w	r3, r3, #2048	; 0x800
  40358a:	2b00      	cmp	r3, #0
  40358c:	d008      	beq.n	4035a0 <ethernet_phy_set_link+0xfc>
  40358e:	68fb      	ldr	r3, [r7, #12]
  403590:	f003 0301 	and.w	r3, r3, #1
  403594:	2b00      	cmp	r3, #0
  403596:	d003      	beq.n	4035a0 <ethernet_phy_set_link+0xfc>
		/* Set MII for 10BaseT and Half Duplex */
		uc_speed = false;
  403598:	2300      	movs	r3, #0
  40359a:	75fb      	strb	r3, [r7, #23]
		uc_fd = false;
  40359c:	2300      	movs	r3, #0
  40359e:	75bb      	strb	r3, [r7, #22]
	}

	gmac_set_speed(p_gmac, uc_speed);
  4035a0:	7dfb      	ldrb	r3, [r7, #23]
  4035a2:	4619      	mov	r1, r3
  4035a4:	6878      	ldr	r0, [r7, #4]
  4035a6:	4b0a      	ldr	r3, [pc, #40]	; (4035d0 <ethernet_phy_set_link+0x12c>)
  4035a8:	4798      	blx	r3
	gmac_enable_full_duplex(p_gmac, uc_fd);
  4035aa:	7dbb      	ldrb	r3, [r7, #22]
  4035ac:	4619      	mov	r1, r3
  4035ae:	6878      	ldr	r0, [r7, #4]
  4035b0:	4b08      	ldr	r3, [pc, #32]	; (4035d4 <ethernet_phy_set_link+0x130>)
  4035b2:	4798      	blx	r3

	/* Start the GMAC transfers */
	gmac_enable_management(p_gmac, false);
  4035b4:	2100      	movs	r1, #0
  4035b6:	6878      	ldr	r0, [r7, #4]
  4035b8:	4b03      	ldr	r3, [pc, #12]	; (4035c8 <ethernet_phy_set_link+0x124>)
  4035ba:	4798      	blx	r3
	return uc_rc;
  4035bc:	7d3b      	ldrb	r3, [r7, #20]
}
  4035be:	4618      	mov	r0, r3
  4035c0:	371c      	adds	r7, #28
  4035c2:	46bd      	mov	sp, r7
  4035c4:	bd90      	pop	{r4, r7, pc}
  4035c6:	bf00      	nop
  4035c8:	004031f1 	.word	0x004031f1
  4035cc:	00403a5d 	.word	0x00403a5d
  4035d0:	00403229 	.word	0x00403229
  4035d4:	00403261 	.word	0x00403261

004035d8 <ethernet_phy_auto_negotiate>:
 * \param uc_phy_addr PHY address.
 *
 * Return GMAC_OK if successfully, GMAC_TIMEOUT if timeout.
 */
uint8_t ethernet_phy_auto_negotiate(Gmac *p_gmac, uint8_t uc_phy_addr)
{
  4035d8:	b590      	push	{r4, r7, lr}
  4035da:	b08b      	sub	sp, #44	; 0x2c
  4035dc:	af00      	add	r7, sp, #0
  4035de:	6078      	str	r0, [r7, #4]
  4035e0:	460b      	mov	r3, r1
  4035e2:	70fb      	strb	r3, [r7, #3]
	uint32_t ul_retry_max = ETH_PHY_RETRY_MAX;
  4035e4:	4b91      	ldr	r3, [pc, #580]	; (40382c <ethernet_phy_auto_negotiate+0x254>)
  4035e6:	61fb      	str	r3, [r7, #28]
	uint32_t ul_value;
	uint32_t ul_phy_anar;
	uint32_t ul_phy_analpar;
	uint32_t ul_retry_count = 0;
  4035e8:	2300      	movs	r3, #0
  4035ea:	627b      	str	r3, [r7, #36]	; 0x24
	uint8_t uc_speed = 0;
  4035ec:	2300      	movs	r3, #0
  4035ee:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
	uint8_t uc_fd=0;
  4035f2:	2300      	movs	r3, #0
  4035f4:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
	uint8_t uc_rc;

	gmac_enable_management(p_gmac, true);
  4035f8:	2101      	movs	r1, #1
  4035fa:	6878      	ldr	r0, [r7, #4]
  4035fc:	4b8c      	ldr	r3, [pc, #560]	; (403830 <ethernet_phy_auto_negotiate+0x258>)
  4035fe:	4798      	blx	r3

	/* Set up control register */
	uc_rc = gmac_phy_read(p_gmac, uc_phy_addr, GMII_BMCR, &ul_value);
  403600:	f107 0310 	add.w	r3, r7, #16
  403604:	78f9      	ldrb	r1, [r7, #3]
  403606:	2200      	movs	r2, #0
  403608:	6878      	ldr	r0, [r7, #4]
  40360a:	4c8a      	ldr	r4, [pc, #552]	; (403834 <ethernet_phy_auto_negotiate+0x25c>)
  40360c:	47a0      	blx	r4
  40360e:	4603      	mov	r3, r0
  403610:	76fb      	strb	r3, [r7, #27]
	if (uc_rc != GMAC_OK) {
  403612:	7efb      	ldrb	r3, [r7, #27]
  403614:	2b00      	cmp	r3, #0
  403616:	d005      	beq.n	403624 <ethernet_phy_auto_negotiate+0x4c>
		gmac_enable_management(p_gmac, false);
  403618:	2100      	movs	r1, #0
  40361a:	6878      	ldr	r0, [r7, #4]
  40361c:	4b84      	ldr	r3, [pc, #528]	; (403830 <ethernet_phy_auto_negotiate+0x258>)
  40361e:	4798      	blx	r3
		return uc_rc;
  403620:	7efb      	ldrb	r3, [r7, #27]
  403622:	e0fe      	b.n	403822 <ethernet_phy_auto_negotiate+0x24a>
	}

	ul_value &= ~(uint32_t)GMII_AUTONEG; /* Remove auto-negotiation enable */
  403624:	693b      	ldr	r3, [r7, #16]
  403626:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
  40362a:	613b      	str	r3, [r7, #16]
	ul_value &= ~(uint32_t)(GMII_LOOPBACK | GMII_POWER_DOWN);
  40362c:	693b      	ldr	r3, [r7, #16]
  40362e:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
  403632:	613b      	str	r3, [r7, #16]
	ul_value |= (uint32_t)GMII_ISOLATE; /* Electrically isolate PHY */
  403634:	693b      	ldr	r3, [r7, #16]
  403636:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
  40363a:	613b      	str	r3, [r7, #16]
	uc_rc = gmac_phy_write(p_gmac, uc_phy_addr, GMII_BMCR, ul_value);
  40363c:	693b      	ldr	r3, [r7, #16]
  40363e:	78f9      	ldrb	r1, [r7, #3]
  403640:	2200      	movs	r2, #0
  403642:	6878      	ldr	r0, [r7, #4]
  403644:	4c7c      	ldr	r4, [pc, #496]	; (403838 <ethernet_phy_auto_negotiate+0x260>)
  403646:	47a0      	blx	r4
  403648:	4603      	mov	r3, r0
  40364a:	76fb      	strb	r3, [r7, #27]
	if (uc_rc != GMAC_OK) {
  40364c:	7efb      	ldrb	r3, [r7, #27]
  40364e:	2b00      	cmp	r3, #0
  403650:	d005      	beq.n	40365e <ethernet_phy_auto_negotiate+0x86>
		gmac_enable_management(p_gmac, false);
  403652:	2100      	movs	r1, #0
  403654:	6878      	ldr	r0, [r7, #4]
  403656:	4b76      	ldr	r3, [pc, #472]	; (403830 <ethernet_phy_auto_negotiate+0x258>)
  403658:	4798      	blx	r3
		return uc_rc;
  40365a:	7efb      	ldrb	r3, [r7, #27]
  40365c:	e0e1      	b.n	403822 <ethernet_phy_auto_negotiate+0x24a>
	/* 
	 * Set the Auto_negotiation Advertisement Register.
	 * MII advertising for Next page.
	 * 100BaseTxFD and HD, 10BaseTFD and HD, IEEE 802.3.
	 */
	ul_phy_anar = GMII_100TX_FDX | GMII_100TX_HDX | GMII_10_FDX | GMII_10_HDX | 
  40365e:	f240 13e1 	movw	r3, #481	; 0x1e1
  403662:	617b      	str	r3, [r7, #20]
			GMII_AN_IEEE_802_3;
	uc_rc = gmac_phy_write(p_gmac, uc_phy_addr, GMII_ANAR, ul_phy_anar);
  403664:	78f9      	ldrb	r1, [r7, #3]
  403666:	697b      	ldr	r3, [r7, #20]
  403668:	2204      	movs	r2, #4
  40366a:	6878      	ldr	r0, [r7, #4]
  40366c:	4c72      	ldr	r4, [pc, #456]	; (403838 <ethernet_phy_auto_negotiate+0x260>)
  40366e:	47a0      	blx	r4
  403670:	4603      	mov	r3, r0
  403672:	76fb      	strb	r3, [r7, #27]
	if (uc_rc != GMAC_OK) {
  403674:	7efb      	ldrb	r3, [r7, #27]
  403676:	2b00      	cmp	r3, #0
  403678:	d005      	beq.n	403686 <ethernet_phy_auto_negotiate+0xae>
		gmac_enable_management(p_gmac, false);
  40367a:	2100      	movs	r1, #0
  40367c:	6878      	ldr	r0, [r7, #4]
  40367e:	4b6c      	ldr	r3, [pc, #432]	; (403830 <ethernet_phy_auto_negotiate+0x258>)
  403680:	4798      	blx	r3
		return uc_rc;
  403682:	7efb      	ldrb	r3, [r7, #27]
  403684:	e0cd      	b.n	403822 <ethernet_phy_auto_negotiate+0x24a>
	}

	/* Read & modify control register */
	uc_rc = gmac_phy_read(p_gmac, uc_phy_addr, GMII_BMCR, &ul_value);
  403686:	f107 0310 	add.w	r3, r7, #16
  40368a:	78f9      	ldrb	r1, [r7, #3]
  40368c:	2200      	movs	r2, #0
  40368e:	6878      	ldr	r0, [r7, #4]
  403690:	4c68      	ldr	r4, [pc, #416]	; (403834 <ethernet_phy_auto_negotiate+0x25c>)
  403692:	47a0      	blx	r4
  403694:	4603      	mov	r3, r0
  403696:	76fb      	strb	r3, [r7, #27]
	if (uc_rc != GMAC_OK) {
  403698:	7efb      	ldrb	r3, [r7, #27]
  40369a:	2b00      	cmp	r3, #0
  40369c:	d005      	beq.n	4036aa <ethernet_phy_auto_negotiate+0xd2>
		gmac_enable_management(p_gmac, false);
  40369e:	2100      	movs	r1, #0
  4036a0:	6878      	ldr	r0, [r7, #4]
  4036a2:	4b63      	ldr	r3, [pc, #396]	; (403830 <ethernet_phy_auto_negotiate+0x258>)
  4036a4:	4798      	blx	r3
		return uc_rc;
  4036a6:	7efb      	ldrb	r3, [r7, #27]
  4036a8:	e0bb      	b.n	403822 <ethernet_phy_auto_negotiate+0x24a>
	}

	ul_value |= GMII_SPEED_SELECT | GMII_AUTONEG | GMII_DUPLEX_MODE;
  4036aa:	693b      	ldr	r3, [r7, #16]
  4036ac:	f443 5344 	orr.w	r3, r3, #12544	; 0x3100
  4036b0:	613b      	str	r3, [r7, #16]
	uc_rc = gmac_phy_write(p_gmac, uc_phy_addr, GMII_BMCR, ul_value);
  4036b2:	693b      	ldr	r3, [r7, #16]
  4036b4:	78f9      	ldrb	r1, [r7, #3]
  4036b6:	2200      	movs	r2, #0
  4036b8:	6878      	ldr	r0, [r7, #4]
  4036ba:	4c5f      	ldr	r4, [pc, #380]	; (403838 <ethernet_phy_auto_negotiate+0x260>)
  4036bc:	47a0      	blx	r4
  4036be:	4603      	mov	r3, r0
  4036c0:	76fb      	strb	r3, [r7, #27]
	if (uc_rc != GMAC_OK) {
  4036c2:	7efb      	ldrb	r3, [r7, #27]
  4036c4:	2b00      	cmp	r3, #0
  4036c6:	d005      	beq.n	4036d4 <ethernet_phy_auto_negotiate+0xfc>
		gmac_enable_management(p_gmac, false);
  4036c8:	2100      	movs	r1, #0
  4036ca:	6878      	ldr	r0, [r7, #4]
  4036cc:	4b58      	ldr	r3, [pc, #352]	; (403830 <ethernet_phy_auto_negotiate+0x258>)
  4036ce:	4798      	blx	r3
		return uc_rc;
  4036d0:	7efb      	ldrb	r3, [r7, #27]
  4036d2:	e0a6      	b.n	403822 <ethernet_phy_auto_negotiate+0x24a>
	}

	/* Restart auto negotiation */
	ul_value |= (uint32_t)GMII_RESTART_AUTONEG;
  4036d4:	693b      	ldr	r3, [r7, #16]
  4036d6:	f443 7300 	orr.w	r3, r3, #512	; 0x200
  4036da:	613b      	str	r3, [r7, #16]
	ul_value &= ~(uint32_t)GMII_ISOLATE;
  4036dc:	693b      	ldr	r3, [r7, #16]
  4036de:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
  4036e2:	613b      	str	r3, [r7, #16]
	uc_rc = gmac_phy_write(p_gmac, uc_phy_addr, GMII_BMCR, ul_value);
  4036e4:	693b      	ldr	r3, [r7, #16]
  4036e6:	78f9      	ldrb	r1, [r7, #3]
  4036e8:	2200      	movs	r2, #0
  4036ea:	6878      	ldr	r0, [r7, #4]
  4036ec:	4c52      	ldr	r4, [pc, #328]	; (403838 <ethernet_phy_auto_negotiate+0x260>)
  4036ee:	47a0      	blx	r4
  4036f0:	4603      	mov	r3, r0
  4036f2:	76fb      	strb	r3, [r7, #27]
	if (uc_rc != GMAC_OK) {
  4036f4:	7efb      	ldrb	r3, [r7, #27]
  4036f6:	2b00      	cmp	r3, #0
  4036f8:	d005      	beq.n	403706 <ethernet_phy_auto_negotiate+0x12e>
		gmac_enable_management(p_gmac, false);
  4036fa:	2100      	movs	r1, #0
  4036fc:	6878      	ldr	r0, [r7, #4]
  4036fe:	4b4c      	ldr	r3, [pc, #304]	; (403830 <ethernet_phy_auto_negotiate+0x258>)
  403700:	4798      	blx	r3
		return uc_rc;
  403702:	7efb      	ldrb	r3, [r7, #27]
  403704:	e08d      	b.n	403822 <ethernet_phy_auto_negotiate+0x24a>
	}

	/* Check if auto negotiation is completed */
	while (1) {
		uc_rc = gmac_phy_read(p_gmac, uc_phy_addr, GMII_BMSR, &ul_value);
  403706:	f107 0310 	add.w	r3, r7, #16
  40370a:	78f9      	ldrb	r1, [r7, #3]
  40370c:	2201      	movs	r2, #1
  40370e:	6878      	ldr	r0, [r7, #4]
  403710:	4c48      	ldr	r4, [pc, #288]	; (403834 <ethernet_phy_auto_negotiate+0x25c>)
  403712:	47a0      	blx	r4
  403714:	4603      	mov	r3, r0
  403716:	76fb      	strb	r3, [r7, #27]
		if (uc_rc != GMAC_OK) {
  403718:	7efb      	ldrb	r3, [r7, #27]
  40371a:	2b00      	cmp	r3, #0
  40371c:	d005      	beq.n	40372a <ethernet_phy_auto_negotiate+0x152>
			gmac_enable_management(p_gmac, false);
  40371e:	2100      	movs	r1, #0
  403720:	6878      	ldr	r0, [r7, #4]
  403722:	4b43      	ldr	r3, [pc, #268]	; (403830 <ethernet_phy_auto_negotiate+0x258>)
  403724:	4798      	blx	r3
			return uc_rc;
  403726:	7efb      	ldrb	r3, [r7, #27]
  403728:	e07b      	b.n	403822 <ethernet_phy_auto_negotiate+0x24a>
		}
		/* Done successfully */
		if (ul_value & GMII_AUTONEG_COMP) {
  40372a:	693b      	ldr	r3, [r7, #16]
  40372c:	f003 0320 	and.w	r3, r3, #32
  403730:	2b00      	cmp	r3, #0
  403732:	d10f      	bne.n	403754 <ethernet_phy_auto_negotiate+0x17c>
			break;
		}

		/* Timeout check */
		if (ul_retry_max) {
  403734:	69fb      	ldr	r3, [r7, #28]
  403736:	2b00      	cmp	r3, #0
  403738:	d0e5      	beq.n	403706 <ethernet_phy_auto_negotiate+0x12e>
			if (++ul_retry_count >= ul_retry_max) {
  40373a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40373c:	3301      	adds	r3, #1
  40373e:	627b      	str	r3, [r7, #36]	; 0x24
  403740:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  403742:	69fb      	ldr	r3, [r7, #28]
  403744:	429a      	cmp	r2, r3
  403746:	d3de      	bcc.n	403706 <ethernet_phy_auto_negotiate+0x12e>
				gmac_enable_management(p_gmac, false);
  403748:	2100      	movs	r1, #0
  40374a:	6878      	ldr	r0, [r7, #4]
  40374c:	4b38      	ldr	r3, [pc, #224]	; (403830 <ethernet_phy_auto_negotiate+0x258>)
  40374e:	4798      	blx	r3
				return GMAC_TIMEOUT;
  403750:	2301      	movs	r3, #1
  403752:	e066      	b.n	403822 <ethernet_phy_auto_negotiate+0x24a>
			break;
  403754:	bf00      	nop
			}
		}
	}

	/* Get the auto negotiate link partner base page */
	uc_rc = gmac_phy_read(p_gmac, uc_phy_addr, GMII_ANLPAR, &ul_phy_analpar);
  403756:	f107 030c 	add.w	r3, r7, #12
  40375a:	78f9      	ldrb	r1, [r7, #3]
  40375c:	2205      	movs	r2, #5
  40375e:	6878      	ldr	r0, [r7, #4]
  403760:	4c34      	ldr	r4, [pc, #208]	; (403834 <ethernet_phy_auto_negotiate+0x25c>)
  403762:	47a0      	blx	r4
  403764:	4603      	mov	r3, r0
  403766:	76fb      	strb	r3, [r7, #27]
	if (uc_rc != GMAC_OK) {
  403768:	7efb      	ldrb	r3, [r7, #27]
  40376a:	2b00      	cmp	r3, #0
  40376c:	d005      	beq.n	40377a <ethernet_phy_auto_negotiate+0x1a2>
		gmac_enable_management(p_gmac, false);
  40376e:	2100      	movs	r1, #0
  403770:	6878      	ldr	r0, [r7, #4]
  403772:	4b2f      	ldr	r3, [pc, #188]	; (403830 <ethernet_phy_auto_negotiate+0x258>)
  403774:	4798      	blx	r3
		return uc_rc;
  403776:	7efb      	ldrb	r3, [r7, #27]
  403778:	e053      	b.n	403822 <ethernet_phy_auto_negotiate+0x24a>
	}


	/* Set up the GMAC link speed */
	if ((ul_phy_anar & ul_phy_analpar) & GMII_100TX_FDX) {
  40377a:	68fa      	ldr	r2, [r7, #12]
  40377c:	697b      	ldr	r3, [r7, #20]
  40377e:	4013      	ands	r3, r2
  403780:	f403 7380 	and.w	r3, r3, #256	; 0x100
  403784:	2b00      	cmp	r3, #0
  403786:	d006      	beq.n	403796 <ethernet_phy_auto_negotiate+0x1be>
		/* Set MII for 100BaseTX and Full Duplex */
		uc_speed = true;
  403788:	2301      	movs	r3, #1
  40378a:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
		uc_fd = true;
  40378e:	2301      	movs	r3, #1
  403790:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
  403794:	e028      	b.n	4037e8 <ethernet_phy_auto_negotiate+0x210>
	} else if ((ul_phy_anar & ul_phy_analpar) & GMII_10_FDX) {
  403796:	68fa      	ldr	r2, [r7, #12]
  403798:	697b      	ldr	r3, [r7, #20]
  40379a:	4013      	ands	r3, r2
  40379c:	f003 0340 	and.w	r3, r3, #64	; 0x40
  4037a0:	2b00      	cmp	r3, #0
  4037a2:	d006      	beq.n	4037b2 <ethernet_phy_auto_negotiate+0x1da>
		/* Set MII for 10BaseT and Full Duplex */
		uc_speed = false;
  4037a4:	2300      	movs	r3, #0
  4037a6:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
		uc_fd = true;
  4037aa:	2301      	movs	r3, #1
  4037ac:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
  4037b0:	e01a      	b.n	4037e8 <ethernet_phy_auto_negotiate+0x210>
	} else if ((ul_phy_anar & ul_phy_analpar) & GMII_100TX_HDX) {
  4037b2:	68fa      	ldr	r2, [r7, #12]
  4037b4:	697b      	ldr	r3, [r7, #20]
  4037b6:	4013      	ands	r3, r2
  4037b8:	f003 0380 	and.w	r3, r3, #128	; 0x80
  4037bc:	2b00      	cmp	r3, #0
  4037be:	d006      	beq.n	4037ce <ethernet_phy_auto_negotiate+0x1f6>
		/* Set MII for 100BaseTX and half Duplex */
		uc_speed = true;
  4037c0:	2301      	movs	r3, #1
  4037c2:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
		uc_fd = false;
  4037c6:	2300      	movs	r3, #0
  4037c8:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
  4037cc:	e00c      	b.n	4037e8 <ethernet_phy_auto_negotiate+0x210>
	} else if ((ul_phy_anar & ul_phy_analpar) & GMII_10_HDX) {
  4037ce:	68fa      	ldr	r2, [r7, #12]
  4037d0:	697b      	ldr	r3, [r7, #20]
  4037d2:	4013      	ands	r3, r2
  4037d4:	f003 0320 	and.w	r3, r3, #32
  4037d8:	2b00      	cmp	r3, #0
  4037da:	d005      	beq.n	4037e8 <ethernet_phy_auto_negotiate+0x210>
		/* Set MII for 10BaseT and half Duplex */
		uc_speed = false;
  4037dc:	2300      	movs	r3, #0
  4037de:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
		uc_fd = false;
  4037e2:	2300      	movs	r3, #0
  4037e4:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
	}

	gmac_set_speed(p_gmac, uc_speed);
  4037e8:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
  4037ec:	4619      	mov	r1, r3
  4037ee:	6878      	ldr	r0, [r7, #4]
  4037f0:	4b12      	ldr	r3, [pc, #72]	; (40383c <ethernet_phy_auto_negotiate+0x264>)
  4037f2:	4798      	blx	r3
	gmac_enable_full_duplex(p_gmac, uc_fd);
  4037f4:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
  4037f8:	4619      	mov	r1, r3
  4037fa:	6878      	ldr	r0, [r7, #4]
  4037fc:	4b10      	ldr	r3, [pc, #64]	; (403840 <ethernet_phy_auto_negotiate+0x268>)
  4037fe:	4798      	blx	r3

	/* Select Media Independent Interface type */
	gmac_select_mii_mode(p_gmac, ETH_PHY_MODE);
  403800:	2100      	movs	r1, #0
  403802:	6878      	ldr	r0, [r7, #4]
  403804:	4b0f      	ldr	r3, [pc, #60]	; (403844 <ethernet_phy_auto_negotiate+0x26c>)
  403806:	4798      	blx	r3

	gmac_enable_transmit(GMAC, true);
  403808:	2101      	movs	r1, #1
  40380a:	480f      	ldr	r0, [pc, #60]	; (403848 <ethernet_phy_auto_negotiate+0x270>)
  40380c:	4b0f      	ldr	r3, [pc, #60]	; (40384c <ethernet_phy_auto_negotiate+0x274>)
  40380e:	4798      	blx	r3
	gmac_enable_receive(GMAC, true);
  403810:	2101      	movs	r1, #1
  403812:	480d      	ldr	r0, [pc, #52]	; (403848 <ethernet_phy_auto_negotiate+0x270>)
  403814:	4b0e      	ldr	r3, [pc, #56]	; (403850 <ethernet_phy_auto_negotiate+0x278>)
  403816:	4798      	blx	r3

	gmac_enable_management(p_gmac, false);
  403818:	2100      	movs	r1, #0
  40381a:	6878      	ldr	r0, [r7, #4]
  40381c:	4b04      	ldr	r3, [pc, #16]	; (403830 <ethernet_phy_auto_negotiate+0x258>)
  40381e:	4798      	blx	r3
	return uc_rc;
  403820:	7efb      	ldrb	r3, [r7, #27]
}
  403822:	4618      	mov	r0, r3
  403824:	372c      	adds	r7, #44	; 0x2c
  403826:	46bd      	mov	sp, r7
  403828:	bd90      	pop	{r4, r7, pc}
  40382a:	bf00      	nop
  40382c:	000f4240 	.word	0x000f4240
  403830:	004031f1 	.word	0x004031f1
  403834:	00403a5d 	.word	0x00403a5d
  403838:	00403ab9 	.word	0x00403ab9
  40383c:	00403229 	.word	0x00403229
  403840:	00403261 	.word	0x00403261
  403844:	00403341 	.word	0x00403341
  403848:	40034000 	.word	0x40034000
  40384c:	004031b9 	.word	0x004031b9
  403850:	00403181 	.word	0x00403181

00403854 <ethernet_phy_reset>:
 * \param uc_phy_addr PHY address.
 *
 * \Return GMAC_OK if successfully, GMAC_TIMEOUT if timeout.
 */
uint8_t ethernet_phy_reset(Gmac *p_gmac, uint8_t uc_phy_addr)
{
  403854:	b590      	push	{r4, r7, lr}
  403856:	b087      	sub	sp, #28
  403858:	af00      	add	r7, sp, #0
  40385a:	6078      	str	r0, [r7, #4]
  40385c:	460b      	mov	r3, r1
  40385e:	70fb      	strb	r3, [r7, #3]
	uint32_t ul_bmcr;
	uint8_t uc_phy_address = uc_phy_addr;
  403860:	78fb      	ldrb	r3, [r7, #3]
  403862:	74bb      	strb	r3, [r7, #18]
	uint32_t ul_timeout = ETH_PHY_TIMEOUT;
  403864:	230a      	movs	r3, #10
  403866:	617b      	str	r3, [r7, #20]
	uint8_t uc_rc = GMAC_TIMEOUT;
  403868:	2301      	movs	r3, #1
  40386a:	74fb      	strb	r3, [r7, #19]

	gmac_enable_management(p_gmac, true);
  40386c:	2101      	movs	r1, #1
  40386e:	6878      	ldr	r0, [r7, #4]
  403870:	4b15      	ldr	r3, [pc, #84]	; (4038c8 <ethernet_phy_reset+0x74>)
  403872:	4798      	blx	r3

	ul_bmcr = GMII_RESET;
  403874:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  403878:	60fb      	str	r3, [r7, #12]
	gmac_phy_write(p_gmac, uc_phy_address, GMII_BMCR, ul_bmcr);
  40387a:	68fb      	ldr	r3, [r7, #12]
  40387c:	7cb9      	ldrb	r1, [r7, #18]
  40387e:	2200      	movs	r2, #0
  403880:	6878      	ldr	r0, [r7, #4]
  403882:	4c12      	ldr	r4, [pc, #72]	; (4038cc <ethernet_phy_reset+0x78>)
  403884:	47a0      	blx	r4

	do {
		gmac_phy_read(p_gmac, uc_phy_address, GMII_BMCR, &ul_bmcr);
  403886:	f107 030c 	add.w	r3, r7, #12
  40388a:	7cb9      	ldrb	r1, [r7, #18]
  40388c:	2200      	movs	r2, #0
  40388e:	6878      	ldr	r0, [r7, #4]
  403890:	4c0f      	ldr	r4, [pc, #60]	; (4038d0 <ethernet_phy_reset+0x7c>)
  403892:	47a0      	blx	r4
		ul_timeout--;
  403894:	697b      	ldr	r3, [r7, #20]
  403896:	3b01      	subs	r3, #1
  403898:	617b      	str	r3, [r7, #20]
	} while ((ul_bmcr & GMII_RESET) && ul_timeout);
  40389a:	68fb      	ldr	r3, [r7, #12]
  40389c:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
  4038a0:	2b00      	cmp	r3, #0
  4038a2:	d002      	beq.n	4038aa <ethernet_phy_reset+0x56>
  4038a4:	697b      	ldr	r3, [r7, #20]
  4038a6:	2b00      	cmp	r3, #0
  4038a8:	d1ed      	bne.n	403886 <ethernet_phy_reset+0x32>

	gmac_enable_management(p_gmac, false);
  4038aa:	2100      	movs	r1, #0
  4038ac:	6878      	ldr	r0, [r7, #4]
  4038ae:	4b06      	ldr	r3, [pc, #24]	; (4038c8 <ethernet_phy_reset+0x74>)
  4038b0:	4798      	blx	r3

	if (!ul_timeout) {
  4038b2:	697b      	ldr	r3, [r7, #20]
  4038b4:	2b00      	cmp	r3, #0
  4038b6:	d101      	bne.n	4038bc <ethernet_phy_reset+0x68>
		uc_rc = GMAC_OK;
  4038b8:	2300      	movs	r3, #0
  4038ba:	74fb      	strb	r3, [r7, #19]
	}

	return (uc_rc);
  4038bc:	7cfb      	ldrb	r3, [r7, #19]
}
  4038be:	4618      	mov	r0, r3
  4038c0:	371c      	adds	r7, #28
  4038c2:	46bd      	mov	sp, r7
  4038c4:	bd90      	pop	{r4, r7, pc}
  4038c6:	bf00      	nop
  4038c8:	004031f1 	.word	0x004031f1
  4038cc:	00403ab9 	.word	0x00403ab9
  4038d0:	00403a5d 	.word	0x00403a5d

004038d4 <smc_set_setup_timing>:
 * \param ul_cs Chip Select number to be set.
 * \param ul_setup_timing Setup timing for NWE, NCS, NRD.
 */
void smc_set_setup_timing(Smc *p_smc, uint32_t ul_cs,
		uint32_t ul_setup_timing)
{
  4038d4:	b480      	push	{r7}
  4038d6:	b085      	sub	sp, #20
  4038d8:	af00      	add	r7, sp, #0
  4038da:	60f8      	str	r0, [r7, #12]
  4038dc:	60b9      	str	r1, [r7, #8]
  4038de:	607a      	str	r2, [r7, #4]
	p_smc->SMC_CS_NUMBER[ul_cs].SMC_SETUP = ul_setup_timing;
  4038e0:	68fa      	ldr	r2, [r7, #12]
  4038e2:	68bb      	ldr	r3, [r7, #8]
  4038e4:	011b      	lsls	r3, r3, #4
  4038e6:	4413      	add	r3, r2
  4038e8:	687a      	ldr	r2, [r7, #4]
  4038ea:	601a      	str	r2, [r3, #0]
}
  4038ec:	bf00      	nop
  4038ee:	3714      	adds	r7, #20
  4038f0:	46bd      	mov	sp, r7
  4038f2:	f85d 7b04 	ldr.w	r7, [sp], #4
  4038f6:	4770      	bx	lr

004038f8 <smc_set_pulse_timing>:
 * \param ul_cs Chip Select number to be set.
 * \param ul_pulse_timing Pulse timing for NWE,NCS,NRD.
 */
void smc_set_pulse_timing(Smc *p_smc, uint32_t ul_cs,
		uint32_t ul_pulse_timing)
{
  4038f8:	b480      	push	{r7}
  4038fa:	b085      	sub	sp, #20
  4038fc:	af00      	add	r7, sp, #0
  4038fe:	60f8      	str	r0, [r7, #12]
  403900:	60b9      	str	r1, [r7, #8]
  403902:	607a      	str	r2, [r7, #4]
	p_smc->SMC_CS_NUMBER[ul_cs].SMC_PULSE = ul_pulse_timing;
  403904:	68fa      	ldr	r2, [r7, #12]
  403906:	68bb      	ldr	r3, [r7, #8]
  403908:	011b      	lsls	r3, r3, #4
  40390a:	4413      	add	r3, r2
  40390c:	3304      	adds	r3, #4
  40390e:	687a      	ldr	r2, [r7, #4]
  403910:	601a      	str	r2, [r3, #0]
}
  403912:	bf00      	nop
  403914:	3714      	adds	r7, #20
  403916:	46bd      	mov	sp, r7
  403918:	f85d 7b04 	ldr.w	r7, [sp], #4
  40391c:	4770      	bx	lr

0040391e <smc_set_cycle_timing>:
 * \param ul_cs Chip Select number to be set.
 * \param ul_cycle_timing Cycle timing for NWE and NRD.
 */
void smc_set_cycle_timing(Smc *p_smc, uint32_t ul_cs,
		uint32_t ul_cycle_timing)
{
  40391e:	b480      	push	{r7}
  403920:	b085      	sub	sp, #20
  403922:	af00      	add	r7, sp, #0
  403924:	60f8      	str	r0, [r7, #12]
  403926:	60b9      	str	r1, [r7, #8]
  403928:	607a      	str	r2, [r7, #4]
	p_smc->SMC_CS_NUMBER[ul_cs].SMC_CYCLE = ul_cycle_timing;
  40392a:	68fa      	ldr	r2, [r7, #12]
  40392c:	68bb      	ldr	r3, [r7, #8]
  40392e:	011b      	lsls	r3, r3, #4
  403930:	4413      	add	r3, r2
  403932:	3308      	adds	r3, #8
  403934:	687a      	ldr	r2, [r7, #4]
  403936:	601a      	str	r2, [r3, #0]
}
  403938:	bf00      	nop
  40393a:	3714      	adds	r7, #20
  40393c:	46bd      	mov	sp, r7
  40393e:	f85d 7b04 	ldr.w	r7, [sp], #4
  403942:	4770      	bx	lr

00403944 <smc_set_mode>:
 * \param p_smc Pointer to an SMC instance.
 * \param ul_cs Chip select number to be set.
 * \param ul_mode SMC mode.
 */
void smc_set_mode(Smc *p_smc, uint32_t ul_cs, uint32_t ul_mode)
{
  403944:	b480      	push	{r7}
  403946:	b085      	sub	sp, #20
  403948:	af00      	add	r7, sp, #0
  40394a:	60f8      	str	r0, [r7, #12]
  40394c:	60b9      	str	r1, [r7, #8]
  40394e:	607a      	str	r2, [r7, #4]
	p_smc->SMC_CS_NUMBER[ul_cs].SMC_MODE = ul_mode;
  403950:	68fa      	ldr	r2, [r7, #12]
  403952:	68bb      	ldr	r3, [r7, #8]
  403954:	011b      	lsls	r3, r3, #4
  403956:	4413      	add	r3, r2
  403958:	330c      	adds	r3, #12
  40395a:	687a      	ldr	r2, [r7, #4]
  40395c:	601a      	str	r2, [r3, #0]
}
  40395e:	bf00      	nop
  403960:	3714      	adds	r7, #20
  403962:	46bd      	mov	sp, r7
  403964:	f85d 7b04 	ldr.w	r7, [sp], #4
  403968:	4770      	bx	lr

0040396a <gmac_is_phy_idle>:
{
  40396a:	b480      	push	{r7}
  40396c:	b083      	sub	sp, #12
  40396e:	af00      	add	r7, sp, #0
  403970:	6078      	str	r0, [r7, #4]
	return ((p_gmac->GMAC_NSR & GMAC_NSR_IDLE) > 0);
  403972:	687b      	ldr	r3, [r7, #4]
  403974:	689b      	ldr	r3, [r3, #8]
  403976:	f003 0304 	and.w	r3, r3, #4
  40397a:	2b00      	cmp	r3, #0
  40397c:	bf14      	ite	ne
  40397e:	2301      	movne	r3, #1
  403980:	2300      	moveq	r3, #0
  403982:	b2db      	uxtb	r3, r3
}
  403984:	4618      	mov	r0, r3
  403986:	370c      	adds	r7, #12
  403988:	46bd      	mov	sp, r7
  40398a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40398e:	4770      	bx	lr

00403990 <gmac_maintain_phy>:
{
  403990:	b480      	push	{r7}
  403992:	b083      	sub	sp, #12
  403994:	af00      	add	r7, sp, #0
  403996:	6078      	str	r0, [r7, #4]
  403998:	4608      	mov	r0, r1
  40399a:	4611      	mov	r1, r2
  40399c:	461a      	mov	r2, r3
  40399e:	4603      	mov	r3, r0
  4039a0:	70fb      	strb	r3, [r7, #3]
  4039a2:	460b      	mov	r3, r1
  4039a4:	70bb      	strb	r3, [r7, #2]
  4039a6:	4613      	mov	r3, r2
  4039a8:	707b      	strb	r3, [r7, #1]
	while ((p_gmac->GMAC_NSR & GMAC_NSR_IDLE) == 0);
  4039aa:	bf00      	nop
  4039ac:	687b      	ldr	r3, [r7, #4]
  4039ae:	689b      	ldr	r3, [r3, #8]
  4039b0:	f003 0304 	and.w	r3, r3, #4
  4039b4:	2b00      	cmp	r3, #0
  4039b6:	d0f9      	beq.n	4039ac <gmac_maintain_phy+0x1c>
			| GMAC_MAN_PHYA(uc_phy_addr)
  4039b8:	78fb      	ldrb	r3, [r7, #3]
  4039ba:	05db      	lsls	r3, r3, #23
  4039bc:	f003 6278 	and.w	r2, r3, #260046848	; 0xf800000
			| GMAC_MAN_REGA(uc_reg_addr)
  4039c0:	78bb      	ldrb	r3, [r7, #2]
  4039c2:	049b      	lsls	r3, r3, #18
  4039c4:	f403 03f8 	and.w	r3, r3, #8126464	; 0x7c0000
  4039c8:	431a      	orrs	r2, r3
			| GMAC_MAN_OP((uc_rw ? GMAC_MAN_RW_TYPE : GMAC_MAN_READ_ONLY))
  4039ca:	787b      	ldrb	r3, [r7, #1]
  4039cc:	2b00      	cmp	r3, #0
  4039ce:	d002      	beq.n	4039d6 <gmac_maintain_phy+0x46>
  4039d0:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
  4039d4:	e001      	b.n	4039da <gmac_maintain_phy+0x4a>
  4039d6:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
  4039da:	431a      	orrs	r2, r3
			| GMAC_MAN_DATA(us_data);
  4039dc:	8a3b      	ldrh	r3, [r7, #16]
  4039de:	4313      	orrs	r3, r2
  4039e0:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
  4039e4:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
	p_gmac->GMAC_MAN = GMAC_MAN_WTN(GMAC_MAN_CODE_VALUE)
  4039e8:	687a      	ldr	r2, [r7, #4]
  4039ea:	6353      	str	r3, [r2, #52]	; 0x34
}
  4039ec:	bf00      	nop
  4039ee:	370c      	adds	r7, #12
  4039f0:	46bd      	mov	sp, r7
  4039f2:	f85d 7b04 	ldr.w	r7, [sp], #4
  4039f6:	4770      	bx	lr

004039f8 <gmac_get_phy_data>:
{
  4039f8:	b480      	push	{r7}
  4039fa:	b083      	sub	sp, #12
  4039fc:	af00      	add	r7, sp, #0
  4039fe:	6078      	str	r0, [r7, #4]
	while ((p_gmac->GMAC_NSR & GMAC_NSR_IDLE) == 0);
  403a00:	bf00      	nop
  403a02:	687b      	ldr	r3, [r7, #4]
  403a04:	689b      	ldr	r3, [r3, #8]
  403a06:	f003 0304 	and.w	r3, r3, #4
  403a0a:	2b00      	cmp	r3, #0
  403a0c:	d0f9      	beq.n	403a02 <gmac_get_phy_data+0xa>
	return (uint16_t) (p_gmac->GMAC_MAN & GMAC_MAN_DATA_Msk);
  403a0e:	687b      	ldr	r3, [r7, #4]
  403a10:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  403a12:	b29b      	uxth	r3, r3
}
  403a14:	4618      	mov	r0, r3
  403a16:	370c      	adds	r7, #12
  403a18:	46bd      	mov	sp, r7
  403a1a:	f85d 7b04 	ldr.w	r7, [sp], #4
  403a1e:	4770      	bx	lr

00403a20 <gmac_phy_wait>:
 * \param ul_retry The retry times.
 *
 * Return GMAC_OK if the operation is completed successfully.
 */
static uint8_t gmac_phy_wait(Gmac* p_gmac, const uint32_t ul_retry)
{
  403a20:	b580      	push	{r7, lr}
  403a22:	b084      	sub	sp, #16
  403a24:	af00      	add	r7, sp, #0
  403a26:	6078      	str	r0, [r7, #4]
  403a28:	6039      	str	r1, [r7, #0]
	volatile uint32_t ul_retry_count = 0;
  403a2a:	2300      	movs	r3, #0
  403a2c:	60fb      	str	r3, [r7, #12]

	while (!gmac_is_phy_idle(p_gmac)) {
  403a2e:	e008      	b.n	403a42 <gmac_phy_wait+0x22>
		ul_retry_count++;
  403a30:	68fb      	ldr	r3, [r7, #12]
  403a32:	3301      	adds	r3, #1
  403a34:	60fb      	str	r3, [r7, #12]

		if (ul_retry_count >= ul_retry) {
  403a36:	68fa      	ldr	r2, [r7, #12]
  403a38:	683b      	ldr	r3, [r7, #0]
  403a3a:	429a      	cmp	r2, r3
  403a3c:	d301      	bcc.n	403a42 <gmac_phy_wait+0x22>
			return GMAC_TIMEOUT;
  403a3e:	2301      	movs	r3, #1
  403a40:	e006      	b.n	403a50 <gmac_phy_wait+0x30>
	while (!gmac_is_phy_idle(p_gmac)) {
  403a42:	6878      	ldr	r0, [r7, #4]
  403a44:	4b04      	ldr	r3, [pc, #16]	; (403a58 <gmac_phy_wait+0x38>)
  403a46:	4798      	blx	r3
  403a48:	4603      	mov	r3, r0
  403a4a:	2b00      	cmp	r3, #0
  403a4c:	d0f0      	beq.n	403a30 <gmac_phy_wait+0x10>
		}
	}
	return GMAC_OK;
  403a4e:	2300      	movs	r3, #0
}
  403a50:	4618      	mov	r0, r3
  403a52:	3710      	adds	r7, #16
  403a54:	46bd      	mov	sp, r7
  403a56:	bd80      	pop	{r7, pc}
  403a58:	0040396b 	.word	0x0040396b

00403a5c <gmac_phy_read>:
 *
 * \Return GMAC_OK if successfully, GMAC_TIMEOUT if timeout.
 */
uint8_t gmac_phy_read(Gmac* p_gmac, uint8_t uc_phy_address, uint8_t uc_address,
		uint32_t* p_value)
{
  403a5c:	b590      	push	{r4, r7, lr}
  403a5e:	b087      	sub	sp, #28
  403a60:	af02      	add	r7, sp, #8
  403a62:	60f8      	str	r0, [r7, #12]
  403a64:	607b      	str	r3, [r7, #4]
  403a66:	460b      	mov	r3, r1
  403a68:	72fb      	strb	r3, [r7, #11]
  403a6a:	4613      	mov	r3, r2
  403a6c:	72bb      	strb	r3, [r7, #10]
	gmac_maintain_phy(p_gmac, uc_phy_address, uc_address, 1, 0);
  403a6e:	7aba      	ldrb	r2, [r7, #10]
  403a70:	7af9      	ldrb	r1, [r7, #11]
  403a72:	2300      	movs	r3, #0
  403a74:	9300      	str	r3, [sp, #0]
  403a76:	2301      	movs	r3, #1
  403a78:	68f8      	ldr	r0, [r7, #12]
  403a7a:	4c0b      	ldr	r4, [pc, #44]	; (403aa8 <gmac_phy_read+0x4c>)
  403a7c:	47a0      	blx	r4

	if (gmac_phy_wait(p_gmac, MAC_PHY_RETRY_MAX) == GMAC_TIMEOUT) {
  403a7e:	490b      	ldr	r1, [pc, #44]	; (403aac <gmac_phy_read+0x50>)
  403a80:	68f8      	ldr	r0, [r7, #12]
  403a82:	4b0b      	ldr	r3, [pc, #44]	; (403ab0 <gmac_phy_read+0x54>)
  403a84:	4798      	blx	r3
  403a86:	4603      	mov	r3, r0
  403a88:	2b01      	cmp	r3, #1
  403a8a:	d101      	bne.n	403a90 <gmac_phy_read+0x34>
		return GMAC_TIMEOUT;
  403a8c:	2301      	movs	r3, #1
  403a8e:	e007      	b.n	403aa0 <gmac_phy_read+0x44>
	}
	*p_value = gmac_get_phy_data(p_gmac);
  403a90:	68f8      	ldr	r0, [r7, #12]
  403a92:	4b08      	ldr	r3, [pc, #32]	; (403ab4 <gmac_phy_read+0x58>)
  403a94:	4798      	blx	r3
  403a96:	4603      	mov	r3, r0
  403a98:	461a      	mov	r2, r3
  403a9a:	687b      	ldr	r3, [r7, #4]
  403a9c:	601a      	str	r2, [r3, #0]
	return GMAC_OK;
  403a9e:	2300      	movs	r3, #0
}
  403aa0:	4618      	mov	r0, r3
  403aa2:	3714      	adds	r7, #20
  403aa4:	46bd      	mov	sp, r7
  403aa6:	bd90      	pop	{r4, r7, pc}
  403aa8:	00403991 	.word	0x00403991
  403aac:	000f4240 	.word	0x000f4240
  403ab0:	00403a21 	.word	0x00403a21
  403ab4:	004039f9 	.word	0x004039f9

00403ab8 <gmac_phy_write>:
 *
 * \Return GMAC_OK if successfully, GMAC_TIMEOUT if timeout.
 */
uint8_t gmac_phy_write(Gmac* p_gmac, uint8_t uc_phy_address,
		uint8_t uc_address, uint32_t ul_value)
{
  403ab8:	b590      	push	{r4, r7, lr}
  403aba:	b087      	sub	sp, #28
  403abc:	af02      	add	r7, sp, #8
  403abe:	60f8      	str	r0, [r7, #12]
  403ac0:	607b      	str	r3, [r7, #4]
  403ac2:	460b      	mov	r3, r1
  403ac4:	72fb      	strb	r3, [r7, #11]
  403ac6:	4613      	mov	r3, r2
  403ac8:	72bb      	strb	r3, [r7, #10]
	gmac_maintain_phy(p_gmac, uc_phy_address, uc_address, 0, ul_value);
  403aca:	687b      	ldr	r3, [r7, #4]
  403acc:	b29b      	uxth	r3, r3
  403ace:	7aba      	ldrb	r2, [r7, #10]
  403ad0:	7af9      	ldrb	r1, [r7, #11]
  403ad2:	9300      	str	r3, [sp, #0]
  403ad4:	2300      	movs	r3, #0
  403ad6:	68f8      	ldr	r0, [r7, #12]
  403ad8:	4c07      	ldr	r4, [pc, #28]	; (403af8 <gmac_phy_write+0x40>)
  403ada:	47a0      	blx	r4

	if (gmac_phy_wait(p_gmac, MAC_PHY_RETRY_MAX) == GMAC_TIMEOUT) {
  403adc:	4907      	ldr	r1, [pc, #28]	; (403afc <gmac_phy_write+0x44>)
  403ade:	68f8      	ldr	r0, [r7, #12]
  403ae0:	4b07      	ldr	r3, [pc, #28]	; (403b00 <gmac_phy_write+0x48>)
  403ae2:	4798      	blx	r3
  403ae4:	4603      	mov	r3, r0
  403ae6:	2b01      	cmp	r3, #1
  403ae8:	d101      	bne.n	403aee <gmac_phy_write+0x36>
		return GMAC_TIMEOUT;
  403aea:	2301      	movs	r3, #1
  403aec:	e000      	b.n	403af0 <gmac_phy_write+0x38>
	}
	return GMAC_OK;
  403aee:	2300      	movs	r3, #0
}
  403af0:	4618      	mov	r0, r3
  403af2:	3714      	adds	r7, #20
  403af4:	46bd      	mov	sp, r7
  403af6:	bd90      	pop	{r4, r7, pc}
  403af8:	00403991 	.word	0x00403991
  403afc:	000f4240 	.word	0x000f4240
  403b00:	00403a21 	.word	0x00403a21

00403b04 <pio_pull_up>:
 * \param ul_pull_up_enable Indicates if the pin(s) internal pull-up shall be
 * configured.
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
  403b04:	b480      	push	{r7}
  403b06:	b085      	sub	sp, #20
  403b08:	af00      	add	r7, sp, #0
  403b0a:	60f8      	str	r0, [r7, #12]
  403b0c:	60b9      	str	r1, [r7, #8]
  403b0e:	607a      	str	r2, [r7, #4]
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
  403b10:	687b      	ldr	r3, [r7, #4]
  403b12:	2b00      	cmp	r3, #0
  403b14:	d003      	beq.n	403b1e <pio_pull_up+0x1a>
		p_pio->PIO_PUER = ul_mask;
  403b16:	68fb      	ldr	r3, [r7, #12]
  403b18:	68ba      	ldr	r2, [r7, #8]
  403b1a:	665a      	str	r2, [r3, #100]	; 0x64
	} else {
		p_pio->PIO_PUDR = ul_mask;
	}
}
  403b1c:	e002      	b.n	403b24 <pio_pull_up+0x20>
		p_pio->PIO_PUDR = ul_mask;
  403b1e:	68fb      	ldr	r3, [r7, #12]
  403b20:	68ba      	ldr	r2, [r7, #8]
  403b22:	661a      	str	r2, [r3, #96]	; 0x60
}
  403b24:	bf00      	nop
  403b26:	3714      	adds	r7, #20
  403b28:	46bd      	mov	sp, r7
  403b2a:	f85d 7b04 	ldr.w	r7, [sp], #4
  403b2e:	4770      	bx	lr

00403b30 <pio_set_peripheral>:
 * \param ul_type PIO type.
 * \param ul_mask Bitmask of one or more pin(s) to configure.
 */
void pio_set_peripheral(Pio *p_pio, const pio_type_t ul_type,
		const uint32_t ul_mask)
{
  403b30:	b480      	push	{r7}
  403b32:	b087      	sub	sp, #28
  403b34:	af00      	add	r7, sp, #0
  403b36:	60f8      	str	r0, [r7, #12]
  403b38:	60b9      	str	r1, [r7, #8]
  403b3a:	607a      	str	r2, [r7, #4]
	uint32_t ul_sr;

	/* Disable interrupts on the pin(s) */
	p_pio->PIO_IDR = ul_mask;
  403b3c:	68fb      	ldr	r3, [r7, #12]
  403b3e:	687a      	ldr	r2, [r7, #4]
  403b40:	645a      	str	r2, [r3, #68]	; 0x44

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	switch (ul_type) {
  403b42:	68bb      	ldr	r3, [r7, #8]
  403b44:	f1b3 5fc0 	cmp.w	r3, #402653184	; 0x18000000
  403b48:	d04a      	beq.n	403be0 <pio_set_peripheral+0xb0>
  403b4a:	f1b3 5fc0 	cmp.w	r3, #402653184	; 0x18000000
  403b4e:	d808      	bhi.n	403b62 <pio_set_peripheral+0x32>
  403b50:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
  403b54:	d016      	beq.n	403b84 <pio_set_peripheral+0x54>
  403b56:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
  403b5a:	d02c      	beq.n	403bb6 <pio_set_peripheral+0x86>
  403b5c:	2b00      	cmp	r3, #0
  403b5e:	d069      	beq.n	403c34 <pio_set_peripheral+0x104>
  403b60:	e064      	b.n	403c2c <pio_set_peripheral+0xfc>
  403b62:	f1b3 5f20 	cmp.w	r3, #671088640	; 0x28000000
  403b66:	d065      	beq.n	403c34 <pio_set_peripheral+0x104>
  403b68:	f1b3 5f20 	cmp.w	r3, #671088640	; 0x28000000
  403b6c:	d803      	bhi.n	403b76 <pio_set_peripheral+0x46>
  403b6e:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
  403b72:	d04a      	beq.n	403c0a <pio_set_peripheral+0xda>
  403b74:	e05a      	b.n	403c2c <pio_set_peripheral+0xfc>
  403b76:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
  403b7a:	d05b      	beq.n	403c34 <pio_set_peripheral+0x104>
  403b7c:	f1b3 5f60 	cmp.w	r3, #939524096	; 0x38000000
  403b80:	d058      	beq.n	403c34 <pio_set_peripheral+0x104>
  403b82:	e053      	b.n	403c2c <pio_set_peripheral+0xfc>
	case PIO_PERIPH_A:
		ul_sr = p_pio->PIO_ABCDSR[0];
  403b84:	68fb      	ldr	r3, [r7, #12]
  403b86:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  403b88:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[0] &= (~ul_mask & ul_sr);
  403b8a:	68fb      	ldr	r3, [r7, #12]
  403b8c:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  403b8e:	687b      	ldr	r3, [r7, #4]
  403b90:	43d9      	mvns	r1, r3
  403b92:	697b      	ldr	r3, [r7, #20]
  403b94:	400b      	ands	r3, r1
  403b96:	401a      	ands	r2, r3
  403b98:	68fb      	ldr	r3, [r7, #12]
  403b9a:	671a      	str	r2, [r3, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  403b9c:	68fb      	ldr	r3, [r7, #12]
  403b9e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  403ba0:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
  403ba2:	68fb      	ldr	r3, [r7, #12]
  403ba4:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  403ba6:	687b      	ldr	r3, [r7, #4]
  403ba8:	43d9      	mvns	r1, r3
  403baa:	697b      	ldr	r3, [r7, #20]
  403bac:	400b      	ands	r3, r1
  403bae:	401a      	ands	r2, r3
  403bb0:	68fb      	ldr	r3, [r7, #12]
  403bb2:	675a      	str	r2, [r3, #116]	; 0x74
		break;
  403bb4:	e03a      	b.n	403c2c <pio_set_peripheral+0xfc>
	case PIO_PERIPH_B:
		ul_sr = p_pio->PIO_ABCDSR[0];
  403bb6:	68fb      	ldr	r3, [r7, #12]
  403bb8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  403bba:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[0] = (ul_mask | ul_sr);
  403bbc:	687a      	ldr	r2, [r7, #4]
  403bbe:	697b      	ldr	r3, [r7, #20]
  403bc0:	431a      	orrs	r2, r3
  403bc2:	68fb      	ldr	r3, [r7, #12]
  403bc4:	671a      	str	r2, [r3, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  403bc6:	68fb      	ldr	r3, [r7, #12]
  403bc8:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  403bca:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
  403bcc:	68fb      	ldr	r3, [r7, #12]
  403bce:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  403bd0:	687b      	ldr	r3, [r7, #4]
  403bd2:	43d9      	mvns	r1, r3
  403bd4:	697b      	ldr	r3, [r7, #20]
  403bd6:	400b      	ands	r3, r1
  403bd8:	401a      	ands	r2, r3
  403bda:	68fb      	ldr	r3, [r7, #12]
  403bdc:	675a      	str	r2, [r3, #116]	; 0x74
		break;
  403bde:	e025      	b.n	403c2c <pio_set_peripheral+0xfc>
#if (!SAMG)
	case PIO_PERIPH_C:
		ul_sr = p_pio->PIO_ABCDSR[0];
  403be0:	68fb      	ldr	r3, [r7, #12]
  403be2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  403be4:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[0] &= (~ul_mask & ul_sr);
  403be6:	68fb      	ldr	r3, [r7, #12]
  403be8:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  403bea:	687b      	ldr	r3, [r7, #4]
  403bec:	43d9      	mvns	r1, r3
  403bee:	697b      	ldr	r3, [r7, #20]
  403bf0:	400b      	ands	r3, r1
  403bf2:	401a      	ands	r2, r3
  403bf4:	68fb      	ldr	r3, [r7, #12]
  403bf6:	671a      	str	r2, [r3, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  403bf8:	68fb      	ldr	r3, [r7, #12]
  403bfa:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  403bfc:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[1] = (ul_mask | ul_sr);
  403bfe:	687a      	ldr	r2, [r7, #4]
  403c00:	697b      	ldr	r3, [r7, #20]
  403c02:	431a      	orrs	r2, r3
  403c04:	68fb      	ldr	r3, [r7, #12]
  403c06:	675a      	str	r2, [r3, #116]	; 0x74
		break;
  403c08:	e010      	b.n	403c2c <pio_set_peripheral+0xfc>
	case PIO_PERIPH_D:
		ul_sr = p_pio->PIO_ABCDSR[0];
  403c0a:	68fb      	ldr	r3, [r7, #12]
  403c0c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  403c0e:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[0] = (ul_mask | ul_sr);
  403c10:	687a      	ldr	r2, [r7, #4]
  403c12:	697b      	ldr	r3, [r7, #20]
  403c14:	431a      	orrs	r2, r3
  403c16:	68fb      	ldr	r3, [r7, #12]
  403c18:	671a      	str	r2, [r3, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  403c1a:	68fb      	ldr	r3, [r7, #12]
  403c1c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  403c1e:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[1] = (ul_mask | ul_sr);
  403c20:	687a      	ldr	r2, [r7, #4]
  403c22:	697b      	ldr	r3, [r7, #20]
  403c24:	431a      	orrs	r2, r3
  403c26:	68fb      	ldr	r3, [r7, #12]
  403c28:	675a      	str	r2, [r3, #116]	; 0x74
		break;
  403c2a:	bf00      	nop
#else
#error "Unsupported device"
#endif

	/* Remove the pins from under the control of PIO */
	p_pio->PIO_PDR = ul_mask;
  403c2c:	68fb      	ldr	r3, [r7, #12]
  403c2e:	687a      	ldr	r2, [r7, #4]
  403c30:	605a      	str	r2, [r3, #4]
  403c32:	e000      	b.n	403c36 <pio_set_peripheral+0x106>
		return;
  403c34:	bf00      	nop
}
  403c36:	371c      	adds	r7, #28
  403c38:	46bd      	mov	sp, r7
  403c3a:	f85d 7b04 	ldr.w	r7, [sp], #4
  403c3e:	4770      	bx	lr

00403c40 <pio_set_input>:
 * \param ul_mask Bitmask indicating which pin(s) to configure as input(s).
 * \param ul_attribute PIO attribute(s).
 */
void pio_set_input(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_attribute)
{
  403c40:	b580      	push	{r7, lr}
  403c42:	b084      	sub	sp, #16
  403c44:	af00      	add	r7, sp, #0
  403c46:	60f8      	str	r0, [r7, #12]
  403c48:	60b9      	str	r1, [r7, #8]
  403c4a:	607a      	str	r2, [r7, #4]
	pio_disable_interrupt(p_pio, ul_mask);
  403c4c:	68b9      	ldr	r1, [r7, #8]
  403c4e:	68f8      	ldr	r0, [r7, #12]
  403c50:	4b19      	ldr	r3, [pc, #100]	; (403cb8 <pio_set_input+0x78>)
  403c52:	4798      	blx	r3
	pio_pull_up(p_pio, ul_mask, ul_attribute & PIO_PULLUP);
  403c54:	687b      	ldr	r3, [r7, #4]
  403c56:	f003 0301 	and.w	r3, r3, #1
  403c5a:	461a      	mov	r2, r3
  403c5c:	68b9      	ldr	r1, [r7, #8]
  403c5e:	68f8      	ldr	r0, [r7, #12]
  403c60:	4b16      	ldr	r3, [pc, #88]	; (403cbc <pio_set_input+0x7c>)
  403c62:	4798      	blx	r3

	/* Enable Input Filter if necessary */
	if (ul_attribute & (PIO_DEGLITCH | PIO_DEBOUNCE)) {
  403c64:	687b      	ldr	r3, [r7, #4]
  403c66:	f003 030a 	and.w	r3, r3, #10
  403c6a:	2b00      	cmp	r3, #0
  403c6c:	d003      	beq.n	403c76 <pio_set_input+0x36>
		p_pio->PIO_IFER = ul_mask;
  403c6e:	68fb      	ldr	r3, [r7, #12]
  403c70:	68ba      	ldr	r2, [r7, #8]
  403c72:	621a      	str	r2, [r3, #32]
  403c74:	e002      	b.n	403c7c <pio_set_input+0x3c>
	} else {
		p_pio->PIO_IFDR = ul_mask;
  403c76:	68fb      	ldr	r3, [r7, #12]
  403c78:	68ba      	ldr	r2, [r7, #8]
  403c7a:	625a      	str	r2, [r3, #36]	; 0x24
	}

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	/* Enable de-glitch or de-bounce if necessary */
	if (ul_attribute & PIO_DEGLITCH) {
  403c7c:	687b      	ldr	r3, [r7, #4]
  403c7e:	f003 0302 	and.w	r3, r3, #2
  403c82:	2b00      	cmp	r3, #0
  403c84:	d004      	beq.n	403c90 <pio_set_input+0x50>
		p_pio->PIO_IFSCDR = ul_mask;
  403c86:	68fb      	ldr	r3, [r7, #12]
  403c88:	68ba      	ldr	r2, [r7, #8]
  403c8a:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  403c8e:	e008      	b.n	403ca2 <pio_set_input+0x62>
	} else {
		if (ul_attribute & PIO_DEBOUNCE) {
  403c90:	687b      	ldr	r3, [r7, #4]
  403c92:	f003 0308 	and.w	r3, r3, #8
  403c96:	2b00      	cmp	r3, #0
  403c98:	d003      	beq.n	403ca2 <pio_set_input+0x62>
			p_pio->PIO_IFSCER = ul_mask;
  403c9a:	68fb      	ldr	r3, [r7, #12]
  403c9c:	68ba      	ldr	r2, [r7, #8]
  403c9e:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
#else
#error "Unsupported device"
#endif

	/* Configure pin as input */
	p_pio->PIO_ODR = ul_mask;
  403ca2:	68fb      	ldr	r3, [r7, #12]
  403ca4:	68ba      	ldr	r2, [r7, #8]
  403ca6:	615a      	str	r2, [r3, #20]
	p_pio->PIO_PER = ul_mask;
  403ca8:	68fb      	ldr	r3, [r7, #12]
  403caa:	68ba      	ldr	r2, [r7, #8]
  403cac:	601a      	str	r2, [r3, #0]
}
  403cae:	bf00      	nop
  403cb0:	3710      	adds	r7, #16
  403cb2:	46bd      	mov	sp, r7
  403cb4:	bd80      	pop	{r7, pc}
  403cb6:	bf00      	nop
  403cb8:	00403dad 	.word	0x00403dad
  403cbc:	00403b05 	.word	0x00403b05

00403cc0 <pio_set_output>:
 */
void pio_set_output(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_default_level,
		const uint32_t ul_multidrive_enable,
		const uint32_t ul_pull_up_enable)
{
  403cc0:	b580      	push	{r7, lr}
  403cc2:	b084      	sub	sp, #16
  403cc4:	af00      	add	r7, sp, #0
  403cc6:	60f8      	str	r0, [r7, #12]
  403cc8:	60b9      	str	r1, [r7, #8]
  403cca:	607a      	str	r2, [r7, #4]
  403ccc:	603b      	str	r3, [r7, #0]
	pio_disable_interrupt(p_pio, ul_mask);
  403cce:	68b9      	ldr	r1, [r7, #8]
  403cd0:	68f8      	ldr	r0, [r7, #12]
  403cd2:	4b12      	ldr	r3, [pc, #72]	; (403d1c <pio_set_output+0x5c>)
  403cd4:	4798      	blx	r3
	pio_pull_up(p_pio, ul_mask, ul_pull_up_enable);
  403cd6:	69ba      	ldr	r2, [r7, #24]
  403cd8:	68b9      	ldr	r1, [r7, #8]
  403cda:	68f8      	ldr	r0, [r7, #12]
  403cdc:	4b10      	ldr	r3, [pc, #64]	; (403d20 <pio_set_output+0x60>)
  403cde:	4798      	blx	r3

	/* Enable multi-drive if necessary */
	if (ul_multidrive_enable) {
  403ce0:	683b      	ldr	r3, [r7, #0]
  403ce2:	2b00      	cmp	r3, #0
  403ce4:	d003      	beq.n	403cee <pio_set_output+0x2e>
		p_pio->PIO_MDER = ul_mask;
  403ce6:	68fb      	ldr	r3, [r7, #12]
  403ce8:	68ba      	ldr	r2, [r7, #8]
  403cea:	651a      	str	r2, [r3, #80]	; 0x50
  403cec:	e002      	b.n	403cf4 <pio_set_output+0x34>
	} else {
		p_pio->PIO_MDDR = ul_mask;
  403cee:	68fb      	ldr	r3, [r7, #12]
  403cf0:	68ba      	ldr	r2, [r7, #8]
  403cf2:	655a      	str	r2, [r3, #84]	; 0x54
	}

	/* Set default value */
	if (ul_default_level) {
  403cf4:	687b      	ldr	r3, [r7, #4]
  403cf6:	2b00      	cmp	r3, #0
  403cf8:	d003      	beq.n	403d02 <pio_set_output+0x42>
		p_pio->PIO_SODR = ul_mask;
  403cfa:	68fb      	ldr	r3, [r7, #12]
  403cfc:	68ba      	ldr	r2, [r7, #8]
  403cfe:	631a      	str	r2, [r3, #48]	; 0x30
  403d00:	e002      	b.n	403d08 <pio_set_output+0x48>
	} else {
		p_pio->PIO_CODR = ul_mask;
  403d02:	68fb      	ldr	r3, [r7, #12]
  403d04:	68ba      	ldr	r2, [r7, #8]
  403d06:	635a      	str	r2, [r3, #52]	; 0x34
	}

	/* Configure pin(s) as output(s) */
	p_pio->PIO_OER = ul_mask;
  403d08:	68fb      	ldr	r3, [r7, #12]
  403d0a:	68ba      	ldr	r2, [r7, #8]
  403d0c:	611a      	str	r2, [r3, #16]
	p_pio->PIO_PER = ul_mask;
  403d0e:	68fb      	ldr	r3, [r7, #12]
  403d10:	68ba      	ldr	r2, [r7, #8]
  403d12:	601a      	str	r2, [r3, #0]
}
  403d14:	bf00      	nop
  403d16:	3710      	adds	r7, #16
  403d18:	46bd      	mov	sp, r7
  403d1a:	bd80      	pop	{r7, pc}
  403d1c:	00403dad 	.word	0x00403dad
  403d20:	00403b05 	.word	0x00403b05

00403d24 <pio_configure_interrupt>:
 * \param ul_mask Interrupt source bit map.
 * \param ul_attr Interrupt source attributes.
 */
void pio_configure_interrupt(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_attr)
{
  403d24:	b480      	push	{r7}
  403d26:	b085      	sub	sp, #20
  403d28:	af00      	add	r7, sp, #0
  403d2a:	60f8      	str	r0, [r7, #12]
  403d2c:	60b9      	str	r1, [r7, #8]
  403d2e:	607a      	str	r2, [r7, #4]
	/* Configure additional interrupt mode registers. */
	if (ul_attr & PIO_IT_AIME) {
  403d30:	687b      	ldr	r3, [r7, #4]
  403d32:	f003 0310 	and.w	r3, r3, #16
  403d36:	2b00      	cmp	r3, #0
  403d38:	d020      	beq.n	403d7c <pio_configure_interrupt+0x58>
		/* Enable additional interrupt mode. */
		p_pio->PIO_AIMER = ul_mask;
  403d3a:	68fb      	ldr	r3, [r7, #12]
  403d3c:	68ba      	ldr	r2, [r7, #8]
  403d3e:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0

		/* If bit field of the selected pin is 1, set as
		   Rising Edge/High level detection event. */
		if (ul_attr & PIO_IT_RE_OR_HL) {
  403d42:	687b      	ldr	r3, [r7, #4]
  403d44:	f003 0320 	and.w	r3, r3, #32
  403d48:	2b00      	cmp	r3, #0
  403d4a:	d004      	beq.n	403d56 <pio_configure_interrupt+0x32>
			/* Rising Edge or High Level */
			p_pio->PIO_REHLSR = ul_mask;
  403d4c:	68fb      	ldr	r3, [r7, #12]
  403d4e:	68ba      	ldr	r2, [r7, #8]
  403d50:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
  403d54:	e003      	b.n	403d5e <pio_configure_interrupt+0x3a>
		} else {
			/* Falling Edge or Low Level */
			p_pio->PIO_FELLSR = ul_mask;
  403d56:	68fb      	ldr	r3, [r7, #12]
  403d58:	68ba      	ldr	r2, [r7, #8]
  403d5a:	f8c3 20d0 	str.w	r2, [r3, #208]	; 0xd0
		}

		/* If bit field of the selected pin is 1, set as
		   edge detection source. */
		if (ul_attr & PIO_IT_EDGE) {
  403d5e:	687b      	ldr	r3, [r7, #4]
  403d60:	f003 0340 	and.w	r3, r3, #64	; 0x40
  403d64:	2b00      	cmp	r3, #0
  403d66:	d004      	beq.n	403d72 <pio_configure_interrupt+0x4e>
			/* Edge select */
			p_pio->PIO_ESR = ul_mask;
  403d68:	68fb      	ldr	r3, [r7, #12]
  403d6a:	68ba      	ldr	r2, [r7, #8]
  403d6c:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
		}
	} else {
		/* Disable additional interrupt mode. */
		p_pio->PIO_AIMDR = ul_mask;
	}
}
  403d70:	e008      	b.n	403d84 <pio_configure_interrupt+0x60>
			p_pio->PIO_LSR = ul_mask;
  403d72:	68fb      	ldr	r3, [r7, #12]
  403d74:	68ba      	ldr	r2, [r7, #8]
  403d76:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
}
  403d7a:	e003      	b.n	403d84 <pio_configure_interrupt+0x60>
		p_pio->PIO_AIMDR = ul_mask;
  403d7c:	68fb      	ldr	r3, [r7, #12]
  403d7e:	68ba      	ldr	r2, [r7, #8]
  403d80:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
}
  403d84:	bf00      	nop
  403d86:	3714      	adds	r7, #20
  403d88:	46bd      	mov	sp, r7
  403d8a:	f85d 7b04 	ldr.w	r7, [sp], #4
  403d8e:	4770      	bx	lr

00403d90 <pio_enable_interrupt>:
 *
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_enable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
  403d90:	b480      	push	{r7}
  403d92:	b083      	sub	sp, #12
  403d94:	af00      	add	r7, sp, #0
  403d96:	6078      	str	r0, [r7, #4]
  403d98:	6039      	str	r1, [r7, #0]
	p_pio->PIO_IER = ul_mask;
  403d9a:	687b      	ldr	r3, [r7, #4]
  403d9c:	683a      	ldr	r2, [r7, #0]
  403d9e:	641a      	str	r2, [r3, #64]	; 0x40
}
  403da0:	bf00      	nop
  403da2:	370c      	adds	r7, #12
  403da4:	46bd      	mov	sp, r7
  403da6:	f85d 7b04 	ldr.w	r7, [sp], #4
  403daa:	4770      	bx	lr

00403dac <pio_disable_interrupt>:
 *
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_disable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
  403dac:	b480      	push	{r7}
  403dae:	b083      	sub	sp, #12
  403db0:	af00      	add	r7, sp, #0
  403db2:	6078      	str	r0, [r7, #4]
  403db4:	6039      	str	r1, [r7, #0]
	p_pio->PIO_IDR = ul_mask;
  403db6:	687b      	ldr	r3, [r7, #4]
  403db8:	683a      	ldr	r2, [r7, #0]
  403dba:	645a      	str	r2, [r3, #68]	; 0x44
}
  403dbc:	bf00      	nop
  403dbe:	370c      	adds	r7, #12
  403dc0:	46bd      	mov	sp, r7
  403dc2:	f85d 7b04 	ldr.w	r7, [sp], #4
  403dc6:	4770      	bx	lr

00403dc8 <pio_get_interrupt_status>:
 * \param p_pio Pointer to a PIO instance.
 *
 * \return The interrupt status value.
 */
uint32_t pio_get_interrupt_status(const Pio *p_pio)
{
  403dc8:	b480      	push	{r7}
  403dca:	b083      	sub	sp, #12
  403dcc:	af00      	add	r7, sp, #0
  403dce:	6078      	str	r0, [r7, #4]
	return p_pio->PIO_ISR;
  403dd0:	687b      	ldr	r3, [r7, #4]
  403dd2:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
}
  403dd4:	4618      	mov	r0, r3
  403dd6:	370c      	adds	r7, #12
  403dd8:	46bd      	mov	sp, r7
  403dda:	f85d 7b04 	ldr.w	r7, [sp], #4
  403dde:	4770      	bx	lr

00403de0 <pio_get_interrupt_mask>:
 * \param p_pio Pointer to a PIO instance.
 *
 * \return The interrupt mask value.
 */
uint32_t pio_get_interrupt_mask(const Pio *p_pio)
{
  403de0:	b480      	push	{r7}
  403de2:	b083      	sub	sp, #12
  403de4:	af00      	add	r7, sp, #0
  403de6:	6078      	str	r0, [r7, #4]
	return p_pio->PIO_IMR;
  403de8:	687b      	ldr	r3, [r7, #4]
  403dea:	6c9b      	ldr	r3, [r3, #72]	; 0x48
}
  403dec:	4618      	mov	r0, r3
  403dee:	370c      	adds	r7, #12
  403df0:	46bd      	mov	sp, r7
  403df2:	f85d 7b04 	ldr.w	r7, [sp], #4
  403df6:	4770      	bx	lr

00403df8 <pio_configure_pin_group>:
 *
 * \return Whether the pin(s) have been configured properly.
 */
uint32_t pio_configure_pin_group(Pio *p_pio,
		uint32_t ul_mask, const uint32_t ul_flags)
{
  403df8:	b590      	push	{r4, r7, lr}
  403dfa:	b087      	sub	sp, #28
  403dfc:	af02      	add	r7, sp, #8
  403dfe:	60f8      	str	r0, [r7, #12]
  403e00:	60b9      	str	r1, [r7, #8]
  403e02:	607a      	str	r2, [r7, #4]
	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
  403e04:	687b      	ldr	r3, [r7, #4]
  403e06:	f003 43f0 	and.w	r3, r3, #2013265920	; 0x78000000
  403e0a:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
  403e0e:	d043      	beq.n	403e98 <pio_configure_pin_group+0xa0>
  403e10:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
  403e14:	d809      	bhi.n	403e2a <pio_configure_pin_group+0x32>
  403e16:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
  403e1a:	d01f      	beq.n	403e5c <pio_configure_pin_group+0x64>
  403e1c:	f1b3 5fc0 	cmp.w	r3, #402653184	; 0x18000000
  403e20:	d02b      	beq.n	403e7a <pio_configure_pin_group+0x82>
  403e22:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
  403e26:	d00a      	beq.n	403e3e <pio_configure_pin_group+0x46>
  403e28:	e06d      	b.n	403f06 <pio_configure_pin_group+0x10e>
  403e2a:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
  403e2e:	d048      	beq.n	403ec2 <pio_configure_pin_group+0xca>
  403e30:	f1b3 5f60 	cmp.w	r3, #939524096	; 0x38000000
  403e34:	d045      	beq.n	403ec2 <pio_configure_pin_group+0xca>
  403e36:	f1b3 5f20 	cmp.w	r3, #671088640	; 0x28000000
  403e3a:	d03c      	beq.n	403eb6 <pio_configure_pin_group+0xbe>
  403e3c:	e063      	b.n	403f06 <pio_configure_pin_group+0x10e>
	case PIO_TYPE_PIO_PERIPH_A:
		pio_set_peripheral(p_pio, PIO_PERIPH_A, ul_mask);
  403e3e:	68ba      	ldr	r2, [r7, #8]
  403e40:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
  403e44:	68f8      	ldr	r0, [r7, #12]
  403e46:	4b33      	ldr	r3, [pc, #204]	; (403f14 <pio_configure_pin_group+0x11c>)
  403e48:	4798      	blx	r3
		pio_pull_up(p_pio, ul_mask, (ul_flags & PIO_PULLUP));
  403e4a:	687b      	ldr	r3, [r7, #4]
  403e4c:	f003 0301 	and.w	r3, r3, #1
  403e50:	461a      	mov	r2, r3
  403e52:	68b9      	ldr	r1, [r7, #8]
  403e54:	68f8      	ldr	r0, [r7, #12]
  403e56:	4b30      	ldr	r3, [pc, #192]	; (403f18 <pio_configure_pin_group+0x120>)
  403e58:	4798      	blx	r3
		break;
  403e5a:	e056      	b.n	403f0a <pio_configure_pin_group+0x112>
	case PIO_TYPE_PIO_PERIPH_B:
		pio_set_peripheral(p_pio, PIO_PERIPH_B, ul_mask);
  403e5c:	68ba      	ldr	r2, [r7, #8]
  403e5e:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
  403e62:	68f8      	ldr	r0, [r7, #12]
  403e64:	4b2b      	ldr	r3, [pc, #172]	; (403f14 <pio_configure_pin_group+0x11c>)
  403e66:	4798      	blx	r3
		pio_pull_up(p_pio, ul_mask, (ul_flags & PIO_PULLUP));
  403e68:	687b      	ldr	r3, [r7, #4]
  403e6a:	f003 0301 	and.w	r3, r3, #1
  403e6e:	461a      	mov	r2, r3
  403e70:	68b9      	ldr	r1, [r7, #8]
  403e72:	68f8      	ldr	r0, [r7, #12]
  403e74:	4b28      	ldr	r3, [pc, #160]	; (403f18 <pio_configure_pin_group+0x120>)
  403e76:	4798      	blx	r3
		break;
  403e78:	e047      	b.n	403f0a <pio_configure_pin_group+0x112>
#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	case PIO_TYPE_PIO_PERIPH_C:
		pio_set_peripheral(p_pio, PIO_PERIPH_C, ul_mask);
  403e7a:	68ba      	ldr	r2, [r7, #8]
  403e7c:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  403e80:	68f8      	ldr	r0, [r7, #12]
  403e82:	4b24      	ldr	r3, [pc, #144]	; (403f14 <pio_configure_pin_group+0x11c>)
  403e84:	4798      	blx	r3
		pio_pull_up(p_pio, ul_mask, (ul_flags & PIO_PULLUP));
  403e86:	687b      	ldr	r3, [r7, #4]
  403e88:	f003 0301 	and.w	r3, r3, #1
  403e8c:	461a      	mov	r2, r3
  403e8e:	68b9      	ldr	r1, [r7, #8]
  403e90:	68f8      	ldr	r0, [r7, #12]
  403e92:	4b21      	ldr	r3, [pc, #132]	; (403f18 <pio_configure_pin_group+0x120>)
  403e94:	4798      	blx	r3
		break;
  403e96:	e038      	b.n	403f0a <pio_configure_pin_group+0x112>
	case PIO_TYPE_PIO_PERIPH_D:
		pio_set_peripheral(p_pio, PIO_PERIPH_D, ul_mask);
  403e98:	68ba      	ldr	r2, [r7, #8]
  403e9a:	f04f 5100 	mov.w	r1, #536870912	; 0x20000000
  403e9e:	68f8      	ldr	r0, [r7, #12]
  403ea0:	4b1c      	ldr	r3, [pc, #112]	; (403f14 <pio_configure_pin_group+0x11c>)
  403ea2:	4798      	blx	r3
		pio_pull_up(p_pio, ul_mask, (ul_flags & PIO_PULLUP));
  403ea4:	687b      	ldr	r3, [r7, #4]
  403ea6:	f003 0301 	and.w	r3, r3, #1
  403eaa:	461a      	mov	r2, r3
  403eac:	68b9      	ldr	r1, [r7, #8]
  403eae:	68f8      	ldr	r0, [r7, #12]
  403eb0:	4b19      	ldr	r3, [pc, #100]	; (403f18 <pio_configure_pin_group+0x120>)
  403eb2:	4798      	blx	r3
		break;
  403eb4:	e029      	b.n	403f0a <pio_configure_pin_group+0x112>
#endif

	case PIO_TYPE_PIO_INPUT:
		pio_set_input(p_pio, ul_mask, ul_flags);
  403eb6:	687a      	ldr	r2, [r7, #4]
  403eb8:	68b9      	ldr	r1, [r7, #8]
  403eba:	68f8      	ldr	r0, [r7, #12]
  403ebc:	4b17      	ldr	r3, [pc, #92]	; (403f1c <pio_configure_pin_group+0x124>)
  403ebe:	4798      	blx	r3
		break;
  403ec0:	e023      	b.n	403f0a <pio_configure_pin_group+0x112>

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, ul_mask,
				((ul_flags & PIO_TYPE_PIO_OUTPUT_1)
  403ec2:	687b      	ldr	r3, [r7, #4]
  403ec4:	f003 5360 	and.w	r3, r3, #939524096	; 0x38000000
		pio_set_output(p_pio, ul_mask,
  403ec8:	f1b3 5f60 	cmp.w	r3, #939524096	; 0x38000000
  403ecc:	bf0c      	ite	eq
  403ece:	2301      	moveq	r3, #1
  403ed0:	2300      	movne	r3, #0
  403ed2:	b2db      	uxtb	r3, r3
  403ed4:	461a      	mov	r2, r3
				== PIO_TYPE_PIO_OUTPUT_1) ? 1 : 0,
				(ul_flags & PIO_OPENDRAIN) ? 1 : 0,
  403ed6:	687b      	ldr	r3, [r7, #4]
  403ed8:	f003 0304 	and.w	r3, r3, #4
		pio_set_output(p_pio, ul_mask,
  403edc:	2b00      	cmp	r3, #0
  403ede:	bf14      	ite	ne
  403ee0:	2301      	movne	r3, #1
  403ee2:	2300      	moveq	r3, #0
  403ee4:	b2db      	uxtb	r3, r3
  403ee6:	4619      	mov	r1, r3
				(ul_flags & PIO_PULLUP) ? 1 : 0);
  403ee8:	687b      	ldr	r3, [r7, #4]
  403eea:	f003 0301 	and.w	r3, r3, #1
		pio_set_output(p_pio, ul_mask,
  403eee:	2b00      	cmp	r3, #0
  403ef0:	bf14      	ite	ne
  403ef2:	2301      	movne	r3, #1
  403ef4:	2300      	moveq	r3, #0
  403ef6:	b2db      	uxtb	r3, r3
  403ef8:	9300      	str	r3, [sp, #0]
  403efa:	460b      	mov	r3, r1
  403efc:	68b9      	ldr	r1, [r7, #8]
  403efe:	68f8      	ldr	r0, [r7, #12]
  403f00:	4c07      	ldr	r4, [pc, #28]	; (403f20 <pio_configure_pin_group+0x128>)
  403f02:	47a0      	blx	r4
		break;
  403f04:	e001      	b.n	403f0a <pio_configure_pin_group+0x112>

	default:
		return 0;
  403f06:	2300      	movs	r3, #0
  403f08:	e000      	b.n	403f0c <pio_configure_pin_group+0x114>
	}

	return 1;
  403f0a:	2301      	movs	r3, #1
}
  403f0c:	4618      	mov	r0, r3
  403f0e:	3714      	adds	r7, #20
  403f10:	46bd      	mov	sp, r7
  403f12:	bd90      	pop	{r4, r7, pc}
  403f14:	00403b31 	.word	0x00403b31
  403f18:	00403b05 	.word	0x00403b05
  403f1c:	00403c41 	.word	0x00403c41
  403f20:	00403cc1 	.word	0x00403cc1

00403f24 <pio_handler_process>:
 *
 * \param p_pio PIO controller base address.
 * \param ul_id PIO controller ID.
 */
void pio_handler_process(Pio *p_pio, uint32_t ul_id)
{
  403f24:	b580      	push	{r7, lr}
  403f26:	b084      	sub	sp, #16
  403f28:	af00      	add	r7, sp, #0
  403f2a:	6078      	str	r0, [r7, #4]
  403f2c:	6039      	str	r1, [r7, #0]
	uint32_t status;
	uint32_t i;

	/* Read PIO controller status */
	status = pio_get_interrupt_status(p_pio);
  403f2e:	6878      	ldr	r0, [r7, #4]
  403f30:	4b2c      	ldr	r3, [pc, #176]	; (403fe4 <pio_handler_process+0xc0>)
  403f32:	4798      	blx	r3
  403f34:	60f8      	str	r0, [r7, #12]
	status &= pio_get_interrupt_mask(p_pio);
  403f36:	6878      	ldr	r0, [r7, #4]
  403f38:	4b2b      	ldr	r3, [pc, #172]	; (403fe8 <pio_handler_process+0xc4>)
  403f3a:	4798      	blx	r3
  403f3c:	4602      	mov	r2, r0
  403f3e:	68fb      	ldr	r3, [r7, #12]
  403f40:	4013      	ands	r3, r2
  403f42:	60fb      	str	r3, [r7, #12]

	/* Check pending events */
	if (status != 0) {
  403f44:	68fb      	ldr	r3, [r7, #12]
  403f46:	2b00      	cmp	r3, #0
  403f48:	d03c      	beq.n	403fc4 <pio_handler_process+0xa0>
		/* Find triggering source */
		i = 0;
  403f4a:	2300      	movs	r3, #0
  403f4c:	60bb      	str	r3, [r7, #8]
		while (status != 0) {
  403f4e:	e034      	b.n	403fba <pio_handler_process+0x96>
			/* Source is configured on the same controller */
			if (gs_interrupt_sources[i].id == ul_id) {
  403f50:	4a26      	ldr	r2, [pc, #152]	; (403fec <pio_handler_process+0xc8>)
  403f52:	68bb      	ldr	r3, [r7, #8]
  403f54:	011b      	lsls	r3, r3, #4
  403f56:	4413      	add	r3, r2
  403f58:	681a      	ldr	r2, [r3, #0]
  403f5a:	683b      	ldr	r3, [r7, #0]
  403f5c:	429a      	cmp	r2, r3
  403f5e:	d126      	bne.n	403fae <pio_handler_process+0x8a>
				/* Source has PIOs whose statuses have changed */
				if ((status & gs_interrupt_sources[i].mask) != 0) {
  403f60:	4a22      	ldr	r2, [pc, #136]	; (403fec <pio_handler_process+0xc8>)
  403f62:	68bb      	ldr	r3, [r7, #8]
  403f64:	011b      	lsls	r3, r3, #4
  403f66:	4413      	add	r3, r2
  403f68:	3304      	adds	r3, #4
  403f6a:	681a      	ldr	r2, [r3, #0]
  403f6c:	68fb      	ldr	r3, [r7, #12]
  403f6e:	4013      	ands	r3, r2
  403f70:	2b00      	cmp	r3, #0
  403f72:	d01c      	beq.n	403fae <pio_handler_process+0x8a>
					gs_interrupt_sources[i].handler(gs_interrupt_sources[i].id,
  403f74:	4a1d      	ldr	r2, [pc, #116]	; (403fec <pio_handler_process+0xc8>)
  403f76:	68bb      	ldr	r3, [r7, #8]
  403f78:	011b      	lsls	r3, r3, #4
  403f7a:	4413      	add	r3, r2
  403f7c:	330c      	adds	r3, #12
  403f7e:	681b      	ldr	r3, [r3, #0]
  403f80:	491a      	ldr	r1, [pc, #104]	; (403fec <pio_handler_process+0xc8>)
  403f82:	68ba      	ldr	r2, [r7, #8]
  403f84:	0112      	lsls	r2, r2, #4
  403f86:	440a      	add	r2, r1
  403f88:	6810      	ldr	r0, [r2, #0]
  403f8a:	4918      	ldr	r1, [pc, #96]	; (403fec <pio_handler_process+0xc8>)
  403f8c:	68ba      	ldr	r2, [r7, #8]
  403f8e:	0112      	lsls	r2, r2, #4
  403f90:	440a      	add	r2, r1
  403f92:	3204      	adds	r2, #4
  403f94:	6812      	ldr	r2, [r2, #0]
  403f96:	4611      	mov	r1, r2
  403f98:	4798      	blx	r3
							gs_interrupt_sources[i].mask);
					status &= ~(gs_interrupt_sources[i].mask);
  403f9a:	4a14      	ldr	r2, [pc, #80]	; (403fec <pio_handler_process+0xc8>)
  403f9c:	68bb      	ldr	r3, [r7, #8]
  403f9e:	011b      	lsls	r3, r3, #4
  403fa0:	4413      	add	r3, r2
  403fa2:	3304      	adds	r3, #4
  403fa4:	681b      	ldr	r3, [r3, #0]
  403fa6:	43db      	mvns	r3, r3
  403fa8:	68fa      	ldr	r2, [r7, #12]
  403faa:	4013      	ands	r3, r2
  403fac:	60fb      	str	r3, [r7, #12]
				}
			}
			i++;
  403fae:	68bb      	ldr	r3, [r7, #8]
  403fb0:	3301      	adds	r3, #1
  403fb2:	60bb      	str	r3, [r7, #8]
			if (i >= MAX_INTERRUPT_SOURCES) {
  403fb4:	68bb      	ldr	r3, [r7, #8]
  403fb6:	2b06      	cmp	r3, #6
  403fb8:	d803      	bhi.n	403fc2 <pio_handler_process+0x9e>
		while (status != 0) {
  403fba:	68fb      	ldr	r3, [r7, #12]
  403fbc:	2b00      	cmp	r3, #0
  403fbe:	d1c7      	bne.n	403f50 <pio_handler_process+0x2c>
  403fc0:	e000      	b.n	403fc4 <pio_handler_process+0xa0>
				break;
  403fc2:	bf00      	nop
		}
	}

	/* Check capture events */
#if (SAM3S || SAM4S || SAM4E)
	if (pio_capture_enable_flag) {
  403fc4:	4b0a      	ldr	r3, [pc, #40]	; (403ff0 <pio_handler_process+0xcc>)
  403fc6:	681b      	ldr	r3, [r3, #0]
  403fc8:	2b00      	cmp	r3, #0
  403fca:	d007      	beq.n	403fdc <pio_handler_process+0xb8>
		if (pio_capture_handler) {
  403fcc:	4b09      	ldr	r3, [pc, #36]	; (403ff4 <pio_handler_process+0xd0>)
  403fce:	681b      	ldr	r3, [r3, #0]
  403fd0:	2b00      	cmp	r3, #0
  403fd2:	d003      	beq.n	403fdc <pio_handler_process+0xb8>
			pio_capture_handler(p_pio);
  403fd4:	4b07      	ldr	r3, [pc, #28]	; (403ff4 <pio_handler_process+0xd0>)
  403fd6:	681b      	ldr	r3, [r3, #0]
  403fd8:	6878      	ldr	r0, [r7, #4]
  403fda:	4798      	blx	r3
		}
	}
#endif
}
  403fdc:	bf00      	nop
  403fde:	3710      	adds	r7, #16
  403fe0:	46bd      	mov	sp, r7
  403fe2:	bd80      	pop	{r7, pc}
  403fe4:	00403dc9 	.word	0x00403dc9
  403fe8:	00403de1 	.word	0x00403de1
  403fec:	20006bc8 	.word	0x20006bc8
  403ff0:	2000b594 	.word	0x2000b594
  403ff4:	20006c3c 	.word	0x20006c3c

00403ff8 <pio_handler_set>:
 *
 * \return 0 if successful, 1 if the maximum number of sources has been defined.
 */
uint32_t pio_handler_set(Pio *p_pio, uint32_t ul_id, uint32_t ul_mask,
		uint32_t ul_attr, void (*p_handler) (uint32_t, uint32_t))
{
  403ff8:	b580      	push	{r7, lr}
  403ffa:	b086      	sub	sp, #24
  403ffc:	af00      	add	r7, sp, #0
  403ffe:	60f8      	str	r0, [r7, #12]
  404000:	60b9      	str	r1, [r7, #8]
  404002:	607a      	str	r2, [r7, #4]
  404004:	603b      	str	r3, [r7, #0]
    uint8_t i;
	struct s_interrupt_source *pSource;

	if (gs_ul_nb_sources >= MAX_INTERRUPT_SOURCES)
  404006:	4b21      	ldr	r3, [pc, #132]	; (40408c <pio_handler_set+0x94>)
  404008:	681b      	ldr	r3, [r3, #0]
  40400a:	2b06      	cmp	r3, #6
  40400c:	d901      	bls.n	404012 <pio_handler_set+0x1a>
		return 1;
  40400e:	2301      	movs	r3, #1
  404010:	e038      	b.n	404084 <pio_handler_set+0x8c>

    /* Check interrupt for this pin, if already defined, redefine it. */
	for (i = 0; i <= gs_ul_nb_sources; i++) {
  404012:	2300      	movs	r3, #0
  404014:	75fb      	strb	r3, [r7, #23]
  404016:	e011      	b.n	40403c <pio_handler_set+0x44>
		pSource = &(gs_interrupt_sources[i]);
  404018:	7dfb      	ldrb	r3, [r7, #23]
  40401a:	011b      	lsls	r3, r3, #4
  40401c:	4a1c      	ldr	r2, [pc, #112]	; (404090 <pio_handler_set+0x98>)
  40401e:	4413      	add	r3, r2
  404020:	613b      	str	r3, [r7, #16]
		if (pSource->id == ul_id && pSource->mask == ul_mask) {
  404022:	693b      	ldr	r3, [r7, #16]
  404024:	681a      	ldr	r2, [r3, #0]
  404026:	68bb      	ldr	r3, [r7, #8]
  404028:	429a      	cmp	r2, r3
  40402a:	d104      	bne.n	404036 <pio_handler_set+0x3e>
  40402c:	693b      	ldr	r3, [r7, #16]
  40402e:	685a      	ldr	r2, [r3, #4]
  404030:	687b      	ldr	r3, [r7, #4]
  404032:	429a      	cmp	r2, r3
  404034:	d008      	beq.n	404048 <pio_handler_set+0x50>
	for (i = 0; i <= gs_ul_nb_sources; i++) {
  404036:	7dfb      	ldrb	r3, [r7, #23]
  404038:	3301      	adds	r3, #1
  40403a:	75fb      	strb	r3, [r7, #23]
  40403c:	7dfa      	ldrb	r2, [r7, #23]
  40403e:	4b13      	ldr	r3, [pc, #76]	; (40408c <pio_handler_set+0x94>)
  404040:	681b      	ldr	r3, [r3, #0]
  404042:	429a      	cmp	r2, r3
  404044:	d9e8      	bls.n	404018 <pio_handler_set+0x20>
  404046:	e000      	b.n	40404a <pio_handler_set+0x52>
			break;
  404048:	bf00      	nop
		}
	}

	/* Define new source */
	pSource->id = ul_id;
  40404a:	693b      	ldr	r3, [r7, #16]
  40404c:	68ba      	ldr	r2, [r7, #8]
  40404e:	601a      	str	r2, [r3, #0]
	pSource->mask = ul_mask;
  404050:	693b      	ldr	r3, [r7, #16]
  404052:	687a      	ldr	r2, [r7, #4]
  404054:	605a      	str	r2, [r3, #4]
	pSource->attr = ul_attr;
  404056:	693b      	ldr	r3, [r7, #16]
  404058:	683a      	ldr	r2, [r7, #0]
  40405a:	609a      	str	r2, [r3, #8]
	pSource->handler = p_handler;
  40405c:	693b      	ldr	r3, [r7, #16]
  40405e:	6a3a      	ldr	r2, [r7, #32]
  404060:	60da      	str	r2, [r3, #12]
	if (i == gs_ul_nb_sources + 1) {
  404062:	7dfa      	ldrb	r2, [r7, #23]
  404064:	4b09      	ldr	r3, [pc, #36]	; (40408c <pio_handler_set+0x94>)
  404066:	681b      	ldr	r3, [r3, #0]
  404068:	3301      	adds	r3, #1
  40406a:	429a      	cmp	r2, r3
  40406c:	d104      	bne.n	404078 <pio_handler_set+0x80>
		gs_ul_nb_sources++;
  40406e:	4b07      	ldr	r3, [pc, #28]	; (40408c <pio_handler_set+0x94>)
  404070:	681b      	ldr	r3, [r3, #0]
  404072:	3301      	adds	r3, #1
  404074:	4a05      	ldr	r2, [pc, #20]	; (40408c <pio_handler_set+0x94>)
  404076:	6013      	str	r3, [r2, #0]
	}

	/* Configure interrupt mode */
	pio_configure_interrupt(p_pio, ul_mask, ul_attr);
  404078:	683a      	ldr	r2, [r7, #0]
  40407a:	6879      	ldr	r1, [r7, #4]
  40407c:	68f8      	ldr	r0, [r7, #12]
  40407e:	4b05      	ldr	r3, [pc, #20]	; (404094 <pio_handler_set+0x9c>)
  404080:	4798      	blx	r3

	return 0;
  404082:	2300      	movs	r3, #0
}
  404084:	4618      	mov	r0, r3
  404086:	3718      	adds	r7, #24
  404088:	46bd      	mov	sp, r7
  40408a:	bd80      	pop	{r7, pc}
  40408c:	20006c38 	.word	0x20006c38
  404090:	20006bc8 	.word	0x20006bc8
  404094:	00403d25 	.word	0x00403d25

00404098 <PIOA_Handler>:
/**
 * \brief Parallel IO Controller A interrupt handler.
 * Redefined PIOA interrupt handler for NVIC interrupt table.
 */
void PIOA_Handler(void)
{
  404098:	b580      	push	{r7, lr}
  40409a:	af00      	add	r7, sp, #0
	pio_handler_process(PIOA, ID_PIOA);
  40409c:	2109      	movs	r1, #9
  40409e:	4802      	ldr	r0, [pc, #8]	; (4040a8 <PIOA_Handler+0x10>)
  4040a0:	4b02      	ldr	r3, [pc, #8]	; (4040ac <PIOA_Handler+0x14>)
  4040a2:	4798      	blx	r3
}
  4040a4:	bf00      	nop
  4040a6:	bd80      	pop	{r7, pc}
  4040a8:	400e0e00 	.word	0x400e0e00
  4040ac:	00403f25 	.word	0x00403f25

004040b0 <PIOB_Handler>:
/**
 * \brief Parallel IO Controller B interrupt handler
 * Redefined PIOB interrupt handler for NVIC interrupt table.
 */
void PIOB_Handler(void)
{
  4040b0:	b580      	push	{r7, lr}
  4040b2:	af00      	add	r7, sp, #0
    pio_handler_process(PIOB, ID_PIOB);
  4040b4:	210a      	movs	r1, #10
  4040b6:	4802      	ldr	r0, [pc, #8]	; (4040c0 <PIOB_Handler+0x10>)
  4040b8:	4b02      	ldr	r3, [pc, #8]	; (4040c4 <PIOB_Handler+0x14>)
  4040ba:	4798      	blx	r3
}
  4040bc:	bf00      	nop
  4040be:	bd80      	pop	{r7, pc}
  4040c0:	400e1000 	.word	0x400e1000
  4040c4:	00403f25 	.word	0x00403f25

004040c8 <PIOC_Handler>:
/**
 * \brief Parallel IO Controller C interrupt handler.
 * Redefined PIOC interrupt handler for NVIC interrupt table.
 */
void PIOC_Handler(void)
{
  4040c8:	b580      	push	{r7, lr}
  4040ca:	af00      	add	r7, sp, #0
	pio_handler_process(PIOC, ID_PIOC);
  4040cc:	210b      	movs	r1, #11
  4040ce:	4802      	ldr	r0, [pc, #8]	; (4040d8 <PIOC_Handler+0x10>)
  4040d0:	4b02      	ldr	r3, [pc, #8]	; (4040dc <PIOC_Handler+0x14>)
  4040d2:	4798      	blx	r3
}
  4040d4:	bf00      	nop
  4040d6:	bd80      	pop	{r7, pc}
  4040d8:	400e1200 	.word	0x400e1200
  4040dc:	00403f25 	.word	0x00403f25

004040e0 <PIOD_Handler>:
/**
 * \brief Parallel IO Controller D interrupt handler.
 * Redefined PIOD interrupt handler for NVIC interrupt table.
 */
void PIOD_Handler(void)
{
  4040e0:	b580      	push	{r7, lr}
  4040e2:	af00      	add	r7, sp, #0
	pio_handler_process(PIOD, ID_PIOD);
  4040e4:	210c      	movs	r1, #12
  4040e6:	4802      	ldr	r0, [pc, #8]	; (4040f0 <PIOD_Handler+0x10>)
  4040e8:	4b02      	ldr	r3, [pc, #8]	; (4040f4 <PIOD_Handler+0x14>)
  4040ea:	4798      	blx	r3
}
  4040ec:	bf00      	nop
  4040ee:	bd80      	pop	{r7, pc}
  4040f0:	400e1400 	.word	0x400e1400
  4040f4:	00403f25 	.word	0x00403f25

004040f8 <PIOE_Handler>:
/**
 * \brief Parallel IO Controller E interrupt handler.
 * Redefined PIOE interrupt handler for NVIC interrupt table.
 */
void PIOE_Handler(void)
{
  4040f8:	b580      	push	{r7, lr}
  4040fa:	af00      	add	r7, sp, #0
	pio_handler_process(PIOE, ID_PIOE);
  4040fc:	210d      	movs	r1, #13
  4040fe:	4802      	ldr	r0, [pc, #8]	; (404108 <PIOE_Handler+0x10>)
  404100:	4b02      	ldr	r3, [pc, #8]	; (40410c <PIOE_Handler+0x14>)
  404102:	4798      	blx	r3
}
  404104:	bf00      	nop
  404106:	bd80      	pop	{r7, pc}
  404108:	400e1600 	.word	0x400e1600
  40410c:	00403f25 	.word	0x00403f25

00404110 <pmc_switch_mck_to_pllack>:
 *
 * \retval 0 Success.
 * \retval 1 Timeout error.
 */
uint32_t pmc_switch_mck_to_pllack(uint32_t ul_pres)
{
  404110:	b480      	push	{r7}
  404112:	b085      	sub	sp, #20
  404114:	af00      	add	r7, sp, #0
  404116:	6078      	str	r0, [r7, #4]
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
  404118:	491d      	ldr	r1, [pc, #116]	; (404190 <pmc_switch_mck_to_pllack+0x80>)
  40411a:	4b1d      	ldr	r3, [pc, #116]	; (404190 <pmc_switch_mck_to_pllack+0x80>)
  40411c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  40411e:	f023 0270 	bic.w	r2, r3, #112	; 0x70
  404122:	687b      	ldr	r3, [r7, #4]
  404124:	4313      	orrs	r3, r2
  404126:	630b      	str	r3, [r1, #48]	; 0x30
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  404128:	f44f 6300 	mov.w	r3, #2048	; 0x800
  40412c:	60fb      	str	r3, [r7, #12]
  40412e:	e007      	b.n	404140 <pmc_switch_mck_to_pllack+0x30>
			--ul_timeout) {
		if (ul_timeout == 0) {
  404130:	68fb      	ldr	r3, [r7, #12]
  404132:	2b00      	cmp	r3, #0
  404134:	d101      	bne.n	40413a <pmc_switch_mck_to_pllack+0x2a>
			return 1;
  404136:	2301      	movs	r3, #1
  404138:	e023      	b.n	404182 <pmc_switch_mck_to_pllack+0x72>
			--ul_timeout) {
  40413a:	68fb      	ldr	r3, [r7, #12]
  40413c:	3b01      	subs	r3, #1
  40413e:	60fb      	str	r3, [r7, #12]
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  404140:	4b13      	ldr	r3, [pc, #76]	; (404190 <pmc_switch_mck_to_pllack+0x80>)
  404142:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  404144:	f003 0308 	and.w	r3, r3, #8
  404148:	2b00      	cmp	r3, #0
  40414a:	d0f1      	beq.n	404130 <pmc_switch_mck_to_pllack+0x20>
		}
	}

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
  40414c:	4a10      	ldr	r2, [pc, #64]	; (404190 <pmc_switch_mck_to_pllack+0x80>)
  40414e:	4b10      	ldr	r3, [pc, #64]	; (404190 <pmc_switch_mck_to_pllack+0x80>)
  404150:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  404152:	f023 0303 	bic.w	r3, r3, #3
  404156:	f043 0302 	orr.w	r3, r3, #2
  40415a:	6313      	str	r3, [r2, #48]	; 0x30
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  40415c:	f44f 6300 	mov.w	r3, #2048	; 0x800
  404160:	60fb      	str	r3, [r7, #12]
  404162:	e007      	b.n	404174 <pmc_switch_mck_to_pllack+0x64>
			--ul_timeout) {
		if (ul_timeout == 0) {
  404164:	68fb      	ldr	r3, [r7, #12]
  404166:	2b00      	cmp	r3, #0
  404168:	d101      	bne.n	40416e <pmc_switch_mck_to_pllack+0x5e>
			return 1;
  40416a:	2301      	movs	r3, #1
  40416c:	e009      	b.n	404182 <pmc_switch_mck_to_pllack+0x72>
			--ul_timeout) {
  40416e:	68fb      	ldr	r3, [r7, #12]
  404170:	3b01      	subs	r3, #1
  404172:	60fb      	str	r3, [r7, #12]
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  404174:	4b06      	ldr	r3, [pc, #24]	; (404190 <pmc_switch_mck_to_pllack+0x80>)
  404176:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  404178:	f003 0308 	and.w	r3, r3, #8
  40417c:	2b00      	cmp	r3, #0
  40417e:	d0f1      	beq.n	404164 <pmc_switch_mck_to_pllack+0x54>
		}
	}

	return 0;
  404180:	2300      	movs	r3, #0
}
  404182:	4618      	mov	r0, r3
  404184:	3714      	adds	r7, #20
  404186:	46bd      	mov	sp, r7
  404188:	f85d 7b04 	ldr.w	r7, [sp], #4
  40418c:	4770      	bx	lr
  40418e:	bf00      	nop
  404190:	400e0400 	.word	0x400e0400

00404194 <pmc_switch_sclk_to_32kxtal>:
 *       VDDIO power supply.
 *
 * \param ul_bypass 0 for Xtal, 1 for bypass.
 */
void pmc_switch_sclk_to_32kxtal(uint32_t ul_bypass)
{
  404194:	b480      	push	{r7}
  404196:	b083      	sub	sp, #12
  404198:	af00      	add	r7, sp, #0
  40419a:	6078      	str	r0, [r7, #4]
	/* Set Bypass mode if required */
	if (ul_bypass == 1) {
  40419c:	687b      	ldr	r3, [r7, #4]
  40419e:	2b01      	cmp	r3, #1
  4041a0:	d107      	bne.n	4041b2 <pmc_switch_sclk_to_32kxtal+0x1e>
		SUPC->SUPC_MR |= SUPC_MR_KEY_PASSWD |
  4041a2:	4a08      	ldr	r2, [pc, #32]	; (4041c4 <pmc_switch_sclk_to_32kxtal+0x30>)
  4041a4:	4b07      	ldr	r3, [pc, #28]	; (4041c4 <pmc_switch_sclk_to_32kxtal+0x30>)
  4041a6:	689b      	ldr	r3, [r3, #8]
  4041a8:	f043 4325 	orr.w	r3, r3, #2768240640	; 0xa5000000
  4041ac:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
  4041b0:	6093      	str	r3, [r2, #8]
			SUPC_MR_OSCBYPASS;
	}

	SUPC->SUPC_CR = SUPC_CR_KEY_PASSWD | SUPC_CR_XTALSEL;
  4041b2:	4b04      	ldr	r3, [pc, #16]	; (4041c4 <pmc_switch_sclk_to_32kxtal+0x30>)
  4041b4:	4a04      	ldr	r2, [pc, #16]	; (4041c8 <pmc_switch_sclk_to_32kxtal+0x34>)
  4041b6:	601a      	str	r2, [r3, #0]
}
  4041b8:	bf00      	nop
  4041ba:	370c      	adds	r7, #12
  4041bc:	46bd      	mov	sp, r7
  4041be:	f85d 7b04 	ldr.w	r7, [sp], #4
  4041c2:	4770      	bx	lr
  4041c4:	400e1810 	.word	0x400e1810
  4041c8:	a5000008 	.word	0xa5000008

004041cc <pmc_osc_is_ready_32kxtal>:
 *
 * \retval 1 External 32k Xtal is ready.
 * \retval 0 External 32k Xtal is not ready.
 */
uint32_t pmc_osc_is_ready_32kxtal(void)
{
  4041cc:	b480      	push	{r7}
  4041ce:	af00      	add	r7, sp, #0
	return ((SUPC->SUPC_SR & SUPC_SR_OSCSEL)
  4041d0:	4b09      	ldr	r3, [pc, #36]	; (4041f8 <pmc_osc_is_ready_32kxtal+0x2c>)
  4041d2:	695b      	ldr	r3, [r3, #20]
  4041d4:	f003 0380 	and.w	r3, r3, #128	; 0x80
			&& (PMC->PMC_SR & PMC_SR_OSCSELS));
  4041d8:	2b00      	cmp	r3, #0
  4041da:	d007      	beq.n	4041ec <pmc_osc_is_ready_32kxtal+0x20>
  4041dc:	4b07      	ldr	r3, [pc, #28]	; (4041fc <pmc_osc_is_ready_32kxtal+0x30>)
  4041de:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  4041e0:	f003 0380 	and.w	r3, r3, #128	; 0x80
  4041e4:	2b00      	cmp	r3, #0
  4041e6:	d001      	beq.n	4041ec <pmc_osc_is_ready_32kxtal+0x20>
  4041e8:	2301      	movs	r3, #1
  4041ea:	e000      	b.n	4041ee <pmc_osc_is_ready_32kxtal+0x22>
  4041ec:	2300      	movs	r3, #0
}
  4041ee:	4618      	mov	r0, r3
  4041f0:	46bd      	mov	sp, r7
  4041f2:	f85d 7b04 	ldr.w	r7, [sp], #4
  4041f6:	4770      	bx	lr
  4041f8:	400e1810 	.word	0x400e1810
  4041fc:	400e0400 	.word	0x400e0400

00404200 <pmc_switch_mainck_to_fastrc>:
 * \retval 0 Success.
 * \retval 1 Timeout error.
 * \retval 2 Invalid frequency.
 */
void pmc_switch_mainck_to_fastrc(uint32_t ul_moscrcf)
{
  404200:	b480      	push	{r7}
  404202:	b083      	sub	sp, #12
  404204:	af00      	add	r7, sp, #0
  404206:	6078      	str	r0, [r7, #4]
	/* Enable Fast RC oscillator but DO NOT switch to RC now */
	PMC->CKGR_MOR |= (CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCRCEN);
  404208:	4a18      	ldr	r2, [pc, #96]	; (40426c <pmc_switch_mainck_to_fastrc+0x6c>)
  40420a:	4b18      	ldr	r3, [pc, #96]	; (40426c <pmc_switch_mainck_to_fastrc+0x6c>)
  40420c:	6a1b      	ldr	r3, [r3, #32]
  40420e:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
  404212:	f043 0308 	orr.w	r3, r3, #8
  404216:	6213      	str	r3, [r2, #32]

	/* Wait the Fast RC to stabilize */
	while (!(PMC->PMC_SR & PMC_SR_MOSCRCS));
  404218:	bf00      	nop
  40421a:	4b14      	ldr	r3, [pc, #80]	; (40426c <pmc_switch_mainck_to_fastrc+0x6c>)
  40421c:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  40421e:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
  404222:	2b00      	cmp	r3, #0
  404224:	d0f9      	beq.n	40421a <pmc_switch_mainck_to_fastrc+0x1a>

	/* Change Fast RC oscillator frequency */
	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCF_Msk) |
  404226:	4911      	ldr	r1, [pc, #68]	; (40426c <pmc_switch_mainck_to_fastrc+0x6c>)
  404228:	4b10      	ldr	r3, [pc, #64]	; (40426c <pmc_switch_mainck_to_fastrc+0x6c>)
  40422a:	6a1b      	ldr	r3, [r3, #32]
  40422c:	f423 135c 	bic.w	r3, r3, #3604480	; 0x370000
  404230:	f023 0370 	bic.w	r3, r3, #112	; 0x70
			CKGR_MOR_KEY_PASSWD | ul_moscrcf;
  404234:	687a      	ldr	r2, [r7, #4]
  404236:	4313      	orrs	r3, r2
  404238:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCF_Msk) |
  40423c:	620b      	str	r3, [r1, #32]

	/* Wait the Fast RC to stabilize */
	while (!(PMC->PMC_SR & PMC_SR_MOSCRCS));
  40423e:	bf00      	nop
  404240:	4b0a      	ldr	r3, [pc, #40]	; (40426c <pmc_switch_mainck_to_fastrc+0x6c>)
  404242:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  404244:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
  404248:	2b00      	cmp	r3, #0
  40424a:	d0f9      	beq.n	404240 <pmc_switch_mainck_to_fastrc+0x40>

	/* Switch to Fast RC */
	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCSEL) |
  40424c:	4a07      	ldr	r2, [pc, #28]	; (40426c <pmc_switch_mainck_to_fastrc+0x6c>)
  40424e:	4b07      	ldr	r3, [pc, #28]	; (40426c <pmc_switch_mainck_to_fastrc+0x6c>)
  404250:	6a1b      	ldr	r3, [r3, #32]
  404252:	f023 739b 	bic.w	r3, r3, #20316160	; 0x1360000
  404256:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
  40425a:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
  40425e:	6213      	str	r3, [r2, #32]
			CKGR_MOR_KEY_PASSWD;
}
  404260:	bf00      	nop
  404262:	370c      	adds	r7, #12
  404264:	46bd      	mov	sp, r7
  404266:	f85d 7b04 	ldr.w	r7, [sp], #4
  40426a:	4770      	bx	lr
  40426c:	400e0400 	.word	0x400e0400

00404270 <pmc_switch_mainck_to_xtal>:
 * \retval 0 Success.
 * \retval 1 Timeout error.
 */
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass,
		uint32_t ul_xtal_startup_time)
{
  404270:	b480      	push	{r7}
  404272:	b083      	sub	sp, #12
  404274:	af00      	add	r7, sp, #0
  404276:	6078      	str	r0, [r7, #4]
  404278:	6039      	str	r1, [r7, #0]
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
  40427a:	687b      	ldr	r3, [r7, #4]
  40427c:	2b00      	cmp	r3, #0
  40427e:	d008      	beq.n	404292 <pmc_switch_mainck_to_xtal+0x22>
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  404280:	4916      	ldr	r1, [pc, #88]	; (4042dc <pmc_switch_mainck_to_xtal+0x6c>)
  404282:	4b16      	ldr	r3, [pc, #88]	; (4042dc <pmc_switch_mainck_to_xtal+0x6c>)
  404284:	6a1b      	ldr	r3, [r3, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
  404286:	4a16      	ldr	r2, [pc, #88]	; (4042e0 <pmc_switch_mainck_to_xtal+0x70>)
  404288:	401a      	ands	r2, r3
  40428a:	4b16      	ldr	r3, [pc, #88]	; (4042e4 <pmc_switch_mainck_to_xtal+0x74>)
  40428c:	4313      	orrs	r3, r2
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  40428e:	620b      	str	r3, [r1, #32]
		/* Wait the Xtal to stabilize */
		while (!(PMC->PMC_SR & PMC_SR_MOSCXTS));

		PMC->CKGR_MOR |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCSEL;
	}
}
  404290:	e01e      	b.n	4042d0 <pmc_switch_mainck_to_xtal+0x60>
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
  404292:	4912      	ldr	r1, [pc, #72]	; (4042dc <pmc_switch_mainck_to_xtal+0x6c>)
  404294:	4b11      	ldr	r3, [pc, #68]	; (4042dc <pmc_switch_mainck_to_xtal+0x6c>)
  404296:	6a1b      	ldr	r3, [r3, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
  404298:	f423 135c 	bic.w	r3, r3, #3604480	; 0x370000
  40429c:	f023 0303 	bic.w	r3, r3, #3
				CKGR_MOR_MOSCXTST(ul_xtal_startup_time);
  4042a0:	683a      	ldr	r2, [r7, #0]
  4042a2:	0212      	lsls	r2, r2, #8
  4042a4:	b292      	uxth	r2, r2
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
  4042a6:	4313      	orrs	r3, r2
  4042a8:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
  4042ac:	f043 0301 	orr.w	r3, r3, #1
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
  4042b0:	620b      	str	r3, [r1, #32]
		while (!(PMC->PMC_SR & PMC_SR_MOSCXTS));
  4042b2:	bf00      	nop
  4042b4:	4b09      	ldr	r3, [pc, #36]	; (4042dc <pmc_switch_mainck_to_xtal+0x6c>)
  4042b6:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  4042b8:	f003 0301 	and.w	r3, r3, #1
  4042bc:	2b00      	cmp	r3, #0
  4042be:	d0f9      	beq.n	4042b4 <pmc_switch_mainck_to_xtal+0x44>
		PMC->CKGR_MOR |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCSEL;
  4042c0:	4a06      	ldr	r2, [pc, #24]	; (4042dc <pmc_switch_mainck_to_xtal+0x6c>)
  4042c2:	4b06      	ldr	r3, [pc, #24]	; (4042dc <pmc_switch_mainck_to_xtal+0x6c>)
  4042c4:	6a1b      	ldr	r3, [r3, #32]
  4042c6:	f043 739b 	orr.w	r3, r3, #20316160	; 0x1360000
  4042ca:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
  4042ce:	6213      	str	r3, [r2, #32]
}
  4042d0:	bf00      	nop
  4042d2:	370c      	adds	r7, #12
  4042d4:	46bd      	mov	sp, r7
  4042d6:	f85d 7b04 	ldr.w	r7, [sp], #4
  4042da:	4770      	bx	lr
  4042dc:	400e0400 	.word	0x400e0400
  4042e0:	fec8fffc 	.word	0xfec8fffc
  4042e4:	01370002 	.word	0x01370002

004042e8 <pmc_osc_is_ready_mainck>:
 *
 * \retval 1 Xtal is ready.
 * \retval 0 Xtal is not ready.
 */
uint32_t pmc_osc_is_ready_mainck(void)
{
  4042e8:	b480      	push	{r7}
  4042ea:	af00      	add	r7, sp, #0
	return PMC->PMC_SR & PMC_SR_MOSCSELS;
  4042ec:	4b04      	ldr	r3, [pc, #16]	; (404300 <pmc_osc_is_ready_mainck+0x18>)
  4042ee:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  4042f0:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
}
  4042f4:	4618      	mov	r0, r3
  4042f6:	46bd      	mov	sp, r7
  4042f8:	f85d 7b04 	ldr.w	r7, [sp], #4
  4042fc:	4770      	bx	lr
  4042fe:	bf00      	nop
  404300:	400e0400 	.word	0x400e0400

00404304 <pmc_disable_pllack>:

/**
 * \brief Disable PLLA clock.
 */
void pmc_disable_pllack(void)
{
  404304:	b480      	push	{r7}
  404306:	af00      	add	r7, sp, #0
#if (SAM4C || SAM4CM || SAM4CP || SAMG)
	PMC->CKGR_PLLAR = CKGR_PLLAR_MULA(0);
#else
	PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | CKGR_PLLAR_MULA(0);
  404308:	4b04      	ldr	r3, [pc, #16]	; (40431c <pmc_disable_pllack+0x18>)
  40430a:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
  40430e:	629a      	str	r2, [r3, #40]	; 0x28
#endif
}
  404310:	bf00      	nop
  404312:	46bd      	mov	sp, r7
  404314:	f85d 7b04 	ldr.w	r7, [sp], #4
  404318:	4770      	bx	lr
  40431a:	bf00      	nop
  40431c:	400e0400 	.word	0x400e0400

00404320 <pmc_is_locked_pllack>:
 *
 * \retval 0 Not locked.
 * \retval 1 Locked.
 */
uint32_t pmc_is_locked_pllack(void)
{
  404320:	b480      	push	{r7}
  404322:	af00      	add	r7, sp, #0
	return (PMC->PMC_SR & PMC_SR_LOCKA);
  404324:	4b04      	ldr	r3, [pc, #16]	; (404338 <pmc_is_locked_pllack+0x18>)
  404326:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  404328:	f003 0302 	and.w	r3, r3, #2
}
  40432c:	4618      	mov	r0, r3
  40432e:	46bd      	mov	sp, r7
  404330:	f85d 7b04 	ldr.w	r7, [sp], #4
  404334:	4770      	bx	lr
  404336:	bf00      	nop
  404338:	400e0400 	.word	0x400e0400

0040433c <pmc_enable_periph_clk>:
 *
 * \retval 0 Success.
 * \retval 1 Invalid parameter.
 */
uint32_t pmc_enable_periph_clk(uint32_t ul_id)
{
  40433c:	b480      	push	{r7}
  40433e:	b083      	sub	sp, #12
  404340:	af00      	add	r7, sp, #0
  404342:	6078      	str	r0, [r7, #4]
	PMC->PMC_PCR = ul_id & 0x7F;
	pcr = PMC->PMC_PCR | PMC_PCR_EN | PMC_PCR_CMD;
	PMC->PMC_PCR = pcr;
	return 0;
#else
	if (ul_id > MAX_PERIPH_ID) {
  404344:	687b      	ldr	r3, [r7, #4]
  404346:	2b2f      	cmp	r3, #47	; 0x2f
  404348:	d901      	bls.n	40434e <pmc_enable_periph_clk+0x12>
		return 1;
  40434a:	2301      	movs	r3, #1
  40434c:	e02f      	b.n	4043ae <pmc_enable_periph_clk+0x72>
	}

	if (ul_id < 32) {
  40434e:	687b      	ldr	r3, [r7, #4]
  404350:	2b1f      	cmp	r3, #31
  404352:	d813      	bhi.n	40437c <pmc_enable_periph_clk+0x40>
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
  404354:	4b19      	ldr	r3, [pc, #100]	; (4043bc <pmc_enable_periph_clk+0x80>)
  404356:	699a      	ldr	r2, [r3, #24]
  404358:	2101      	movs	r1, #1
  40435a:	687b      	ldr	r3, [r7, #4]
  40435c:	fa01 f303 	lsl.w	r3, r1, r3
  404360:	401a      	ands	r2, r3
  404362:	2101      	movs	r1, #1
  404364:	687b      	ldr	r3, [r7, #4]
  404366:	fa01 f303 	lsl.w	r3, r1, r3
  40436a:	429a      	cmp	r2, r3
  40436c:	d01e      	beq.n	4043ac <pmc_enable_periph_clk+0x70>
			PMC->PMC_PCER0 = 1 << ul_id;
  40436e:	4a13      	ldr	r2, [pc, #76]	; (4043bc <pmc_enable_periph_clk+0x80>)
  404370:	2101      	movs	r1, #1
  404372:	687b      	ldr	r3, [r7, #4]
  404374:	fa01 f303 	lsl.w	r3, r1, r3
  404378:	6113      	str	r3, [r2, #16]
  40437a:	e017      	b.n	4043ac <pmc_enable_periph_clk+0x70>
		}
#if (SAM3S || SAM3XA || SAM4S || SAM4E || SAM4C || SAM4CM || SAM4CP || SAMG55 || SAMV71 || SAMV70 || SAME70 || SAMS70)
	} else {
		ul_id -= 32;
  40437c:	687b      	ldr	r3, [r7, #4]
  40437e:	3b20      	subs	r3, #32
  404380:	607b      	str	r3, [r7, #4]
		if ((PMC->PMC_PCSR1 & (1u << ul_id)) != (1u << ul_id)) {
  404382:	4b0e      	ldr	r3, [pc, #56]	; (4043bc <pmc_enable_periph_clk+0x80>)
  404384:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
  404388:	2101      	movs	r1, #1
  40438a:	687b      	ldr	r3, [r7, #4]
  40438c:	fa01 f303 	lsl.w	r3, r1, r3
  404390:	401a      	ands	r2, r3
  404392:	2101      	movs	r1, #1
  404394:	687b      	ldr	r3, [r7, #4]
  404396:	fa01 f303 	lsl.w	r3, r1, r3
  40439a:	429a      	cmp	r2, r3
  40439c:	d006      	beq.n	4043ac <pmc_enable_periph_clk+0x70>
			PMC->PMC_PCER1 = 1 << ul_id;
  40439e:	4a07      	ldr	r2, [pc, #28]	; (4043bc <pmc_enable_periph_clk+0x80>)
  4043a0:	2101      	movs	r1, #1
  4043a2:	687b      	ldr	r3, [r7, #4]
  4043a4:	fa01 f303 	lsl.w	r3, r1, r3
  4043a8:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
		}
#endif
	}

	return 0;
  4043ac:	2300      	movs	r3, #0
#endif /* defined(REG_PMC_PCR) && !SAMG55 */
}
  4043ae:	4618      	mov	r0, r3
  4043b0:	370c      	adds	r7, #12
  4043b2:	46bd      	mov	sp, r7
  4043b4:	f85d 7b04 	ldr.w	r7, [sp], #4
  4043b8:	4770      	bx	lr
  4043ba:	bf00      	nop
  4043bc:	400e0400 	.word	0x400e0400

004043c0 <pmc_disable_periph_clk>:
 *
 * \retval 0 Success.
 * \retval 1 Invalid parameter.
 */
uint32_t pmc_disable_periph_clk(uint32_t ul_id)
{
  4043c0:	b480      	push	{r7}
  4043c2:	b083      	sub	sp, #12
  4043c4:	af00      	add	r7, sp, #0
  4043c6:	6078      	str	r0, [r7, #4]
	PMC->PMC_PCR = ul_id & 0x7F;
	pcr = PMC->PMC_PCR | PMC_PCR_CMD;
	PMC->PMC_PCR = pcr;
	return 0;
#else
	if (ul_id > MAX_PERIPH_ID) {
  4043c8:	687b      	ldr	r3, [r7, #4]
  4043ca:	2b2f      	cmp	r3, #47	; 0x2f
  4043cc:	d901      	bls.n	4043d2 <pmc_disable_periph_clk+0x12>
		return 1;
  4043ce:	2301      	movs	r3, #1
  4043d0:	e02f      	b.n	404432 <pmc_disable_periph_clk+0x72>
	}

	if (ul_id < 32) {
  4043d2:	687b      	ldr	r3, [r7, #4]
  4043d4:	2b1f      	cmp	r3, #31
  4043d6:	d813      	bhi.n	404400 <pmc_disable_periph_clk+0x40>
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) == (1u << ul_id)) {
  4043d8:	4b19      	ldr	r3, [pc, #100]	; (404440 <pmc_disable_periph_clk+0x80>)
  4043da:	699a      	ldr	r2, [r3, #24]
  4043dc:	2101      	movs	r1, #1
  4043de:	687b      	ldr	r3, [r7, #4]
  4043e0:	fa01 f303 	lsl.w	r3, r1, r3
  4043e4:	401a      	ands	r2, r3
  4043e6:	2101      	movs	r1, #1
  4043e8:	687b      	ldr	r3, [r7, #4]
  4043ea:	fa01 f303 	lsl.w	r3, r1, r3
  4043ee:	429a      	cmp	r2, r3
  4043f0:	d11e      	bne.n	404430 <pmc_disable_periph_clk+0x70>
			PMC->PMC_PCDR0 = 1 << ul_id;
  4043f2:	4a13      	ldr	r2, [pc, #76]	; (404440 <pmc_disable_periph_clk+0x80>)
  4043f4:	2101      	movs	r1, #1
  4043f6:	687b      	ldr	r3, [r7, #4]
  4043f8:	fa01 f303 	lsl.w	r3, r1, r3
  4043fc:	6153      	str	r3, [r2, #20]
  4043fe:	e017      	b.n	404430 <pmc_disable_periph_clk+0x70>
		}
#if (SAM3S || SAM3XA || SAM4S || SAM4E || SAM4C || SAM4CM || SAM4CP || SAMG55 || SAMV71 \
		|| SAMV70 || SAME70 || SAMS70)
	} else {
		ul_id -= 32;
  404400:	687b      	ldr	r3, [r7, #4]
  404402:	3b20      	subs	r3, #32
  404404:	607b      	str	r3, [r7, #4]
		if ((PMC->PMC_PCSR1 & (1u << ul_id)) == (1u << ul_id)) {
  404406:	4b0e      	ldr	r3, [pc, #56]	; (404440 <pmc_disable_periph_clk+0x80>)
  404408:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
  40440c:	2101      	movs	r1, #1
  40440e:	687b      	ldr	r3, [r7, #4]
  404410:	fa01 f303 	lsl.w	r3, r1, r3
  404414:	401a      	ands	r2, r3
  404416:	2101      	movs	r1, #1
  404418:	687b      	ldr	r3, [r7, #4]
  40441a:	fa01 f303 	lsl.w	r3, r1, r3
  40441e:	429a      	cmp	r2, r3
  404420:	d106      	bne.n	404430 <pmc_disable_periph_clk+0x70>
			PMC->PMC_PCDR1 = 1 << ul_id;
  404422:	4a07      	ldr	r2, [pc, #28]	; (404440 <pmc_disable_periph_clk+0x80>)
  404424:	2101      	movs	r1, #1
  404426:	687b      	ldr	r3, [r7, #4]
  404428:	fa01 f303 	lsl.w	r3, r1, r3
  40442c:	f8c2 3104 	str.w	r3, [r2, #260]	; 0x104
		}
#endif
	}
	return 0;
  404430:	2300      	movs	r3, #0
#endif /* defined(REG_PMC_PCR) && !SAMG55 */
}
  404432:	4618      	mov	r0, r3
  404434:	370c      	adds	r7, #12
  404436:	46bd      	mov	sp, r7
  404438:	f85d 7b04 	ldr.w	r7, [sp], #4
  40443c:	4770      	bx	lr
  40443e:	bf00      	nop
  404440:	400e0400 	.word	0x400e0400

00404444 <pmc_is_wakeup_clocks_restored>:
#endif
	}
}

bool pmc_is_wakeup_clocks_restored(void)
{
  404444:	b480      	push	{r7}
  404446:	af00      	add	r7, sp, #0
	return !b_is_sleep_clock_used;
  404448:	4b09      	ldr	r3, [pc, #36]	; (404470 <pmc_is_wakeup_clocks_restored+0x2c>)
  40444a:	781b      	ldrb	r3, [r3, #0]
  40444c:	b2db      	uxtb	r3, r3
  40444e:	2b00      	cmp	r3, #0
  404450:	bf14      	ite	ne
  404452:	2301      	movne	r3, #1
  404454:	2300      	moveq	r3, #0
  404456:	b2db      	uxtb	r3, r3
  404458:	f083 0301 	eor.w	r3, r3, #1
  40445c:	b2db      	uxtb	r3, r3
  40445e:	f003 0301 	and.w	r3, r3, #1
  404462:	b2db      	uxtb	r3, r3
}
  404464:	4618      	mov	r0, r3
  404466:	46bd      	mov	sp, r7
  404468:	f85d 7b04 	ldr.w	r7, [sp], #4
  40446c:	4770      	bx	lr
  40446e:	bf00      	nop
  404470:	20006c40 	.word	0x20006c40

00404474 <sysclk_enable_peripheral_clock>:
{
  404474:	b580      	push	{r7, lr}
  404476:	b082      	sub	sp, #8
  404478:	af00      	add	r7, sp, #0
  40447a:	6078      	str	r0, [r7, #4]
	pmc_enable_periph_clk(ul_id);
  40447c:	6878      	ldr	r0, [r7, #4]
  40447e:	4b03      	ldr	r3, [pc, #12]	; (40448c <sysclk_enable_peripheral_clock+0x18>)
  404480:	4798      	blx	r3
}
  404482:	bf00      	nop
  404484:	3708      	adds	r7, #8
  404486:	46bd      	mov	sp, r7
  404488:	bd80      	pop	{r7, pc}
  40448a:	bf00      	nop
  40448c:	0040433d 	.word	0x0040433d

00404490 <spi_enable_clock>:
 * \brief Enable SPI clock.
 *
 * \param p_spi Pointer to an SPI instance.
 */
void spi_enable_clock(Spi *p_spi)
{
  404490:	b580      	push	{r7, lr}
  404492:	b082      	sub	sp, #8
  404494:	af00      	add	r7, sp, #0
  404496:	6078      	str	r0, [r7, #4]
#if (SAM4S || SAM3S || SAM3N || SAM3U || SAM4E || SAM4N || SAMG51|| SAMG53|| SAMG54)
	UNUSED(p_spi);
	sysclk_enable_peripheral_clock(ID_SPI);
  404498:	2013      	movs	r0, #19
  40449a:	4b03      	ldr	r3, [pc, #12]	; (4044a8 <spi_enable_clock+0x18>)
  40449c:	4798      	blx	r3
	}
	#endif
#elif SAM4L
	sysclk_enable_peripheral_clock(p_spi);
#endif
}
  40449e:	bf00      	nop
  4044a0:	3708      	adds	r7, #8
  4044a2:	46bd      	mov	sp, r7
  4044a4:	bd80      	pop	{r7, pc}
  4044a6:	bf00      	nop
  4044a8:	00404475 	.word	0x00404475

004044ac <spi_set_peripheral_chip_select_value>:
 *                 The decode mode can be enabled/disabled by follow functions:
 *                 \ref spi_enable_peripheral_select_decode,
 *                 \ref spi_disable_peripheral_select_decode.
 */
void spi_set_peripheral_chip_select_value(Spi *p_spi, uint32_t ul_value)
{
  4044ac:	b480      	push	{r7}
  4044ae:	b083      	sub	sp, #12
  4044b0:	af00      	add	r7, sp, #0
  4044b2:	6078      	str	r0, [r7, #4]
  4044b4:	6039      	str	r1, [r7, #0]
	p_spi->SPI_MR &= (~SPI_MR_PCS_Msk);
  4044b6:	687b      	ldr	r3, [r7, #4]
  4044b8:	685b      	ldr	r3, [r3, #4]
  4044ba:	f423 2270 	bic.w	r2, r3, #983040	; 0xf0000
  4044be:	687b      	ldr	r3, [r7, #4]
  4044c0:	605a      	str	r2, [r3, #4]
	p_spi->SPI_MR |= SPI_MR_PCS(ul_value);
  4044c2:	687b      	ldr	r3, [r7, #4]
  4044c4:	685a      	ldr	r2, [r3, #4]
  4044c6:	683b      	ldr	r3, [r7, #0]
  4044c8:	041b      	lsls	r3, r3, #16
  4044ca:	f403 2370 	and.w	r3, r3, #983040	; 0xf0000
  4044ce:	431a      	orrs	r2, r3
  4044d0:	687b      	ldr	r3, [r7, #4]
  4044d2:	605a      	str	r2, [r3, #4]
}
  4044d4:	bf00      	nop
  4044d6:	370c      	adds	r7, #12
  4044d8:	46bd      	mov	sp, r7
  4044da:	f85d 7b04 	ldr.w	r7, [sp], #4
  4044de:	4770      	bx	lr

004044e0 <spi_set_delay_between_chip_select>:
 *
 * \param p_spi Pointer to an SPI instance.
 * \param ul_delay Delay between chip selects (in number of MCK clocks).
 */
void spi_set_delay_between_chip_select(Spi *p_spi, uint32_t ul_delay)
{
  4044e0:	b480      	push	{r7}
  4044e2:	b083      	sub	sp, #12
  4044e4:	af00      	add	r7, sp, #0
  4044e6:	6078      	str	r0, [r7, #4]
  4044e8:	6039      	str	r1, [r7, #0]
	p_spi->SPI_MR &= (~SPI_MR_DLYBCS_Msk);
  4044ea:	687b      	ldr	r3, [r7, #4]
  4044ec:	685b      	ldr	r3, [r3, #4]
  4044ee:	f023 427f 	bic.w	r2, r3, #4278190080	; 0xff000000
  4044f2:	687b      	ldr	r3, [r7, #4]
  4044f4:	605a      	str	r2, [r3, #4]
	p_spi->SPI_MR |= SPI_MR_DLYBCS(ul_delay);
  4044f6:	687b      	ldr	r3, [r7, #4]
  4044f8:	685a      	ldr	r2, [r3, #4]
  4044fa:	683b      	ldr	r3, [r7, #0]
  4044fc:	061b      	lsls	r3, r3, #24
  4044fe:	431a      	orrs	r2, r3
  404500:	687b      	ldr	r3, [r7, #4]
  404502:	605a      	str	r2, [r3, #4]
}
  404504:	bf00      	nop
  404506:	370c      	adds	r7, #12
  404508:	46bd      	mov	sp, r7
  40450a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40450e:	4770      	bx	lr

00404510 <spi_set_clock_polarity>:
 * \param ul_pcs_ch Peripheral Chip Select channel (0~3).
 * \param ul_polarity Default clock state is logical one(high)/zero(low).
 */
void spi_set_clock_polarity(Spi *p_spi, uint32_t ul_pcs_ch,
		uint32_t ul_polarity)
{
  404510:	b480      	push	{r7}
  404512:	b085      	sub	sp, #20
  404514:	af00      	add	r7, sp, #0
  404516:	60f8      	str	r0, [r7, #12]
  404518:	60b9      	str	r1, [r7, #8]
  40451a:	607a      	str	r2, [r7, #4]
	if (ul_polarity) {
  40451c:	687b      	ldr	r3, [r7, #4]
  40451e:	2b00      	cmp	r3, #0
  404520:	d00c      	beq.n	40453c <spi_set_clock_polarity+0x2c>
		p_spi->SPI_CSR[ul_pcs_ch] |= SPI_CSR_CPOL;
  404522:	68fb      	ldr	r3, [r7, #12]
  404524:	68ba      	ldr	r2, [r7, #8]
  404526:	320c      	adds	r2, #12
  404528:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  40452c:	f043 0101 	orr.w	r1, r3, #1
  404530:	68fb      	ldr	r3, [r7, #12]
  404532:	68ba      	ldr	r2, [r7, #8]
  404534:	320c      	adds	r2, #12
  404536:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	} else {
		p_spi->SPI_CSR[ul_pcs_ch] &= (~SPI_CSR_CPOL);
	}
}
  40453a:	e00b      	b.n	404554 <spi_set_clock_polarity+0x44>
		p_spi->SPI_CSR[ul_pcs_ch] &= (~SPI_CSR_CPOL);
  40453c:	68fb      	ldr	r3, [r7, #12]
  40453e:	68ba      	ldr	r2, [r7, #8]
  404540:	320c      	adds	r2, #12
  404542:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  404546:	f023 0101 	bic.w	r1, r3, #1
  40454a:	68fb      	ldr	r3, [r7, #12]
  40454c:	68ba      	ldr	r2, [r7, #8]
  40454e:	320c      	adds	r2, #12
  404550:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
  404554:	bf00      	nop
  404556:	3714      	adds	r7, #20
  404558:	46bd      	mov	sp, r7
  40455a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40455e:	4770      	bx	lr

00404560 <spi_set_clock_phase>:
 * \param p_spi Pointer to an SPI instance.
 *  \param ul_pcs_ch Peripheral Chip Select channel (0~3).
 *  \param ul_phase Data capture on the rising/falling edge of clock.
 */
void spi_set_clock_phase(Spi *p_spi, uint32_t ul_pcs_ch, uint32_t ul_phase)
{
  404560:	b480      	push	{r7}
  404562:	b085      	sub	sp, #20
  404564:	af00      	add	r7, sp, #0
  404566:	60f8      	str	r0, [r7, #12]
  404568:	60b9      	str	r1, [r7, #8]
  40456a:	607a      	str	r2, [r7, #4]
	if (ul_phase) {
  40456c:	687b      	ldr	r3, [r7, #4]
  40456e:	2b00      	cmp	r3, #0
  404570:	d00c      	beq.n	40458c <spi_set_clock_phase+0x2c>
		p_spi->SPI_CSR[ul_pcs_ch] |= SPI_CSR_NCPHA;
  404572:	68fb      	ldr	r3, [r7, #12]
  404574:	68ba      	ldr	r2, [r7, #8]
  404576:	320c      	adds	r2, #12
  404578:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  40457c:	f043 0102 	orr.w	r1, r3, #2
  404580:	68fb      	ldr	r3, [r7, #12]
  404582:	68ba      	ldr	r2, [r7, #8]
  404584:	320c      	adds	r2, #12
  404586:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	} else {
		p_spi->SPI_CSR[ul_pcs_ch] &= (~SPI_CSR_NCPHA);
	}
}
  40458a:	e00b      	b.n	4045a4 <spi_set_clock_phase+0x44>
		p_spi->SPI_CSR[ul_pcs_ch] &= (~SPI_CSR_NCPHA);
  40458c:	68fb      	ldr	r3, [r7, #12]
  40458e:	68ba      	ldr	r2, [r7, #8]
  404590:	320c      	adds	r2, #12
  404592:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  404596:	f023 0102 	bic.w	r1, r3, #2
  40459a:	68fb      	ldr	r3, [r7, #12]
  40459c:	68ba      	ldr	r2, [r7, #8]
  40459e:	320c      	adds	r2, #12
  4045a0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
  4045a4:	bf00      	nop
  4045a6:	3714      	adds	r7, #20
  4045a8:	46bd      	mov	sp, r7
  4045aa:	f85d 7b04 	ldr.w	r7, [sp], #4
  4045ae:	4770      	bx	lr

004045b0 <spi_configure_cs_behavior>:
 * \param ul_pcs_ch Peripheral Chip Select channel (0~3).
 * \param ul_cs_behavior Behavior of the Chip Select after transfer.
 */
void spi_configure_cs_behavior(Spi *p_spi, uint32_t ul_pcs_ch,
		uint32_t ul_cs_behavior)
{
  4045b0:	b480      	push	{r7}
  4045b2:	b085      	sub	sp, #20
  4045b4:	af00      	add	r7, sp, #0
  4045b6:	60f8      	str	r0, [r7, #12]
  4045b8:	60b9      	str	r1, [r7, #8]
  4045ba:	607a      	str	r2, [r7, #4]
	if (ul_cs_behavior == SPI_CS_RISE_FORCED) {
  4045bc:	687b      	ldr	r3, [r7, #4]
  4045be:	2b04      	cmp	r3, #4
  4045c0:	d118      	bne.n	4045f4 <spi_configure_cs_behavior+0x44>
		p_spi->SPI_CSR[ul_pcs_ch] &= (~SPI_CSR_CSAAT);
  4045c2:	68fb      	ldr	r3, [r7, #12]
  4045c4:	68ba      	ldr	r2, [r7, #8]
  4045c6:	320c      	adds	r2, #12
  4045c8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  4045cc:	f023 0108 	bic.w	r1, r3, #8
  4045d0:	68fb      	ldr	r3, [r7, #12]
  4045d2:	68ba      	ldr	r2, [r7, #8]
  4045d4:	320c      	adds	r2, #12
  4045d6:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
		p_spi->SPI_CSR[ul_pcs_ch] |= SPI_CSR_CSNAAT;
  4045da:	68fb      	ldr	r3, [r7, #12]
  4045dc:	68ba      	ldr	r2, [r7, #8]
  4045de:	320c      	adds	r2, #12
  4045e0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  4045e4:	f043 0104 	orr.w	r1, r3, #4
  4045e8:	68fb      	ldr	r3, [r7, #12]
  4045ea:	68ba      	ldr	r2, [r7, #8]
  4045ec:	320c      	adds	r2, #12
  4045ee:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
		p_spi->SPI_CSR[ul_pcs_ch] &= (~SPI_CSR_CSAAT);
		p_spi->SPI_CSR[ul_pcs_ch] &= (~SPI_CSR_CSNAAT);
	} else if (ul_cs_behavior == SPI_CS_KEEP_LOW) {
		p_spi->SPI_CSR[ul_pcs_ch] |= SPI_CSR_CSAAT;
	}
}
  4045f2:	e02a      	b.n	40464a <spi_configure_cs_behavior+0x9a>
	} else if (ul_cs_behavior == SPI_CS_RISE_NO_TX) {
  4045f4:	687b      	ldr	r3, [r7, #4]
  4045f6:	2b00      	cmp	r3, #0
  4045f8:	d118      	bne.n	40462c <spi_configure_cs_behavior+0x7c>
		p_spi->SPI_CSR[ul_pcs_ch] &= (~SPI_CSR_CSAAT);
  4045fa:	68fb      	ldr	r3, [r7, #12]
  4045fc:	68ba      	ldr	r2, [r7, #8]
  4045fe:	320c      	adds	r2, #12
  404600:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  404604:	f023 0108 	bic.w	r1, r3, #8
  404608:	68fb      	ldr	r3, [r7, #12]
  40460a:	68ba      	ldr	r2, [r7, #8]
  40460c:	320c      	adds	r2, #12
  40460e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
		p_spi->SPI_CSR[ul_pcs_ch] &= (~SPI_CSR_CSNAAT);
  404612:	68fb      	ldr	r3, [r7, #12]
  404614:	68ba      	ldr	r2, [r7, #8]
  404616:	320c      	adds	r2, #12
  404618:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  40461c:	f023 0104 	bic.w	r1, r3, #4
  404620:	68fb      	ldr	r3, [r7, #12]
  404622:	68ba      	ldr	r2, [r7, #8]
  404624:	320c      	adds	r2, #12
  404626:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
  40462a:	e00e      	b.n	40464a <spi_configure_cs_behavior+0x9a>
	} else if (ul_cs_behavior == SPI_CS_KEEP_LOW) {
  40462c:	687b      	ldr	r3, [r7, #4]
  40462e:	2b08      	cmp	r3, #8
  404630:	d10b      	bne.n	40464a <spi_configure_cs_behavior+0x9a>
		p_spi->SPI_CSR[ul_pcs_ch] |= SPI_CSR_CSAAT;
  404632:	68fb      	ldr	r3, [r7, #12]
  404634:	68ba      	ldr	r2, [r7, #8]
  404636:	320c      	adds	r2, #12
  404638:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  40463c:	f043 0108 	orr.w	r1, r3, #8
  404640:	68fb      	ldr	r3, [r7, #12]
  404642:	68ba      	ldr	r2, [r7, #8]
  404644:	320c      	adds	r2, #12
  404646:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
  40464a:	bf00      	nop
  40464c:	3714      	adds	r7, #20
  40464e:	46bd      	mov	sp, r7
  404650:	f85d 7b04 	ldr.w	r7, [sp], #4
  404654:	4770      	bx	lr

00404656 <spi_set_bits_per_transfer>:
 * \param ul_bits Number of bits (8~16), use the pattern defined
 *        in the device header file.
 */
void spi_set_bits_per_transfer(Spi *p_spi, uint32_t ul_pcs_ch,
		uint32_t ul_bits)
{
  404656:	b480      	push	{r7}
  404658:	b085      	sub	sp, #20
  40465a:	af00      	add	r7, sp, #0
  40465c:	60f8      	str	r0, [r7, #12]
  40465e:	60b9      	str	r1, [r7, #8]
  404660:	607a      	str	r2, [r7, #4]
	p_spi->SPI_CSR[ul_pcs_ch] &= (~SPI_CSR_BITS_Msk);
  404662:	68fb      	ldr	r3, [r7, #12]
  404664:	68ba      	ldr	r2, [r7, #8]
  404666:	320c      	adds	r2, #12
  404668:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  40466c:	f023 01f0 	bic.w	r1, r3, #240	; 0xf0
  404670:	68fb      	ldr	r3, [r7, #12]
  404672:	68ba      	ldr	r2, [r7, #8]
  404674:	320c      	adds	r2, #12
  404676:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	p_spi->SPI_CSR[ul_pcs_ch] |= ul_bits;
  40467a:	68fb      	ldr	r3, [r7, #12]
  40467c:	68ba      	ldr	r2, [r7, #8]
  40467e:	320c      	adds	r2, #12
  404680:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
  404684:	687b      	ldr	r3, [r7, #4]
  404686:	ea42 0103 	orr.w	r1, r2, r3
  40468a:	68fb      	ldr	r3, [r7, #12]
  40468c:	68ba      	ldr	r2, [r7, #8]
  40468e:	320c      	adds	r2, #12
  404690:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
  404694:	bf00      	nop
  404696:	3714      	adds	r7, #20
  404698:	46bd      	mov	sp, r7
  40469a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40469e:	4770      	bx	lr

004046a0 <spi_calc_baudrate_div>:
 * \return Divider or error code.
 *   \retval > 0  Success.
 *   \retval < 0  Error.
 */
int16_t spi_calc_baudrate_div(const uint32_t baudrate, uint32_t mck)
{
  4046a0:	b480      	push	{r7}
  4046a2:	b085      	sub	sp, #20
  4046a4:	af00      	add	r7, sp, #0
  4046a6:	6078      	str	r0, [r7, #4]
  4046a8:	6039      	str	r1, [r7, #0]
	int baud_div = div_ceil(mck, baudrate);
  4046aa:	683a      	ldr	r2, [r7, #0]
  4046ac:	687b      	ldr	r3, [r7, #4]
  4046ae:	4413      	add	r3, r2
  4046b0:	1e5a      	subs	r2, r3, #1
  4046b2:	687b      	ldr	r3, [r7, #4]
  4046b4:	fbb2 f3f3 	udiv	r3, r2, r3
  4046b8:	60fb      	str	r3, [r7, #12]

	/* The value of baud_div is from 1 to 255 in the SCBR field. */
	if (baud_div <= 0 || baud_div > 255) {
  4046ba:	68fb      	ldr	r3, [r7, #12]
  4046bc:	2b00      	cmp	r3, #0
  4046be:	dd02      	ble.n	4046c6 <spi_calc_baudrate_div+0x26>
  4046c0:	68fb      	ldr	r3, [r7, #12]
  4046c2:	2bff      	cmp	r3, #255	; 0xff
  4046c4:	dd02      	ble.n	4046cc <spi_calc_baudrate_div+0x2c>
		return -1;
  4046c6:	f04f 33ff 	mov.w	r3, #4294967295
  4046ca:	e001      	b.n	4046d0 <spi_calc_baudrate_div+0x30>
	}

	return baud_div;
  4046cc:	68fb      	ldr	r3, [r7, #12]
  4046ce:	b21b      	sxth	r3, r3
}
  4046d0:	4618      	mov	r0, r3
  4046d2:	3714      	adds	r7, #20
  4046d4:	46bd      	mov	sp, r7
  4046d6:	f85d 7b04 	ldr.w	r7, [sp], #4
  4046da:	4770      	bx	lr

004046dc <spi_set_baudrate_div>:
 * \retval is 0 Success.
 * \retval is -1 Error.
 */
int16_t spi_set_baudrate_div(Spi *p_spi, uint32_t ul_pcs_ch,
		uint8_t uc_baudrate_divider)
{
  4046dc:	b480      	push	{r7}
  4046de:	b085      	sub	sp, #20
  4046e0:	af00      	add	r7, sp, #0
  4046e2:	60f8      	str	r0, [r7, #12]
  4046e4:	60b9      	str	r1, [r7, #8]
  4046e6:	4613      	mov	r3, r2
  4046e8:	71fb      	strb	r3, [r7, #7]
    /* Programming the SCBR field to 0 is forbidden */
    if (!uc_baudrate_divider){
  4046ea:	79fb      	ldrb	r3, [r7, #7]
  4046ec:	2b00      	cmp	r3, #0
  4046ee:	d102      	bne.n	4046f6 <spi_set_baudrate_div+0x1a>
        return -1;
  4046f0:	f04f 33ff 	mov.w	r3, #4294967295
  4046f4:	e01b      	b.n	40472e <spi_set_baudrate_div+0x52>
	}
	p_spi->SPI_CSR[ul_pcs_ch] &= (~SPI_CSR_SCBR_Msk);
  4046f6:	68fb      	ldr	r3, [r7, #12]
  4046f8:	68ba      	ldr	r2, [r7, #8]
  4046fa:	320c      	adds	r2, #12
  4046fc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  404700:	f423 417f 	bic.w	r1, r3, #65280	; 0xff00
  404704:	68fb      	ldr	r3, [r7, #12]
  404706:	68ba      	ldr	r2, [r7, #8]
  404708:	320c      	adds	r2, #12
  40470a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	p_spi->SPI_CSR[ul_pcs_ch] |= SPI_CSR_SCBR(uc_baudrate_divider);
  40470e:	68fb      	ldr	r3, [r7, #12]
  404710:	68ba      	ldr	r2, [r7, #8]
  404712:	320c      	adds	r2, #12
  404714:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
  404718:	79fb      	ldrb	r3, [r7, #7]
  40471a:	021b      	lsls	r3, r3, #8
  40471c:	b29b      	uxth	r3, r3
  40471e:	ea42 0103 	orr.w	r1, r2, r3
  404722:	68fb      	ldr	r3, [r7, #12]
  404724:	68ba      	ldr	r2, [r7, #8]
  404726:	320c      	adds	r2, #12
  404728:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    return 0;
  40472c:	2300      	movs	r3, #0
}
  40472e:	4618      	mov	r0, r3
  404730:	3714      	adds	r7, #20
  404732:	46bd      	mov	sp, r7
  404734:	f85d 7b04 	ldr.w	r7, [sp], #4
  404738:	4770      	bx	lr

0040473a <spi_set_transfer_delay>:
 * \param uc_dlybs Delay before SPCK (in number of MCK clocks).
 * \param uc_dlybct Delay between consecutive transfers (in number of MCK clocks).
 */
void spi_set_transfer_delay(Spi *p_spi, uint32_t ul_pcs_ch,
		uint8_t uc_dlybs, uint8_t uc_dlybct)
{
  40473a:	b480      	push	{r7}
  40473c:	b085      	sub	sp, #20
  40473e:	af00      	add	r7, sp, #0
  404740:	60f8      	str	r0, [r7, #12]
  404742:	60b9      	str	r1, [r7, #8]
  404744:	4611      	mov	r1, r2
  404746:	461a      	mov	r2, r3
  404748:	460b      	mov	r3, r1
  40474a:	71fb      	strb	r3, [r7, #7]
  40474c:	4613      	mov	r3, r2
  40474e:	71bb      	strb	r3, [r7, #6]
	p_spi->SPI_CSR[ul_pcs_ch] &= ~(SPI_CSR_DLYBS_Msk | SPI_CSR_DLYBCT_Msk);
  404750:	68fb      	ldr	r3, [r7, #12]
  404752:	68ba      	ldr	r2, [r7, #8]
  404754:	320c      	adds	r2, #12
  404756:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  40475a:	b299      	uxth	r1, r3
  40475c:	68fb      	ldr	r3, [r7, #12]
  40475e:	68ba      	ldr	r2, [r7, #8]
  404760:	320c      	adds	r2, #12
  404762:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	p_spi->SPI_CSR[ul_pcs_ch] |= SPI_CSR_DLYBS(uc_dlybs)
  404766:	68fb      	ldr	r3, [r7, #12]
  404768:	68ba      	ldr	r2, [r7, #8]
  40476a:	320c      	adds	r2, #12
  40476c:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
  404770:	79fb      	ldrb	r3, [r7, #7]
  404772:	041b      	lsls	r3, r3, #16
  404774:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
			| SPI_CSR_DLYBCT(uc_dlybct);
  404778:	79b9      	ldrb	r1, [r7, #6]
  40477a:	0609      	lsls	r1, r1, #24
  40477c:	430b      	orrs	r3, r1
	p_spi->SPI_CSR[ul_pcs_ch] |= SPI_CSR_DLYBS(uc_dlybs)
  40477e:	ea42 0103 	orr.w	r1, r2, r3
  404782:	68fb      	ldr	r3, [r7, #12]
  404784:	68ba      	ldr	r2, [r7, #8]
  404786:	320c      	adds	r2, #12
  404788:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
  40478c:	bf00      	nop
  40478e:	3714      	adds	r7, #20
  404790:	46bd      	mov	sp, r7
  404792:	f85d 7b04 	ldr.w	r7, [sp], #4
  404796:	4770      	bx	lr

00404798 <uart_init>:
 *
 * \retval 0 Success.
 * \retval 1 Bad baud rate generator value.
 */
uint32_t uart_init(Uart *p_uart, const sam_uart_opt_t *p_uart_opt)
{
  404798:	b480      	push	{r7}
  40479a:	b085      	sub	sp, #20
  40479c:	af00      	add	r7, sp, #0
  40479e:	6078      	str	r0, [r7, #4]
  4047a0:	6039      	str	r1, [r7, #0]
	uint32_t cd = 0;
  4047a2:	2300      	movs	r3, #0
  4047a4:	60fb      	str	r3, [r7, #12]

	/* Reset and disable receiver & transmitter */
	p_uart->UART_CR = UART_CR_RSTRX | UART_CR_RSTTX
  4047a6:	687b      	ldr	r3, [r7, #4]
  4047a8:	22ac      	movs	r2, #172	; 0xac
  4047aa:	601a      	str	r2, [r3, #0]
			| UART_CR_RXDIS | UART_CR_TXDIS;

	/* Check and configure baudrate */
	/* Asynchronous, no oversampling */
	cd = (p_uart_opt->ul_mck / p_uart_opt->ul_baudrate) / UART_MCK_DIV;
  4047ac:	683b      	ldr	r3, [r7, #0]
  4047ae:	681a      	ldr	r2, [r3, #0]
  4047b0:	683b      	ldr	r3, [r7, #0]
  4047b2:	685b      	ldr	r3, [r3, #4]
  4047b4:	fbb2 f3f3 	udiv	r3, r2, r3
  4047b8:	091b      	lsrs	r3, r3, #4
  4047ba:	60fb      	str	r3, [r7, #12]
	if (cd < UART_MCK_DIV_MIN_FACTOR || cd > UART_MCK_DIV_MAX_FACTOR)
  4047bc:	68fb      	ldr	r3, [r7, #12]
  4047be:	2b00      	cmp	r3, #0
  4047c0:	d003      	beq.n	4047ca <uart_init+0x32>
  4047c2:	68fb      	ldr	r3, [r7, #12]
  4047c4:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
  4047c8:	d301      	bcc.n	4047ce <uart_init+0x36>
		return 1;
  4047ca:	2301      	movs	r3, #1
  4047cc:	e00f      	b.n	4047ee <uart_init+0x56>

	p_uart->UART_BRGR = cd;
  4047ce:	687b      	ldr	r3, [r7, #4]
  4047d0:	68fa      	ldr	r2, [r7, #12]
  4047d2:	621a      	str	r2, [r3, #32]
	/* Configure mode */
	p_uart->UART_MR = p_uart_opt->ul_mode;
  4047d4:	683b      	ldr	r3, [r7, #0]
  4047d6:	689a      	ldr	r2, [r3, #8]
  4047d8:	687b      	ldr	r3, [r7, #4]
  4047da:	605a      	str	r2, [r3, #4]

#if (!SAMV71 && !SAMV70 && !SAME70 && !SAMS70)
	/* Disable PDC channel */
	p_uart->UART_PTCR = UART_PTCR_RXTDIS | UART_PTCR_TXTDIS;
  4047dc:	687b      	ldr	r3, [r7, #4]
  4047de:	f240 2202 	movw	r2, #514	; 0x202
  4047e2:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
#endif

	/* Enable receiver and transmitter */
	p_uart->UART_CR = UART_CR_RXEN | UART_CR_TXEN;
  4047e6:	687b      	ldr	r3, [r7, #4]
  4047e8:	2250      	movs	r2, #80	; 0x50
  4047ea:	601a      	str	r2, [r3, #0]

	return 0;
  4047ec:	2300      	movs	r3, #0
}
  4047ee:	4618      	mov	r0, r3
  4047f0:	3714      	adds	r7, #20
  4047f2:	46bd      	mov	sp, r7
  4047f4:	f85d 7b04 	ldr.w	r7, [sp], #4
  4047f8:	4770      	bx	lr

004047fa <uart_write>:
 *
 * \retval 0 Success.
 * \retval 1 I/O Failure, UART is not ready.
 */
uint32_t uart_write(Uart *p_uart, const uint8_t uc_data)
{
  4047fa:	b480      	push	{r7}
  4047fc:	b083      	sub	sp, #12
  4047fe:	af00      	add	r7, sp, #0
  404800:	6078      	str	r0, [r7, #4]
  404802:	460b      	mov	r3, r1
  404804:	70fb      	strb	r3, [r7, #3]
	/* Check if the transmitter is ready */
	if (!(p_uart->UART_SR & UART_SR_TXRDY))
  404806:	687b      	ldr	r3, [r7, #4]
  404808:	695b      	ldr	r3, [r3, #20]
  40480a:	f003 0302 	and.w	r3, r3, #2
  40480e:	2b00      	cmp	r3, #0
  404810:	d101      	bne.n	404816 <uart_write+0x1c>
		return 1;
  404812:	2301      	movs	r3, #1
  404814:	e003      	b.n	40481e <uart_write+0x24>

	/* Send character */
	p_uart->UART_THR = uc_data;
  404816:	78fa      	ldrb	r2, [r7, #3]
  404818:	687b      	ldr	r3, [r7, #4]
  40481a:	61da      	str	r2, [r3, #28]
	return 0;
  40481c:	2300      	movs	r3, #0
}
  40481e:	4618      	mov	r0, r3
  404820:	370c      	adds	r7, #12
  404822:	46bd      	mov	sp, r7
  404824:	f85d 7b04 	ldr.w	r7, [sp], #4
  404828:	4770      	bx	lr

0040482a <uart_read>:
 *
 * \retval 0 Success.
 * \retval 1 I/O Failure, UART is not ready.
 */
uint32_t uart_read(Uart *p_uart, uint8_t *puc_data)
{
  40482a:	b480      	push	{r7}
  40482c:	b083      	sub	sp, #12
  40482e:	af00      	add	r7, sp, #0
  404830:	6078      	str	r0, [r7, #4]
  404832:	6039      	str	r1, [r7, #0]
	/* Check if the receiver is ready */
	if ((p_uart->UART_SR & UART_SR_RXRDY) == 0)
  404834:	687b      	ldr	r3, [r7, #4]
  404836:	695b      	ldr	r3, [r3, #20]
  404838:	f003 0301 	and.w	r3, r3, #1
  40483c:	2b00      	cmp	r3, #0
  40483e:	d101      	bne.n	404844 <uart_read+0x1a>
		return 1;
  404840:	2301      	movs	r3, #1
  404842:	e005      	b.n	404850 <uart_read+0x26>

	/* Read character */
	*puc_data = (uint8_t) p_uart->UART_RHR;
  404844:	687b      	ldr	r3, [r7, #4]
  404846:	699b      	ldr	r3, [r3, #24]
  404848:	b2da      	uxtb	r2, r3
  40484a:	683b      	ldr	r3, [r7, #0]
  40484c:	701a      	strb	r2, [r3, #0]
	return 0;
  40484e:	2300      	movs	r3, #0
}
  404850:	4618      	mov	r0, r3
  404852:	370c      	adds	r7, #12
  404854:	46bd      	mov	sp, r7
  404856:	f85d 7b04 	ldr.w	r7, [sp], #4
  40485a:	4770      	bx	lr

0040485c <cpu_irq_save>:

static volatile uint32_t cpu_irq_critical_section_counter;
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
  40485c:	b480      	push	{r7}
  40485e:	b083      	sub	sp, #12
  404860:	af00      	add	r7, sp, #0
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
  404862:	f3ef 8310 	mrs	r3, PRIMASK
  404866:	607b      	str	r3, [r7, #4]
  return(result);
  404868:	687b      	ldr	r3, [r7, #4]
	volatile irqflags_t flags = cpu_irq_is_enabled();
  40486a:	2b00      	cmp	r3, #0
  40486c:	bf0c      	ite	eq
  40486e:	2301      	moveq	r3, #1
  404870:	2300      	movne	r3, #0
  404872:	b2db      	uxtb	r3, r3
  404874:	603b      	str	r3, [r7, #0]
  __ASM volatile ("cpsid i" : : : "memory");
  404876:	b672      	cpsid	i
    This function ensures the apparent order of the explicit memory operations before
    and after the instruction, without ensuring their completion.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb");
  404878:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
  40487c:	4b04      	ldr	r3, [pc, #16]	; (404890 <cpu_irq_save+0x34>)
  40487e:	2200      	movs	r2, #0
  404880:	701a      	strb	r2, [r3, #0]
	return flags;
  404882:	683b      	ldr	r3, [r7, #0]
}
  404884:	4618      	mov	r0, r3
  404886:	370c      	adds	r7, #12
  404888:	46bd      	mov	sp, r7
  40488a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40488e:	4770      	bx	lr
  404890:	200000c2 	.word	0x200000c2

00404894 <cpu_irq_is_enabled_flags>:

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
  404894:	b480      	push	{r7}
  404896:	b083      	sub	sp, #12
  404898:	af00      	add	r7, sp, #0
  40489a:	6078      	str	r0, [r7, #4]
	return (flags);
  40489c:	687b      	ldr	r3, [r7, #4]
  40489e:	2b00      	cmp	r3, #0
  4048a0:	bf14      	ite	ne
  4048a2:	2301      	movne	r3, #1
  4048a4:	2300      	moveq	r3, #0
  4048a6:	b2db      	uxtb	r3, r3
}
  4048a8:	4618      	mov	r0, r3
  4048aa:	370c      	adds	r7, #12
  4048ac:	46bd      	mov	sp, r7
  4048ae:	f85d 7b04 	ldr.w	r7, [sp], #4
  4048b2:	4770      	bx	lr

004048b4 <cpu_irq_restore>:

static inline void cpu_irq_restore(irqflags_t flags)
{
  4048b4:	b580      	push	{r7, lr}
  4048b6:	b082      	sub	sp, #8
  4048b8:	af00      	add	r7, sp, #0
  4048ba:	6078      	str	r0, [r7, #4]
	if (cpu_irq_is_enabled_flags(flags))
  4048bc:	6878      	ldr	r0, [r7, #4]
  4048be:	4b07      	ldr	r3, [pc, #28]	; (4048dc <cpu_irq_restore+0x28>)
  4048c0:	4798      	blx	r3
  4048c2:	4603      	mov	r3, r0
  4048c4:	2b00      	cmp	r3, #0
  4048c6:	d005      	beq.n	4048d4 <cpu_irq_restore+0x20>
		cpu_irq_enable();
  4048c8:	4b05      	ldr	r3, [pc, #20]	; (4048e0 <cpu_irq_restore+0x2c>)
  4048ca:	2201      	movs	r2, #1
  4048cc:	701a      	strb	r2, [r3, #0]
  4048ce:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
  4048d2:	b662      	cpsie	i
}
  4048d4:	bf00      	nop
  4048d6:	3708      	adds	r7, #8
  4048d8:	46bd      	mov	sp, r7
  4048da:	bd80      	pop	{r7, pc}
  4048dc:	00404895 	.word	0x00404895
  4048e0:	200000c2 	.word	0x200000c2

004048e4 <sleepmgr_lock_mode>:
 * not put the device to sleep in the deeper sleep modes.
 *
 * \param mode Sleep mode to lock.
 */
static inline void sleepmgr_lock_mode(enum sleepmgr_mode mode)
{
  4048e4:	b580      	push	{r7, lr}
  4048e6:	b084      	sub	sp, #16
  4048e8:	af00      	add	r7, sp, #0
  4048ea:	4603      	mov	r3, r0
  4048ec:	71fb      	strb	r3, [r7, #7]
#ifdef CONFIG_SLEEPMGR_ENABLE
	irqflags_t flags;

	if(sleepmgr_locks[mode] >= 0xff) {
  4048ee:	79fb      	ldrb	r3, [r7, #7]
  4048f0:	4a0a      	ldr	r2, [pc, #40]	; (40491c <sleepmgr_lock_mode+0x38>)
  4048f2:	5cd3      	ldrb	r3, [r2, r3]
  4048f4:	2bff      	cmp	r3, #255	; 0xff
  4048f6:	d100      	bne.n	4048fa <sleepmgr_lock_mode+0x16>
		while (true) {
  4048f8:	e7fe      	b.n	4048f8 <sleepmgr_lock_mode+0x14>
			// Check APP or change the data type to uint16_t.
		}
	}

	// Enter a critical section
	flags = cpu_irq_save();
  4048fa:	4b09      	ldr	r3, [pc, #36]	; (404920 <sleepmgr_lock_mode+0x3c>)
  4048fc:	4798      	blx	r3
  4048fe:	60f8      	str	r0, [r7, #12]

	++sleepmgr_locks[mode];
  404900:	79fb      	ldrb	r3, [r7, #7]
  404902:	4a06      	ldr	r2, [pc, #24]	; (40491c <sleepmgr_lock_mode+0x38>)
  404904:	5cd2      	ldrb	r2, [r2, r3]
  404906:	3201      	adds	r2, #1
  404908:	b2d1      	uxtb	r1, r2
  40490a:	4a04      	ldr	r2, [pc, #16]	; (40491c <sleepmgr_lock_mode+0x38>)
  40490c:	54d1      	strb	r1, [r2, r3]

	// Leave the critical section
	cpu_irq_restore(flags);
  40490e:	68f8      	ldr	r0, [r7, #12]
  404910:	4b04      	ldr	r3, [pc, #16]	; (404924 <sleepmgr_lock_mode+0x40>)
  404912:	4798      	blx	r3
#else
	UNUSED(mode);
#endif /* CONFIG_SLEEPMGR_ENABLE */
}
  404914:	bf00      	nop
  404916:	3710      	adds	r7, #16
  404918:	46bd      	mov	sp, r7
  40491a:	bd80      	pop	{r7, pc}
  40491c:	2000b580 	.word	0x2000b580
  404920:	0040485d 	.word	0x0040485d
  404924:	004048b5 	.word	0x004048b5

00404928 <sleepmgr_unlock_mode>:
 * manager can put the device to sleep in the deeper sleep modes.
 *
 * \param mode Sleep mode to unlock.
 */
static inline void sleepmgr_unlock_mode(enum sleepmgr_mode mode)
{
  404928:	b580      	push	{r7, lr}
  40492a:	b084      	sub	sp, #16
  40492c:	af00      	add	r7, sp, #0
  40492e:	4603      	mov	r3, r0
  404930:	71fb      	strb	r3, [r7, #7]
#ifdef CONFIG_SLEEPMGR_ENABLE
	irqflags_t flags;

	if(sleepmgr_locks[mode] == 0) {
  404932:	79fb      	ldrb	r3, [r7, #7]
  404934:	4a0a      	ldr	r2, [pc, #40]	; (404960 <sleepmgr_unlock_mode+0x38>)
  404936:	5cd3      	ldrb	r3, [r2, r3]
  404938:	2b00      	cmp	r3, #0
  40493a:	d100      	bne.n	40493e <sleepmgr_unlock_mode+0x16>
		while (true) {
  40493c:	e7fe      	b.n	40493c <sleepmgr_unlock_mode+0x14>
			// Check APP.
		}
	}

	// Enter a critical section
	flags = cpu_irq_save();
  40493e:	4b09      	ldr	r3, [pc, #36]	; (404964 <sleepmgr_unlock_mode+0x3c>)
  404940:	4798      	blx	r3
  404942:	60f8      	str	r0, [r7, #12]

	--sleepmgr_locks[mode];
  404944:	79fb      	ldrb	r3, [r7, #7]
  404946:	4a06      	ldr	r2, [pc, #24]	; (404960 <sleepmgr_unlock_mode+0x38>)
  404948:	5cd2      	ldrb	r2, [r2, r3]
  40494a:	3a01      	subs	r2, #1
  40494c:	b2d1      	uxtb	r1, r2
  40494e:	4a04      	ldr	r2, [pc, #16]	; (404960 <sleepmgr_unlock_mode+0x38>)
  404950:	54d1      	strb	r1, [r2, r3]

	// Leave the critical section
	cpu_irq_restore(flags);
  404952:	68f8      	ldr	r0, [r7, #12]
  404954:	4b04      	ldr	r3, [pc, #16]	; (404968 <sleepmgr_unlock_mode+0x40>)
  404956:	4798      	blx	r3
#else
	UNUSED(mode);
#endif /* CONFIG_SLEEPMGR_ENABLE */
}
  404958:	bf00      	nop
  40495a:	3710      	adds	r7, #16
  40495c:	46bd      	mov	sp, r7
  40495e:	bd80      	pop	{r7, pc}
  404960:	2000b580 	.word	0x2000b580
  404964:	0040485d 	.word	0x0040485d
  404968:	004048b5 	.word	0x004048b5

0040496c <udd_sleep_mode>:
/*! \brief Authorize or not the CPU powerdown mode
 *
 * \param b_enable   true to authorize idle mode
 */
static void udd_sleep_mode(bool b_idle)
{
  40496c:	b580      	push	{r7, lr}
  40496e:	b082      	sub	sp, #8
  404970:	af00      	add	r7, sp, #0
  404972:	4603      	mov	r3, r0
  404974:	71fb      	strb	r3, [r7, #7]
	if (!b_idle && udd_b_idle) {
  404976:	79fb      	ldrb	r3, [r7, #7]
  404978:	f083 0301 	eor.w	r3, r3, #1
  40497c:	b2db      	uxtb	r3, r3
  40497e:	2b00      	cmp	r3, #0
  404980:	d006      	beq.n	404990 <udd_sleep_mode+0x24>
  404982:	4b0d      	ldr	r3, [pc, #52]	; (4049b8 <udd_sleep_mode+0x4c>)
  404984:	781b      	ldrb	r3, [r3, #0]
  404986:	2b00      	cmp	r3, #0
  404988:	d002      	beq.n	404990 <udd_sleep_mode+0x24>
		sleepmgr_unlock_mode(UDP_SLEEP_MODE_USB_IDLE);
  40498a:	2002      	movs	r0, #2
  40498c:	4b0b      	ldr	r3, [pc, #44]	; (4049bc <udd_sleep_mode+0x50>)
  40498e:	4798      	blx	r3
	}
	if (b_idle && !udd_b_idle) {
  404990:	79fb      	ldrb	r3, [r7, #7]
  404992:	2b00      	cmp	r3, #0
  404994:	d009      	beq.n	4049aa <udd_sleep_mode+0x3e>
  404996:	4b08      	ldr	r3, [pc, #32]	; (4049b8 <udd_sleep_mode+0x4c>)
  404998:	781b      	ldrb	r3, [r3, #0]
  40499a:	f083 0301 	eor.w	r3, r3, #1
  40499e:	b2db      	uxtb	r3, r3
  4049a0:	2b00      	cmp	r3, #0
  4049a2:	d002      	beq.n	4049aa <udd_sleep_mode+0x3e>
		sleepmgr_lock_mode(UDP_SLEEP_MODE_USB_IDLE);
  4049a4:	2002      	movs	r0, #2
  4049a6:	4b06      	ldr	r3, [pc, #24]	; (4049c0 <udd_sleep_mode+0x54>)
  4049a8:	4798      	blx	r3
	}
	udd_b_idle = b_idle;
  4049aa:	4a03      	ldr	r2, [pc, #12]	; (4049b8 <udd_sleep_mode+0x4c>)
  4049ac:	79fb      	ldrb	r3, [r7, #7]
  4049ae:	7013      	strb	r3, [r2, #0]
}
  4049b0:	bf00      	nop
  4049b2:	3708      	adds	r7, #8
  4049b4:	46bd      	mov	sp, r7
  4049b6:	bd80      	pop	{r7, pc}
  4049b8:	20006c41 	.word	0x20006c41
  4049bc:	00404929 	.word	0x00404929
  4049c0:	004048e5 	.word	0x004048e5

004049c4 <UDP_Handler>:
 * - control endpoint events (setup reception, end of data transfer, underflow, overflow, stall)
 * - bulk/interrupt/isochronous endpoints events (end of data transfer)
 *
 */
ISR(UDD_USB_INT_FUN)
{
  4049c4:	b580      	push	{r7, lr}
  4049c6:	af00      	add	r7, sp, #0
	/* For fast wakeup clocks restore
	 * In WAIT mode, clocks are switched to FASTRC.
	 * After wakeup clocks should be restored, before that ISR should not
	 * be served.
	 */
	if (!pmc_is_wakeup_clocks_restored() && !Is_udd_suspend()) {
  4049c8:	4b66      	ldr	r3, [pc, #408]	; (404b64 <UDP_Handler+0x1a0>)
  4049ca:	4798      	blx	r3
  4049cc:	4603      	mov	r3, r0
  4049ce:	f083 0301 	eor.w	r3, r3, #1
  4049d2:	b2db      	uxtb	r3, r3
  4049d4:	2b00      	cmp	r3, #0
  4049d6:	d00c      	beq.n	4049f2 <UDP_Handler+0x2e>
  4049d8:	4b63      	ldr	r3, [pc, #396]	; (404b68 <UDP_Handler+0x1a4>)
  4049da:	69db      	ldr	r3, [r3, #28]
  4049dc:	f403 7380 	and.w	r3, r3, #256	; 0x100
  4049e0:	2b00      	cmp	r3, #0
  4049e2:	d106      	bne.n	4049f2 <UDP_Handler+0x2e>
  __ASM volatile ("cpsid i" : : : "memory");
  4049e4:	b672      	cpsid	i
  4049e6:	f3bf 8f5f 	dmb	sy
		cpu_irq_disable();
  4049ea:	4b60      	ldr	r3, [pc, #384]	; (404b6c <UDP_Handler+0x1a8>)
  4049ec:	2200      	movs	r2, #0
  4049ee:	701a      	strb	r2, [r3, #0]
		return;
  4049f0:	e0b7      	b.n	404b62 <UDP_Handler+0x19e>
	}
#endif
	/* The UDP peripheral clock in the Power Management Controller (PMC)
	   must be enabled before any read/write operations to the UDP registers
	   including the UDP_TXVC register. */
	udd_enable_periph_ck();
  4049f2:	2023      	movs	r0, #35	; 0x23
  4049f4:	4b5e      	ldr	r3, [pc, #376]	; (404b70 <UDP_Handler+0x1ac>)
  4049f6:	4798      	blx	r3

	if (Is_udd_sof_interrupt_enabled() && Is_udd_sof()) {
  4049f8:	4b5b      	ldr	r3, [pc, #364]	; (404b68 <UDP_Handler+0x1a4>)
  4049fa:	699b      	ldr	r3, [r3, #24]
  4049fc:	f403 6300 	and.w	r3, r3, #2048	; 0x800
  404a00:	2b00      	cmp	r3, #0
  404a02:	d00e      	beq.n	404a22 <UDP_Handler+0x5e>
  404a04:	4b58      	ldr	r3, [pc, #352]	; (404b68 <UDP_Handler+0x1a4>)
  404a06:	69db      	ldr	r3, [r3, #28]
  404a08:	f403 6300 	and.w	r3, r3, #2048	; 0x800
  404a0c:	2b00      	cmp	r3, #0
  404a0e:	d008      	beq.n	404a22 <UDP_Handler+0x5e>
		udd_ack_sof();
  404a10:	4b55      	ldr	r3, [pc, #340]	; (404b68 <UDP_Handler+0x1a4>)
  404a12:	f44f 6200 	mov.w	r2, #2048	; 0x800
  404a16:	621a      	str	r2, [r3, #32]
		udc_sof_notify();
  404a18:	4b56      	ldr	r3, [pc, #344]	; (404b74 <UDP_Handler+0x1b0>)
  404a1a:	4798      	blx	r3
#ifdef UDC_SOF_EVENT
		UDC_SOF_EVENT();
  404a1c:	4b56      	ldr	r3, [pc, #344]	; (404b78 <UDP_Handler+0x1b4>)
  404a1e:	4798      	blx	r3
#endif
		goto udd_interrupt_sof_end;
  404a20:	e09d      	b.n	404b5e <UDP_Handler+0x19a>
	}

	if (udd_ctrl_interrupt()) {
  404a22:	4b56      	ldr	r3, [pc, #344]	; (404b7c <UDP_Handler+0x1b8>)
  404a24:	4798      	blx	r3
  404a26:	4603      	mov	r3, r0
  404a28:	2b00      	cmp	r3, #0
  404a2a:	f040 8095 	bne.w	404b58 <UDP_Handler+0x194>
		goto udd_interrupt_end; // Interrupt acked by control endpoint managed
	}

#if (0 != USB_DEVICE_MAX_EP)
	if (udd_ep_interrupt()) {
  404a2e:	4b54      	ldr	r3, [pc, #336]	; (404b80 <UDP_Handler+0x1bc>)
  404a30:	4798      	blx	r3
  404a32:	4603      	mov	r3, r0
  404a34:	2b00      	cmp	r3, #0
  404a36:	f040 8091 	bne.w	404b5c <UDP_Handler+0x198>
		goto udd_interrupt_end; // Interrupt acked by bulk/interrupt/isochronous endpoint managed
	}
#endif

	if ((Is_udd_wake_up_interrupt_enabled() && Is_udd_wake_up()) ||
  404a3a:	4b4b      	ldr	r3, [pc, #300]	; (404b68 <UDP_Handler+0x1a4>)
  404a3c:	699b      	ldr	r3, [r3, #24]
  404a3e:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
  404a42:	2b00      	cmp	r3, #0
  404a44:	d005      	beq.n	404a52 <UDP_Handler+0x8e>
  404a46:	4b48      	ldr	r3, [pc, #288]	; (404b68 <UDP_Handler+0x1a4>)
  404a48:	69db      	ldr	r3, [r3, #28]
  404a4a:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
  404a4e:	2b00      	cmp	r3, #0
  404a50:	d117      	bne.n	404a82 <UDP_Handler+0xbe>
		(Is_udd_resume_interrupt_enabled() && Is_udd_resume()) ||
  404a52:	4b45      	ldr	r3, [pc, #276]	; (404b68 <UDP_Handler+0x1a4>)
  404a54:	699b      	ldr	r3, [r3, #24]
  404a56:	f403 7300 	and.w	r3, r3, #512	; 0x200
	if ((Is_udd_wake_up_interrupt_enabled() && Is_udd_wake_up()) ||
  404a5a:	2b00      	cmp	r3, #0
  404a5c:	d005      	beq.n	404a6a <UDP_Handler+0xa6>
		(Is_udd_resume_interrupt_enabled() && Is_udd_resume()) ||
  404a5e:	4b42      	ldr	r3, [pc, #264]	; (404b68 <UDP_Handler+0x1a4>)
  404a60:	69db      	ldr	r3, [r3, #28]
  404a62:	f403 7300 	and.w	r3, r3, #512	; 0x200
  404a66:	2b00      	cmp	r3, #0
  404a68:	d10b      	bne.n	404a82 <UDP_Handler+0xbe>
		(Is_udd_ext_resume_interrupt_enabled() && Is_udd_ext_resume())) {
  404a6a:	4b3f      	ldr	r3, [pc, #252]	; (404b68 <UDP_Handler+0x1a4>)
  404a6c:	699b      	ldr	r3, [r3, #24]
  404a6e:	f403 6380 	and.w	r3, r3, #1024	; 0x400
		(Is_udd_resume_interrupt_enabled() && Is_udd_resume()) ||
  404a72:	2b00      	cmp	r3, #0
  404a74:	d01f      	beq.n	404ab6 <UDP_Handler+0xf2>
		(Is_udd_ext_resume_interrupt_enabled() && Is_udd_ext_resume())) {
  404a76:	4b3c      	ldr	r3, [pc, #240]	; (404b68 <UDP_Handler+0x1a4>)
  404a78:	69db      	ldr	r3, [r3, #28]
  404a7a:	f403 6380 	and.w	r3, r3, #1024	; 0x400
  404a7e:	2b00      	cmp	r3, #0
  404a80:	d019      	beq.n	404ab6 <UDP_Handler+0xf2>
		// Ack wakeup interrupt and enable suspend interrupt
		udd_ack_wakeups();
  404a82:	4b39      	ldr	r3, [pc, #228]	; (404b68 <UDP_Handler+0x1a4>)
  404a84:	f44f 5218 	mov.w	r2, #9728	; 0x2600
  404a88:	621a      	str	r2, [r3, #32]
		// Do resume operations
		udd_disable_wakeups();
  404a8a:	4b37      	ldr	r3, [pc, #220]	; (404b68 <UDP_Handler+0x1a4>)
  404a8c:	f44f 5218 	mov.w	r2, #9728	; 0x2600
  404a90:	615a      	str	r2, [r3, #20]

		udd_sleep_mode(true); // Enter in IDLE mode
  404a92:	2001      	movs	r0, #1
  404a94:	4b3b      	ldr	r3, [pc, #236]	; (404b84 <UDP_Handler+0x1c0>)
  404a96:	4798      	blx	r3
#ifdef UDC_RESUME_EVENT
		UDC_RESUME_EVENT();
  404a98:	4b3b      	ldr	r3, [pc, #236]	; (404b88 <UDP_Handler+0x1c4>)
  404a9a:	4798      	blx	r3
#endif
		udd_ack_suspend();
  404a9c:	4b32      	ldr	r3, [pc, #200]	; (404b68 <UDP_Handler+0x1a4>)
  404a9e:	f44f 7280 	mov.w	r2, #256	; 0x100
  404aa2:	621a      	str	r2, [r3, #32]
		udd_enable_suspend_interrupt();
  404aa4:	4b30      	ldr	r3, [pc, #192]	; (404b68 <UDP_Handler+0x1a4>)
  404aa6:	f44f 7280 	mov.w	r2, #256	; 0x100
  404aaa:	611a      	str	r2, [r3, #16]
		udd_enable_sof_interrupt();
  404aac:	4b2e      	ldr	r3, [pc, #184]	; (404b68 <UDP_Handler+0x1a4>)
  404aae:	f44f 6200 	mov.w	r2, #2048	; 0x800
  404ab2:	611a      	str	r2, [r3, #16]
		goto udd_interrupt_end;
  404ab4:	e053      	b.n	404b5e <UDP_Handler+0x19a>
	}

	if (Is_udd_suspend_interrupt_enabled() && Is_udd_suspend()) {
  404ab6:	4b2c      	ldr	r3, [pc, #176]	; (404b68 <UDP_Handler+0x1a4>)
  404ab8:	699b      	ldr	r3, [r3, #24]
  404aba:	f403 7380 	and.w	r3, r3, #256	; 0x100
  404abe:	2b00      	cmp	r3, #0
  404ac0:	d022      	beq.n	404b08 <UDP_Handler+0x144>
  404ac2:	4b29      	ldr	r3, [pc, #164]	; (404b68 <UDP_Handler+0x1a4>)
  404ac4:	69db      	ldr	r3, [r3, #28]
  404ac6:	f403 7380 	and.w	r3, r3, #256	; 0x100
  404aca:	2b00      	cmp	r3, #0
  404acc:	d01c      	beq.n	404b08 <UDP_Handler+0x144>
		// Ack suspend interrupt and enable resume interrupt
		udd_ack_suspend();
  404ace:	4b26      	ldr	r3, [pc, #152]	; (404b68 <UDP_Handler+0x1a4>)
  404ad0:	f44f 7280 	mov.w	r2, #256	; 0x100
  404ad4:	621a      	str	r2, [r3, #32]
		udd_disable_suspend_interrupt();
  404ad6:	4b24      	ldr	r3, [pc, #144]	; (404b68 <UDP_Handler+0x1a4>)
  404ad8:	f44f 7280 	mov.w	r2, #256	; 0x100
  404adc:	615a      	str	r2, [r3, #20]
		udd_enable_wake_up_interrupt();
  404ade:	4b22      	ldr	r3, [pc, #136]	; (404b68 <UDP_Handler+0x1a4>)
  404ae0:	f44f 5200 	mov.w	r2, #8192	; 0x2000
  404ae4:	611a      	str	r2, [r3, #16]
		udd_enable_resume_interrupt();
  404ae6:	4b20      	ldr	r3, [pc, #128]	; (404b68 <UDP_Handler+0x1a4>)
  404ae8:	f44f 7200 	mov.w	r2, #512	; 0x200
  404aec:	611a      	str	r2, [r3, #16]
		udd_enable_ext_resume_interrupt();
  404aee:	4b1e      	ldr	r3, [pc, #120]	; (404b68 <UDP_Handler+0x1a4>)
  404af0:	f44f 6280 	mov.w	r2, #1024	; 0x400
  404af4:	611a      	str	r2, [r3, #16]
		udd_disable_periph_ck();
  404af6:	2023      	movs	r0, #35	; 0x23
  404af8:	4b24      	ldr	r3, [pc, #144]	; (404b8c <UDP_Handler+0x1c8>)
  404afa:	4798      	blx	r3

		udd_sleep_mode(false); // Enter in SUSPEND mode
  404afc:	2000      	movs	r0, #0
  404afe:	4b21      	ldr	r3, [pc, #132]	; (404b84 <UDP_Handler+0x1c0>)
  404b00:	4798      	blx	r3
#ifdef UDC_SUSPEND_EVENT
		UDC_SUSPEND_EVENT();
  404b02:	4b23      	ldr	r3, [pc, #140]	; (404b90 <UDP_Handler+0x1cc>)
  404b04:	4798      	blx	r3
#endif
		goto udd_interrupt_end;
  404b06:	e02a      	b.n	404b5e <UDP_Handler+0x19a>
	}
	if (Is_udd_reset()) {
  404b08:	4b17      	ldr	r3, [pc, #92]	; (404b68 <UDP_Handler+0x1a4>)
  404b0a:	69db      	ldr	r3, [r3, #28]
  404b0c:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
  404b10:	2b00      	cmp	r3, #0
  404b12:	d025      	beq.n	404b60 <UDP_Handler+0x19c>
		// USB bus reset detection
		udd_ack_reset();
  404b14:	4b14      	ldr	r3, [pc, #80]	; (404b68 <UDP_Handler+0x1a4>)
  404b16:	f44f 5280 	mov.w	r2, #4096	; 0x1000
  404b1a:	621a      	str	r2, [r3, #32]

		// Abort all jobs on-going
#if (0 != USB_DEVICE_MAX_EP)
		udd_ep_job_table_kill();
  404b1c:	4b1d      	ldr	r3, [pc, #116]	; (404b94 <UDP_Handler+0x1d0>)
  404b1e:	4798      	blx	r3
#endif
		// Reset USB Device Stack Core
		udc_reset();
  404b20:	4b1d      	ldr	r3, [pc, #116]	; (404b98 <UDP_Handler+0x1d4>)
  404b22:	4798      	blx	r3
		// Reset device state
		udd_disable_address_state();
  404b24:	4a10      	ldr	r2, [pc, #64]	; (404b68 <UDP_Handler+0x1a4>)
  404b26:	4b10      	ldr	r3, [pc, #64]	; (404b68 <UDP_Handler+0x1a4>)
  404b28:	685b      	ldr	r3, [r3, #4]
  404b2a:	f023 0301 	bic.w	r3, r3, #1
  404b2e:	6053      	str	r3, [r2, #4]
		udd_disable_configured_state();
  404b30:	4a0d      	ldr	r2, [pc, #52]	; (404b68 <UDP_Handler+0x1a4>)
  404b32:	4b0d      	ldr	r3, [pc, #52]	; (404b68 <UDP_Handler+0x1a4>)
  404b34:	685b      	ldr	r3, [r3, #4]
  404b36:	f023 0302 	bic.w	r3, r3, #2
  404b3a:	6053      	str	r3, [r2, #4]
		// Reset endpoint control
		udd_reset_ep_ctrl();
  404b3c:	4b17      	ldr	r3, [pc, #92]	; (404b9c <UDP_Handler+0x1d8>)
  404b3e:	4798      	blx	r3
		// Reset endpoint control management
		udd_ctrl_init();
  404b40:	4b17      	ldr	r3, [pc, #92]	; (404ba0 <UDP_Handler+0x1dc>)
  404b42:	4798      	blx	r3
		// After a USB reset, the suspend and SOF interrupt masks has been reseted
		// Thus, re-enable these
		udd_enable_suspend_interrupt();
  404b44:	4b08      	ldr	r3, [pc, #32]	; (404b68 <UDP_Handler+0x1a4>)
  404b46:	f44f 7280 	mov.w	r2, #256	; 0x100
  404b4a:	611a      	str	r2, [r3, #16]
		udd_enable_sof_interrupt();
  404b4c:	4b06      	ldr	r3, [pc, #24]	; (404b68 <UDP_Handler+0x1a4>)
  404b4e:	f44f 6200 	mov.w	r2, #2048	; 0x800
  404b52:	611a      	str	r2, [r3, #16]
		goto udd_interrupt_end;
  404b54:	bf00      	nop
  404b56:	e002      	b.n	404b5e <UDP_Handler+0x19a>
		goto udd_interrupt_end; // Interrupt acked by control endpoint managed
  404b58:	bf00      	nop
  404b5a:	e000      	b.n	404b5e <UDP_Handler+0x19a>
		goto udd_interrupt_end; // Interrupt acked by bulk/interrupt/isochronous endpoint managed
  404b5c:	bf00      	nop
	}

udd_interrupt_end:
udd_interrupt_sof_end:
	return;
  404b5e:	bf00      	nop
  404b60:	bf00      	nop
}
  404b62:	bd80      	pop	{r7, pc}
  404b64:	00404445 	.word	0x00404445
  404b68:	40084000 	.word	0x40084000
  404b6c:	200000c2 	.word	0x200000c2
  404b70:	0040433d 	.word	0x0040433d
  404b74:	00401f9d 	.word	0x00401f9d
  404b78:	004162e1 	.word	0x004162e1
  404b7c:	00405d39 	.word	0x00405d39
  404b80:	00406391 	.word	0x00406391
  404b84:	0040496d 	.word	0x0040496d
  404b88:	004162d1 	.word	0x004162d1
  404b8c:	004043c1 	.word	0x004043c1
  404b90:	004162c1 	.word	0x004162c1
  404b94:	00405de1 	.word	0x00405de1
  404b98:	00401f49 	.word	0x00401f49
  404b9c:	00405589 	.word	0x00405589
  404ba0:	00405631 	.word	0x00405631

00404ba4 <udd_set_address>:
	return false;
}


void udd_set_address(uint8_t address)
{
  404ba4:	b480      	push	{r7}
  404ba6:	b083      	sub	sp, #12
  404ba8:	af00      	add	r7, sp, #0
  404baa:	4603      	mov	r3, r0
  404bac:	71fb      	strb	r3, [r7, #7]
	udd_disable_address_state();
  404bae:	4a15      	ldr	r2, [pc, #84]	; (404c04 <udd_set_address+0x60>)
  404bb0:	4b14      	ldr	r3, [pc, #80]	; (404c04 <udd_set_address+0x60>)
  404bb2:	685b      	ldr	r3, [r3, #4]
  404bb4:	f023 0301 	bic.w	r3, r3, #1
  404bb8:	6053      	str	r3, [r2, #4]
	udd_disable_address();
  404bba:	4a12      	ldr	r2, [pc, #72]	; (404c04 <udd_set_address+0x60>)
  404bbc:	4b11      	ldr	r3, [pc, #68]	; (404c04 <udd_set_address+0x60>)
  404bbe:	689b      	ldr	r3, [r3, #8]
  404bc0:	f423 7380 	bic.w	r3, r3, #256	; 0x100
  404bc4:	6093      	str	r3, [r2, #8]
	if (address) {
  404bc6:	79fb      	ldrb	r3, [r7, #7]
  404bc8:	2b00      	cmp	r3, #0
  404bca:	d015      	beq.n	404bf8 <udd_set_address+0x54>
		udd_configure_address(address);
  404bcc:	490d      	ldr	r1, [pc, #52]	; (404c04 <udd_set_address+0x60>)
  404bce:	4b0d      	ldr	r3, [pc, #52]	; (404c04 <udd_set_address+0x60>)
  404bd0:	689b      	ldr	r3, [r3, #8]
  404bd2:	f023 027f 	bic.w	r2, r3, #127	; 0x7f
  404bd6:	79fb      	ldrb	r3, [r7, #7]
  404bd8:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  404bdc:	4313      	orrs	r3, r2
  404bde:	608b      	str	r3, [r1, #8]
		udd_enable_address();
  404be0:	4a08      	ldr	r2, [pc, #32]	; (404c04 <udd_set_address+0x60>)
  404be2:	4b08      	ldr	r3, [pc, #32]	; (404c04 <udd_set_address+0x60>)
  404be4:	689b      	ldr	r3, [r3, #8]
  404be6:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  404bea:	6093      	str	r3, [r2, #8]
		udd_enable_address_state();
  404bec:	4a05      	ldr	r2, [pc, #20]	; (404c04 <udd_set_address+0x60>)
  404bee:	4b05      	ldr	r3, [pc, #20]	; (404c04 <udd_set_address+0x60>)
  404bf0:	685b      	ldr	r3, [r3, #4]
  404bf2:	f043 0301 	orr.w	r3, r3, #1
  404bf6:	6053      	str	r3, [r2, #4]
	}
}
  404bf8:	bf00      	nop
  404bfa:	370c      	adds	r7, #12
  404bfc:	46bd      	mov	sp, r7
  404bfe:	f85d 7b04 	ldr.w	r7, [sp], #4
  404c02:	4770      	bx	lr
  404c04:	40084000 	.word	0x40084000

00404c08 <udd_getaddress>:


uint8_t udd_getaddress(void)
{
  404c08:	b480      	push	{r7}
  404c0a:	af00      	add	r7, sp, #0
	if (Is_udd_address_state_enabled())
  404c0c:	4b09      	ldr	r3, [pc, #36]	; (404c34 <udd_getaddress+0x2c>)
  404c0e:	685b      	ldr	r3, [r3, #4]
  404c10:	f003 0301 	and.w	r3, r3, #1
  404c14:	2b00      	cmp	r3, #0
  404c16:	d006      	beq.n	404c26 <udd_getaddress+0x1e>
		return udd_get_configured_address();
  404c18:	4b06      	ldr	r3, [pc, #24]	; (404c34 <udd_getaddress+0x2c>)
  404c1a:	689b      	ldr	r3, [r3, #8]
  404c1c:	b2db      	uxtb	r3, r3
  404c1e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  404c22:	b2db      	uxtb	r3, r3
  404c24:	e000      	b.n	404c28 <udd_getaddress+0x20>
	return 0;
  404c26:	2300      	movs	r3, #0
}
  404c28:	4618      	mov	r0, r3
  404c2a:	46bd      	mov	sp, r7
  404c2c:	f85d 7b04 	ldr.w	r7, [sp], #4
  404c30:	4770      	bx	lr
  404c32:	bf00      	nop
  404c34:	40084000 	.word	0x40084000

00404c38 <udd_get_frame_number>:


uint16_t udd_get_frame_number(void)
{
  404c38:	b480      	push	{r7}
  404c3a:	af00      	add	r7, sp, #0
	return udd_frame_number();
  404c3c:	4b05      	ldr	r3, [pc, #20]	; (404c54 <udd_get_frame_number+0x1c>)
  404c3e:	681b      	ldr	r3, [r3, #0]
  404c40:	b29b      	uxth	r3, r3
  404c42:	f3c3 030a 	ubfx	r3, r3, #0, #11
  404c46:	b29b      	uxth	r3, r3
}
  404c48:	4618      	mov	r0, r3
  404c4a:	46bd      	mov	sp, r7
  404c4c:	f85d 7b04 	ldr.w	r7, [sp], #4
  404c50:	4770      	bx	lr
  404c52:	bf00      	nop
  404c54:	40084000 	.word	0x40084000

00404c58 <udd_set_setup_payload>:
	}
}


void udd_set_setup_payload( uint8_t *payload, uint16_t payload_size )
{
  404c58:	b480      	push	{r7}
  404c5a:	b083      	sub	sp, #12
  404c5c:	af00      	add	r7, sp, #0
  404c5e:	6078      	str	r0, [r7, #4]
  404c60:	460b      	mov	r3, r1
  404c62:	807b      	strh	r3, [r7, #2]
	udd_g_ctrlreq.payload = payload;
  404c64:	4a05      	ldr	r2, [pc, #20]	; (404c7c <udd_set_setup_payload+0x24>)
  404c66:	687b      	ldr	r3, [r7, #4]
  404c68:	6093      	str	r3, [r2, #8]
	udd_g_ctrlreq.payload_size = payload_size;
  404c6a:	4a04      	ldr	r2, [pc, #16]	; (404c7c <udd_set_setup_payload+0x24>)
  404c6c:	887b      	ldrh	r3, [r7, #2]
  404c6e:	8193      	strh	r3, [r2, #12]
}
  404c70:	bf00      	nop
  404c72:	370c      	adds	r7, #12
  404c74:	46bd      	mov	sp, r7
  404c76:	f85d 7b04 	ldr.w	r7, [sp], #4
  404c7a:	4770      	bx	lr
  404c7c:	2000b598 	.word	0x2000b598

00404c80 <udd_ep_alloc>:


#if (0!=USB_DEVICE_MAX_EP)
bool udd_ep_alloc(udd_ep_id_t ep, uint8_t bmAttributes,
		uint16_t MaxEndpointSize)
{
  404c80:	b480      	push	{r7}
  404c82:	b087      	sub	sp, #28
  404c84:	af00      	add	r7, sp, #0
  404c86:	4603      	mov	r3, r0
  404c88:	71fb      	strb	r3, [r7, #7]
  404c8a:	460b      	mov	r3, r1
  404c8c:	71bb      	strb	r3, [r7, #6]
  404c8e:	4613      	mov	r3, r2
  404c90:	80bb      	strh	r3, [r7, #4]
	udd_ep_job_t *ptr_job;
	bool b_dir_in;
	bool b_iso;
	b_dir_in = ep & USB_EP_DIR_IN;
  404c92:	79fb      	ldrb	r3, [r7, #7]
  404c94:	f003 0380 	and.w	r3, r3, #128	; 0x80
  404c98:	2b00      	cmp	r3, #0
  404c9a:	bf14      	ite	ne
  404c9c:	2301      	movne	r3, #1
  404c9e:	2300      	moveq	r3, #0
  404ca0:	75fb      	strb	r3, [r7, #23]
	b_iso = (bmAttributes&USB_EP_TYPE_MASK) == USB_EP_TYPE_ISOCHRONOUS;
  404ca2:	79bb      	ldrb	r3, [r7, #6]
  404ca4:	f003 0303 	and.w	r3, r3, #3
  404ca8:	2b01      	cmp	r3, #1
  404caa:	bf0c      	ite	eq
  404cac:	2301      	moveq	r3, #1
  404cae:	2300      	movne	r3, #0
  404cb0:	75bb      	strb	r3, [r7, #22]
	ep = ep & USB_EP_ADDR_MASK;
  404cb2:	79fb      	ldrb	r3, [r7, #7]
  404cb4:	f003 030f 	and.w	r3, r3, #15
  404cb8:	71fb      	strb	r3, [r7, #7]

	if (ep > USB_DEVICE_MAX_EP) {
  404cba:	79fb      	ldrb	r3, [r7, #7]
  404cbc:	2b02      	cmp	r3, #2
  404cbe:	d901      	bls.n	404cc4 <udd_ep_alloc+0x44>
		return false;
  404cc0:	2300      	movs	r3, #0
  404cc2:	e0ca      	b.n	404e5a <udd_ep_alloc+0x1da>
	}
	if (Is_udd_endpoint_enabled(ep)) {
  404cc4:	4a68      	ldr	r2, [pc, #416]	; (404e68 <udd_ep_alloc+0x1e8>)
  404cc6:	79fb      	ldrb	r3, [r7, #7]
  404cc8:	330c      	adds	r3, #12
  404cca:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  404cce:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
  404cd2:	2b00      	cmp	r3, #0
  404cd4:	d001      	beq.n	404cda <udd_ep_alloc+0x5a>
		return false;
  404cd6:	2300      	movs	r3, #0
  404cd8:	e0bf      	b.n	404e5a <udd_ep_alloc+0x1da>
	}

	// Check parameters
	if (b_iso && (!udd_is_endpoint_support_iso(ep))) {
  404cda:	7dbb      	ldrb	r3, [r7, #22]
  404cdc:	2b00      	cmp	r3, #0
  404cde:	d007      	beq.n	404cf0 <udd_ep_alloc+0x70>
  404ce0:	79fb      	ldrb	r3, [r7, #7]
  404ce2:	2b00      	cmp	r3, #0
  404ce4:	d002      	beq.n	404cec <udd_ep_alloc+0x6c>
  404ce6:	79fb      	ldrb	r3, [r7, #7]
  404ce8:	2b03      	cmp	r3, #3
  404cea:	d101      	bne.n	404cf0 <udd_ep_alloc+0x70>
		return false;
  404cec:	2300      	movs	r3, #0
  404cee:	e0b4      	b.n	404e5a <udd_ep_alloc+0x1da>
	}
	if (MaxEndpointSize > udd_get_endpoint_size_max(ep)) {
  404cf0:	88ba      	ldrh	r2, [r7, #4]
  404cf2:	79fb      	ldrb	r3, [r7, #7]
  404cf4:	2b04      	cmp	r3, #4
  404cf6:	d002      	beq.n	404cfe <udd_ep_alloc+0x7e>
  404cf8:	79fb      	ldrb	r3, [r7, #7]
  404cfa:	2b05      	cmp	r3, #5
  404cfc:	d102      	bne.n	404d04 <udd_ep_alloc+0x84>
  404cfe:	f44f 7300 	mov.w	r3, #512	; 0x200
  404d02:	e000      	b.n	404d06 <udd_ep_alloc+0x86>
  404d04:	2340      	movs	r3, #64	; 0x40
  404d06:	429a      	cmp	r2, r3
  404d08:	dd01      	ble.n	404d0e <udd_ep_alloc+0x8e>
		return false;
  404d0a:	2300      	movs	r3, #0
  404d0c:	e0a5      	b.n	404e5a <udd_ep_alloc+0x1da>
	}
	ptr_job = &udd_ep_job[ep - 1];
  404d0e:	79fb      	ldrb	r3, [r7, #7]
  404d10:	1e5a      	subs	r2, r3, #1
  404d12:	4613      	mov	r3, r2
  404d14:	009b      	lsls	r3, r3, #2
  404d16:	4413      	add	r3, r2
  404d18:	009b      	lsls	r3, r3, #2
  404d1a:	4a54      	ldr	r2, [pc, #336]	; (404e6c <udd_ep_alloc+0x1ec>)
  404d1c:	4413      	add	r3, r2
  404d1e:	613b      	str	r3, [r7, #16]

	// Set endpoint size
	ptr_job->size = MaxEndpointSize;
  404d20:	88bb      	ldrh	r3, [r7, #4]
  404d22:	f3c3 0309 	ubfx	r3, r3, #0, #10
  404d26:	b299      	uxth	r1, r3
  404d28:	693a      	ldr	r2, [r7, #16]
  404d2a:	8a13      	ldrh	r3, [r2, #16]
  404d2c:	f361 0309 	bfi	r3, r1, #0, #10
  404d30:	8213      	strh	r3, [r2, #16]
	ptr_job->b_buf_end = false;
  404d32:	693a      	ldr	r2, [r7, #16]
  404d34:	7c53      	ldrb	r3, [r2, #17]
  404d36:	f36f 13c7 	bfc	r3, #7, #1
  404d3a:	7453      	strb	r3, [r2, #17]
	ptr_job->b_stall_requested = false;
  404d3c:	693a      	ldr	r2, [r7, #16]
  404d3e:	7c53      	ldrb	r3, [r2, #17]
  404d40:	f36f 1345 	bfc	r3, #5, #1
  404d44:	7453      	strb	r3, [r2, #17]
	if (b_dir_in) {
  404d46:	7dfb      	ldrb	r3, [r7, #23]
  404d48:	2b00      	cmp	r3, #0
  404d4a:	d004      	beq.n	404d56 <udd_ep_alloc+0xd6>
		// No data buffered in FIFO
		ptr_job->bank = 0;
  404d4c:	693a      	ldr	r2, [r7, #16]
  404d4e:	7c53      	ldrb	r3, [r2, #17]
  404d50:	f36f 0383 	bfc	r3, #2, #2
  404d54:	7453      	strb	r3, [r2, #17]
	}

	// Reset FIFOs
	udd_reset_endpoint(ep);
  404d56:	4944      	ldr	r1, [pc, #272]	; (404e68 <udd_ep_alloc+0x1e8>)
  404d58:	4b43      	ldr	r3, [pc, #268]	; (404e68 <udd_ep_alloc+0x1e8>)
  404d5a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  404d5c:	79fb      	ldrb	r3, [r7, #7]
  404d5e:	2001      	movs	r0, #1
  404d60:	fa00 f303 	lsl.w	r3, r0, r3
  404d64:	4313      	orrs	r3, r2
  404d66:	628b      	str	r3, [r1, #40]	; 0x28
  404d68:	bf00      	nop
  404d6a:	4b3f      	ldr	r3, [pc, #252]	; (404e68 <udd_ep_alloc+0x1e8>)
  404d6c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  404d6e:	79fb      	ldrb	r3, [r7, #7]
  404d70:	2101      	movs	r1, #1
  404d72:	fa01 f303 	lsl.w	r3, r1, r3
  404d76:	4013      	ands	r3, r2
  404d78:	2b00      	cmp	r3, #0
  404d7a:	d0f6      	beq.n	404d6a <udd_ep_alloc+0xea>
  404d7c:	493a      	ldr	r1, [pc, #232]	; (404e68 <udd_ep_alloc+0x1e8>)
  404d7e:	4b3a      	ldr	r3, [pc, #232]	; (404e68 <udd_ep_alloc+0x1e8>)
  404d80:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  404d82:	79fb      	ldrb	r3, [r7, #7]
  404d84:	2001      	movs	r0, #1
  404d86:	fa00 f303 	lsl.w	r3, r0, r3
  404d8a:	43db      	mvns	r3, r3
  404d8c:	4013      	ands	r3, r2
  404d8e:	628b      	str	r3, [r1, #40]	; 0x28
	// Set configuration of new endpoint
	udd_configure_endpoint(ep,
  404d90:	4a35      	ldr	r2, [pc, #212]	; (404e68 <udd_ep_alloc+0x1e8>)
  404d92:	79fb      	ldrb	r3, [r7, #7]
  404d94:	330c      	adds	r3, #12
  404d96:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  404d9a:	60fb      	str	r3, [r7, #12]
  404d9c:	68fb      	ldr	r3, [r7, #12]
  404d9e:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  404da2:	60fb      	str	r3, [r7, #12]
  404da4:	68fb      	ldr	r3, [r7, #12]
  404da6:	f423 4307 	bic.w	r3, r3, #34560	; 0x8700
  404daa:	f023 0380 	bic.w	r3, r3, #128	; 0x80
  404dae:	60fb      	str	r3, [r7, #12]
  404db0:	7dfb      	ldrb	r3, [r7, #23]
  404db2:	2b00      	cmp	r3, #0
  404db4:	d00d      	beq.n	404dd2 <udd_ep_alloc+0x152>
  404db6:	79bb      	ldrb	r3, [r7, #6]
  404db8:	021b      	lsls	r3, r3, #8
  404dba:	f403 7340 	and.w	r3, r3, #768	; 0x300
  404dbe:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
  404dc2:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
  404dc6:	f443 4200 	orr.w	r2, r3, #32768	; 0x8000
  404dca:	f248 7380 	movw	r3, #34688	; 0x8780
  404dce:	4013      	ands	r3, r2
  404dd0:	e008      	b.n	404de4 <udd_ep_alloc+0x164>
  404dd2:	79bb      	ldrb	r3, [r7, #6]
  404dd4:	021b      	lsls	r3, r3, #8
  404dd6:	f403 7340 	and.w	r3, r3, #768	; 0x300
  404dda:	f443 4200 	orr.w	r2, r3, #32768	; 0x8000
  404dde:	f248 7380 	movw	r3, #34688	; 0x8780
  404de2:	4013      	ands	r3, r2
  404de4:	68fa      	ldr	r2, [r7, #12]
  404de6:	4313      	orrs	r3, r2
  404de8:	60fb      	str	r3, [r7, #12]
  404dea:	491f      	ldr	r1, [pc, #124]	; (404e68 <udd_ep_alloc+0x1e8>)
  404dec:	79fb      	ldrb	r3, [r7, #7]
  404dee:	68fa      	ldr	r2, [r7, #12]
  404df0:	330c      	adds	r3, #12
  404df2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  404df6:	bf00      	nop
  404df8:	4a1b      	ldr	r2, [pc, #108]	; (404e68 <udd_ep_alloc+0x1e8>)
  404dfa:	79fb      	ldrb	r3, [r7, #7]
  404dfc:	330c      	adds	r3, #12
  404dfe:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
  404e02:	7dfb      	ldrb	r3, [r7, #23]
  404e04:	2b00      	cmp	r3, #0
  404e06:	d00a      	beq.n	404e1e <udd_ep_alloc+0x19e>
  404e08:	79bb      	ldrb	r3, [r7, #6]
  404e0a:	021b      	lsls	r3, r3, #8
  404e0c:	f403 7340 	and.w	r3, r3, #768	; 0x300
  404e10:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
  404e14:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
  404e18:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
  404e1c:	e005      	b.n	404e2a <udd_ep_alloc+0x1aa>
  404e1e:	79bb      	ldrb	r3, [r7, #6]
  404e20:	021b      	lsls	r3, r3, #8
  404e22:	f403 7340 	and.w	r3, r3, #768	; 0x300
  404e26:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
  404e2a:	401a      	ands	r2, r3
  404e2c:	7dfb      	ldrb	r3, [r7, #23]
  404e2e:	2b00      	cmp	r3, #0
  404e30:	d00a      	beq.n	404e48 <udd_ep_alloc+0x1c8>
  404e32:	79bb      	ldrb	r3, [r7, #6]
  404e34:	021b      	lsls	r3, r3, #8
  404e36:	f403 7340 	and.w	r3, r3, #768	; 0x300
  404e3a:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
  404e3e:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
  404e42:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
  404e46:	e005      	b.n	404e54 <udd_ep_alloc+0x1d4>
  404e48:	79bb      	ldrb	r3, [r7, #6]
  404e4a:	021b      	lsls	r3, r3, #8
  404e4c:	f403 7340 	and.w	r3, r3, #768	; 0x300
  404e50:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
  404e54:	429a      	cmp	r2, r3
  404e56:	d1cf      	bne.n	404df8 <udd_ep_alloc+0x178>
		(b_dir_in ? ((bmAttributes&USB_EP_TYPE_MASK) | 0x4) : (bmAttributes&USB_EP_TYPE_MASK)),
		0);
	return true;
  404e58:	2301      	movs	r3, #1
}
  404e5a:	4618      	mov	r0, r3
  404e5c:	371c      	adds	r7, #28
  404e5e:	46bd      	mov	sp, r7
  404e60:	f85d 7b04 	ldr.w	r7, [sp], #4
  404e64:	4770      	bx	lr
  404e66:	bf00      	nop
  404e68:	40084000 	.word	0x40084000
  404e6c:	20006c48 	.word	0x20006c48

00404e70 <udd_ep_free>:


void udd_ep_free(udd_ep_id_t ep)
{
  404e70:	b580      	push	{r7, lr}
  404e72:	b084      	sub	sp, #16
  404e74:	af00      	add	r7, sp, #0
  404e76:	4603      	mov	r3, r0
  404e78:	71fb      	strb	r3, [r7, #7]
	uint8_t ep_index = ep & USB_EP_ADDR_MASK;
  404e7a:	79fb      	ldrb	r3, [r7, #7]
  404e7c:	f003 030f 	and.w	r3, r3, #15
  404e80:	73fb      	strb	r3, [r7, #15]
	if (USB_DEVICE_MAX_EP < ep_index) {
  404e82:	7bfb      	ldrb	r3, [r7, #15]
  404e84:	2b02      	cmp	r3, #2
  404e86:	d822      	bhi.n	404ece <udd_ep_free+0x5e>
		return;
	}
	udd_disable_endpoint(ep_index);
  404e88:	4a13      	ldr	r2, [pc, #76]	; (404ed8 <udd_ep_free+0x68>)
  404e8a:	7bfb      	ldrb	r3, [r7, #15]
  404e8c:	330c      	adds	r3, #12
  404e8e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  404e92:	60bb      	str	r3, [r7, #8]
  404e94:	68bb      	ldr	r3, [r7, #8]
  404e96:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  404e9a:	60bb      	str	r3, [r7, #8]
  404e9c:	68bb      	ldr	r3, [r7, #8]
  404e9e:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
  404ea2:	60bb      	str	r3, [r7, #8]
  404ea4:	490c      	ldr	r1, [pc, #48]	; (404ed8 <udd_ep_free+0x68>)
  404ea6:	7bfb      	ldrb	r3, [r7, #15]
  404ea8:	68ba      	ldr	r2, [r7, #8]
  404eaa:	330c      	adds	r3, #12
  404eac:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  404eb0:	bf00      	nop
  404eb2:	4a09      	ldr	r2, [pc, #36]	; (404ed8 <udd_ep_free+0x68>)
  404eb4:	7bfb      	ldrb	r3, [r7, #15]
  404eb6:	330c      	adds	r3, #12
  404eb8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  404ebc:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
  404ec0:	2b00      	cmp	r3, #0
  404ec2:	d1f6      	bne.n	404eb2 <udd_ep_free+0x42>
	udd_ep_abort_job(ep);
  404ec4:	79fb      	ldrb	r3, [r7, #7]
  404ec6:	4618      	mov	r0, r3
  404ec8:	4b04      	ldr	r3, [pc, #16]	; (404edc <udd_ep_free+0x6c>)
  404eca:	4798      	blx	r3
  404ecc:	e000      	b.n	404ed0 <udd_ep_free+0x60>
		return;
  404ece:	bf00      	nop
}
  404ed0:	3710      	adds	r7, #16
  404ed2:	46bd      	mov	sp, r7
  404ed4:	bd80      	pop	{r7, pc}
  404ed6:	bf00      	nop
  404ed8:	40084000 	.word	0x40084000
  404edc:	00405e25 	.word	0x00405e25

00404ee0 <udd_ep_is_halted>:


bool udd_ep_is_halted(udd_ep_id_t ep)
{
  404ee0:	b480      	push	{r7}
  404ee2:	b085      	sub	sp, #20
  404ee4:	af00      	add	r7, sp, #0
  404ee6:	4603      	mov	r3, r0
  404ee8:	71fb      	strb	r3, [r7, #7]
	uint8_t ep_index = ep & USB_EP_ADDR_MASK;
  404eea:	79fb      	ldrb	r3, [r7, #7]
  404eec:	f003 030f 	and.w	r3, r3, #15
  404ef0:	73fb      	strb	r3, [r7, #15]
	udd_ep_job_t *ptr_job = &udd_ep_job[ep_index - 1];
  404ef2:	7bfb      	ldrb	r3, [r7, #15]
  404ef4:	1e5a      	subs	r2, r3, #1
  404ef6:	4613      	mov	r3, r2
  404ef8:	009b      	lsls	r3, r3, #2
  404efa:	4413      	add	r3, r2
  404efc:	009b      	lsls	r3, r3, #2
  404efe:	4a13      	ldr	r2, [pc, #76]	; (404f4c <udd_ep_is_halted+0x6c>)
  404f00:	4413      	add	r3, r2
  404f02:	60bb      	str	r3, [r7, #8]
	if (USB_DEVICE_MAX_EP < ep_index) {
  404f04:	7bfb      	ldrb	r3, [r7, #15]
  404f06:	2b02      	cmp	r3, #2
  404f08:	d901      	bls.n	404f0e <udd_ep_is_halted+0x2e>
		return false;
  404f0a:	2300      	movs	r3, #0
  404f0c:	e017      	b.n	404f3e <udd_ep_is_halted+0x5e>
	}
	return ptr_job->b_stall_requested ||
  404f0e:	68bb      	ldr	r3, [r7, #8]
  404f10:	7c5b      	ldrb	r3, [r3, #17]
  404f12:	f003 0320 	and.w	r3, r3, #32
  404f16:	b2db      	uxtb	r3, r3
  404f18:	2b00      	cmp	r3, #0
  404f1a:	d10a      	bne.n	404f32 <udd_ep_is_halted+0x52>
			Is_udd_endpoint_stall_pending(ep & USB_EP_ADDR_MASK);
  404f1c:	4a0c      	ldr	r2, [pc, #48]	; (404f50 <udd_ep_is_halted+0x70>)
  404f1e:	79fb      	ldrb	r3, [r7, #7]
  404f20:	f003 030f 	and.w	r3, r3, #15
  404f24:	330c      	adds	r3, #12
  404f26:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  404f2a:	f003 0328 	and.w	r3, r3, #40	; 0x28
	return ptr_job->b_stall_requested ||
  404f2e:	2b00      	cmp	r3, #0
  404f30:	d001      	beq.n	404f36 <udd_ep_is_halted+0x56>
  404f32:	2301      	movs	r3, #1
  404f34:	e000      	b.n	404f38 <udd_ep_is_halted+0x58>
  404f36:	2300      	movs	r3, #0
  404f38:	f003 0301 	and.w	r3, r3, #1
  404f3c:	b2db      	uxtb	r3, r3
}
  404f3e:	4618      	mov	r0, r3
  404f40:	3714      	adds	r7, #20
  404f42:	46bd      	mov	sp, r7
  404f44:	f85d 7b04 	ldr.w	r7, [sp], #4
  404f48:	4770      	bx	lr
  404f4a:	bf00      	nop
  404f4c:	20006c48 	.word	0x20006c48
  404f50:	40084000 	.word	0x40084000

00404f54 <udd_ep_set_halt>:


bool udd_ep_set_halt(udd_ep_id_t ep)
{
  404f54:	b580      	push	{r7, lr}
  404f56:	b086      	sub	sp, #24
  404f58:	af00      	add	r7, sp, #0
  404f5a:	4603      	mov	r3, r0
  404f5c:	71fb      	strb	r3, [r7, #7]
	bool b_dir_in = ep & USB_EP_DIR_IN;
  404f5e:	79fb      	ldrb	r3, [r7, #7]
  404f60:	f003 0380 	and.w	r3, r3, #128	; 0x80
  404f64:	2b00      	cmp	r3, #0
  404f66:	bf14      	ite	ne
  404f68:	2301      	movne	r3, #1
  404f6a:	2300      	moveq	r3, #0
  404f6c:	75fb      	strb	r3, [r7, #23]
	uint8_t ep_index = ep & USB_EP_ADDR_MASK;
  404f6e:	79fb      	ldrb	r3, [r7, #7]
  404f70:	f003 030f 	and.w	r3, r3, #15
  404f74:	75bb      	strb	r3, [r7, #22]
	udd_ep_job_t *ptr_job = &udd_ep_job[ep_index - 1];
  404f76:	7dbb      	ldrb	r3, [r7, #22]
  404f78:	1e5a      	subs	r2, r3, #1
  404f7a:	4613      	mov	r3, r2
  404f7c:	009b      	lsls	r3, r3, #2
  404f7e:	4413      	add	r3, r2
  404f80:	009b      	lsls	r3, r3, #2
  404f82:	4a2d      	ldr	r2, [pc, #180]	; (405038 <udd_ep_set_halt+0xe4>)
  404f84:	4413      	add	r3, r2
  404f86:	613b      	str	r3, [r7, #16]
	irqflags_t flags;
	if (USB_DEVICE_MAX_EP < ep_index) {
  404f88:	7dbb      	ldrb	r3, [r7, #22]
  404f8a:	2b02      	cmp	r3, #2
  404f8c:	d901      	bls.n	404f92 <udd_ep_set_halt+0x3e>
		return false;
  404f8e:	2300      	movs	r3, #0
  404f90:	e04d      	b.n	40502e <udd_ep_set_halt+0xda>
	}
	flags = cpu_irq_save();
  404f92:	4b2a      	ldr	r3, [pc, #168]	; (40503c <udd_ep_set_halt+0xe8>)
  404f94:	4798      	blx	r3
  404f96:	60f8      	str	r0, [r7, #12]
	if (b_dir_in && (Is_udd_transmit_ready(ep_index)
  404f98:	7dfb      	ldrb	r3, [r7, #23]
  404f9a:	2b00      	cmp	r3, #0
  404f9c:	d01f      	beq.n	404fde <udd_ep_set_halt+0x8a>
  404f9e:	4a28      	ldr	r2, [pc, #160]	; (405040 <udd_ep_set_halt+0xec>)
  404fa0:	7dbb      	ldrb	r3, [r7, #22]
  404fa2:	330c      	adds	r3, #12
  404fa4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  404fa8:	f003 0310 	and.w	r3, r3, #16
  404fac:	2b00      	cmp	r3, #0
  404fae:	d106      	bne.n	404fbe <udd_ep_set_halt+0x6a>
				|| ptr_job->bank > 1)) {
  404fb0:	693b      	ldr	r3, [r7, #16]
  404fb2:	7c5b      	ldrb	r3, [r3, #17]
  404fb4:	f3c3 0381 	ubfx	r3, r3, #2, #2
  404fb8:	b2db      	uxtb	r3, r3
  404fba:	2b01      	cmp	r3, #1
  404fbc:	dd0f      	ble.n	404fde <udd_ep_set_halt+0x8a>
		// Halt until banks sent
		ptr_job->b_stall_requested = true;
  404fbe:	693a      	ldr	r2, [r7, #16]
  404fc0:	7c53      	ldrb	r3, [r2, #17]
  404fc2:	f043 0320 	orr.w	r3, r3, #32
  404fc6:	7453      	strb	r3, [r2, #17]
		udd_enable_endpoint_interrupt(ep_index);
  404fc8:	4a1d      	ldr	r2, [pc, #116]	; (405040 <udd_ep_set_halt+0xec>)
  404fca:	7dbb      	ldrb	r3, [r7, #22]
  404fcc:	2101      	movs	r1, #1
  404fce:	fa01 f303 	lsl.w	r3, r1, r3
  404fd2:	6113      	str	r3, [r2, #16]
		cpu_irq_restore(flags);
  404fd4:	68f8      	ldr	r0, [r7, #12]
  404fd6:	4b1b      	ldr	r3, [pc, #108]	; (405044 <udd_ep_set_halt+0xf0>)
  404fd8:	4798      	blx	r3
		return true;
  404fda:	2301      	movs	r3, #1
  404fdc:	e027      	b.n	40502e <udd_ep_set_halt+0xda>
	} else {
		// Stall endpoint
		udd_enable_stall_handshake(ep_index);
  404fde:	4a18      	ldr	r2, [pc, #96]	; (405040 <udd_ep_set_halt+0xec>)
  404fe0:	7dbb      	ldrb	r3, [r7, #22]
  404fe2:	330c      	adds	r3, #12
  404fe4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  404fe8:	60bb      	str	r3, [r7, #8]
  404fea:	68bb      	ldr	r3, [r7, #8]
  404fec:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  404ff0:	60bb      	str	r3, [r7, #8]
  404ff2:	68bb      	ldr	r3, [r7, #8]
  404ff4:	f043 0320 	orr.w	r3, r3, #32
  404ff8:	60bb      	str	r3, [r7, #8]
  404ffa:	4911      	ldr	r1, [pc, #68]	; (405040 <udd_ep_set_halt+0xec>)
  404ffc:	7dbb      	ldrb	r3, [r7, #22]
  404ffe:	68ba      	ldr	r2, [r7, #8]
  405000:	330c      	adds	r3, #12
  405002:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  405006:	bf00      	nop
  405008:	4a0d      	ldr	r2, [pc, #52]	; (405040 <udd_ep_set_halt+0xec>)
  40500a:	7dbb      	ldrb	r3, [r7, #22]
  40500c:	330c      	adds	r3, #12
  40500e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  405012:	f003 0320 	and.w	r3, r3, #32
  405016:	2b20      	cmp	r3, #32
  405018:	d1f6      	bne.n	405008 <udd_ep_set_halt+0xb4>
		udd_enable_endpoint_interrupt(ep_index);
  40501a:	4a09      	ldr	r2, [pc, #36]	; (405040 <udd_ep_set_halt+0xec>)
  40501c:	7dbb      	ldrb	r3, [r7, #22]
  40501e:	2101      	movs	r1, #1
  405020:	fa01 f303 	lsl.w	r3, r1, r3
  405024:	6113      	str	r3, [r2, #16]
		cpu_irq_restore(flags);
  405026:	68f8      	ldr	r0, [r7, #12]
  405028:	4b06      	ldr	r3, [pc, #24]	; (405044 <udd_ep_set_halt+0xf0>)
  40502a:	4798      	blx	r3
	}
	return true;
  40502c:	2301      	movs	r3, #1
}
  40502e:	4618      	mov	r0, r3
  405030:	3718      	adds	r7, #24
  405032:	46bd      	mov	sp, r7
  405034:	bd80      	pop	{r7, pc}
  405036:	bf00      	nop
  405038:	20006c48 	.word	0x20006c48
  40503c:	0040485d 	.word	0x0040485d
  405040:	40084000 	.word	0x40084000
  405044:	004048b5 	.word	0x004048b5

00405048 <udd_ep_clear_halt>:


bool udd_ep_clear_halt(udd_ep_id_t ep)
{
  405048:	b580      	push	{r7, lr}
  40504a:	b086      	sub	sp, #24
  40504c:	af00      	add	r7, sp, #0
  40504e:	4603      	mov	r3, r0
  405050:	71fb      	strb	r3, [r7, #7]
	udd_ep_job_t *ptr_job;

	ep &= USB_EP_ADDR_MASK;
  405052:	79fb      	ldrb	r3, [r7, #7]
  405054:	f003 030f 	and.w	r3, r3, #15
  405058:	71fb      	strb	r3, [r7, #7]
	if (USB_DEVICE_MAX_EP < ep)
  40505a:	79fb      	ldrb	r3, [r7, #7]
  40505c:	2b02      	cmp	r3, #2
  40505e:	d901      	bls.n	405064 <udd_ep_clear_halt+0x1c>
		return false;
  405060:	2300      	movs	r3, #0
  405062:	e07f      	b.n	405164 <udd_ep_clear_halt+0x11c>
	ptr_job = &udd_ep_job[ep - 1];
  405064:	79fb      	ldrb	r3, [r7, #7]
  405066:	1e5a      	subs	r2, r3, #1
  405068:	4613      	mov	r3, r2
  40506a:	009b      	lsls	r3, r3, #2
  40506c:	4413      	add	r3, r2
  40506e:	009b      	lsls	r3, r3, #2
  405070:	4a3e      	ldr	r2, [pc, #248]	; (40516c <udd_ep_clear_halt+0x124>)
  405072:	4413      	add	r3, r2
  405074:	617b      	str	r3, [r7, #20]

	ptr_job->b_stall_requested = false;
  405076:	697a      	ldr	r2, [r7, #20]
  405078:	7c53      	ldrb	r3, [r2, #17]
  40507a:	f36f 1345 	bfc	r3, #5, #1
  40507e:	7453      	strb	r3, [r2, #17]
	if (Is_udd_endpoint_stall_requested(ep)) {
  405080:	4a3b      	ldr	r2, [pc, #236]	; (405170 <udd_ep_clear_halt+0x128>)
  405082:	79fb      	ldrb	r3, [r7, #7]
  405084:	330c      	adds	r3, #12
  405086:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  40508a:	f003 0320 	and.w	r3, r3, #32
  40508e:	2b00      	cmp	r3, #0
  405090:	d067      	beq.n	405162 <udd_ep_clear_halt+0x11a>
		// Remove stall
		udd_disable_stall_handshake(ep);
  405092:	4a37      	ldr	r2, [pc, #220]	; (405170 <udd_ep_clear_halt+0x128>)
  405094:	79fb      	ldrb	r3, [r7, #7]
  405096:	330c      	adds	r3, #12
  405098:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  40509c:	613b      	str	r3, [r7, #16]
  40509e:	693b      	ldr	r3, [r7, #16]
  4050a0:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  4050a4:	613b      	str	r3, [r7, #16]
  4050a6:	693b      	ldr	r3, [r7, #16]
  4050a8:	f023 0320 	bic.w	r3, r3, #32
  4050ac:	613b      	str	r3, [r7, #16]
  4050ae:	4930      	ldr	r1, [pc, #192]	; (405170 <udd_ep_clear_halt+0x128>)
  4050b0:	79fb      	ldrb	r3, [r7, #7]
  4050b2:	693a      	ldr	r2, [r7, #16]
  4050b4:	330c      	adds	r3, #12
  4050b6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  4050ba:	bf00      	nop
  4050bc:	4a2c      	ldr	r2, [pc, #176]	; (405170 <udd_ep_clear_halt+0x128>)
  4050be:	79fb      	ldrb	r3, [r7, #7]
  4050c0:	330c      	adds	r3, #12
  4050c2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  4050c6:	f003 0320 	and.w	r3, r3, #32
  4050ca:	2b00      	cmp	r3, #0
  4050cc:	d1f6      	bne.n	4050bc <udd_ep_clear_halt+0x74>
		// Reset FIFO and data toggle (after stall cleared)
		udd_reset_endpoint(ep);
  4050ce:	4928      	ldr	r1, [pc, #160]	; (405170 <udd_ep_clear_halt+0x128>)
  4050d0:	4b27      	ldr	r3, [pc, #156]	; (405170 <udd_ep_clear_halt+0x128>)
  4050d2:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  4050d4:	79fb      	ldrb	r3, [r7, #7]
  4050d6:	2001      	movs	r0, #1
  4050d8:	fa00 f303 	lsl.w	r3, r0, r3
  4050dc:	4313      	orrs	r3, r2
  4050de:	628b      	str	r3, [r1, #40]	; 0x28
  4050e0:	bf00      	nop
  4050e2:	4b23      	ldr	r3, [pc, #140]	; (405170 <udd_ep_clear_halt+0x128>)
  4050e4:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  4050e6:	79fb      	ldrb	r3, [r7, #7]
  4050e8:	2101      	movs	r1, #1
  4050ea:	fa01 f303 	lsl.w	r3, r1, r3
  4050ee:	4013      	ands	r3, r2
  4050f0:	2b00      	cmp	r3, #0
  4050f2:	d0f6      	beq.n	4050e2 <udd_ep_clear_halt+0x9a>
  4050f4:	491e      	ldr	r1, [pc, #120]	; (405170 <udd_ep_clear_halt+0x128>)
  4050f6:	4b1e      	ldr	r3, [pc, #120]	; (405170 <udd_ep_clear_halt+0x128>)
  4050f8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  4050fa:	79fb      	ldrb	r3, [r7, #7]
  4050fc:	2001      	movs	r0, #1
  4050fe:	fa00 f303 	lsl.w	r3, r0, r3
  405102:	43db      	mvns	r3, r3
  405104:	4013      	ands	r3, r2
  405106:	628b      	str	r3, [r1, #40]	; 0x28
		// Clear stall status
		udd_ack_stall(ep);
  405108:	4a19      	ldr	r2, [pc, #100]	; (405170 <udd_ep_clear_halt+0x128>)
  40510a:	79fb      	ldrb	r3, [r7, #7]
  40510c:	330c      	adds	r3, #12
  40510e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  405112:	60fb      	str	r3, [r7, #12]
  405114:	68fb      	ldr	r3, [r7, #12]
  405116:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  40511a:	60fb      	str	r3, [r7, #12]
  40511c:	68fb      	ldr	r3, [r7, #12]
  40511e:	f023 0308 	bic.w	r3, r3, #8
  405122:	60fb      	str	r3, [r7, #12]
  405124:	4912      	ldr	r1, [pc, #72]	; (405170 <udd_ep_clear_halt+0x128>)
  405126:	79fb      	ldrb	r3, [r7, #7]
  405128:	68fa      	ldr	r2, [r7, #12]
  40512a:	330c      	adds	r3, #12
  40512c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  405130:	bf00      	nop
  405132:	4a0f      	ldr	r2, [pc, #60]	; (405170 <udd_ep_clear_halt+0x128>)
  405134:	79fb      	ldrb	r3, [r7, #7]
  405136:	330c      	adds	r3, #12
  405138:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  40513c:	f003 0308 	and.w	r3, r3, #8
  405140:	2b00      	cmp	r3, #0
  405142:	d1f6      	bne.n	405132 <udd_ep_clear_halt+0xea>
		// If a job is register on clear halt action
		// then execute callback
		if (ptr_job->busy == true) {
  405144:	697b      	ldr	r3, [r7, #20]
  405146:	7c5b      	ldrb	r3, [r3, #17]
  405148:	f003 0310 	and.w	r3, r3, #16
  40514c:	b2db      	uxtb	r3, r3
  40514e:	2b00      	cmp	r3, #0
  405150:	d007      	beq.n	405162 <udd_ep_clear_halt+0x11a>
			ptr_job->busy = false;
  405152:	697a      	ldr	r2, [r7, #20]
  405154:	7c53      	ldrb	r3, [r2, #17]
  405156:	f36f 1304 	bfc	r3, #4, #1
  40515a:	7453      	strb	r3, [r2, #17]
			ptr_job->call_nohalt();
  40515c:	697b      	ldr	r3, [r7, #20]
  40515e:	681b      	ldr	r3, [r3, #0]
  405160:	4798      	blx	r3
		}
	}
	return true;
  405162:	2301      	movs	r3, #1
}
  405164:	4618      	mov	r0, r3
  405166:	3718      	adds	r7, #24
  405168:	46bd      	mov	sp, r7
  40516a:	bd80      	pop	{r7, pc}
  40516c:	20006c48 	.word	0x20006c48
  405170:	40084000 	.word	0x40084000

00405174 <udd_ep_run>:


bool udd_ep_run(udd_ep_id_t ep, bool b_shortpacket,
		uint8_t * buf, iram_size_t buf_size,
		udd_callback_trans_t callback)
{
  405174:	b580      	push	{r7, lr}
  405176:	b088      	sub	sp, #32
  405178:	af00      	add	r7, sp, #0
  40517a:	60ba      	str	r2, [r7, #8]
  40517c:	607b      	str	r3, [r7, #4]
  40517e:	4603      	mov	r3, r0
  405180:	73fb      	strb	r3, [r7, #15]
  405182:	460b      	mov	r3, r1
  405184:	73bb      	strb	r3, [r7, #14]
	udd_ep_job_t *ptr_job;
	irqflags_t flags;
	bool b_dir_in = ep & USB_EP_DIR_IN;
  405186:	7bfb      	ldrb	r3, [r7, #15]
  405188:	f003 0380 	and.w	r3, r3, #128	; 0x80
  40518c:	2b00      	cmp	r3, #0
  40518e:	bf14      	ite	ne
  405190:	2301      	movne	r3, #1
  405192:	2300      	moveq	r3, #0
  405194:	77fb      	strb	r3, [r7, #31]

	ep &= USB_EP_ADDR_MASK;
  405196:	7bfb      	ldrb	r3, [r7, #15]
  405198:	f003 030f 	and.w	r3, r3, #15
  40519c:	73fb      	strb	r3, [r7, #15]
	if (USB_DEVICE_MAX_EP < ep) {
  40519e:	7bfb      	ldrb	r3, [r7, #15]
  4051a0:	2b02      	cmp	r3, #2
  4051a2:	d901      	bls.n	4051a8 <udd_ep_run+0x34>
		return false;
  4051a4:	2300      	movs	r3, #0
  4051a6:	e083      	b.n	4052b0 <udd_ep_run+0x13c>
	}
	// Get job about endpoint
	ptr_job = &udd_ep_job[ep - 1];
  4051a8:	7bfb      	ldrb	r3, [r7, #15]
  4051aa:	1e5a      	subs	r2, r3, #1
  4051ac:	4613      	mov	r3, r2
  4051ae:	009b      	lsls	r3, r3, #2
  4051b0:	4413      	add	r3, r2
  4051b2:	009b      	lsls	r3, r3, #2
  4051b4:	4a40      	ldr	r2, [pc, #256]	; (4052b8 <udd_ep_run+0x144>)
  4051b6:	4413      	add	r3, r2
  4051b8:	61bb      	str	r3, [r7, #24]

	if ((!Is_udd_endpoint_enabled(ep))
  4051ba:	4a40      	ldr	r2, [pc, #256]	; (4052bc <udd_ep_run+0x148>)
  4051bc:	7bfb      	ldrb	r3, [r7, #15]
  4051be:	330c      	adds	r3, #12
  4051c0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  4051c4:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
  4051c8:	2b00      	cmp	r3, #0
  4051ca:	d00f      	beq.n	4051ec <udd_ep_run+0x78>
			|| ptr_job->b_stall_requested
  4051cc:	69bb      	ldr	r3, [r7, #24]
  4051ce:	7c5b      	ldrb	r3, [r3, #17]
  4051d0:	f003 0320 	and.w	r3, r3, #32
  4051d4:	b2db      	uxtb	r3, r3
  4051d6:	2b00      	cmp	r3, #0
  4051d8:	d108      	bne.n	4051ec <udd_ep_run+0x78>
			|| Is_udd_endpoint_stall_requested(ep)) {
  4051da:	4a38      	ldr	r2, [pc, #224]	; (4052bc <udd_ep_run+0x148>)
  4051dc:	7bfb      	ldrb	r3, [r7, #15]
  4051de:	330c      	adds	r3, #12
  4051e0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  4051e4:	f003 0320 	and.w	r3, r3, #32
  4051e8:	2b00      	cmp	r3, #0
  4051ea:	d001      	beq.n	4051f0 <udd_ep_run+0x7c>
		return false; // Endpoint is halted
  4051ec:	2300      	movs	r3, #0
  4051ee:	e05f      	b.n	4052b0 <udd_ep_run+0x13c>
	}

	flags = cpu_irq_save();
  4051f0:	4b33      	ldr	r3, [pc, #204]	; (4052c0 <udd_ep_run+0x14c>)
  4051f2:	4798      	blx	r3
  4051f4:	6178      	str	r0, [r7, #20]
	if (ptr_job->busy == true) {
  4051f6:	69bb      	ldr	r3, [r7, #24]
  4051f8:	7c5b      	ldrb	r3, [r3, #17]
  4051fa:	f003 0310 	and.w	r3, r3, #16
  4051fe:	b2db      	uxtb	r3, r3
  405200:	2b00      	cmp	r3, #0
  405202:	d004      	beq.n	40520e <udd_ep_run+0x9a>
		cpu_irq_restore(flags);
  405204:	6978      	ldr	r0, [r7, #20]
  405206:	4b2f      	ldr	r3, [pc, #188]	; (4052c4 <udd_ep_run+0x150>)
  405208:	4798      	blx	r3
		return false; // Job already on going
  40520a:	2300      	movs	r3, #0
  40520c:	e050      	b.n	4052b0 <udd_ep_run+0x13c>
	}
	ptr_job->busy = true;
  40520e:	69ba      	ldr	r2, [r7, #24]
  405210:	7c53      	ldrb	r3, [r2, #17]
  405212:	f043 0310 	orr.w	r3, r3, #16
  405216:	7453      	strb	r3, [r2, #17]
	cpu_irq_restore(flags);
  405218:	6978      	ldr	r0, [r7, #20]
  40521a:	4b2a      	ldr	r3, [pc, #168]	; (4052c4 <udd_ep_run+0x150>)
  40521c:	4798      	blx	r3

	// No job running. Let's setup a new one.
	ptr_job->buf = buf;
  40521e:	69bb      	ldr	r3, [r7, #24]
  405220:	68ba      	ldr	r2, [r7, #8]
  405222:	605a      	str	r2, [r3, #4]
	ptr_job->buf_size = buf_size;
  405224:	69bb      	ldr	r3, [r7, #24]
  405226:	687a      	ldr	r2, [r7, #4]
  405228:	609a      	str	r2, [r3, #8]
	ptr_job->buf_cnt = 0;
  40522a:	69bb      	ldr	r3, [r7, #24]
  40522c:	2200      	movs	r2, #0
  40522e:	60da      	str	r2, [r3, #12]
	ptr_job->call_trans = callback;
  405230:	69bb      	ldr	r3, [r7, #24]
  405232:	6aba      	ldr	r2, [r7, #40]	; 0x28
  405234:	601a      	str	r2, [r3, #0]
	ptr_job->b_shortpacket = b_shortpacket || (buf_size == 0);
  405236:	7bbb      	ldrb	r3, [r7, #14]
  405238:	2b00      	cmp	r3, #0
  40523a:	d102      	bne.n	405242 <udd_ep_run+0xce>
  40523c:	687b      	ldr	r3, [r7, #4]
  40523e:	2b00      	cmp	r3, #0
  405240:	d101      	bne.n	405246 <udd_ep_run+0xd2>
  405242:	2301      	movs	r3, #1
  405244:	e000      	b.n	405248 <udd_ep_run+0xd4>
  405246:	2300      	movs	r3, #0
  405248:	b2db      	uxtb	r3, r3
  40524a:	f003 0301 	and.w	r3, r3, #1
  40524e:	b2d9      	uxtb	r1, r3
  405250:	69ba      	ldr	r2, [r7, #24]
  405252:	7c53      	ldrb	r3, [r2, #17]
  405254:	f361 1386 	bfi	r3, r1, #6, #1
  405258:	7453      	strb	r3, [r2, #17]
	ptr_job->b_buf_end = false;
  40525a:	69ba      	ldr	r2, [r7, #24]
  40525c:	7c53      	ldrb	r3, [r2, #17]
  40525e:	f36f 13c7 	bfc	r3, #7, #1
  405262:	7453      	strb	r3, [r2, #17]

	flags = cpu_irq_save();
  405264:	4b16      	ldr	r3, [pc, #88]	; (4052c0 <udd_ep_run+0x14c>)
  405266:	4798      	blx	r3
  405268:	6178      	str	r0, [r7, #20]
	udd_enable_endpoint_interrupt(ep);
  40526a:	4a14      	ldr	r2, [pc, #80]	; (4052bc <udd_ep_run+0x148>)
  40526c:	7bfb      	ldrb	r3, [r7, #15]
  40526e:	2101      	movs	r1, #1
  405270:	fa01 f303 	lsl.w	r3, r1, r3
  405274:	6113      	str	r3, [r2, #16]
	// Request first transfer
	if (b_dir_in) {
  405276:	7ffb      	ldrb	r3, [r7, #31]
  405278:	2b00      	cmp	r3, #0
  40527a:	d015      	beq.n	4052a8 <udd_ep_run+0x134>
		if (Is_udd_in_pending(ep)) {
  40527c:	4a0f      	ldr	r2, [pc, #60]	; (4052bc <udd_ep_run+0x148>)
  40527e:	7bfb      	ldrb	r3, [r7, #15]
  405280:	330c      	adds	r3, #12
  405282:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  405286:	f003 0311 	and.w	r3, r3, #17
  40528a:	2b00      	cmp	r3, #0
  40528c:	d10c      	bne.n	4052a8 <udd_ep_run+0x134>
			// Append more data (handled in interrupt service)
		} else {
			// Start new, try to fill 1~2 banks before handling status
			if (udd_ep_in_sent(ep, true)) {
  40528e:	7bfb      	ldrb	r3, [r7, #15]
  405290:	2101      	movs	r1, #1
  405292:	4618      	mov	r0, r3
  405294:	4b0c      	ldr	r3, [pc, #48]	; (4052c8 <udd_ep_run+0x154>)
  405296:	4798      	blx	r3
  405298:	4603      	mov	r3, r0
  40529a:	2b00      	cmp	r3, #0
  40529c:	d004      	beq.n	4052a8 <udd_ep_run+0x134>
				// Over one bank
				udd_ep_in_sent(ep, false);
  40529e:	7bfb      	ldrb	r3, [r7, #15]
  4052a0:	2100      	movs	r1, #0
  4052a2:	4618      	mov	r0, r3
  4052a4:	4b08      	ldr	r3, [pc, #32]	; (4052c8 <udd_ep_run+0x154>)
  4052a6:	4798      	blx	r3
			}
		}
	} else {
		// Waiting for OUT received interrupt
	}
	cpu_irq_restore(flags);
  4052a8:	6978      	ldr	r0, [r7, #20]
  4052aa:	4b06      	ldr	r3, [pc, #24]	; (4052c4 <udd_ep_run+0x150>)
  4052ac:	4798      	blx	r3

	return true;
  4052ae:	2301      	movs	r3, #1
}
  4052b0:	4618      	mov	r0, r3
  4052b2:	3720      	adds	r7, #32
  4052b4:	46bd      	mov	sp, r7
  4052b6:	bd80      	pop	{r7, pc}
  4052b8:	20006c48 	.word	0x20006c48
  4052bc:	40084000 	.word	0x40084000
  4052c0:	0040485d 	.word	0x0040485d
  4052c4:	004048b5 	.word	0x004048b5
  4052c8:	0040617d 	.word	0x0040617d

004052cc <udd_ep_abort>:


void udd_ep_abort(udd_ep_id_t ep)
{
  4052cc:	b580      	push	{r7, lr}
  4052ce:	b088      	sub	sp, #32
  4052d0:	af00      	add	r7, sp, #0
  4052d2:	4603      	mov	r3, r0
  4052d4:	71fb      	strb	r3, [r7, #7]
	bool b_dir_in = ep & USB_EP_DIR_IN;
  4052d6:	79fb      	ldrb	r3, [r7, #7]
  4052d8:	f003 0380 	and.w	r3, r3, #128	; 0x80
  4052dc:	2b00      	cmp	r3, #0
  4052de:	bf14      	ite	ne
  4052e0:	2301      	movne	r3, #1
  4052e2:	2300      	moveq	r3, #0
  4052e4:	77fb      	strb	r3, [r7, #31]
	irqflags_t flags;

	ep &= USB_EP_ADDR_MASK;
  4052e6:	79fb      	ldrb	r3, [r7, #7]
  4052e8:	f003 030f 	and.w	r3, r3, #15
  4052ec:	71fb      	strb	r3, [r7, #7]
	if (USB_DEVICE_MAX_EP < ep)
  4052ee:	79fb      	ldrb	r3, [r7, #7]
  4052f0:	2b02      	cmp	r3, #2
  4052f2:	f200 80e9 	bhi.w	4054c8 <udd_ep_abort+0x1fc>
		return;

	// Disable interrupts
	flags = cpu_irq_save();
  4052f6:	4b76      	ldr	r3, [pc, #472]	; (4054d0 <udd_ep_abort+0x204>)
  4052f8:	4798      	blx	r3
  4052fa:	61b8      	str	r0, [r7, #24]
	udd_disable_endpoint_interrupt(ep);
  4052fc:	4a75      	ldr	r2, [pc, #468]	; (4054d4 <udd_ep_abort+0x208>)
  4052fe:	79fb      	ldrb	r3, [r7, #7]
  405300:	2101      	movs	r1, #1
  405302:	fa01 f303 	lsl.w	r3, r1, r3
  405306:	6153      	str	r3, [r2, #20]
	cpu_irq_restore(flags);
  405308:	69b8      	ldr	r0, [r7, #24]
  40530a:	4b73      	ldr	r3, [pc, #460]	; (4054d8 <udd_ep_abort+0x20c>)
  40530c:	4798      	blx	r3
	// Clear pending statuses
	if (b_dir_in) {
  40530e:	7ffb      	ldrb	r3, [r7, #31]
  405310:	2b00      	cmp	r3, #0
  405312:	f000 80ae 	beq.w	405472 <udd_ep_abort+0x1a6>
		// Kill banks
		if (Is_udd_transmit_ready(ep)) {
  405316:	4a6f      	ldr	r2, [pc, #444]	; (4054d4 <udd_ep_abort+0x208>)
  405318:	79fb      	ldrb	r3, [r7, #7]
  40531a:	330c      	adds	r3, #12
  40531c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  405320:	f003 0310 	and.w	r3, r3, #16
  405324:	2b00      	cmp	r3, #0
  405326:	d073      	beq.n	405410 <udd_ep_abort+0x144>
			udd_kill_data_in_fifo(ep,
  405328:	79fb      	ldrb	r3, [r7, #7]
  40532a:	2b00      	cmp	r3, #0
  40532c:	d052      	beq.n	4053d4 <udd_ep_abort+0x108>
  40532e:	79fb      	ldrb	r3, [r7, #7]
  405330:	2b03      	cmp	r3, #3
  405332:	d04f      	beq.n	4053d4 <udd_ep_abort+0x108>
  405334:	4a67      	ldr	r2, [pc, #412]	; (4054d4 <udd_ep_abort+0x208>)
  405336:	79fb      	ldrb	r3, [r7, #7]
  405338:	330c      	adds	r3, #12
  40533a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  40533e:	617b      	str	r3, [r7, #20]
  405340:	697b      	ldr	r3, [r7, #20]
  405342:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  405346:	617b      	str	r3, [r7, #20]
  405348:	697b      	ldr	r3, [r7, #20]
  40534a:	f023 0310 	bic.w	r3, r3, #16
  40534e:	617b      	str	r3, [r7, #20]
  405350:	4960      	ldr	r1, [pc, #384]	; (4054d4 <udd_ep_abort+0x208>)
  405352:	79fb      	ldrb	r3, [r7, #7]
  405354:	697a      	ldr	r2, [r7, #20]
  405356:	330c      	adds	r3, #12
  405358:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  40535c:	bf00      	nop
  40535e:	4a5d      	ldr	r2, [pc, #372]	; (4054d4 <udd_ep_abort+0x208>)
  405360:	79fb      	ldrb	r3, [r7, #7]
  405362:	330c      	adds	r3, #12
  405364:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  405368:	f003 0310 	and.w	r3, r3, #16
  40536c:	2b00      	cmp	r3, #0
  40536e:	d1f6      	bne.n	40535e <udd_ep_abort+0x92>
  405370:	bf00      	nop
  405372:	4a58      	ldr	r2, [pc, #352]	; (4054d4 <udd_ep_abort+0x208>)
  405374:	79fb      	ldrb	r3, [r7, #7]
  405376:	330c      	adds	r3, #12
  405378:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  40537c:	f003 0310 	and.w	r3, r3, #16
  405380:	2b00      	cmp	r3, #0
  405382:	d1f6      	bne.n	405372 <udd_ep_abort+0xa6>
  405384:	4a53      	ldr	r2, [pc, #332]	; (4054d4 <udd_ep_abort+0x208>)
  405386:	79fb      	ldrb	r3, [r7, #7]
  405388:	330c      	adds	r3, #12
  40538a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  40538e:	613b      	str	r3, [r7, #16]
  405390:	693b      	ldr	r3, [r7, #16]
  405392:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  405396:	613b      	str	r3, [r7, #16]
  405398:	693b      	ldr	r3, [r7, #16]
  40539a:	f043 0310 	orr.w	r3, r3, #16
  40539e:	613b      	str	r3, [r7, #16]
  4053a0:	494c      	ldr	r1, [pc, #304]	; (4054d4 <udd_ep_abort+0x208>)
  4053a2:	79fb      	ldrb	r3, [r7, #7]
  4053a4:	693a      	ldr	r2, [r7, #16]
  4053a6:	330c      	adds	r3, #12
  4053a8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  4053ac:	bf00      	nop
  4053ae:	4a49      	ldr	r2, [pc, #292]	; (4054d4 <udd_ep_abort+0x208>)
  4053b0:	79fb      	ldrb	r3, [r7, #7]
  4053b2:	330c      	adds	r3, #12
  4053b4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  4053b8:	f003 0310 	and.w	r3, r3, #16
  4053bc:	2b10      	cmp	r3, #16
  4053be:	d1f6      	bne.n	4053ae <udd_ep_abort+0xe2>
  4053c0:	bf00      	nop
  4053c2:	4a44      	ldr	r2, [pc, #272]	; (4054d4 <udd_ep_abort+0x208>)
  4053c4:	79fb      	ldrb	r3, [r7, #7]
  4053c6:	330c      	adds	r3, #12
  4053c8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  4053cc:	f003 0310 	and.w	r3, r3, #16
  4053d0:	2b00      	cmp	r3, #0
  4053d2:	d0f6      	beq.n	4053c2 <udd_ep_abort+0xf6>
  4053d4:	4a3f      	ldr	r2, [pc, #252]	; (4054d4 <udd_ep_abort+0x208>)
  4053d6:	79fb      	ldrb	r3, [r7, #7]
  4053d8:	330c      	adds	r3, #12
  4053da:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  4053de:	60fb      	str	r3, [r7, #12]
  4053e0:	68fb      	ldr	r3, [r7, #12]
  4053e2:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  4053e6:	60fb      	str	r3, [r7, #12]
  4053e8:	68fb      	ldr	r3, [r7, #12]
  4053ea:	f023 0310 	bic.w	r3, r3, #16
  4053ee:	60fb      	str	r3, [r7, #12]
  4053f0:	4938      	ldr	r1, [pc, #224]	; (4054d4 <udd_ep_abort+0x208>)
  4053f2:	79fb      	ldrb	r3, [r7, #7]
  4053f4:	68fa      	ldr	r2, [r7, #12]
  4053f6:	330c      	adds	r3, #12
  4053f8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  4053fc:	bf00      	nop
  4053fe:	4a35      	ldr	r2, [pc, #212]	; (4054d4 <udd_ep_abort+0x208>)
  405400:	79fb      	ldrb	r3, [r7, #7]
  405402:	330c      	adds	r3, #12
  405404:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  405408:	f003 0310 	and.w	r3, r3, #16
  40540c:	2b00      	cmp	r3, #0
  40540e:	d1f6      	bne.n	4053fe <udd_ep_abort+0x132>
					udd_get_endpoint_bank_max_nbr(ep)>1);
		}
		udd_ack_in_sent(ep);
  405410:	4a30      	ldr	r2, [pc, #192]	; (4054d4 <udd_ep_abort+0x208>)
  405412:	79fb      	ldrb	r3, [r7, #7]
  405414:	330c      	adds	r3, #12
  405416:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  40541a:	60bb      	str	r3, [r7, #8]
  40541c:	68bb      	ldr	r3, [r7, #8]
  40541e:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  405422:	60bb      	str	r3, [r7, #8]
  405424:	68bb      	ldr	r3, [r7, #8]
  405426:	f023 0301 	bic.w	r3, r3, #1
  40542a:	60bb      	str	r3, [r7, #8]
  40542c:	4929      	ldr	r1, [pc, #164]	; (4054d4 <udd_ep_abort+0x208>)
  40542e:	79fb      	ldrb	r3, [r7, #7]
  405430:	68ba      	ldr	r2, [r7, #8]
  405432:	330c      	adds	r3, #12
  405434:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  405438:	bf00      	nop
  40543a:	4a26      	ldr	r2, [pc, #152]	; (4054d4 <udd_ep_abort+0x208>)
  40543c:	79fb      	ldrb	r3, [r7, #7]
  40543e:	330c      	adds	r3, #12
  405440:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  405444:	f003 0301 	and.w	r3, r3, #1
  405448:	2b00      	cmp	r3, #0
  40544a:	d1f6      	bne.n	40543a <udd_ep_abort+0x16e>
		// Reset number of buffered banks
		udd_ep_job[ep - 1].bank = 0;
  40544c:	79fb      	ldrb	r3, [r7, #7]
  40544e:	1e5a      	subs	r2, r3, #1
  405450:	4922      	ldr	r1, [pc, #136]	; (4054dc <udd_ep_abort+0x210>)
  405452:	4613      	mov	r3, r2
  405454:	009b      	lsls	r3, r3, #2
  405456:	4413      	add	r3, r2
  405458:	009b      	lsls	r3, r3, #2
  40545a:	440b      	add	r3, r1
  40545c:	f103 0210 	add.w	r2, r3, #16
  405460:	7853      	ldrb	r3, [r2, #1]
  405462:	f36f 0383 	bfc	r3, #2, #2
  405466:	7053      	strb	r3, [r2, #1]
  405468:	e00c      	b.n	405484 <udd_ep_abort+0x1b8>
	} else {
		// Clear all pending banks statuses
		while(Is_udd_any_bank_received(ep)) {
			udd_ep_ack_out_received(ep);
  40546a:	79fb      	ldrb	r3, [r7, #7]
  40546c:	4618      	mov	r0, r3
  40546e:	4b1c      	ldr	r3, [pc, #112]	; (4054e0 <udd_ep_abort+0x214>)
  405470:	4798      	blx	r3
		while(Is_udd_any_bank_received(ep)) {
  405472:	4a18      	ldr	r2, [pc, #96]	; (4054d4 <udd_ep_abort+0x208>)
  405474:	79fb      	ldrb	r3, [r7, #7]
  405476:	330c      	adds	r3, #12
  405478:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  40547c:	f003 0342 	and.w	r3, r3, #66	; 0x42
  405480:	2b00      	cmp	r3, #0
  405482:	d1f2      	bne.n	40546a <udd_ep_abort+0x19e>
		}
	}
	// Reset FIFO and data toggle
	udd_reset_endpoint(ep);
  405484:	4913      	ldr	r1, [pc, #76]	; (4054d4 <udd_ep_abort+0x208>)
  405486:	4b13      	ldr	r3, [pc, #76]	; (4054d4 <udd_ep_abort+0x208>)
  405488:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  40548a:	79fb      	ldrb	r3, [r7, #7]
  40548c:	2001      	movs	r0, #1
  40548e:	fa00 f303 	lsl.w	r3, r0, r3
  405492:	4313      	orrs	r3, r2
  405494:	628b      	str	r3, [r1, #40]	; 0x28
  405496:	bf00      	nop
  405498:	4b0e      	ldr	r3, [pc, #56]	; (4054d4 <udd_ep_abort+0x208>)
  40549a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  40549c:	79fb      	ldrb	r3, [r7, #7]
  40549e:	2101      	movs	r1, #1
  4054a0:	fa01 f303 	lsl.w	r3, r1, r3
  4054a4:	4013      	ands	r3, r2
  4054a6:	2b00      	cmp	r3, #0
  4054a8:	d0f6      	beq.n	405498 <udd_ep_abort+0x1cc>
  4054aa:	490a      	ldr	r1, [pc, #40]	; (4054d4 <udd_ep_abort+0x208>)
  4054ac:	4b09      	ldr	r3, [pc, #36]	; (4054d4 <udd_ep_abort+0x208>)
  4054ae:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  4054b0:	79fb      	ldrb	r3, [r7, #7]
  4054b2:	2001      	movs	r0, #1
  4054b4:	fa00 f303 	lsl.w	r3, r0, r3
  4054b8:	43db      	mvns	r3, r3
  4054ba:	4013      	ands	r3, r2
  4054bc:	628b      	str	r3, [r1, #40]	; 0x28
	// Abort job
	udd_ep_abort_job(ep);
  4054be:	79fb      	ldrb	r3, [r7, #7]
  4054c0:	4618      	mov	r0, r3
  4054c2:	4b08      	ldr	r3, [pc, #32]	; (4054e4 <udd_ep_abort+0x218>)
  4054c4:	4798      	blx	r3
  4054c6:	e000      	b.n	4054ca <udd_ep_abort+0x1fe>
		return;
  4054c8:	bf00      	nop
}
  4054ca:	3720      	adds	r7, #32
  4054cc:	46bd      	mov	sp, r7
  4054ce:	bd80      	pop	{r7, pc}
  4054d0:	0040485d 	.word	0x0040485d
  4054d4:	40084000 	.word	0x40084000
  4054d8:	004048b5 	.word	0x004048b5
  4054dc:	20006c48 	.word	0x20006c48
  4054e0:	00405ed5 	.word	0x00405ed5
  4054e4:	00405e25 	.word	0x00405e25

004054e8 <udd_ep_wait_stall_clear>:


bool udd_ep_wait_stall_clear(udd_ep_id_t ep,
		udd_callback_halt_cleared_t callback)
{
  4054e8:	b580      	push	{r7, lr}
  4054ea:	b084      	sub	sp, #16
  4054ec:	af00      	add	r7, sp, #0
  4054ee:	4603      	mov	r3, r0
  4054f0:	6039      	str	r1, [r7, #0]
  4054f2:	71fb      	strb	r3, [r7, #7]
	udd_ep_job_t *ptr_job;

	ep &= USB_EP_ADDR_MASK;
  4054f4:	79fb      	ldrb	r3, [r7, #7]
  4054f6:	f003 030f 	and.w	r3, r3, #15
  4054fa:	71fb      	strb	r3, [r7, #7]
	if (USB_DEVICE_MAX_EP < ep) {
  4054fc:	79fb      	ldrb	r3, [r7, #7]
  4054fe:	2b02      	cmp	r3, #2
  405500:	d901      	bls.n	405506 <udd_ep_wait_stall_clear+0x1e>
		return false;
  405502:	2300      	movs	r3, #0
  405504:	e038      	b.n	405578 <udd_ep_wait_stall_clear+0x90>
	}

	ptr_job = &udd_ep_job[ep - 1];
  405506:	79fb      	ldrb	r3, [r7, #7]
  405508:	1e5a      	subs	r2, r3, #1
  40550a:	4613      	mov	r3, r2
  40550c:	009b      	lsls	r3, r3, #2
  40550e:	4413      	add	r3, r2
  405510:	009b      	lsls	r3, r3, #2
  405512:	4a1b      	ldr	r2, [pc, #108]	; (405580 <udd_ep_wait_stall_clear+0x98>)
  405514:	4413      	add	r3, r2
  405516:	60fb      	str	r3, [r7, #12]

	if (!Is_udd_endpoint_enabled(ep)) {
  405518:	4a1a      	ldr	r2, [pc, #104]	; (405584 <udd_ep_wait_stall_clear+0x9c>)
  40551a:	79fb      	ldrb	r3, [r7, #7]
  40551c:	330c      	adds	r3, #12
  40551e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  405522:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
  405526:	2b00      	cmp	r3, #0
  405528:	d101      	bne.n	40552e <udd_ep_wait_stall_clear+0x46>
		return false; // Endpoint not enabled
  40552a:	2300      	movs	r3, #0
  40552c:	e024      	b.n	405578 <udd_ep_wait_stall_clear+0x90>
	}

	// Wait clear halt endpoint
	if (ptr_job->busy == true) {
  40552e:	68fb      	ldr	r3, [r7, #12]
  405530:	7c5b      	ldrb	r3, [r3, #17]
  405532:	f003 0310 	and.w	r3, r3, #16
  405536:	b2db      	uxtb	r3, r3
  405538:	2b00      	cmp	r3, #0
  40553a:	d001      	beq.n	405540 <udd_ep_wait_stall_clear+0x58>
		return false; // Job already on going
  40553c:	2300      	movs	r3, #0
  40553e:	e01b      	b.n	405578 <udd_ep_wait_stall_clear+0x90>
	}

	if (Is_udd_endpoint_stall_requested(ep)
  405540:	4a10      	ldr	r2, [pc, #64]	; (405584 <udd_ep_wait_stall_clear+0x9c>)
  405542:	79fb      	ldrb	r3, [r7, #7]
  405544:	330c      	adds	r3, #12
  405546:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  40554a:	f003 0320 	and.w	r3, r3, #32
  40554e:	2b00      	cmp	r3, #0
  405550:	d106      	bne.n	405560 <udd_ep_wait_stall_clear+0x78>
			|| ptr_job->b_stall_requested) {
  405552:	68fb      	ldr	r3, [r7, #12]
  405554:	7c5b      	ldrb	r3, [r3, #17]
  405556:	f003 0320 	and.w	r3, r3, #32
  40555a:	b2db      	uxtb	r3, r3
  40555c:	2b00      	cmp	r3, #0
  40555e:	d008      	beq.n	405572 <udd_ep_wait_stall_clear+0x8a>
		// Endpoint halted then registers the callback
		ptr_job->busy = true;
  405560:	68fa      	ldr	r2, [r7, #12]
  405562:	7c53      	ldrb	r3, [r2, #17]
  405564:	f043 0310 	orr.w	r3, r3, #16
  405568:	7453      	strb	r3, [r2, #17]
		ptr_job->call_nohalt = callback;
  40556a:	68fb      	ldr	r3, [r7, #12]
  40556c:	683a      	ldr	r2, [r7, #0]
  40556e:	601a      	str	r2, [r3, #0]
  405570:	e001      	b.n	405576 <udd_ep_wait_stall_clear+0x8e>
	} else {
		// endpoint not halted then call directly callback
		callback();
  405572:	683b      	ldr	r3, [r7, #0]
  405574:	4798      	blx	r3
	}
	return true;
  405576:	2301      	movs	r3, #1
}
  405578:	4618      	mov	r0, r3
  40557a:	3710      	adds	r7, #16
  40557c:	46bd      	mov	sp, r7
  40557e:	bd80      	pop	{r7, pc}
  405580:	20006c48 	.word	0x20006c48
  405584:	40084000 	.word	0x40084000

00405588 <udd_reset_ep_ctrl>:

//--------------------------------------------------------
//--- INTERNAL ROUTINES TO MANAGED THE CONTROL ENDPOINT

static void udd_reset_ep_ctrl(void)
{
  405588:	b580      	push	{r7, lr}
  40558a:	b084      	sub	sp, #16
  40558c:	af00      	add	r7, sp, #0
	irqflags_t flags;

	// Reset USB address to 0
	udd_enable_address();
  40558e:	4a25      	ldr	r2, [pc, #148]	; (405624 <udd_reset_ep_ctrl+0x9c>)
  405590:	4b24      	ldr	r3, [pc, #144]	; (405624 <udd_reset_ep_ctrl+0x9c>)
  405592:	689b      	ldr	r3, [r3, #8]
  405594:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  405598:	6093      	str	r3, [r2, #8]
	udd_configure_address(0);
  40559a:	4a22      	ldr	r2, [pc, #136]	; (405624 <udd_reset_ep_ctrl+0x9c>)
  40559c:	4b21      	ldr	r3, [pc, #132]	; (405624 <udd_reset_ep_ctrl+0x9c>)
  40559e:	689b      	ldr	r3, [r3, #8]
  4055a0:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
  4055a4:	6093      	str	r3, [r2, #8]
	// Alloc and configure control endpoint in OUT direction
	udd_configure_endpoint(0, USB_EP_TYPE_CONTROL, 0);
  4055a6:	4b1f      	ldr	r3, [pc, #124]	; (405624 <udd_reset_ep_ctrl+0x9c>)
  4055a8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4055aa:	60bb      	str	r3, [r7, #8]
  4055ac:	68bb      	ldr	r3, [r7, #8]
  4055ae:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  4055b2:	60bb      	str	r3, [r7, #8]
  4055b4:	68bb      	ldr	r3, [r7, #8]
  4055b6:	f423 4307 	bic.w	r3, r3, #34560	; 0x8700
  4055ba:	f023 0380 	bic.w	r3, r3, #128	; 0x80
  4055be:	60bb      	str	r3, [r7, #8]
  4055c0:	68bb      	ldr	r3, [r7, #8]
  4055c2:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
  4055c6:	60bb      	str	r3, [r7, #8]
  4055c8:	4a16      	ldr	r2, [pc, #88]	; (405624 <udd_reset_ep_ctrl+0x9c>)
  4055ca:	68bb      	ldr	r3, [r7, #8]
  4055cc:	6313      	str	r3, [r2, #48]	; 0x30
  4055ce:	bf00      	nop
  4055d0:	4b14      	ldr	r3, [pc, #80]	; (405624 <udd_reset_ep_ctrl+0x9c>)
  4055d2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4055d4:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
  4055d8:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
  4055dc:	d1f8      	bne.n	4055d0 <udd_reset_ep_ctrl+0x48>
	udd_enable_endpoint(0);
  4055de:	4b11      	ldr	r3, [pc, #68]	; (405624 <udd_reset_ep_ctrl+0x9c>)
  4055e0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4055e2:	607b      	str	r3, [r7, #4]
  4055e4:	687b      	ldr	r3, [r7, #4]
  4055e6:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  4055ea:	607b      	str	r3, [r7, #4]
  4055ec:	687b      	ldr	r3, [r7, #4]
  4055ee:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
  4055f2:	607b      	str	r3, [r7, #4]
  4055f4:	4a0b      	ldr	r2, [pc, #44]	; (405624 <udd_reset_ep_ctrl+0x9c>)
  4055f6:	687b      	ldr	r3, [r7, #4]
  4055f8:	6313      	str	r3, [r2, #48]	; 0x30
  4055fa:	bf00      	nop
  4055fc:	4b09      	ldr	r3, [pc, #36]	; (405624 <udd_reset_ep_ctrl+0x9c>)
  4055fe:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  405600:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
  405604:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
  405608:	d1f8      	bne.n	4055fc <udd_reset_ep_ctrl+0x74>

	flags = cpu_irq_save();
  40560a:	4b07      	ldr	r3, [pc, #28]	; (405628 <udd_reset_ep_ctrl+0xa0>)
  40560c:	4798      	blx	r3
  40560e:	60f8      	str	r0, [r7, #12]
	udd_enable_endpoint_interrupt(0);
  405610:	4b04      	ldr	r3, [pc, #16]	; (405624 <udd_reset_ep_ctrl+0x9c>)
  405612:	2201      	movs	r2, #1
  405614:	611a      	str	r2, [r3, #16]
	cpu_irq_restore(flags);
  405616:	68f8      	ldr	r0, [r7, #12]
  405618:	4b04      	ldr	r3, [pc, #16]	; (40562c <udd_reset_ep_ctrl+0xa4>)
  40561a:	4798      	blx	r3
}
  40561c:	bf00      	nop
  40561e:	3710      	adds	r7, #16
  405620:	46bd      	mov	sp, r7
  405622:	bd80      	pop	{r7, pc}
  405624:	40084000 	.word	0x40084000
  405628:	0040485d 	.word	0x0040485d
  40562c:	004048b5 	.word	0x004048b5

00405630 <udd_ctrl_init>:

static void udd_ctrl_init(void)
{
  405630:	b480      	push	{r7}
  405632:	af00      	add	r7, sp, #0
	udd_g_ctrlreq.callback = NULL;
  405634:	4b08      	ldr	r3, [pc, #32]	; (405658 <udd_ctrl_init+0x28>)
  405636:	2200      	movs	r2, #0
  405638:	611a      	str	r2, [r3, #16]
	udd_g_ctrlreq.over_under_run = NULL;
  40563a:	4b07      	ldr	r3, [pc, #28]	; (405658 <udd_ctrl_init+0x28>)
  40563c:	2200      	movs	r2, #0
  40563e:	615a      	str	r2, [r3, #20]
	udd_g_ctrlreq.payload_size = 0;
  405640:	4b05      	ldr	r3, [pc, #20]	; (405658 <udd_ctrl_init+0x28>)
  405642:	2200      	movs	r2, #0
  405644:	819a      	strh	r2, [r3, #12]
	udd_ep_control_state = UDD_EPCTRL_SETUP;
  405646:	4b05      	ldr	r3, [pc, #20]	; (40565c <udd_ctrl_init+0x2c>)
  405648:	2200      	movs	r2, #0
  40564a:	701a      	strb	r2, [r3, #0]
}
  40564c:	bf00      	nop
  40564e:	46bd      	mov	sp, r7
  405650:	f85d 7b04 	ldr.w	r7, [sp], #4
  405654:	4770      	bx	lr
  405656:	bf00      	nop
  405658:	2000b598 	.word	0x2000b598
  40565c:	20006c42 	.word	0x20006c42

00405660 <udd_ctrl_setup_received>:


static void udd_ctrl_setup_received(void)
{
  405660:	b580      	push	{r7, lr}
  405662:	b086      	sub	sp, #24
  405664:	af00      	add	r7, sp, #0
	uint8_t i;

	if (UDD_EPCTRL_SETUP != udd_ep_control_state) {
  405666:	4b63      	ldr	r3, [pc, #396]	; (4057f4 <udd_ctrl_setup_received+0x194>)
  405668:	781b      	ldrb	r3, [r3, #0]
  40566a:	2b00      	cmp	r3, #0
  40566c:	d003      	beq.n	405676 <udd_ctrl_setup_received+0x16>
		// May be a hidden DATA or ZLP phase
		// or protocol abort
		udd_ctrl_endofrequest();
  40566e:	4b62      	ldr	r3, [pc, #392]	; (4057f8 <udd_ctrl_setup_received+0x198>)
  405670:	4798      	blx	r3

		// Reinitializes control endpoint management
		udd_ctrl_init();
  405672:	4b62      	ldr	r3, [pc, #392]	; (4057fc <udd_ctrl_setup_received+0x19c>)
  405674:	4798      	blx	r3
	}
	// Fill setup request structure
	if (8 != udd_byte_count(0)) {
  405676:	4b62      	ldr	r3, [pc, #392]	; (405800 <udd_ctrl_setup_received+0x1a0>)
  405678:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  40567a:	0c1b      	lsrs	r3, r3, #16
  40567c:	f3c3 030a 	ubfx	r3, r3, #0, #11
  405680:	2b08      	cmp	r3, #8
  405682:	d017      	beq.n	4056b4 <udd_ctrl_setup_received+0x54>
		udd_ack_setup_received(0);
  405684:	4b5e      	ldr	r3, [pc, #376]	; (405800 <udd_ctrl_setup_received+0x1a0>)
  405686:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  405688:	613b      	str	r3, [r7, #16]
  40568a:	693b      	ldr	r3, [r7, #16]
  40568c:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  405690:	613b      	str	r3, [r7, #16]
  405692:	693b      	ldr	r3, [r7, #16]
  405694:	f023 0304 	bic.w	r3, r3, #4
  405698:	613b      	str	r3, [r7, #16]
  40569a:	4a59      	ldr	r2, [pc, #356]	; (405800 <udd_ctrl_setup_received+0x1a0>)
  40569c:	693b      	ldr	r3, [r7, #16]
  40569e:	6313      	str	r3, [r2, #48]	; 0x30
  4056a0:	bf00      	nop
  4056a2:	4b57      	ldr	r3, [pc, #348]	; (405800 <udd_ctrl_setup_received+0x1a0>)
  4056a4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4056a6:	f003 0304 	and.w	r3, r3, #4
  4056aa:	2b00      	cmp	r3, #0
  4056ac:	d1f9      	bne.n	4056a2 <udd_ctrl_setup_received+0x42>
		udd_ctrl_stall_data();
  4056ae:	4b55      	ldr	r3, [pc, #340]	; (405804 <udd_ctrl_setup_received+0x1a4>)
  4056b0:	4798      	blx	r3
		return; // Error data number doesn't correspond to SETUP packet
  4056b2:	e09b      	b.n	4057ec <udd_ctrl_setup_received+0x18c>
	}
	for (i = 0; i < 8; i++) {
  4056b4:	2300      	movs	r3, #0
  4056b6:	75fb      	strb	r3, [r7, #23]
  4056b8:	e009      	b.n	4056ce <udd_ctrl_setup_received+0x6e>
		((uint8_t *) & udd_g_ctrlreq.req)[i] =
  4056ba:	7dfb      	ldrb	r3, [r7, #23]
  4056bc:	4a52      	ldr	r2, [pc, #328]	; (405808 <udd_ctrl_setup_received+0x1a8>)
  4056be:	4413      	add	r3, r2
			udd_endpoint_fifo_read(0);
  4056c0:	4a4f      	ldr	r2, [pc, #316]	; (405800 <udd_ctrl_setup_received+0x1a0>)
  4056c2:	6d12      	ldr	r2, [r2, #80]	; 0x50
		((uint8_t *) & udd_g_ctrlreq.req)[i] =
  4056c4:	b2d2      	uxtb	r2, r2
  4056c6:	701a      	strb	r2, [r3, #0]
	for (i = 0; i < 8; i++) {
  4056c8:	7dfb      	ldrb	r3, [r7, #23]
  4056ca:	3301      	adds	r3, #1
  4056cc:	75fb      	strb	r3, [r7, #23]
  4056ce:	7dfb      	ldrb	r3, [r7, #23]
  4056d0:	2b07      	cmp	r3, #7
  4056d2:	d9f2      	bls.n	4056ba <udd_ctrl_setup_received+0x5a>
	}
	// Manage LSB/MSB to fit with CPU usage
	udd_g_ctrlreq.req.wValue = le16_to_cpu(udd_g_ctrlreq.req.wValue);
  4056d4:	4b4c      	ldr	r3, [pc, #304]	; (405808 <udd_ctrl_setup_received+0x1a8>)
  4056d6:	885a      	ldrh	r2, [r3, #2]
  4056d8:	4b4b      	ldr	r3, [pc, #300]	; (405808 <udd_ctrl_setup_received+0x1a8>)
  4056da:	805a      	strh	r2, [r3, #2]
	udd_g_ctrlreq.req.wIndex = le16_to_cpu(udd_g_ctrlreq.req.wIndex);
  4056dc:	4b4a      	ldr	r3, [pc, #296]	; (405808 <udd_ctrl_setup_received+0x1a8>)
  4056de:	889a      	ldrh	r2, [r3, #4]
  4056e0:	4b49      	ldr	r3, [pc, #292]	; (405808 <udd_ctrl_setup_received+0x1a8>)
  4056e2:	809a      	strh	r2, [r3, #4]
	udd_g_ctrlreq.req.wLength = le16_to_cpu(udd_g_ctrlreq.req.wLength);
  4056e4:	4b48      	ldr	r3, [pc, #288]	; (405808 <udd_ctrl_setup_received+0x1a8>)
  4056e6:	88da      	ldrh	r2, [r3, #6]
  4056e8:	4b47      	ldr	r3, [pc, #284]	; (405808 <udd_ctrl_setup_received+0x1a8>)
  4056ea:	80da      	strh	r2, [r3, #6]

	// Decode setup request
	if (udc_process_setup() == false) {
  4056ec:	4b47      	ldr	r3, [pc, #284]	; (40580c <udd_ctrl_setup_received+0x1ac>)
  4056ee:	4798      	blx	r3
  4056f0:	4603      	mov	r3, r0
  4056f2:	f083 0301 	eor.w	r3, r3, #1
  4056f6:	b2db      	uxtb	r3, r3
  4056f8:	2b00      	cmp	r3, #0
  4056fa:	d017      	beq.n	40572c <udd_ctrl_setup_received+0xcc>
		// Setup request unknown then stall it
		udd_ack_setup_received(0);
  4056fc:	4b40      	ldr	r3, [pc, #256]	; (405800 <udd_ctrl_setup_received+0x1a0>)
  4056fe:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  405700:	60fb      	str	r3, [r7, #12]
  405702:	68fb      	ldr	r3, [r7, #12]
  405704:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  405708:	60fb      	str	r3, [r7, #12]
  40570a:	68fb      	ldr	r3, [r7, #12]
  40570c:	f023 0304 	bic.w	r3, r3, #4
  405710:	60fb      	str	r3, [r7, #12]
  405712:	4a3b      	ldr	r2, [pc, #236]	; (405800 <udd_ctrl_setup_received+0x1a0>)
  405714:	68fb      	ldr	r3, [r7, #12]
  405716:	6313      	str	r3, [r2, #48]	; 0x30
  405718:	bf00      	nop
  40571a:	4b39      	ldr	r3, [pc, #228]	; (405800 <udd_ctrl_setup_received+0x1a0>)
  40571c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  40571e:	f003 0304 	and.w	r3, r3, #4
  405722:	2b00      	cmp	r3, #0
  405724:	d1f9      	bne.n	40571a <udd_ctrl_setup_received+0xba>
		udd_ctrl_stall_data();
  405726:	4b37      	ldr	r3, [pc, #220]	; (405804 <udd_ctrl_setup_received+0x1a4>)
  405728:	4798      	blx	r3
		return;
  40572a:	e05f      	b.n	4057ec <udd_ctrl_setup_received+0x18c>
	}

	if (Udd_setup_is_in()) {
  40572c:	4b36      	ldr	r3, [pc, #216]	; (405808 <udd_ctrl_setup_received+0x1a8>)
  40572e:	781b      	ldrb	r3, [r3, #0]
  405730:	b25b      	sxtb	r3, r3
  405732:	2b00      	cmp	r3, #0
  405734:	da35      	bge.n	4057a2 <udd_ctrl_setup_received+0x142>
		// Set DIR
		udd_set_endpoint_direction_in(0);
  405736:	4b32      	ldr	r3, [pc, #200]	; (405800 <udd_ctrl_setup_received+0x1a0>)
  405738:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  40573a:	60bb      	str	r3, [r7, #8]
  40573c:	68bb      	ldr	r3, [r7, #8]
  40573e:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  405742:	60bb      	str	r3, [r7, #8]
  405744:	68bb      	ldr	r3, [r7, #8]
  405746:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  40574a:	60bb      	str	r3, [r7, #8]
  40574c:	4a2c      	ldr	r2, [pc, #176]	; (405800 <udd_ctrl_setup_received+0x1a0>)
  40574e:	68bb      	ldr	r3, [r7, #8]
  405750:	6313      	str	r3, [r2, #48]	; 0x30
  405752:	bf00      	nop
  405754:	4b2a      	ldr	r3, [pc, #168]	; (405800 <udd_ctrl_setup_received+0x1a0>)
  405756:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  405758:	f003 0380 	and.w	r3, r3, #128	; 0x80
  40575c:	2b80      	cmp	r3, #128	; 0x80
  40575e:	d1f9      	bne.n	405754 <udd_ctrl_setup_received+0xf4>
		udd_ack_setup_received(0);
  405760:	4b27      	ldr	r3, [pc, #156]	; (405800 <udd_ctrl_setup_received+0x1a0>)
  405762:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  405764:	607b      	str	r3, [r7, #4]
  405766:	687b      	ldr	r3, [r7, #4]
  405768:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  40576c:	607b      	str	r3, [r7, #4]
  40576e:	687b      	ldr	r3, [r7, #4]
  405770:	f023 0304 	bic.w	r3, r3, #4
  405774:	607b      	str	r3, [r7, #4]
  405776:	4a22      	ldr	r2, [pc, #136]	; (405800 <udd_ctrl_setup_received+0x1a0>)
  405778:	687b      	ldr	r3, [r7, #4]
  40577a:	6313      	str	r3, [r2, #48]	; 0x30
  40577c:	bf00      	nop
  40577e:	4b20      	ldr	r3, [pc, #128]	; (405800 <udd_ctrl_setup_received+0x1a0>)
  405780:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  405782:	f003 0304 	and.w	r3, r3, #4
  405786:	2b00      	cmp	r3, #0
  405788:	d1f9      	bne.n	40577e <udd_ctrl_setup_received+0x11e>
		// IN data phase requested
		udd_ctrl_prev_payload_nb_trans = 0;
  40578a:	4b21      	ldr	r3, [pc, #132]	; (405810 <udd_ctrl_setup_received+0x1b0>)
  40578c:	2200      	movs	r2, #0
  40578e:	801a      	strh	r2, [r3, #0]
		udd_ctrl_payload_nb_trans = 0;
  405790:	4b20      	ldr	r3, [pc, #128]	; (405814 <udd_ctrl_setup_received+0x1b4>)
  405792:	2200      	movs	r2, #0
  405794:	801a      	strh	r2, [r3, #0]
		udd_ep_control_state = UDD_EPCTRL_DATA_IN;
  405796:	4b17      	ldr	r3, [pc, #92]	; (4057f4 <udd_ctrl_setup_received+0x194>)
  405798:	2202      	movs	r2, #2
  40579a:	701a      	strb	r2, [r3, #0]
		udd_ctrl_in_sent(); // Send first data transfer
  40579c:	4b1e      	ldr	r3, [pc, #120]	; (405818 <udd_ctrl_setup_received+0x1b8>)
  40579e:	4798      	blx	r3
  4057a0:	e024      	b.n	4057ec <udd_ctrl_setup_received+0x18c>
	} else {
		udd_ack_setup_received(0);
  4057a2:	4b17      	ldr	r3, [pc, #92]	; (405800 <udd_ctrl_setup_received+0x1a0>)
  4057a4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4057a6:	603b      	str	r3, [r7, #0]
  4057a8:	683b      	ldr	r3, [r7, #0]
  4057aa:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  4057ae:	603b      	str	r3, [r7, #0]
  4057b0:	683b      	ldr	r3, [r7, #0]
  4057b2:	f023 0304 	bic.w	r3, r3, #4
  4057b6:	603b      	str	r3, [r7, #0]
  4057b8:	4a11      	ldr	r2, [pc, #68]	; (405800 <udd_ctrl_setup_received+0x1a0>)
  4057ba:	683b      	ldr	r3, [r7, #0]
  4057bc:	6313      	str	r3, [r2, #48]	; 0x30
  4057be:	bf00      	nop
  4057c0:	4b0f      	ldr	r3, [pc, #60]	; (405800 <udd_ctrl_setup_received+0x1a0>)
  4057c2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4057c4:	f003 0304 	and.w	r3, r3, #4
  4057c8:	2b00      	cmp	r3, #0
  4057ca:	d1f9      	bne.n	4057c0 <udd_ctrl_setup_received+0x160>
		if (0 == udd_g_ctrlreq.req.wLength) {
  4057cc:	4b0e      	ldr	r3, [pc, #56]	; (405808 <udd_ctrl_setup_received+0x1a8>)
  4057ce:	88db      	ldrh	r3, [r3, #6]
  4057d0:	2b00      	cmp	r3, #0
  4057d2:	d102      	bne.n	4057da <udd_ctrl_setup_received+0x17a>
			// No data phase requested
			// Send IN ZLP to ACK setup request
			udd_ctrl_send_zlp_in();
  4057d4:	4b11      	ldr	r3, [pc, #68]	; (40581c <udd_ctrl_setup_received+0x1bc>)
  4057d6:	4798      	blx	r3
			return;
  4057d8:	e008      	b.n	4057ec <udd_ctrl_setup_received+0x18c>
		}
		// OUT data phase requested
		udd_ctrl_prev_payload_nb_trans = 0;
  4057da:	4b0d      	ldr	r3, [pc, #52]	; (405810 <udd_ctrl_setup_received+0x1b0>)
  4057dc:	2200      	movs	r2, #0
  4057de:	801a      	strh	r2, [r3, #0]
		udd_ctrl_payload_nb_trans = 0;
  4057e0:	4b0c      	ldr	r3, [pc, #48]	; (405814 <udd_ctrl_setup_received+0x1b4>)
  4057e2:	2200      	movs	r2, #0
  4057e4:	801a      	strh	r2, [r3, #0]
		udd_ep_control_state = UDD_EPCTRL_DATA_OUT;
  4057e6:	4b03      	ldr	r3, [pc, #12]	; (4057f4 <udd_ctrl_setup_received+0x194>)
  4057e8:	2201      	movs	r2, #1
  4057ea:	701a      	strb	r2, [r3, #0]
	}
}
  4057ec:	3718      	adds	r7, #24
  4057ee:	46bd      	mov	sp, r7
  4057f0:	bd80      	pop	{r7, pc}
  4057f2:	bf00      	nop
  4057f4:	20006c42 	.word	0x20006c42
  4057f8:	00405d1d 	.word	0x00405d1d
  4057fc:	00405631 	.word	0x00405631
  405800:	40084000 	.word	0x40084000
  405804:	00405c6d 	.word	0x00405c6d
  405808:	2000b598 	.word	0x2000b598
  40580c:	00402819 	.word	0x00402819
  405810:	20006c44 	.word	0x20006c44
  405814:	20006c46 	.word	0x20006c46
  405818:	00405821 	.word	0x00405821
  40581c:	00405cb9 	.word	0x00405cb9

00405820 <udd_ctrl_in_sent>:


static void udd_ctrl_in_sent(void)
{
  405820:	b580      	push	{r7, lr}
  405822:	b088      	sub	sp, #32
  405824:	af00      	add	r7, sp, #0
	uint16_t nb_remain;
	uint8_t i;
	uint8_t *ptr_src;
	irqflags_t flags;

	if (UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP == udd_ep_control_state) {
  405826:	4b71      	ldr	r3, [pc, #452]	; (4059ec <udd_ctrl_in_sent+0x1cc>)
  405828:	781b      	ldrb	r3, [r3, #0]
  40582a:	2b03      	cmp	r3, #3
  40582c:	d119      	bne.n	405862 <udd_ctrl_in_sent+0x42>
		// Ack
		udd_ack_in_sent(0);
  40582e:	4b70      	ldr	r3, [pc, #448]	; (4059f0 <udd_ctrl_in_sent+0x1d0>)
  405830:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  405832:	613b      	str	r3, [r7, #16]
  405834:	693b      	ldr	r3, [r7, #16]
  405836:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  40583a:	613b      	str	r3, [r7, #16]
  40583c:	693b      	ldr	r3, [r7, #16]
  40583e:	f023 0301 	bic.w	r3, r3, #1
  405842:	613b      	str	r3, [r7, #16]
  405844:	4a6a      	ldr	r2, [pc, #424]	; (4059f0 <udd_ctrl_in_sent+0x1d0>)
  405846:	693b      	ldr	r3, [r7, #16]
  405848:	6313      	str	r3, [r2, #48]	; 0x30
  40584a:	bf00      	nop
  40584c:	4b68      	ldr	r3, [pc, #416]	; (4059f0 <udd_ctrl_in_sent+0x1d0>)
  40584e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  405850:	f003 0301 	and.w	r3, r3, #1
  405854:	2b00      	cmp	r3, #0
  405856:	d1f9      	bne.n	40584c <udd_ctrl_in_sent+0x2c>
		// ZLP on IN is sent, then valid end of setup request
		udd_ctrl_endofrequest();
  405858:	4b66      	ldr	r3, [pc, #408]	; (4059f4 <udd_ctrl_in_sent+0x1d4>)
  40585a:	4798      	blx	r3
		// Reinitializes control endpoint management
		udd_ctrl_init();
  40585c:	4b66      	ldr	r3, [pc, #408]	; (4059f8 <udd_ctrl_in_sent+0x1d8>)
  40585e:	4798      	blx	r3
		return;
  405860:	e0c1      	b.n	4059e6 <udd_ctrl_in_sent+0x1c6>
	}
	Assert(udd_ep_control_state == UDD_EPCTRL_DATA_IN);

	nb_remain = udd_g_ctrlreq.payload_size - udd_ctrl_payload_nb_trans;
  405862:	4b66      	ldr	r3, [pc, #408]	; (4059fc <udd_ctrl_in_sent+0x1dc>)
  405864:	899a      	ldrh	r2, [r3, #12]
  405866:	4b66      	ldr	r3, [pc, #408]	; (405a00 <udd_ctrl_in_sent+0x1e0>)
  405868:	881b      	ldrh	r3, [r3, #0]
  40586a:	1ad3      	subs	r3, r2, r3
  40586c:	83fb      	strh	r3, [r7, #30]
	if (0 == nb_remain) {
  40586e:	8bfb      	ldrh	r3, [r7, #30]
  405870:	2b00      	cmp	r3, #0
  405872:	d13c      	bne.n	4058ee <udd_ctrl_in_sent+0xce>
		// All content of current buffer payload are sent
		// Update number of total data sending by previous payload buffer
		udd_ctrl_prev_payload_nb_trans += udd_ctrl_payload_nb_trans;
  405874:	4b63      	ldr	r3, [pc, #396]	; (405a04 <udd_ctrl_in_sent+0x1e4>)
  405876:	881a      	ldrh	r2, [r3, #0]
  405878:	4b61      	ldr	r3, [pc, #388]	; (405a00 <udd_ctrl_in_sent+0x1e0>)
  40587a:	881b      	ldrh	r3, [r3, #0]
  40587c:	4413      	add	r3, r2
  40587e:	b29a      	uxth	r2, r3
  405880:	4b60      	ldr	r3, [pc, #384]	; (405a04 <udd_ctrl_in_sent+0x1e4>)
  405882:	801a      	strh	r2, [r3, #0]
		if ((udd_g_ctrlreq.req.wLength == udd_ctrl_prev_payload_nb_trans)
  405884:	4b5d      	ldr	r3, [pc, #372]	; (4059fc <udd_ctrl_in_sent+0x1dc>)
  405886:	88da      	ldrh	r2, [r3, #6]
  405888:	4b5e      	ldr	r3, [pc, #376]	; (405a04 <udd_ctrl_in_sent+0x1e4>)
  40588a:	881b      	ldrh	r3, [r3, #0]
  40588c:	429a      	cmp	r2, r3
  40588e:	d003      	beq.n	405898 <udd_ctrl_in_sent+0x78>
				|| b_shortpacket) {
  405890:	4b5d      	ldr	r3, [pc, #372]	; (405a08 <udd_ctrl_in_sent+0x1e8>)
  405892:	781b      	ldrb	r3, [r3, #0]
  405894:	2b00      	cmp	r3, #0
  405896:	d017      	beq.n	4058c8 <udd_ctrl_in_sent+0xa8>
			// All data requested are transfered or a short packet has been sent
			// then it is the end of data phase.
			// Generate an OUT ZLP for handshake phase.
			udd_ctrl_send_zlp_out();
  405898:	4b5c      	ldr	r3, [pc, #368]	; (405a0c <udd_ctrl_in_sent+0x1ec>)
  40589a:	4798      	blx	r3
			udd_ack_in_sent(0);
  40589c:	4b54      	ldr	r3, [pc, #336]	; (4059f0 <udd_ctrl_in_sent+0x1d0>)
  40589e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4058a0:	60fb      	str	r3, [r7, #12]
  4058a2:	68fb      	ldr	r3, [r7, #12]
  4058a4:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  4058a8:	60fb      	str	r3, [r7, #12]
  4058aa:	68fb      	ldr	r3, [r7, #12]
  4058ac:	f023 0301 	bic.w	r3, r3, #1
  4058b0:	60fb      	str	r3, [r7, #12]
  4058b2:	4a4f      	ldr	r2, [pc, #316]	; (4059f0 <udd_ctrl_in_sent+0x1d0>)
  4058b4:	68fb      	ldr	r3, [r7, #12]
  4058b6:	6313      	str	r3, [r2, #48]	; 0x30
  4058b8:	bf00      	nop
  4058ba:	4b4d      	ldr	r3, [pc, #308]	; (4059f0 <udd_ctrl_in_sent+0x1d0>)
  4058bc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4058be:	f003 0301 	and.w	r3, r3, #1
  4058c2:	2b00      	cmp	r3, #0
  4058c4:	d1f9      	bne.n	4058ba <udd_ctrl_in_sent+0x9a>
			return;
  4058c6:	e08e      	b.n	4059e6 <udd_ctrl_in_sent+0x1c6>
		}
		// Need of new buffer because the data phase is not complete
		if ((!udd_g_ctrlreq.over_under_run)
  4058c8:	4b4c      	ldr	r3, [pc, #304]	; (4059fc <udd_ctrl_in_sent+0x1dc>)
  4058ca:	695b      	ldr	r3, [r3, #20]
  4058cc:	2b00      	cmp	r3, #0
  4058ce:	d00e      	beq.n	4058ee <udd_ctrl_in_sent+0xce>
				|| (!udd_g_ctrlreq.over_under_run())) {
  4058d0:	4b4a      	ldr	r3, [pc, #296]	; (4059fc <udd_ctrl_in_sent+0x1dc>)
  4058d2:	695b      	ldr	r3, [r3, #20]
  4058d4:	4798      	blx	r3
  4058d6:	4603      	mov	r3, r0
  4058d8:	f083 0301 	eor.w	r3, r3, #1
  4058dc:	b2db      	uxtb	r3, r3
  4058de:	2b00      	cmp	r3, #0
  4058e0:	d105      	bne.n	4058ee <udd_ctrl_in_sent+0xce>
			// Underrun then send zlp on IN
			// Here nb_remain=0 and allows to send a IN ZLP
		} else {
			// A new payload buffer is given
			udd_ctrl_payload_nb_trans = 0;
  4058e2:	4b47      	ldr	r3, [pc, #284]	; (405a00 <udd_ctrl_in_sent+0x1e0>)
  4058e4:	2200      	movs	r2, #0
  4058e6:	801a      	strh	r2, [r3, #0]
			nb_remain = udd_g_ctrlreq.payload_size;
  4058e8:	4b44      	ldr	r3, [pc, #272]	; (4059fc <udd_ctrl_in_sent+0x1dc>)
  4058ea:	899b      	ldrh	r3, [r3, #12]
  4058ec:	83fb      	strh	r3, [r7, #30]
		}
	}
	// Continue transfer and send next data
	if (nb_remain >= USB_DEVICE_EP_CTRL_SIZE) {
  4058ee:	8bfb      	ldrh	r3, [r7, #30]
  4058f0:	2b3f      	cmp	r3, #63	; 0x3f
  4058f2:	d905      	bls.n	405900 <udd_ctrl_in_sent+0xe0>
		nb_remain = USB_DEVICE_EP_CTRL_SIZE;
  4058f4:	2340      	movs	r3, #64	; 0x40
  4058f6:	83fb      	strh	r3, [r7, #30]
		b_shortpacket = false;
  4058f8:	4b43      	ldr	r3, [pc, #268]	; (405a08 <udd_ctrl_in_sent+0x1e8>)
  4058fa:	2200      	movs	r2, #0
  4058fc:	701a      	strb	r2, [r3, #0]
  4058fe:	e002      	b.n	405906 <udd_ctrl_in_sent+0xe6>
	} else {
		b_shortpacket = true;
  405900:	4b41      	ldr	r3, [pc, #260]	; (405a08 <udd_ctrl_in_sent+0x1e8>)
  405902:	2201      	movs	r2, #1
  405904:	701a      	strb	r2, [r3, #0]
	}
	// Fill buffer of endpoint control
	ptr_src = udd_g_ctrlreq.payload + udd_ctrl_payload_nb_trans;
  405906:	4b3d      	ldr	r3, [pc, #244]	; (4059fc <udd_ctrl_in_sent+0x1dc>)
  405908:	689b      	ldr	r3, [r3, #8]
  40590a:	4a3d      	ldr	r2, [pc, #244]	; (405a00 <udd_ctrl_in_sent+0x1e0>)
  40590c:	8812      	ldrh	r2, [r2, #0]
  40590e:	4413      	add	r3, r2
  405910:	61bb      	str	r3, [r7, #24]
	// The IN data don't must be written in endpoint 0 DPRAM during
	// a next setup reception in same endpoint 0 DPRAM.
	// Thereby, an OUT ZLP reception must check before IN data write
	// and if no OUT ZLP is received the data must be written quickly (800us)
	// before an eventually ZLP OUT and SETUP reception
	flags = cpu_irq_save();
  405912:	4b3f      	ldr	r3, [pc, #252]	; (405a10 <udd_ctrl_in_sent+0x1f0>)
  405914:	4798      	blx	r3
  405916:	6178      	str	r0, [r7, #20]
	if (Is_udd_bank0_received(0)) {
  405918:	4b35      	ldr	r3, [pc, #212]	; (4059f0 <udd_ctrl_in_sent+0x1d0>)
  40591a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  40591c:	f003 0302 	and.w	r3, r3, #2
  405920:	2b00      	cmp	r3, #0
  405922:	d01b      	beq.n	40595c <udd_ctrl_in_sent+0x13c>
		// IN DATA phase aborted by OUT ZLP
		cpu_irq_restore(flags);
  405924:	6978      	ldr	r0, [r7, #20]
  405926:	4b3b      	ldr	r3, [pc, #236]	; (405a14 <udd_ctrl_in_sent+0x1f4>)
  405928:	4798      	blx	r3
		udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
  40592a:	4b30      	ldr	r3, [pc, #192]	; (4059ec <udd_ctrl_in_sent+0x1cc>)
  40592c:	2204      	movs	r2, #4
  40592e:	701a      	strb	r2, [r3, #0]
		udd_ack_in_sent(0);
  405930:	4b2f      	ldr	r3, [pc, #188]	; (4059f0 <udd_ctrl_in_sent+0x1d0>)
  405932:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  405934:	60bb      	str	r3, [r7, #8]
  405936:	68bb      	ldr	r3, [r7, #8]
  405938:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  40593c:	60bb      	str	r3, [r7, #8]
  40593e:	68bb      	ldr	r3, [r7, #8]
  405940:	f023 0301 	bic.w	r3, r3, #1
  405944:	60bb      	str	r3, [r7, #8]
  405946:	4a2a      	ldr	r2, [pc, #168]	; (4059f0 <udd_ctrl_in_sent+0x1d0>)
  405948:	68bb      	ldr	r3, [r7, #8]
  40594a:	6313      	str	r3, [r2, #48]	; 0x30
  40594c:	bf00      	nop
  40594e:	4b28      	ldr	r3, [pc, #160]	; (4059f0 <udd_ctrl_in_sent+0x1d0>)
  405950:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  405952:	f003 0301 	and.w	r3, r3, #1
  405956:	2b00      	cmp	r3, #0
  405958:	d1f9      	bne.n	40594e <udd_ctrl_in_sent+0x12e>
		return; // Exit of IN DATA phase
  40595a:	e044      	b.n	4059e6 <udd_ctrl_in_sent+0x1c6>
	}
	// Write quickly the IN data
	for (i = 0; i < nb_remain; i++) {
  40595c:	2300      	movs	r3, #0
  40595e:	777b      	strb	r3, [r7, #29]
  405960:	e008      	b.n	405974 <udd_ctrl_in_sent+0x154>
		udd_endpoint_fifo_write(0, *ptr_src++);
  405962:	4923      	ldr	r1, [pc, #140]	; (4059f0 <udd_ctrl_in_sent+0x1d0>)
  405964:	69bb      	ldr	r3, [r7, #24]
  405966:	1c5a      	adds	r2, r3, #1
  405968:	61ba      	str	r2, [r7, #24]
  40596a:	781b      	ldrb	r3, [r3, #0]
  40596c:	650b      	str	r3, [r1, #80]	; 0x50
	for (i = 0; i < nb_remain; i++) {
  40596e:	7f7b      	ldrb	r3, [r7, #29]
  405970:	3301      	adds	r3, #1
  405972:	777b      	strb	r3, [r7, #29]
  405974:	7f7b      	ldrb	r3, [r7, #29]
  405976:	b29b      	uxth	r3, r3
  405978:	8bfa      	ldrh	r2, [r7, #30]
  40597a:	429a      	cmp	r2, r3
  40597c:	d8f1      	bhi.n	405962 <udd_ctrl_in_sent+0x142>
	}
	udd_ctrl_payload_nb_trans += nb_remain;
  40597e:	4b20      	ldr	r3, [pc, #128]	; (405a00 <udd_ctrl_in_sent+0x1e0>)
  405980:	881a      	ldrh	r2, [r3, #0]
  405982:	8bfb      	ldrh	r3, [r7, #30]
  405984:	4413      	add	r3, r2
  405986:	b29a      	uxth	r2, r3
  405988:	4b1d      	ldr	r3, [pc, #116]	; (405a00 <udd_ctrl_in_sent+0x1e0>)
  40598a:	801a      	strh	r2, [r3, #0]
	// Validate and send the data available in the control endpoint buffer
	udd_set_transmit_ready(0);
  40598c:	4b18      	ldr	r3, [pc, #96]	; (4059f0 <udd_ctrl_in_sent+0x1d0>)
  40598e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  405990:	607b      	str	r3, [r7, #4]
  405992:	687b      	ldr	r3, [r7, #4]
  405994:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  405998:	607b      	str	r3, [r7, #4]
  40599a:	687b      	ldr	r3, [r7, #4]
  40599c:	f043 0310 	orr.w	r3, r3, #16
  4059a0:	607b      	str	r3, [r7, #4]
  4059a2:	4a13      	ldr	r2, [pc, #76]	; (4059f0 <udd_ctrl_in_sent+0x1d0>)
  4059a4:	687b      	ldr	r3, [r7, #4]
  4059a6:	6313      	str	r3, [r2, #48]	; 0x30
  4059a8:	bf00      	nop
  4059aa:	4b11      	ldr	r3, [pc, #68]	; (4059f0 <udd_ctrl_in_sent+0x1d0>)
  4059ac:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4059ae:	f003 0310 	and.w	r3, r3, #16
  4059b2:	2b10      	cmp	r3, #16
  4059b4:	d1f9      	bne.n	4059aa <udd_ctrl_in_sent+0x18a>
	udd_ack_in_sent(0);
  4059b6:	4b0e      	ldr	r3, [pc, #56]	; (4059f0 <udd_ctrl_in_sent+0x1d0>)
  4059b8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4059ba:	603b      	str	r3, [r7, #0]
  4059bc:	683b      	ldr	r3, [r7, #0]
  4059be:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  4059c2:	603b      	str	r3, [r7, #0]
  4059c4:	683b      	ldr	r3, [r7, #0]
  4059c6:	f023 0301 	bic.w	r3, r3, #1
  4059ca:	603b      	str	r3, [r7, #0]
  4059cc:	4a08      	ldr	r2, [pc, #32]	; (4059f0 <udd_ctrl_in_sent+0x1d0>)
  4059ce:	683b      	ldr	r3, [r7, #0]
  4059d0:	6313      	str	r3, [r2, #48]	; 0x30
  4059d2:	bf00      	nop
  4059d4:	4b06      	ldr	r3, [pc, #24]	; (4059f0 <udd_ctrl_in_sent+0x1d0>)
  4059d6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4059d8:	f003 0301 	and.w	r3, r3, #1
  4059dc:	2b00      	cmp	r3, #0
  4059de:	d1f9      	bne.n	4059d4 <udd_ctrl_in_sent+0x1b4>

	// In case of abort of DATA IN phase, no need to enable nak OUT interrupt
	// because OUT endpoint is already free and ZLP OUT accepted.
	cpu_irq_restore(flags);
  4059e0:	6978      	ldr	r0, [r7, #20]
  4059e2:	4b0c      	ldr	r3, [pc, #48]	; (405a14 <udd_ctrl_in_sent+0x1f4>)
  4059e4:	4798      	blx	r3
}
  4059e6:	3720      	adds	r7, #32
  4059e8:	46bd      	mov	sp, r7
  4059ea:	bd80      	pop	{r7, pc}
  4059ec:	20006c42 	.word	0x20006c42
  4059f0:	40084000 	.word	0x40084000
  4059f4:	00405d1d 	.word	0x00405d1d
  4059f8:	00405631 	.word	0x00405631
  4059fc:	2000b598 	.word	0x2000b598
  405a00:	20006c46 	.word	0x20006c46
  405a04:	20006c44 	.word	0x20006c44
  405a08:	20006c70 	.word	0x20006c70
  405a0c:	00405d05 	.word	0x00405d05
  405a10:	0040485d 	.word	0x0040485d
  405a14:	004048b5 	.word	0x004048b5

00405a18 <udd_ctrl_out_received>:


static void udd_ctrl_out_received(void)
{
  405a18:	b580      	push	{r7, lr}
  405a1a:	b088      	sub	sp, #32
  405a1c:	af00      	add	r7, sp, #0
	uint8_t i;
	uint16_t nb_data;

	if (UDD_EPCTRL_DATA_OUT != udd_ep_control_state) {
  405a1e:	4b8a      	ldr	r3, [pc, #552]	; (405c48 <udd_ctrl_out_received+0x230>)
  405a20:	781b      	ldrb	r3, [r3, #0]
  405a22:	2b01      	cmp	r3, #1
  405a24:	d024      	beq.n	405a70 <udd_ctrl_out_received+0x58>
		if ((UDD_EPCTRL_DATA_IN == udd_ep_control_state)
  405a26:	4b88      	ldr	r3, [pc, #544]	; (405c48 <udd_ctrl_out_received+0x230>)
  405a28:	781b      	ldrb	r3, [r3, #0]
  405a2a:	2b02      	cmp	r3, #2
  405a2c:	d003      	beq.n	405a36 <udd_ctrl_out_received+0x1e>
				|| (UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP ==
  405a2e:	4b86      	ldr	r3, [pc, #536]	; (405c48 <udd_ctrl_out_received+0x230>)
  405a30:	781b      	ldrb	r3, [r3, #0]
  405a32:	2b04      	cmp	r3, #4
  405a34:	d102      	bne.n	405a3c <udd_ctrl_out_received+0x24>
				udd_ep_control_state)) {
			// End of SETUP request:
			// - Data IN Phase aborted,
			// - or last Data IN Phase hidden by ZLP OUT sending quickly,
			// - or ZLP OUT received normally.
			udd_ctrl_endofrequest();
  405a36:	4b85      	ldr	r3, [pc, #532]	; (405c4c <udd_ctrl_out_received+0x234>)
  405a38:	4798      	blx	r3
  405a3a:	e001      	b.n	405a40 <udd_ctrl_out_received+0x28>
		} else {
			// Protocol error during SETUP request
			udd_ctrl_stall_data();
  405a3c:	4b84      	ldr	r3, [pc, #528]	; (405c50 <udd_ctrl_out_received+0x238>)
  405a3e:	4798      	blx	r3
		}
		udd_ack_bank0_received(0);
  405a40:	4b84      	ldr	r3, [pc, #528]	; (405c54 <udd_ctrl_out_received+0x23c>)
  405a42:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  405a44:	617b      	str	r3, [r7, #20]
  405a46:	697b      	ldr	r3, [r7, #20]
  405a48:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  405a4c:	617b      	str	r3, [r7, #20]
  405a4e:	697b      	ldr	r3, [r7, #20]
  405a50:	f023 0302 	bic.w	r3, r3, #2
  405a54:	617b      	str	r3, [r7, #20]
  405a56:	4a7f      	ldr	r2, [pc, #508]	; (405c54 <udd_ctrl_out_received+0x23c>)
  405a58:	697b      	ldr	r3, [r7, #20]
  405a5a:	6313      	str	r3, [r2, #48]	; 0x30
  405a5c:	bf00      	nop
  405a5e:	4b7d      	ldr	r3, [pc, #500]	; (405c54 <udd_ctrl_out_received+0x23c>)
  405a60:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  405a62:	f003 0302 	and.w	r3, r3, #2
  405a66:	2b00      	cmp	r3, #0
  405a68:	d1f9      	bne.n	405a5e <udd_ctrl_out_received+0x46>
		// Reinitializes control endpoint management
		udd_ctrl_init();
  405a6a:	4b7b      	ldr	r3, [pc, #492]	; (405c58 <udd_ctrl_out_received+0x240>)
  405a6c:	4798      	blx	r3
		return;
  405a6e:	e0e7      	b.n	405c40 <udd_ctrl_out_received+0x228>
	}
	// Read data received during OUT phase
	nb_data = udd_byte_count(0);
  405a70:	4b78      	ldr	r3, [pc, #480]	; (405c54 <udd_ctrl_out_received+0x23c>)
  405a72:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  405a74:	0c1b      	lsrs	r3, r3, #16
  405a76:	b29b      	uxth	r3, r3
  405a78:	f3c3 030a 	ubfx	r3, r3, #0, #11
  405a7c:	83bb      	strh	r3, [r7, #28]
	if (udd_g_ctrlreq.payload_size < (udd_ctrl_payload_nb_trans + nb_data)) {
  405a7e:	4b77      	ldr	r3, [pc, #476]	; (405c5c <udd_ctrl_out_received+0x244>)
  405a80:	899b      	ldrh	r3, [r3, #12]
  405a82:	461a      	mov	r2, r3
  405a84:	4b76      	ldr	r3, [pc, #472]	; (405c60 <udd_ctrl_out_received+0x248>)
  405a86:	881b      	ldrh	r3, [r3, #0]
  405a88:	4619      	mov	r1, r3
  405a8a:	8bbb      	ldrh	r3, [r7, #28]
  405a8c:	440b      	add	r3, r1
  405a8e:	429a      	cmp	r2, r3
  405a90:	da05      	bge.n	405a9e <udd_ctrl_out_received+0x86>
		// Payload buffer too small
		nb_data = udd_g_ctrlreq.payload_size -
  405a92:	4b72      	ldr	r3, [pc, #456]	; (405c5c <udd_ctrl_out_received+0x244>)
  405a94:	899a      	ldrh	r2, [r3, #12]
  405a96:	4b72      	ldr	r3, [pc, #456]	; (405c60 <udd_ctrl_out_received+0x248>)
  405a98:	881b      	ldrh	r3, [r3, #0]
  405a9a:	1ad3      	subs	r3, r2, r3
  405a9c:	83bb      	strh	r3, [r7, #28]
				udd_ctrl_payload_nb_trans;
	}
	uint8_t *ptr_dest = udd_g_ctrlreq.payload + udd_ctrl_payload_nb_trans;
  405a9e:	4b6f      	ldr	r3, [pc, #444]	; (405c5c <udd_ctrl_out_received+0x244>)
  405aa0:	689b      	ldr	r3, [r3, #8]
  405aa2:	4a6f      	ldr	r2, [pc, #444]	; (405c60 <udd_ctrl_out_received+0x248>)
  405aa4:	8812      	ldrh	r2, [r2, #0]
  405aa6:	4413      	add	r3, r2
  405aa8:	61bb      	str	r3, [r7, #24]
	for (i = 0; i < nb_data; i++) {
  405aaa:	2300      	movs	r3, #0
  405aac:	77fb      	strb	r3, [r7, #31]
  405aae:	e009      	b.n	405ac4 <udd_ctrl_out_received+0xac>
		*ptr_dest++ = udd_endpoint_fifo_read(0);
  405ab0:	69bb      	ldr	r3, [r7, #24]
  405ab2:	1c5a      	adds	r2, r3, #1
  405ab4:	61ba      	str	r2, [r7, #24]
  405ab6:	4a67      	ldr	r2, [pc, #412]	; (405c54 <udd_ctrl_out_received+0x23c>)
  405ab8:	6d12      	ldr	r2, [r2, #80]	; 0x50
  405aba:	b2d2      	uxtb	r2, r2
  405abc:	701a      	strb	r2, [r3, #0]
	for (i = 0; i < nb_data; i++) {
  405abe:	7ffb      	ldrb	r3, [r7, #31]
  405ac0:	3301      	adds	r3, #1
  405ac2:	77fb      	strb	r3, [r7, #31]
  405ac4:	7ffb      	ldrb	r3, [r7, #31]
  405ac6:	b29b      	uxth	r3, r3
  405ac8:	8bba      	ldrh	r2, [r7, #28]
  405aca:	429a      	cmp	r2, r3
  405acc:	d8f0      	bhi.n	405ab0 <udd_ctrl_out_received+0x98>
	}
	udd_ctrl_payload_nb_trans += nb_data;
  405ace:	4b64      	ldr	r3, [pc, #400]	; (405c60 <udd_ctrl_out_received+0x248>)
  405ad0:	881a      	ldrh	r2, [r3, #0]
  405ad2:	8bbb      	ldrh	r3, [r7, #28]
  405ad4:	4413      	add	r3, r2
  405ad6:	b29a      	uxth	r2, r3
  405ad8:	4b61      	ldr	r3, [pc, #388]	; (405c60 <udd_ctrl_out_received+0x248>)
  405ada:	801a      	strh	r2, [r3, #0]

	if ((USB_DEVICE_EP_CTRL_SIZE != nb_data)
  405adc:	8bbb      	ldrh	r3, [r7, #28]
  405ade:	2b40      	cmp	r3, #64	; 0x40
  405ae0:	d10a      	bne.n	405af8 <udd_ctrl_out_received+0xe0>
			|| (udd_g_ctrlreq.req.wLength <=
  405ae2:	4b5e      	ldr	r3, [pc, #376]	; (405c5c <udd_ctrl_out_received+0x244>)
  405ae4:	88db      	ldrh	r3, [r3, #6]
  405ae6:	461a      	mov	r2, r3
			(udd_ctrl_prev_payload_nb_trans +
  405ae8:	4b5e      	ldr	r3, [pc, #376]	; (405c64 <udd_ctrl_out_received+0x24c>)
  405aea:	881b      	ldrh	r3, [r3, #0]
  405aec:	4619      	mov	r1, r3
  405aee:	4b5c      	ldr	r3, [pc, #368]	; (405c60 <udd_ctrl_out_received+0x248>)
  405af0:	881b      	ldrh	r3, [r3, #0]
  405af2:	440b      	add	r3, r1
			|| (udd_g_ctrlreq.req.wLength <=
  405af4:	429a      	cmp	r2, r3
  405af6:	dc40      	bgt.n	405b7a <udd_ctrl_out_received+0x162>
			udd_ctrl_payload_nb_trans))) {
		// End of reception because it is a short packet
		// Before send ZLP, call intermediate callback
		// in case of data receive generate a stall
		udd_g_ctrlreq.payload_size = udd_ctrl_payload_nb_trans;
  405af8:	4b59      	ldr	r3, [pc, #356]	; (405c60 <udd_ctrl_out_received+0x248>)
  405afa:	881a      	ldrh	r2, [r3, #0]
  405afc:	4b57      	ldr	r3, [pc, #348]	; (405c5c <udd_ctrl_out_received+0x244>)
  405afe:	819a      	strh	r2, [r3, #12]
		if (NULL != udd_g_ctrlreq.over_under_run) {
  405b00:	4b56      	ldr	r3, [pc, #344]	; (405c5c <udd_ctrl_out_received+0x244>)
  405b02:	695b      	ldr	r3, [r3, #20]
  405b04:	2b00      	cmp	r3, #0
  405b06:	d020      	beq.n	405b4a <udd_ctrl_out_received+0x132>
			if (!udd_g_ctrlreq.over_under_run()) {
  405b08:	4b54      	ldr	r3, [pc, #336]	; (405c5c <udd_ctrl_out_received+0x244>)
  405b0a:	695b      	ldr	r3, [r3, #20]
  405b0c:	4798      	blx	r3
  405b0e:	4603      	mov	r3, r0
  405b10:	f083 0301 	eor.w	r3, r3, #1
  405b14:	b2db      	uxtb	r3, r3
  405b16:	2b00      	cmp	r3, #0
  405b18:	d017      	beq.n	405b4a <udd_ctrl_out_received+0x132>
				// Stall ZLP
				udd_ctrl_stall_data();
  405b1a:	4b4d      	ldr	r3, [pc, #308]	; (405c50 <udd_ctrl_out_received+0x238>)
  405b1c:	4798      	blx	r3
				// Ack reception of OUT to replace NAK by a STALL
				udd_ack_bank0_received(0);
  405b1e:	4b4d      	ldr	r3, [pc, #308]	; (405c54 <udd_ctrl_out_received+0x23c>)
  405b20:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  405b22:	613b      	str	r3, [r7, #16]
  405b24:	693b      	ldr	r3, [r7, #16]
  405b26:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  405b2a:	613b      	str	r3, [r7, #16]
  405b2c:	693b      	ldr	r3, [r7, #16]
  405b2e:	f023 0302 	bic.w	r3, r3, #2
  405b32:	613b      	str	r3, [r7, #16]
  405b34:	4a47      	ldr	r2, [pc, #284]	; (405c54 <udd_ctrl_out_received+0x23c>)
  405b36:	693b      	ldr	r3, [r7, #16]
  405b38:	6313      	str	r3, [r2, #48]	; 0x30
  405b3a:	bf00      	nop
  405b3c:	4b45      	ldr	r3, [pc, #276]	; (405c54 <udd_ctrl_out_received+0x23c>)
  405b3e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  405b40:	f003 0302 	and.w	r3, r3, #2
  405b44:	2b00      	cmp	r3, #0
  405b46:	d1f9      	bne.n	405b3c <udd_ctrl_out_received+0x124>
				return;
  405b48:	e07a      	b.n	405c40 <udd_ctrl_out_received+0x228>
			}
		}
		// Send IN ZLP to ACK setup request
		udd_ack_bank0_received(0);
  405b4a:	4b42      	ldr	r3, [pc, #264]	; (405c54 <udd_ctrl_out_received+0x23c>)
  405b4c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  405b4e:	60fb      	str	r3, [r7, #12]
  405b50:	68fb      	ldr	r3, [r7, #12]
  405b52:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  405b56:	60fb      	str	r3, [r7, #12]
  405b58:	68fb      	ldr	r3, [r7, #12]
  405b5a:	f023 0302 	bic.w	r3, r3, #2
  405b5e:	60fb      	str	r3, [r7, #12]
  405b60:	4a3c      	ldr	r2, [pc, #240]	; (405c54 <udd_ctrl_out_received+0x23c>)
  405b62:	68fb      	ldr	r3, [r7, #12]
  405b64:	6313      	str	r3, [r2, #48]	; 0x30
  405b66:	bf00      	nop
  405b68:	4b3a      	ldr	r3, [pc, #232]	; (405c54 <udd_ctrl_out_received+0x23c>)
  405b6a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  405b6c:	f003 0302 	and.w	r3, r3, #2
  405b70:	2b00      	cmp	r3, #0
  405b72:	d1f9      	bne.n	405b68 <udd_ctrl_out_received+0x150>
		udd_ctrl_send_zlp_in();
  405b74:	4b3c      	ldr	r3, [pc, #240]	; (405c68 <udd_ctrl_out_received+0x250>)
  405b76:	4798      	blx	r3
		return;
  405b78:	e062      	b.n	405c40 <udd_ctrl_out_received+0x228>
	}

	if (udd_g_ctrlreq.payload_size == udd_ctrl_payload_nb_trans) {
  405b7a:	4b38      	ldr	r3, [pc, #224]	; (405c5c <udd_ctrl_out_received+0x244>)
  405b7c:	899a      	ldrh	r2, [r3, #12]
  405b7e:	4b38      	ldr	r3, [pc, #224]	; (405c60 <udd_ctrl_out_received+0x248>)
  405b80:	881b      	ldrh	r3, [r3, #0]
  405b82:	429a      	cmp	r2, r3
  405b84:	d147      	bne.n	405c16 <udd_ctrl_out_received+0x1fe>
		// Overrun then request a new payload buffer
		if (!udd_g_ctrlreq.over_under_run) {
  405b86:	4b35      	ldr	r3, [pc, #212]	; (405c5c <udd_ctrl_out_received+0x244>)
  405b88:	695b      	ldr	r3, [r3, #20]
  405b8a:	2b00      	cmp	r3, #0
  405b8c:	d117      	bne.n	405bbe <udd_ctrl_out_received+0x1a6>
			// No callback available to request a new payload buffer
			udd_ctrl_stall_data();
  405b8e:	4b30      	ldr	r3, [pc, #192]	; (405c50 <udd_ctrl_out_received+0x238>)
  405b90:	4798      	blx	r3
			// Ack reception of OUT to replace NAK by a STALL
			udd_ack_bank0_received(0);
  405b92:	4b30      	ldr	r3, [pc, #192]	; (405c54 <udd_ctrl_out_received+0x23c>)
  405b94:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  405b96:	60bb      	str	r3, [r7, #8]
  405b98:	68bb      	ldr	r3, [r7, #8]
  405b9a:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  405b9e:	60bb      	str	r3, [r7, #8]
  405ba0:	68bb      	ldr	r3, [r7, #8]
  405ba2:	f023 0302 	bic.w	r3, r3, #2
  405ba6:	60bb      	str	r3, [r7, #8]
  405ba8:	4a2a      	ldr	r2, [pc, #168]	; (405c54 <udd_ctrl_out_received+0x23c>)
  405baa:	68bb      	ldr	r3, [r7, #8]
  405bac:	6313      	str	r3, [r2, #48]	; 0x30
  405bae:	bf00      	nop
  405bb0:	4b28      	ldr	r3, [pc, #160]	; (405c54 <udd_ctrl_out_received+0x23c>)
  405bb2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  405bb4:	f003 0302 	and.w	r3, r3, #2
  405bb8:	2b00      	cmp	r3, #0
  405bba:	d1f9      	bne.n	405bb0 <udd_ctrl_out_received+0x198>
			return;
  405bbc:	e040      	b.n	405c40 <udd_ctrl_out_received+0x228>
		}
		if (!udd_g_ctrlreq.over_under_run()) {
  405bbe:	4b27      	ldr	r3, [pc, #156]	; (405c5c <udd_ctrl_out_received+0x244>)
  405bc0:	695b      	ldr	r3, [r3, #20]
  405bc2:	4798      	blx	r3
  405bc4:	4603      	mov	r3, r0
  405bc6:	f083 0301 	eor.w	r3, r3, #1
  405bca:	b2db      	uxtb	r3, r3
  405bcc:	2b00      	cmp	r3, #0
  405bce:	d017      	beq.n	405c00 <udd_ctrl_out_received+0x1e8>
			// No new payload buffer delivered
			udd_ctrl_stall_data();
  405bd0:	4b1f      	ldr	r3, [pc, #124]	; (405c50 <udd_ctrl_out_received+0x238>)
  405bd2:	4798      	blx	r3
			// Ack reception of OUT to replace NAK by a STALL
			udd_ack_bank0_received(0);
  405bd4:	4b1f      	ldr	r3, [pc, #124]	; (405c54 <udd_ctrl_out_received+0x23c>)
  405bd6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  405bd8:	607b      	str	r3, [r7, #4]
  405bda:	687b      	ldr	r3, [r7, #4]
  405bdc:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  405be0:	607b      	str	r3, [r7, #4]
  405be2:	687b      	ldr	r3, [r7, #4]
  405be4:	f023 0302 	bic.w	r3, r3, #2
  405be8:	607b      	str	r3, [r7, #4]
  405bea:	4a1a      	ldr	r2, [pc, #104]	; (405c54 <udd_ctrl_out_received+0x23c>)
  405bec:	687b      	ldr	r3, [r7, #4]
  405bee:	6313      	str	r3, [r2, #48]	; 0x30
  405bf0:	bf00      	nop
  405bf2:	4b18      	ldr	r3, [pc, #96]	; (405c54 <udd_ctrl_out_received+0x23c>)
  405bf4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  405bf6:	f003 0302 	and.w	r3, r3, #2
  405bfa:	2b00      	cmp	r3, #0
  405bfc:	d1f9      	bne.n	405bf2 <udd_ctrl_out_received+0x1da>
			return;
  405bfe:	e01f      	b.n	405c40 <udd_ctrl_out_received+0x228>
		}
		// New payload buffer available
		// Update number of total data received
		udd_ctrl_prev_payload_nb_trans += udd_ctrl_payload_nb_trans;
  405c00:	4b18      	ldr	r3, [pc, #96]	; (405c64 <udd_ctrl_out_received+0x24c>)
  405c02:	881a      	ldrh	r2, [r3, #0]
  405c04:	4b16      	ldr	r3, [pc, #88]	; (405c60 <udd_ctrl_out_received+0x248>)
  405c06:	881b      	ldrh	r3, [r3, #0]
  405c08:	4413      	add	r3, r2
  405c0a:	b29a      	uxth	r2, r3
  405c0c:	4b15      	ldr	r3, [pc, #84]	; (405c64 <udd_ctrl_out_received+0x24c>)
  405c0e:	801a      	strh	r2, [r3, #0]
		// Reinit reception on payload buffer
		udd_ctrl_payload_nb_trans = 0;
  405c10:	4b13      	ldr	r3, [pc, #76]	; (405c60 <udd_ctrl_out_received+0x248>)
  405c12:	2200      	movs	r2, #0
  405c14:	801a      	strh	r2, [r3, #0]
	}
	// Free buffer of control endpoint to authorize next reception
	udd_ack_bank0_received(0);
  405c16:	4b0f      	ldr	r3, [pc, #60]	; (405c54 <udd_ctrl_out_received+0x23c>)
  405c18:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  405c1a:	603b      	str	r3, [r7, #0]
  405c1c:	683b      	ldr	r3, [r7, #0]
  405c1e:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  405c22:	603b      	str	r3, [r7, #0]
  405c24:	683b      	ldr	r3, [r7, #0]
  405c26:	f023 0302 	bic.w	r3, r3, #2
  405c2a:	603b      	str	r3, [r7, #0]
  405c2c:	4a09      	ldr	r2, [pc, #36]	; (405c54 <udd_ctrl_out_received+0x23c>)
  405c2e:	683b      	ldr	r3, [r7, #0]
  405c30:	6313      	str	r3, [r2, #48]	; 0x30
  405c32:	bf00      	nop
  405c34:	4b07      	ldr	r3, [pc, #28]	; (405c54 <udd_ctrl_out_received+0x23c>)
  405c36:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  405c38:	f003 0302 	and.w	r3, r3, #2
  405c3c:	2b00      	cmp	r3, #0
  405c3e:	d1f9      	bne.n	405c34 <udd_ctrl_out_received+0x21c>
}
  405c40:	3720      	adds	r7, #32
  405c42:	46bd      	mov	sp, r7
  405c44:	bd80      	pop	{r7, pc}
  405c46:	bf00      	nop
  405c48:	20006c42 	.word	0x20006c42
  405c4c:	00405d1d 	.word	0x00405d1d
  405c50:	00405c6d 	.word	0x00405c6d
  405c54:	40084000 	.word	0x40084000
  405c58:	00405631 	.word	0x00405631
  405c5c:	2000b598 	.word	0x2000b598
  405c60:	20006c46 	.word	0x20006c46
  405c64:	20006c44 	.word	0x20006c44
  405c68:	00405cb9 	.word	0x00405cb9

00405c6c <udd_ctrl_stall_data>:


static void udd_ctrl_stall_data(void)
{
  405c6c:	b480      	push	{r7}
  405c6e:	b083      	sub	sp, #12
  405c70:	af00      	add	r7, sp, #0
	// Stall all packets on IN & OUT control endpoint
	udd_ep_control_state = UDD_EPCTRL_STALL_REQ;
  405c72:	4b0f      	ldr	r3, [pc, #60]	; (405cb0 <udd_ctrl_stall_data+0x44>)
  405c74:	2205      	movs	r2, #5
  405c76:	701a      	strb	r2, [r3, #0]
	udd_enable_stall_handshake(0);
  405c78:	4b0e      	ldr	r3, [pc, #56]	; (405cb4 <udd_ctrl_stall_data+0x48>)
  405c7a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  405c7c:	607b      	str	r3, [r7, #4]
  405c7e:	687b      	ldr	r3, [r7, #4]
  405c80:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  405c84:	607b      	str	r3, [r7, #4]
  405c86:	687b      	ldr	r3, [r7, #4]
  405c88:	f043 0320 	orr.w	r3, r3, #32
  405c8c:	607b      	str	r3, [r7, #4]
  405c8e:	4a09      	ldr	r2, [pc, #36]	; (405cb4 <udd_ctrl_stall_data+0x48>)
  405c90:	687b      	ldr	r3, [r7, #4]
  405c92:	6313      	str	r3, [r2, #48]	; 0x30
  405c94:	bf00      	nop
  405c96:	4b07      	ldr	r3, [pc, #28]	; (405cb4 <udd_ctrl_stall_data+0x48>)
  405c98:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  405c9a:	f003 0320 	and.w	r3, r3, #32
  405c9e:	2b20      	cmp	r3, #32
  405ca0:	d1f9      	bne.n	405c96 <udd_ctrl_stall_data+0x2a>
}
  405ca2:	bf00      	nop
  405ca4:	370c      	adds	r7, #12
  405ca6:	46bd      	mov	sp, r7
  405ca8:	f85d 7b04 	ldr.w	r7, [sp], #4
  405cac:	4770      	bx	lr
  405cae:	bf00      	nop
  405cb0:	20006c42 	.word	0x20006c42
  405cb4:	40084000 	.word	0x40084000

00405cb8 <udd_ctrl_send_zlp_in>:


static void udd_ctrl_send_zlp_in(void)
{
  405cb8:	b480      	push	{r7}
  405cba:	b083      	sub	sp, #12
  405cbc:	af00      	add	r7, sp, #0
	udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP;
  405cbe:	4b0f      	ldr	r3, [pc, #60]	; (405cfc <udd_ctrl_send_zlp_in+0x44>)
  405cc0:	2203      	movs	r2, #3
  405cc2:	701a      	strb	r2, [r3, #0]
	// Validate and send empty IN packet on control endpoint
	// Send ZLP on IN endpoint
	udd_set_transmit_ready(0);
  405cc4:	4b0e      	ldr	r3, [pc, #56]	; (405d00 <udd_ctrl_send_zlp_in+0x48>)
  405cc6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  405cc8:	607b      	str	r3, [r7, #4]
  405cca:	687b      	ldr	r3, [r7, #4]
  405ccc:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  405cd0:	607b      	str	r3, [r7, #4]
  405cd2:	687b      	ldr	r3, [r7, #4]
  405cd4:	f043 0310 	orr.w	r3, r3, #16
  405cd8:	607b      	str	r3, [r7, #4]
  405cda:	4a09      	ldr	r2, [pc, #36]	; (405d00 <udd_ctrl_send_zlp_in+0x48>)
  405cdc:	687b      	ldr	r3, [r7, #4]
  405cde:	6313      	str	r3, [r2, #48]	; 0x30
  405ce0:	bf00      	nop
  405ce2:	4b07      	ldr	r3, [pc, #28]	; (405d00 <udd_ctrl_send_zlp_in+0x48>)
  405ce4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  405ce6:	f003 0310 	and.w	r3, r3, #16
  405cea:	2b10      	cmp	r3, #16
  405cec:	d1f9      	bne.n	405ce2 <udd_ctrl_send_zlp_in+0x2a>
}
  405cee:	bf00      	nop
  405cf0:	370c      	adds	r7, #12
  405cf2:	46bd      	mov	sp, r7
  405cf4:	f85d 7b04 	ldr.w	r7, [sp], #4
  405cf8:	4770      	bx	lr
  405cfa:	bf00      	nop
  405cfc:	20006c42 	.word	0x20006c42
  405d00:	40084000 	.word	0x40084000

00405d04 <udd_ctrl_send_zlp_out>:


static void udd_ctrl_send_zlp_out(void)
{
  405d04:	b480      	push	{r7}
  405d06:	af00      	add	r7, sp, #0
	udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
  405d08:	4b03      	ldr	r3, [pc, #12]	; (405d18 <udd_ctrl_send_zlp_out+0x14>)
  405d0a:	2204      	movs	r2, #4
  405d0c:	701a      	strb	r2, [r3, #0]
	// No action is necessary to accept OUT ZLP
	// because the buffer of control endpoint is already free
}
  405d0e:	bf00      	nop
  405d10:	46bd      	mov	sp, r7
  405d12:	f85d 7b04 	ldr.w	r7, [sp], #4
  405d16:	4770      	bx	lr
  405d18:	20006c42 	.word	0x20006c42

00405d1c <udd_ctrl_endofrequest>:


static void udd_ctrl_endofrequest(void)
{
  405d1c:	b580      	push	{r7, lr}
  405d1e:	af00      	add	r7, sp, #0
	// If a callback is registered then call it
	if (udd_g_ctrlreq.callback) {
  405d20:	4b04      	ldr	r3, [pc, #16]	; (405d34 <udd_ctrl_endofrequest+0x18>)
  405d22:	691b      	ldr	r3, [r3, #16]
  405d24:	2b00      	cmp	r3, #0
  405d26:	d002      	beq.n	405d2e <udd_ctrl_endofrequest+0x12>
		udd_g_ctrlreq.callback();
  405d28:	4b02      	ldr	r3, [pc, #8]	; (405d34 <udd_ctrl_endofrequest+0x18>)
  405d2a:	691b      	ldr	r3, [r3, #16]
  405d2c:	4798      	blx	r3
	}
}
  405d2e:	bf00      	nop
  405d30:	bd80      	pop	{r7, pc}
  405d32:	bf00      	nop
  405d34:	2000b598 	.word	0x2000b598

00405d38 <udd_ctrl_interrupt>:


static bool udd_ctrl_interrupt(void)
{
  405d38:	b580      	push	{r7, lr}
  405d3a:	b082      	sub	sp, #8
  405d3c:	af00      	add	r7, sp, #0
	if (!Is_udd_endpoint_interrupt(0))
  405d3e:	4b24      	ldr	r3, [pc, #144]	; (405dd0 <udd_ctrl_interrupt+0x98>)
  405d40:	69db      	ldr	r3, [r3, #28]
  405d42:	f003 0301 	and.w	r3, r3, #1
  405d46:	2b00      	cmp	r3, #0
  405d48:	d101      	bne.n	405d4e <udd_ctrl_interrupt+0x16>
		return false; // No interrupt events on control endpoint
  405d4a:	2300      	movs	r3, #0
  405d4c:	e03b      	b.n	405dc6 <udd_ctrl_interrupt+0x8e>

	// Search event on control endpoint
	if (Is_udd_setup_received(0)) {
  405d4e:	4b20      	ldr	r3, [pc, #128]	; (405dd0 <udd_ctrl_interrupt+0x98>)
  405d50:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  405d52:	f003 0304 	and.w	r3, r3, #4
  405d56:	2b00      	cmp	r3, #0
  405d58:	d003      	beq.n	405d62 <udd_ctrl_interrupt+0x2a>
		// SETUP packet received
		udd_ctrl_setup_received();
  405d5a:	4b1e      	ldr	r3, [pc, #120]	; (405dd4 <udd_ctrl_interrupt+0x9c>)
  405d5c:	4798      	blx	r3
		return true;
  405d5e:	2301      	movs	r3, #1
  405d60:	e031      	b.n	405dc6 <udd_ctrl_interrupt+0x8e>
	}
	if (Is_udd_in_sent(0)) {
  405d62:	4b1b      	ldr	r3, [pc, #108]	; (405dd0 <udd_ctrl_interrupt+0x98>)
  405d64:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  405d66:	f003 0301 	and.w	r3, r3, #1
  405d6a:	2b00      	cmp	r3, #0
  405d6c:	d003      	beq.n	405d76 <udd_ctrl_interrupt+0x3e>
		// IN packet sent
		udd_ctrl_in_sent();
  405d6e:	4b1a      	ldr	r3, [pc, #104]	; (405dd8 <udd_ctrl_interrupt+0xa0>)
  405d70:	4798      	blx	r3
		return true;
  405d72:	2301      	movs	r3, #1
  405d74:	e027      	b.n	405dc6 <udd_ctrl_interrupt+0x8e>
	}
	if (Is_udd_bank0_received(0)) {
  405d76:	4b16      	ldr	r3, [pc, #88]	; (405dd0 <udd_ctrl_interrupt+0x98>)
  405d78:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  405d7a:	f003 0302 	and.w	r3, r3, #2
  405d7e:	2b00      	cmp	r3, #0
  405d80:	d003      	beq.n	405d8a <udd_ctrl_interrupt+0x52>
		// OUT packet received
		udd_ctrl_out_received();
  405d82:	4b16      	ldr	r3, [pc, #88]	; (405ddc <udd_ctrl_interrupt+0xa4>)
  405d84:	4798      	blx	r3
		return true;
  405d86:	2301      	movs	r3, #1
  405d88:	e01d      	b.n	405dc6 <udd_ctrl_interrupt+0x8e>
	}
	if (Is_udd_stall(0)) {
  405d8a:	4b11      	ldr	r3, [pc, #68]	; (405dd0 <udd_ctrl_interrupt+0x98>)
  405d8c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  405d8e:	f003 0308 	and.w	r3, r3, #8
  405d92:	2b00      	cmp	r3, #0
  405d94:	d016      	beq.n	405dc4 <udd_ctrl_interrupt+0x8c>
		// STALLed
		udd_ack_stall(0);
  405d96:	4b0e      	ldr	r3, [pc, #56]	; (405dd0 <udd_ctrl_interrupt+0x98>)
  405d98:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  405d9a:	607b      	str	r3, [r7, #4]
  405d9c:	687b      	ldr	r3, [r7, #4]
  405d9e:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  405da2:	607b      	str	r3, [r7, #4]
  405da4:	687b      	ldr	r3, [r7, #4]
  405da6:	f023 0308 	bic.w	r3, r3, #8
  405daa:	607b      	str	r3, [r7, #4]
  405dac:	4a08      	ldr	r2, [pc, #32]	; (405dd0 <udd_ctrl_interrupt+0x98>)
  405dae:	687b      	ldr	r3, [r7, #4]
  405db0:	6313      	str	r3, [r2, #48]	; 0x30
  405db2:	bf00      	nop
  405db4:	4b06      	ldr	r3, [pc, #24]	; (405dd0 <udd_ctrl_interrupt+0x98>)
  405db6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  405db8:	f003 0308 	and.w	r3, r3, #8
  405dbc:	2b00      	cmp	r3, #0
  405dbe:	d1f9      	bne.n	405db4 <udd_ctrl_interrupt+0x7c>
		return true;
  405dc0:	2301      	movs	r3, #1
  405dc2:	e000      	b.n	405dc6 <udd_ctrl_interrupt+0x8e>
	}
	return false;
  405dc4:	2300      	movs	r3, #0
}
  405dc6:	4618      	mov	r0, r3
  405dc8:	3708      	adds	r7, #8
  405dca:	46bd      	mov	sp, r7
  405dcc:	bd80      	pop	{r7, pc}
  405dce:	bf00      	nop
  405dd0:	40084000 	.word	0x40084000
  405dd4:	00405661 	.word	0x00405661
  405dd8:	00405821 	.word	0x00405821
  405ddc:	00405a19 	.word	0x00405a19

00405de0 <udd_ep_job_table_kill>:
	}
}


static void udd_ep_job_table_kill(void)
{
  405de0:	b580      	push	{r7, lr}
  405de2:	b082      	sub	sp, #8
  405de4:	af00      	add	r7, sp, #0
	uint8_t i;

	// For each endpoint, kill job
	for (i = 0; i < USB_DEVICE_MAX_EP; i++) {
  405de6:	2300      	movs	r3, #0
  405de8:	71fb      	strb	r3, [r7, #7]
  405dea:	e010      	b.n	405e0e <udd_ep_job_table_kill+0x2e>
		udd_ep_finish_job(&udd_ep_job[i], UDD_EP_TRANSFER_ABORT, i + 1);
  405dec:	79fa      	ldrb	r2, [r7, #7]
  405dee:	4613      	mov	r3, r2
  405df0:	009b      	lsls	r3, r3, #2
  405df2:	4413      	add	r3, r2
  405df4:	009b      	lsls	r3, r3, #2
  405df6:	4a09      	ldr	r2, [pc, #36]	; (405e1c <udd_ep_job_table_kill+0x3c>)
  405df8:	1898      	adds	r0, r3, r2
  405dfa:	79fb      	ldrb	r3, [r7, #7]
  405dfc:	3301      	adds	r3, #1
  405dfe:	b2db      	uxtb	r3, r3
  405e00:	461a      	mov	r2, r3
  405e02:	2101      	movs	r1, #1
  405e04:	4b06      	ldr	r3, [pc, #24]	; (405e20 <udd_ep_job_table_kill+0x40>)
  405e06:	4798      	blx	r3
	for (i = 0; i < USB_DEVICE_MAX_EP; i++) {
  405e08:	79fb      	ldrb	r3, [r7, #7]
  405e0a:	3301      	adds	r3, #1
  405e0c:	71fb      	strb	r3, [r7, #7]
  405e0e:	79fb      	ldrb	r3, [r7, #7]
  405e10:	2b01      	cmp	r3, #1
  405e12:	d9eb      	bls.n	405dec <udd_ep_job_table_kill+0xc>
	}
}
  405e14:	bf00      	nop
  405e16:	3708      	adds	r7, #8
  405e18:	46bd      	mov	sp, r7
  405e1a:	bd80      	pop	{r7, pc}
  405e1c:	20006c48 	.word	0x20006c48
  405e20:	00405e61 	.word	0x00405e61

00405e24 <udd_ep_abort_job>:


static void udd_ep_abort_job(udd_ep_id_t ep)
{
  405e24:	b580      	push	{r7, lr}
  405e26:	b082      	sub	sp, #8
  405e28:	af00      	add	r7, sp, #0
  405e2a:	4603      	mov	r3, r0
  405e2c:	71fb      	strb	r3, [r7, #7]
	ep &= USB_EP_ADDR_MASK;
  405e2e:	79fb      	ldrb	r3, [r7, #7]
  405e30:	f003 030f 	and.w	r3, r3, #15
  405e34:	71fb      	strb	r3, [r7, #7]

	// Abort job on endpoint
	udd_ep_finish_job(&udd_ep_job[ep - 1], UDD_EP_TRANSFER_ABORT, ep);
  405e36:	79fb      	ldrb	r3, [r7, #7]
  405e38:	1e5a      	subs	r2, r3, #1
  405e3a:	4613      	mov	r3, r2
  405e3c:	009b      	lsls	r3, r3, #2
  405e3e:	4413      	add	r3, r2
  405e40:	009b      	lsls	r3, r3, #2
  405e42:	4a05      	ldr	r2, [pc, #20]	; (405e58 <udd_ep_abort_job+0x34>)
  405e44:	4413      	add	r3, r2
  405e46:	79fa      	ldrb	r2, [r7, #7]
  405e48:	2101      	movs	r1, #1
  405e4a:	4618      	mov	r0, r3
  405e4c:	4b03      	ldr	r3, [pc, #12]	; (405e5c <udd_ep_abort_job+0x38>)
  405e4e:	4798      	blx	r3
}
  405e50:	bf00      	nop
  405e52:	3708      	adds	r7, #8
  405e54:	46bd      	mov	sp, r7
  405e56:	bd80      	pop	{r7, pc}
  405e58:	20006c48 	.word	0x20006c48
  405e5c:	00405e61 	.word	0x00405e61

00405e60 <udd_ep_finish_job>:


static void udd_ep_finish_job(udd_ep_job_t * ptr_job, int status,
		uint8_t ep_num)
{
  405e60:	b580      	push	{r7, lr}
  405e62:	b084      	sub	sp, #16
  405e64:	af00      	add	r7, sp, #0
  405e66:	60f8      	str	r0, [r7, #12]
  405e68:	60b9      	str	r1, [r7, #8]
  405e6a:	4613      	mov	r3, r2
  405e6c:	71fb      	strb	r3, [r7, #7]
	if (ptr_job->busy == false) {
  405e6e:	68fb      	ldr	r3, [r7, #12]
  405e70:	7c5b      	ldrb	r3, [r3, #17]
  405e72:	f003 0310 	and.w	r3, r3, #16
  405e76:	b2db      	uxtb	r3, r3
  405e78:	2b00      	cmp	r3, #0
  405e7a:	d023      	beq.n	405ec4 <udd_ep_finish_job+0x64>
		return; // No on-going job
	}
	ptr_job->busy = false;
  405e7c:	68fa      	ldr	r2, [r7, #12]
  405e7e:	7c53      	ldrb	r3, [r2, #17]
  405e80:	f36f 1304 	bfc	r3, #4, #1
  405e84:	7453      	strb	r3, [r2, #17]
	if (NULL == ptr_job->call_trans) {
  405e86:	68fb      	ldr	r3, [r7, #12]
  405e88:	681b      	ldr	r3, [r3, #0]
  405e8a:	2b00      	cmp	r3, #0
  405e8c:	d01c      	beq.n	405ec8 <udd_ep_finish_job+0x68>
		return; // No callback linked to job
	}
	if (Is_udd_endpoint_type_in(ep_num)) {
  405e8e:	4a10      	ldr	r2, [pc, #64]	; (405ed0 <udd_ep_finish_job+0x70>)
  405e90:	79fb      	ldrb	r3, [r7, #7]
  405e92:	330c      	adds	r3, #12
  405e94:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  405e98:	f403 6380 	and.w	r3, r3, #1024	; 0x400
  405e9c:	2b00      	cmp	r3, #0
  405e9e:	d003      	beq.n	405ea8 <udd_ep_finish_job+0x48>
		ep_num |= USB_EP_DIR_IN;
  405ea0:	79fb      	ldrb	r3, [r7, #7]
  405ea2:	f063 037f 	orn	r3, r3, #127	; 0x7f
  405ea6:	71fb      	strb	r3, [r7, #7]
	}
	ptr_job->call_trans((status == UDD_EP_TRANSFER_ABORT) ?
  405ea8:	68fb      	ldr	r3, [r7, #12]
  405eaa:	681b      	ldr	r3, [r3, #0]
  405eac:	68ba      	ldr	r2, [r7, #8]
  405eae:	2a01      	cmp	r2, #1
  405eb0:	bf0c      	ite	eq
  405eb2:	2201      	moveq	r2, #1
  405eb4:	2200      	movne	r2, #0
  405eb6:	b2d2      	uxtb	r2, r2
  405eb8:	4610      	mov	r0, r2
  405eba:	68fa      	ldr	r2, [r7, #12]
  405ebc:	6891      	ldr	r1, [r2, #8]
  405ebe:	79fa      	ldrb	r2, [r7, #7]
  405ec0:	4798      	blx	r3
  405ec2:	e002      	b.n	405eca <udd_ep_finish_job+0x6a>
		return; // No on-going job
  405ec4:	bf00      	nop
  405ec6:	e000      	b.n	405eca <udd_ep_finish_job+0x6a>
		return; // No callback linked to job
  405ec8:	bf00      	nop
		UDD_EP_TRANSFER_ABORT : UDD_EP_TRANSFER_OK, ptr_job->buf_size, ep_num);
}
  405eca:	3710      	adds	r7, #16
  405ecc:	46bd      	mov	sp, r7
  405ece:	bd80      	pop	{r7, pc}
  405ed0:	40084000 	.word	0x40084000

00405ed4 <udd_ep_ack_out_received>:


static void udd_ep_ack_out_received(udd_ep_id_t ep)
{
  405ed4:	b480      	push	{r7}
  405ed6:	b087      	sub	sp, #28
  405ed8:	af00      	add	r7, sp, #0
  405eda:	4603      	mov	r3, r0
  405edc:	71fb      	strb	r3, [r7, #7]
	bool bank0_received, bank1_received;
	udd_ep_job_t *ptr_job = &udd_ep_job[ep - 1];
  405ede:	79fb      	ldrb	r3, [r7, #7]
  405ee0:	1e5a      	subs	r2, r3, #1
  405ee2:	4613      	mov	r3, r2
  405ee4:	009b      	lsls	r3, r3, #2
  405ee6:	4413      	add	r3, r2
  405ee8:	009b      	lsls	r3, r3, #2
  405eea:	4a45      	ldr	r2, [pc, #276]	; (406000 <udd_ep_ack_out_received+0x12c>)
  405eec:	4413      	add	r3, r2
  405eee:	617b      	str	r3, [r7, #20]

	bank0_received = Is_udd_bank0_received(ep);
  405ef0:	4a44      	ldr	r2, [pc, #272]	; (406004 <udd_ep_ack_out_received+0x130>)
  405ef2:	79fb      	ldrb	r3, [r7, #7]
  405ef4:	330c      	adds	r3, #12
  405ef6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  405efa:	f003 0302 	and.w	r3, r3, #2
  405efe:	2b00      	cmp	r3, #0
  405f00:	bf14      	ite	ne
  405f02:	2301      	movne	r3, #1
  405f04:	2300      	moveq	r3, #0
  405f06:	74fb      	strb	r3, [r7, #19]
	bank1_received = Is_udd_bank1_received(ep);
  405f08:	4a3e      	ldr	r2, [pc, #248]	; (406004 <udd_ep_ack_out_received+0x130>)
  405f0a:	79fb      	ldrb	r3, [r7, #7]
  405f0c:	330c      	adds	r3, #12
  405f0e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  405f12:	f003 0340 	and.w	r3, r3, #64	; 0x40
  405f16:	2b00      	cmp	r3, #0
  405f18:	bf14      	ite	ne
  405f1a:	2301      	movne	r3, #1
  405f1c:	2300      	moveq	r3, #0
  405f1e:	74bb      	strb	r3, [r7, #18]

	if (bank0_received && bank1_received) {
  405f20:	7cfb      	ldrb	r3, [r7, #19]
  405f22:	2b00      	cmp	r3, #0
  405f24:	d002      	beq.n	405f2c <udd_ep_ack_out_received+0x58>
  405f26:	7cbb      	ldrb	r3, [r7, #18]
  405f28:	2b00      	cmp	r3, #0
  405f2a:	d10e      	bne.n	405f4a <udd_ep_ack_out_received+0x76>
		// The only way is to use ptr_job->bank
	} else if (bank0_received) {
  405f2c:	7cfb      	ldrb	r3, [r7, #19]
  405f2e:	2b00      	cmp	r3, #0
  405f30:	d005      	beq.n	405f3e <udd_ep_ack_out_received+0x6a>
		// Must be bank0
		ptr_job->bank = 0;
  405f32:	697a      	ldr	r2, [r7, #20]
  405f34:	7c53      	ldrb	r3, [r2, #17]
  405f36:	f36f 0383 	bfc	r3, #2, #2
  405f3a:	7453      	strb	r3, [r2, #17]
  405f3c:	e005      	b.n	405f4a <udd_ep_ack_out_received+0x76>
	} else {
		// Must be bank1
		ptr_job->bank = 1;
  405f3e:	697a      	ldr	r2, [r7, #20]
  405f40:	7c53      	ldrb	r3, [r2, #17]
  405f42:	2101      	movs	r1, #1
  405f44:	f361 0383 	bfi	r3, r1, #2, #2
  405f48:	7453      	strb	r3, [r2, #17]
	}
	if (ptr_job->bank == 0) {
  405f4a:	697b      	ldr	r3, [r7, #20]
  405f4c:	7c5b      	ldrb	r3, [r3, #17]
  405f4e:	f003 030c 	and.w	r3, r3, #12
  405f52:	b2db      	uxtb	r3, r3
  405f54:	2b00      	cmp	r3, #0
  405f56:	d12a      	bne.n	405fae <udd_ep_ack_out_received+0xda>
		udd_ack_bank0_received(ep);
  405f58:	4a2a      	ldr	r2, [pc, #168]	; (406004 <udd_ep_ack_out_received+0x130>)
  405f5a:	79fb      	ldrb	r3, [r7, #7]
  405f5c:	330c      	adds	r3, #12
  405f5e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  405f62:	60fb      	str	r3, [r7, #12]
  405f64:	68fb      	ldr	r3, [r7, #12]
  405f66:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  405f6a:	60fb      	str	r3, [r7, #12]
  405f6c:	68fb      	ldr	r3, [r7, #12]
  405f6e:	f023 0302 	bic.w	r3, r3, #2
  405f72:	60fb      	str	r3, [r7, #12]
  405f74:	4923      	ldr	r1, [pc, #140]	; (406004 <udd_ep_ack_out_received+0x130>)
  405f76:	79fb      	ldrb	r3, [r7, #7]
  405f78:	68fa      	ldr	r2, [r7, #12]
  405f7a:	330c      	adds	r3, #12
  405f7c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  405f80:	bf00      	nop
  405f82:	4a20      	ldr	r2, [pc, #128]	; (406004 <udd_ep_ack_out_received+0x130>)
  405f84:	79fb      	ldrb	r3, [r7, #7]
  405f86:	330c      	adds	r3, #12
  405f88:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  405f8c:	f003 0302 	and.w	r3, r3, #2
  405f90:	2b00      	cmp	r3, #0
  405f92:	d1f6      	bne.n	405f82 <udd_ep_ack_out_received+0xae>
		if (udd_get_endpoint_bank_max_nbr(ep) > 1) {
  405f94:	79fb      	ldrb	r3, [r7, #7]
  405f96:	2b00      	cmp	r3, #0
  405f98:	d02c      	beq.n	405ff4 <udd_ep_ack_out_received+0x120>
  405f9a:	79fb      	ldrb	r3, [r7, #7]
  405f9c:	2b03      	cmp	r3, #3
  405f9e:	d029      	beq.n	405ff4 <udd_ep_ack_out_received+0x120>
			ptr_job->bank = 1;
  405fa0:	697a      	ldr	r2, [r7, #20]
  405fa2:	7c53      	ldrb	r3, [r2, #17]
  405fa4:	2101      	movs	r1, #1
  405fa6:	f361 0383 	bfi	r3, r1, #2, #2
  405faa:	7453      	strb	r3, [r2, #17]
		}
	} else {
		udd_ack_bank1_received(ep);
		ptr_job->bank = 0;
	}
}
  405fac:	e022      	b.n	405ff4 <udd_ep_ack_out_received+0x120>
		udd_ack_bank1_received(ep);
  405fae:	4a15      	ldr	r2, [pc, #84]	; (406004 <udd_ep_ack_out_received+0x130>)
  405fb0:	79fb      	ldrb	r3, [r7, #7]
  405fb2:	330c      	adds	r3, #12
  405fb4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  405fb8:	60bb      	str	r3, [r7, #8]
  405fba:	68bb      	ldr	r3, [r7, #8]
  405fbc:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  405fc0:	60bb      	str	r3, [r7, #8]
  405fc2:	68bb      	ldr	r3, [r7, #8]
  405fc4:	f023 0340 	bic.w	r3, r3, #64	; 0x40
  405fc8:	60bb      	str	r3, [r7, #8]
  405fca:	490e      	ldr	r1, [pc, #56]	; (406004 <udd_ep_ack_out_received+0x130>)
  405fcc:	79fb      	ldrb	r3, [r7, #7]
  405fce:	68ba      	ldr	r2, [r7, #8]
  405fd0:	330c      	adds	r3, #12
  405fd2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  405fd6:	bf00      	nop
  405fd8:	4a0a      	ldr	r2, [pc, #40]	; (406004 <udd_ep_ack_out_received+0x130>)
  405fda:	79fb      	ldrb	r3, [r7, #7]
  405fdc:	330c      	adds	r3, #12
  405fde:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  405fe2:	f003 0340 	and.w	r3, r3, #64	; 0x40
  405fe6:	2b00      	cmp	r3, #0
  405fe8:	d1f6      	bne.n	405fd8 <udd_ep_ack_out_received+0x104>
		ptr_job->bank = 0;
  405fea:	697a      	ldr	r2, [r7, #20]
  405fec:	7c53      	ldrb	r3, [r2, #17]
  405fee:	f36f 0383 	bfc	r3, #2, #2
  405ff2:	7453      	strb	r3, [r2, #17]
}
  405ff4:	bf00      	nop
  405ff6:	371c      	adds	r7, #28
  405ff8:	46bd      	mov	sp, r7
  405ffa:	f85d 7b04 	ldr.w	r7, [sp], #4
  405ffe:	4770      	bx	lr
  406000:	20006c48 	.word	0x20006c48
  406004:	40084000 	.word	0x40084000

00406008 <udd_ep_write_fifo>:


static bool udd_ep_write_fifo(udd_ep_id_t ep)
{
  406008:	b480      	push	{r7}
  40600a:	b089      	sub	sp, #36	; 0x24
  40600c:	af00      	add	r7, sp, #0
  40600e:	4603      	mov	r3, r0
  406010:	71fb      	strb	r3, [r7, #7]
	udd_ep_job_t *ptr_job = &udd_ep_job[ep - 1];
  406012:	79fb      	ldrb	r3, [r7, #7]
  406014:	1e5a      	subs	r2, r3, #1
  406016:	4613      	mov	r3, r2
  406018:	009b      	lsls	r3, r3, #2
  40601a:	4413      	add	r3, r2
  40601c:	009b      	lsls	r3, r3, #2
  40601e:	4a55      	ldr	r2, [pc, #340]	; (406174 <udd_ep_write_fifo+0x16c>)
  406020:	4413      	add	r3, r2
  406022:	613b      	str	r3, [r7, #16]
	uint8_t *ptr_src = &ptr_job->buf[ptr_job->buf_cnt];
  406024:	693b      	ldr	r3, [r7, #16]
  406026:	685a      	ldr	r2, [r3, #4]
  406028:	693b      	ldr	r3, [r7, #16]
  40602a:	68db      	ldr	r3, [r3, #12]
  40602c:	4413      	add	r3, r2
  40602e:	61fb      	str	r3, [r7, #28]
	uint32_t nb_remain = ptr_job->buf_size - ptr_job->buf_cnt;
  406030:	693b      	ldr	r3, [r7, #16]
  406032:	689a      	ldr	r2, [r3, #8]
  406034:	693b      	ldr	r3, [r7, #16]
  406036:	68db      	ldr	r3, [r3, #12]
  406038:	1ad3      	subs	r3, r2, r3
  40603a:	60fb      	str	r3, [r7, #12]
	uint32_t pkt_size = ptr_job->size;
  40603c:	693b      	ldr	r3, [r7, #16]
  40603e:	8a1b      	ldrh	r3, [r3, #16]
  406040:	f3c3 0309 	ubfx	r3, r3, #0, #10
  406044:	b29b      	uxth	r3, r3
  406046:	61bb      	str	r3, [r7, #24]
	bool is_short_pkt = false;
  406048:	2300      	movs	r3, #0
  40604a:	75fb      	strb	r3, [r7, #23]

	// Packet size
	if (nb_remain < pkt_size) {
  40604c:	68fa      	ldr	r2, [r7, #12]
  40604e:	69bb      	ldr	r3, [r7, #24]
  406050:	429a      	cmp	r2, r3
  406052:	d203      	bcs.n	40605c <udd_ep_write_fifo+0x54>
		pkt_size = nb_remain;
  406054:	68fb      	ldr	r3, [r7, #12]
  406056:	61bb      	str	r3, [r7, #24]
		is_short_pkt = true;
  406058:	2301      	movs	r3, #1
  40605a:	75fb      	strb	r3, [r7, #23]
	}

	// Modify job information
	ptr_job->buf_cnt += pkt_size;
  40605c:	693b      	ldr	r3, [r7, #16]
  40605e:	68da      	ldr	r2, [r3, #12]
  406060:	69bb      	ldr	r3, [r7, #24]
  406062:	441a      	add	r2, r3
  406064:	693b      	ldr	r3, [r7, #16]
  406066:	60da      	str	r2, [r3, #12]

	// Speed block data transfer to FIFO (DPRAM)
	for (; pkt_size >= 8; pkt_size -= 8) {
  406068:	e05a      	b.n	406120 <udd_ep_write_fifo+0x118>
		udd_endpoint_fifo_write(ep, *ptr_src++);
  40606a:	4843      	ldr	r0, [pc, #268]	; (406178 <udd_ep_write_fifo+0x170>)
  40606c:	79fa      	ldrb	r2, [r7, #7]
  40606e:	69fb      	ldr	r3, [r7, #28]
  406070:	1c59      	adds	r1, r3, #1
  406072:	61f9      	str	r1, [r7, #28]
  406074:	781b      	ldrb	r3, [r3, #0]
  406076:	4619      	mov	r1, r3
  406078:	f102 0314 	add.w	r3, r2, #20
  40607c:	f840 1023 	str.w	r1, [r0, r3, lsl #2]
		udd_endpoint_fifo_write(ep, *ptr_src++);
  406080:	483d      	ldr	r0, [pc, #244]	; (406178 <udd_ep_write_fifo+0x170>)
  406082:	79fa      	ldrb	r2, [r7, #7]
  406084:	69fb      	ldr	r3, [r7, #28]
  406086:	1c59      	adds	r1, r3, #1
  406088:	61f9      	str	r1, [r7, #28]
  40608a:	781b      	ldrb	r3, [r3, #0]
  40608c:	4619      	mov	r1, r3
  40608e:	f102 0314 	add.w	r3, r2, #20
  406092:	f840 1023 	str.w	r1, [r0, r3, lsl #2]
		udd_endpoint_fifo_write(ep, *ptr_src++);
  406096:	4838      	ldr	r0, [pc, #224]	; (406178 <udd_ep_write_fifo+0x170>)
  406098:	79fa      	ldrb	r2, [r7, #7]
  40609a:	69fb      	ldr	r3, [r7, #28]
  40609c:	1c59      	adds	r1, r3, #1
  40609e:	61f9      	str	r1, [r7, #28]
  4060a0:	781b      	ldrb	r3, [r3, #0]
  4060a2:	4619      	mov	r1, r3
  4060a4:	f102 0314 	add.w	r3, r2, #20
  4060a8:	f840 1023 	str.w	r1, [r0, r3, lsl #2]
		udd_endpoint_fifo_write(ep, *ptr_src++);
  4060ac:	4832      	ldr	r0, [pc, #200]	; (406178 <udd_ep_write_fifo+0x170>)
  4060ae:	79fa      	ldrb	r2, [r7, #7]
  4060b0:	69fb      	ldr	r3, [r7, #28]
  4060b2:	1c59      	adds	r1, r3, #1
  4060b4:	61f9      	str	r1, [r7, #28]
  4060b6:	781b      	ldrb	r3, [r3, #0]
  4060b8:	4619      	mov	r1, r3
  4060ba:	f102 0314 	add.w	r3, r2, #20
  4060be:	f840 1023 	str.w	r1, [r0, r3, lsl #2]
		udd_endpoint_fifo_write(ep, *ptr_src++);
  4060c2:	482d      	ldr	r0, [pc, #180]	; (406178 <udd_ep_write_fifo+0x170>)
  4060c4:	79fa      	ldrb	r2, [r7, #7]
  4060c6:	69fb      	ldr	r3, [r7, #28]
  4060c8:	1c59      	adds	r1, r3, #1
  4060ca:	61f9      	str	r1, [r7, #28]
  4060cc:	781b      	ldrb	r3, [r3, #0]
  4060ce:	4619      	mov	r1, r3
  4060d0:	f102 0314 	add.w	r3, r2, #20
  4060d4:	f840 1023 	str.w	r1, [r0, r3, lsl #2]
		udd_endpoint_fifo_write(ep, *ptr_src++);
  4060d8:	4827      	ldr	r0, [pc, #156]	; (406178 <udd_ep_write_fifo+0x170>)
  4060da:	79fa      	ldrb	r2, [r7, #7]
  4060dc:	69fb      	ldr	r3, [r7, #28]
  4060de:	1c59      	adds	r1, r3, #1
  4060e0:	61f9      	str	r1, [r7, #28]
  4060e2:	781b      	ldrb	r3, [r3, #0]
  4060e4:	4619      	mov	r1, r3
  4060e6:	f102 0314 	add.w	r3, r2, #20
  4060ea:	f840 1023 	str.w	r1, [r0, r3, lsl #2]
		udd_endpoint_fifo_write(ep, *ptr_src++);
  4060ee:	4822      	ldr	r0, [pc, #136]	; (406178 <udd_ep_write_fifo+0x170>)
  4060f0:	79fa      	ldrb	r2, [r7, #7]
  4060f2:	69fb      	ldr	r3, [r7, #28]
  4060f4:	1c59      	adds	r1, r3, #1
  4060f6:	61f9      	str	r1, [r7, #28]
  4060f8:	781b      	ldrb	r3, [r3, #0]
  4060fa:	4619      	mov	r1, r3
  4060fc:	f102 0314 	add.w	r3, r2, #20
  406100:	f840 1023 	str.w	r1, [r0, r3, lsl #2]
		udd_endpoint_fifo_write(ep, *ptr_src++);
  406104:	481c      	ldr	r0, [pc, #112]	; (406178 <udd_ep_write_fifo+0x170>)
  406106:	79fa      	ldrb	r2, [r7, #7]
  406108:	69fb      	ldr	r3, [r7, #28]
  40610a:	1c59      	adds	r1, r3, #1
  40610c:	61f9      	str	r1, [r7, #28]
  40610e:	781b      	ldrb	r3, [r3, #0]
  406110:	4619      	mov	r1, r3
  406112:	f102 0314 	add.w	r3, r2, #20
  406116:	f840 1023 	str.w	r1, [r0, r3, lsl #2]
	for (; pkt_size >= 8; pkt_size -= 8) {
  40611a:	69bb      	ldr	r3, [r7, #24]
  40611c:	3b08      	subs	r3, #8
  40611e:	61bb      	str	r3, [r7, #24]
  406120:	69bb      	ldr	r3, [r7, #24]
  406122:	2b07      	cmp	r3, #7
  406124:	d8a1      	bhi.n	40606a <udd_ep_write_fifo+0x62>
	}
	// Normal speed data transfer to FIFO (DPRAM)
	for (; pkt_size; pkt_size--) {
  406126:	e00d      	b.n	406144 <udd_ep_write_fifo+0x13c>
		udd_endpoint_fifo_write(ep, *ptr_src++);
  406128:	4813      	ldr	r0, [pc, #76]	; (406178 <udd_ep_write_fifo+0x170>)
  40612a:	79fa      	ldrb	r2, [r7, #7]
  40612c:	69fb      	ldr	r3, [r7, #28]
  40612e:	1c59      	adds	r1, r3, #1
  406130:	61f9      	str	r1, [r7, #28]
  406132:	781b      	ldrb	r3, [r3, #0]
  406134:	4619      	mov	r1, r3
  406136:	f102 0314 	add.w	r3, r2, #20
  40613a:	f840 1023 	str.w	r1, [r0, r3, lsl #2]
	for (; pkt_size; pkt_size--) {
  40613e:	69bb      	ldr	r3, [r7, #24]
  406140:	3b01      	subs	r3, #1
  406142:	61bb      	str	r3, [r7, #24]
  406144:	69bb      	ldr	r3, [r7, #24]
  406146:	2b00      	cmp	r3, #0
  406148:	d1ee      	bne.n	406128 <udd_ep_write_fifo+0x120>
	}

	// Add to buffered banks
	ptr_job->bank++;
  40614a:	693b      	ldr	r3, [r7, #16]
  40614c:	7c5b      	ldrb	r3, [r3, #17]
  40614e:	f3c3 0381 	ubfx	r3, r3, #2, #2
  406152:	b2db      	uxtb	r3, r3
  406154:	3301      	adds	r3, #1
  406156:	f003 0303 	and.w	r3, r3, #3
  40615a:	b2d9      	uxtb	r1, r3
  40615c:	693a      	ldr	r2, [r7, #16]
  40615e:	7c53      	ldrb	r3, [r2, #17]
  406160:	f361 0383 	bfi	r3, r1, #2, #2
  406164:	7453      	strb	r3, [r2, #17]
	return is_short_pkt;
  406166:	7dfb      	ldrb	r3, [r7, #23]
}
  406168:	4618      	mov	r0, r3
  40616a:	3724      	adds	r7, #36	; 0x24
  40616c:	46bd      	mov	sp, r7
  40616e:	f85d 7b04 	ldr.w	r7, [sp], #4
  406172:	4770      	bx	lr
  406174:	20006c48 	.word	0x20006c48
  406178:	40084000 	.word	0x40084000

0040617c <udd_ep_in_sent>:


static bool udd_ep_in_sent(udd_ep_id_t ep, bool b_tx)
{
  40617c:	b580      	push	{r7, lr}
  40617e:	b086      	sub	sp, #24
  406180:	af00      	add	r7, sp, #0
  406182:	4603      	mov	r3, r0
  406184:	460a      	mov	r2, r1
  406186:	71fb      	strb	r3, [r7, #7]
  406188:	4613      	mov	r3, r2
  40618a:	71bb      	strb	r3, [r7, #6]
	bool b_shortpacket;
	udd_ep_job_t *ptr_job = &udd_ep_job[ep - 1];
  40618c:	79fb      	ldrb	r3, [r7, #7]
  40618e:	1e5a      	subs	r2, r3, #1
  406190:	4613      	mov	r3, r2
  406192:	009b      	lsls	r3, r3, #2
  406194:	4413      	add	r3, r2
  406196:	009b      	lsls	r3, r3, #2
  406198:	4a36      	ldr	r2, [pc, #216]	; (406274 <udd_ep_in_sent+0xf8>)
  40619a:	4413      	add	r3, r2
  40619c:	617b      	str	r3, [r7, #20]

	// All banks are full
	if (ptr_job->bank >= udd_get_endpoint_bank_max_nbr(ep)) {
  40619e:	697b      	ldr	r3, [r7, #20]
  4061a0:	7c5b      	ldrb	r3, [r3, #17]
  4061a2:	f3c3 0381 	ubfx	r3, r3, #2, #2
  4061a6:	b2db      	uxtb	r3, r3
  4061a8:	461a      	mov	r2, r3
  4061aa:	79fb      	ldrb	r3, [r7, #7]
  4061ac:	2b00      	cmp	r3, #0
  4061ae:	d002      	beq.n	4061b6 <udd_ep_in_sent+0x3a>
  4061b0:	79fb      	ldrb	r3, [r7, #7]
  4061b2:	2b03      	cmp	r3, #3
  4061b4:	d101      	bne.n	4061ba <udd_ep_in_sent+0x3e>
  4061b6:	2301      	movs	r3, #1
  4061b8:	e000      	b.n	4061bc <udd_ep_in_sent+0x40>
  4061ba:	2302      	movs	r3, #2
  4061bc:	429a      	cmp	r2, r3
  4061be:	db01      	blt.n	4061c4 <udd_ep_in_sent+0x48>
		return true; // Data pending
  4061c0:	2301      	movs	r3, #1
  4061c2:	e052      	b.n	40626a <udd_ep_in_sent+0xee>
	}

	// No more data in buffer
	if (ptr_job->buf_cnt >= ptr_job->buf_size && !ptr_job->b_shortpacket) {
  4061c4:	697b      	ldr	r3, [r7, #20]
  4061c6:	68da      	ldr	r2, [r3, #12]
  4061c8:	697b      	ldr	r3, [r7, #20]
  4061ca:	689b      	ldr	r3, [r3, #8]
  4061cc:	429a      	cmp	r2, r3
  4061ce:	d308      	bcc.n	4061e2 <udd_ep_in_sent+0x66>
  4061d0:	697b      	ldr	r3, [r7, #20]
  4061d2:	7c5b      	ldrb	r3, [r3, #17]
  4061d4:	f003 0340 	and.w	r3, r3, #64	; 0x40
  4061d8:	b2db      	uxtb	r3, r3
  4061da:	2b00      	cmp	r3, #0
  4061dc:	d101      	bne.n	4061e2 <udd_ep_in_sent+0x66>
		return false;
  4061de:	2300      	movs	r3, #0
  4061e0:	e043      	b.n	40626a <udd_ep_in_sent+0xee>
	}

	// Fill FIFO
	b_shortpacket = udd_ep_write_fifo(ep);
  4061e2:	79fb      	ldrb	r3, [r7, #7]
  4061e4:	4618      	mov	r0, r3
  4061e6:	4b24      	ldr	r3, [pc, #144]	; (406278 <udd_ep_in_sent+0xfc>)
  4061e8:	4798      	blx	r3
  4061ea:	4603      	mov	r3, r0
  4061ec:	74fb      	strb	r3, [r7, #19]

	// Data is ready to send
	if (b_tx) {
  4061ee:	79bb      	ldrb	r3, [r7, #6]
  4061f0:	2b00      	cmp	r3, #0
  4061f2:	d01d      	beq.n	406230 <udd_ep_in_sent+0xb4>
		udd_set_transmit_ready(ep);
  4061f4:	4a21      	ldr	r2, [pc, #132]	; (40627c <udd_ep_in_sent+0x100>)
  4061f6:	79fb      	ldrb	r3, [r7, #7]
  4061f8:	330c      	adds	r3, #12
  4061fa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  4061fe:	60fb      	str	r3, [r7, #12]
  406200:	68fb      	ldr	r3, [r7, #12]
  406202:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  406206:	60fb      	str	r3, [r7, #12]
  406208:	68fb      	ldr	r3, [r7, #12]
  40620a:	f043 0310 	orr.w	r3, r3, #16
  40620e:	60fb      	str	r3, [r7, #12]
  406210:	491a      	ldr	r1, [pc, #104]	; (40627c <udd_ep_in_sent+0x100>)
  406212:	79fb      	ldrb	r3, [r7, #7]
  406214:	68fa      	ldr	r2, [r7, #12]
  406216:	330c      	adds	r3, #12
  406218:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  40621c:	bf00      	nop
  40621e:	4a17      	ldr	r2, [pc, #92]	; (40627c <udd_ep_in_sent+0x100>)
  406220:	79fb      	ldrb	r3, [r7, #7]
  406222:	330c      	adds	r3, #12
  406224:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  406228:	f003 0310 	and.w	r3, r3, #16
  40622c:	2b10      	cmp	r3, #16
  40622e:	d1f6      	bne.n	40621e <udd_ep_in_sent+0xa2>
	}
	// Short PKT? no need to send it again.
	if (b_shortpacket) {
  406230:	7cfb      	ldrb	r3, [r7, #19]
  406232:	2b00      	cmp	r3, #0
  406234:	d004      	beq.n	406240 <udd_ep_in_sent+0xc4>
		ptr_job->b_shortpacket = false;
  406236:	697a      	ldr	r2, [r7, #20]
  406238:	7c53      	ldrb	r3, [r2, #17]
  40623a:	f36f 1386 	bfc	r3, #6, #1
  40623e:	7453      	strb	r3, [r2, #17]
	}
	// All transfer done, including ZLP, Finish Job
	if ((ptr_job->buf_cnt >= ptr_job->buf_size)
  406240:	697b      	ldr	r3, [r7, #20]
  406242:	68da      	ldr	r2, [r3, #12]
  406244:	697b      	ldr	r3, [r7, #20]
  406246:	689b      	ldr	r3, [r3, #8]
  406248:	429a      	cmp	r2, r3
  40624a:	d30d      	bcc.n	406268 <udd_ep_in_sent+0xec>
			&& (!ptr_job->b_shortpacket)) {
  40624c:	697b      	ldr	r3, [r7, #20]
  40624e:	7c5b      	ldrb	r3, [r3, #17]
  406250:	f003 0340 	and.w	r3, r3, #64	; 0x40
  406254:	b2db      	uxtb	r3, r3
  406256:	2b00      	cmp	r3, #0
  406258:	d106      	bne.n	406268 <udd_ep_in_sent+0xec>
		ptr_job->b_buf_end = true;
  40625a:	697a      	ldr	r2, [r7, #20]
  40625c:	7c53      	ldrb	r3, [r2, #17]
  40625e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  406262:	7453      	strb	r3, [r2, #17]
		return false;
  406264:	2300      	movs	r3, #0
  406266:	e000      	b.n	40626a <udd_ep_in_sent+0xee>
	}
	return true; // Pending
  406268:	2301      	movs	r3, #1
}
  40626a:	4618      	mov	r0, r3
  40626c:	3718      	adds	r7, #24
  40626e:	46bd      	mov	sp, r7
  406270:	bd80      	pop	{r7, pc}
  406272:	bf00      	nop
  406274:	20006c48 	.word	0x20006c48
  406278:	00406009 	.word	0x00406009
  40627c:	40084000 	.word	0x40084000

00406280 <udd_ep_out_received>:


static void udd_ep_out_received(udd_ep_id_t ep)
{
  406280:	b580      	push	{r7, lr}
  406282:	b08a      	sub	sp, #40	; 0x28
  406284:	af00      	add	r7, sp, #0
  406286:	4603      	mov	r3, r0
  406288:	71fb      	strb	r3, [r7, #7]
	udd_ep_job_t *ptr_job = &udd_ep_job[ep - 1];
  40628a:	79fb      	ldrb	r3, [r7, #7]
  40628c:	1e5a      	subs	r2, r3, #1
  40628e:	4613      	mov	r3, r2
  406290:	009b      	lsls	r3, r3, #2
  406292:	4413      	add	r3, r2
  406294:	009b      	lsls	r3, r3, #2
  406296:	4a3a      	ldr	r2, [pc, #232]	; (406380 <udd_ep_out_received+0x100>)
  406298:	4413      	add	r3, r2
  40629a:	617b      	str	r3, [r7, #20]
	uint32_t nb_data = 0, i;
  40629c:	2300      	movs	r3, #0
  40629e:	627b      	str	r3, [r7, #36]	; 0x24
	uint32_t nb_remain = ptr_job->buf_size - ptr_job->buf_cnt;
  4062a0:	697b      	ldr	r3, [r7, #20]
  4062a2:	689a      	ldr	r2, [r3, #8]
  4062a4:	697b      	ldr	r3, [r7, #20]
  4062a6:	68db      	ldr	r3, [r3, #12]
  4062a8:	1ad3      	subs	r3, r2, r3
  4062aa:	613b      	str	r3, [r7, #16]
	uint32_t pkt_size = ptr_job->size;
  4062ac:	697b      	ldr	r3, [r7, #20]
  4062ae:	8a1b      	ldrh	r3, [r3, #16]
  4062b0:	f3c3 0309 	ubfx	r3, r3, #0, #10
  4062b4:	b29b      	uxth	r3, r3
  4062b6:	60fb      	str	r3, [r7, #12]
	uint8_t *ptr_dst = &ptr_job->buf[ptr_job->buf_cnt];
  4062b8:	697b      	ldr	r3, [r7, #20]
  4062ba:	685a      	ldr	r2, [r3, #4]
  4062bc:	697b      	ldr	r3, [r7, #20]
  4062be:	68db      	ldr	r3, [r3, #12]
  4062c0:	4413      	add	r3, r2
  4062c2:	61fb      	str	r3, [r7, #28]
	bool b_full = false, b_short;
  4062c4:	2300      	movs	r3, #0
  4062c6:	76fb      	strb	r3, [r7, #27]

	// Read byte count
	nb_data = udd_byte_count(ep);
  4062c8:	4a2e      	ldr	r2, [pc, #184]	; (406384 <udd_ep_out_received+0x104>)
  4062ca:	79fb      	ldrb	r3, [r7, #7]
  4062cc:	330c      	adds	r3, #12
  4062ce:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  4062d2:	0c1b      	lsrs	r3, r3, #16
  4062d4:	f3c3 030a 	ubfx	r3, r3, #0, #11
  4062d8:	627b      	str	r3, [r7, #36]	; 0x24
	b_short = (nb_data < pkt_size);
  4062da:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  4062dc:	68fb      	ldr	r3, [r7, #12]
  4062de:	429a      	cmp	r2, r3
  4062e0:	bf34      	ite	cc
  4062e2:	2301      	movcc	r3, #1
  4062e4:	2300      	movcs	r3, #0
  4062e6:	72fb      	strb	r3, [r7, #11]

	// Copy data if there is
	if (nb_data > 0) {
  4062e8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4062ea:	2b00      	cmp	r3, #0
  4062ec:	d021      	beq.n	406332 <udd_ep_out_received+0xb2>
		if (nb_data >= nb_remain) {
  4062ee:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  4062f0:	693b      	ldr	r3, [r7, #16]
  4062f2:	429a      	cmp	r2, r3
  4062f4:	d303      	bcc.n	4062fe <udd_ep_out_received+0x7e>
			nb_data = nb_remain;
  4062f6:	693b      	ldr	r3, [r7, #16]
  4062f8:	627b      	str	r3, [r7, #36]	; 0x24
			b_full = true;
  4062fa:	2301      	movs	r3, #1
  4062fc:	76fb      	strb	r3, [r7, #27]
		}
		// Modify job information
		ptr_job->buf_cnt += nb_data;
  4062fe:	697b      	ldr	r3, [r7, #20]
  406300:	68da      	ldr	r2, [r3, #12]
  406302:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  406304:	441a      	add	r2, r3
  406306:	697b      	ldr	r3, [r7, #20]
  406308:	60da      	str	r2, [r3, #12]

		// Copy FIFO (DPRAM) to buffer
		for (i = 0; i < nb_data; i++) {
  40630a:	2300      	movs	r3, #0
  40630c:	623b      	str	r3, [r7, #32]
  40630e:	e00c      	b.n	40632a <udd_ep_out_received+0xaa>
			*ptr_dst++ = udd_endpoint_fifo_read(ep);
  406310:	69fb      	ldr	r3, [r7, #28]
  406312:	1c5a      	adds	r2, r3, #1
  406314:	61fa      	str	r2, [r7, #28]
  406316:	491b      	ldr	r1, [pc, #108]	; (406384 <udd_ep_out_received+0x104>)
  406318:	79fa      	ldrb	r2, [r7, #7]
  40631a:	3214      	adds	r2, #20
  40631c:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
  406320:	b2d2      	uxtb	r2, r2
  406322:	701a      	strb	r2, [r3, #0]
		for (i = 0; i < nb_data; i++) {
  406324:	6a3b      	ldr	r3, [r7, #32]
  406326:	3301      	adds	r3, #1
  406328:	623b      	str	r3, [r7, #32]
  40632a:	6a3a      	ldr	r2, [r7, #32]
  40632c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40632e:	429a      	cmp	r2, r3
  406330:	d3ee      	bcc.n	406310 <udd_ep_out_received+0x90>
		}
	}
	// Clear FIFO Status
	udd_ep_ack_out_received(ep);
  406332:	79fb      	ldrb	r3, [r7, #7]
  406334:	4618      	mov	r0, r3
  406336:	4b14      	ldr	r3, [pc, #80]	; (406388 <udd_ep_out_received+0x108>)
  406338:	4798      	blx	r3
	// Finish job on error or short packet
	if ((b_full || b_short) &&
  40633a:	7efb      	ldrb	r3, [r7, #27]
  40633c:	2b00      	cmp	r3, #0
  40633e:	d102      	bne.n	406346 <udd_ep_out_received+0xc6>
  406340:	7afb      	ldrb	r3, [r7, #11]
  406342:	2b00      	cmp	r3, #0
  406344:	d018      	beq.n	406378 <udd_ep_out_received+0xf8>
			!Is_udd_endpoint_stall_requested(ep)) {
  406346:	4a0f      	ldr	r2, [pc, #60]	; (406384 <udd_ep_out_received+0x104>)
  406348:	79fb      	ldrb	r3, [r7, #7]
  40634a:	330c      	adds	r3, #12
  40634c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  406350:	f003 0320 	and.w	r3, r3, #32
	if ((b_full || b_short) &&
  406354:	2b00      	cmp	r3, #0
  406356:	d10f      	bne.n	406378 <udd_ep_out_received+0xf8>
		udd_disable_endpoint_interrupt(ep);
  406358:	4a0a      	ldr	r2, [pc, #40]	; (406384 <udd_ep_out_received+0x104>)
  40635a:	79fb      	ldrb	r3, [r7, #7]
  40635c:	2101      	movs	r1, #1
  40635e:	fa01 f303 	lsl.w	r3, r1, r3
  406362:	6153      	str	r3, [r2, #20]
		ptr_job->buf_size = ptr_job->buf_cnt; // buf_size is passed to callback as XFR count
  406364:	697b      	ldr	r3, [r7, #20]
  406366:	68da      	ldr	r2, [r3, #12]
  406368:	697b      	ldr	r3, [r7, #20]
  40636a:	609a      	str	r2, [r3, #8]
		udd_ep_finish_job(ptr_job, UDD_EP_TRANSFER_OK, ep);
  40636c:	79fb      	ldrb	r3, [r7, #7]
  40636e:	461a      	mov	r2, r3
  406370:	2100      	movs	r1, #0
  406372:	6978      	ldr	r0, [r7, #20]
  406374:	4b05      	ldr	r3, [pc, #20]	; (40638c <udd_ep_out_received+0x10c>)
  406376:	4798      	blx	r3
	}
}
  406378:	bf00      	nop
  40637a:	3728      	adds	r7, #40	; 0x28
  40637c:	46bd      	mov	sp, r7
  40637e:	bd80      	pop	{r7, pc}
  406380:	20006c48 	.word	0x20006c48
  406384:	40084000 	.word	0x40084000
  406388:	00405ed5 	.word	0x00405ed5
  40638c:	00405e61 	.word	0x00405e61

00406390 <udd_ep_interrupt>:


static bool udd_ep_interrupt(void)
{
  406390:	b580      	push	{r7, lr}
  406392:	b08e      	sub	sp, #56	; 0x38
  406394:	af00      	add	r7, sp, #0
	udd_ep_id_t ep;
	udd_ep_job_t *ptr_job;

	// For each endpoint different of control endpoint (0)
	for (ep = 1; ep <= USB_DEVICE_MAX_EP; ep++) {
  406396:	2301      	movs	r3, #1
  406398:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
  40639c:	e260      	b.n	406860 <udd_ep_interrupt+0x4d0>
		// Check RXRDY and TXEMPTY event for none DMA endpoints
		if (!Is_udd_endpoint_interrupt_enabled(ep)) {
  40639e:	4b9e      	ldr	r3, [pc, #632]	; (406618 <udd_ep_interrupt+0x288>)
  4063a0:	699a      	ldr	r2, [r3, #24]
  4063a2:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  4063a6:	2101      	movs	r1, #1
  4063a8:	fa01 f303 	lsl.w	r3, r1, r3
  4063ac:	4013      	ands	r3, r2
  4063ae:	2b00      	cmp	r3, #0
  4063b0:	f000 8250 	beq.w	406854 <udd_ep_interrupt+0x4c4>
			continue;
		}

		// Get job corresponding at endpoint
		ptr_job = &udd_ep_job[ep - 1];
  4063b4:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  4063b8:	1e5a      	subs	r2, r3, #1
  4063ba:	4613      	mov	r3, r2
  4063bc:	009b      	lsls	r3, r3, #2
  4063be:	4413      	add	r3, r2
  4063c0:	009b      	lsls	r3, r3, #2
  4063c2:	4a96      	ldr	r2, [pc, #600]	; (40661c <udd_ep_interrupt+0x28c>)
  4063c4:	4413      	add	r3, r2
  4063c6:	633b      	str	r3, [r7, #48]	; 0x30

		// RXOUT: Full packet received
		if (Is_udd_any_bank_received(ep)) {
  4063c8:	4a93      	ldr	r2, [pc, #588]	; (406618 <udd_ep_interrupt+0x288>)
  4063ca:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  4063ce:	330c      	adds	r3, #12
  4063d0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  4063d4:	f003 0342 	and.w	r3, r3, #66	; 0x42
  4063d8:	2b00      	cmp	r3, #0
  4063da:	d006      	beq.n	4063ea <udd_ep_interrupt+0x5a>
			udd_ep_out_received(ep);
  4063dc:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  4063e0:	4618      	mov	r0, r3
  4063e2:	4b8f      	ldr	r3, [pc, #572]	; (406620 <udd_ep_interrupt+0x290>)
  4063e4:	4798      	blx	r3
			return true;
  4063e6:	2301      	movs	r3, #1
  4063e8:	e240      	b.n	40686c <udd_ep_interrupt+0x4dc>
		}
		// TXIN: packet sent
		if (Is_udd_in_sent(ep)) {
  4063ea:	4a8b      	ldr	r2, [pc, #556]	; (406618 <udd_ep_interrupt+0x288>)
  4063ec:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  4063f0:	330c      	adds	r3, #12
  4063f2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  4063f6:	f003 0301 	and.w	r3, r3, #1
  4063fa:	2b00      	cmp	r3, #0
  4063fc:	f000 81ec 	beq.w	4067d8 <udd_ep_interrupt+0x448>

			ptr_job->bank--;
  406400:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  406402:	7c5b      	ldrb	r3, [r3, #17]
  406404:	f3c3 0381 	ubfx	r3, r3, #2, #2
  406408:	b2db      	uxtb	r3, r3
  40640a:	3303      	adds	r3, #3
  40640c:	f003 0303 	and.w	r3, r3, #3
  406410:	b2d9      	uxtb	r1, r3
  406412:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  406414:	7c53      	ldrb	r3, [r2, #17]
  406416:	f361 0383 	bfi	r3, r1, #2, #2
  40641a:	7453      	strb	r3, [r2, #17]
			// Stall when all banks free
			if (ptr_job->b_stall_requested) {
  40641c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  40641e:	7c5b      	ldrb	r3, [r3, #17]
  406420:	f003 0320 	and.w	r3, r3, #32
  406424:	b2db      	uxtb	r3, r3
  406426:	2b00      	cmp	r3, #0
  406428:	f000 8093 	beq.w	406552 <udd_ep_interrupt+0x1c2>
				if (ptr_job->bank) {
  40642c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  40642e:	7c5b      	ldrb	r3, [r3, #17]
  406430:	f003 030c 	and.w	r3, r3, #12
  406434:	b2db      	uxtb	r3, r3
  406436:	2b00      	cmp	r3, #0
  406438:	d042      	beq.n	4064c0 <udd_ep_interrupt+0x130>
					// Send remaining
					udd_set_transmit_ready(ep);
  40643a:	4a77      	ldr	r2, [pc, #476]	; (406618 <udd_ep_interrupt+0x288>)
  40643c:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  406440:	330c      	adds	r3, #12
  406442:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  406446:	62bb      	str	r3, [r7, #40]	; 0x28
  406448:	6abb      	ldr	r3, [r7, #40]	; 0x28
  40644a:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  40644e:	62bb      	str	r3, [r7, #40]	; 0x28
  406450:	6abb      	ldr	r3, [r7, #40]	; 0x28
  406452:	f043 0310 	orr.w	r3, r3, #16
  406456:	62bb      	str	r3, [r7, #40]	; 0x28
  406458:	496f      	ldr	r1, [pc, #444]	; (406618 <udd_ep_interrupt+0x288>)
  40645a:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  40645e:	6aba      	ldr	r2, [r7, #40]	; 0x28
  406460:	330c      	adds	r3, #12
  406462:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  406466:	bf00      	nop
  406468:	4a6b      	ldr	r2, [pc, #428]	; (406618 <udd_ep_interrupt+0x288>)
  40646a:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  40646e:	330c      	adds	r3, #12
  406470:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  406474:	f003 0310 	and.w	r3, r3, #16
  406478:	2b10      	cmp	r3, #16
  40647a:	d1f5      	bne.n	406468 <udd_ep_interrupt+0xd8>
					udd_ack_in_sent(ep);
  40647c:	4a66      	ldr	r2, [pc, #408]	; (406618 <udd_ep_interrupt+0x288>)
  40647e:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  406482:	330c      	adds	r3, #12
  406484:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  406488:	627b      	str	r3, [r7, #36]	; 0x24
  40648a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40648c:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  406490:	627b      	str	r3, [r7, #36]	; 0x24
  406492:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  406494:	f023 0301 	bic.w	r3, r3, #1
  406498:	627b      	str	r3, [r7, #36]	; 0x24
  40649a:	495f      	ldr	r1, [pc, #380]	; (406618 <udd_ep_interrupt+0x288>)
  40649c:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  4064a0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  4064a2:	330c      	adds	r3, #12
  4064a4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  4064a8:	bf00      	nop
  4064aa:	4a5b      	ldr	r2, [pc, #364]	; (406618 <udd_ep_interrupt+0x288>)
  4064ac:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  4064b0:	330c      	adds	r3, #12
  4064b2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  4064b6:	f003 0301 	and.w	r3, r3, #1
  4064ba:	2b00      	cmp	r3, #0
  4064bc:	d1f5      	bne.n	4064aa <udd_ep_interrupt+0x11a>
  4064be:	e046      	b.n	40654e <udd_ep_interrupt+0x1be>
				} else {
					// Ack last packet
					udd_ack_in_sent(ep);
  4064c0:	4a55      	ldr	r2, [pc, #340]	; (406618 <udd_ep_interrupt+0x288>)
  4064c2:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  4064c6:	330c      	adds	r3, #12
  4064c8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  4064cc:	623b      	str	r3, [r7, #32]
  4064ce:	6a3b      	ldr	r3, [r7, #32]
  4064d0:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  4064d4:	623b      	str	r3, [r7, #32]
  4064d6:	6a3b      	ldr	r3, [r7, #32]
  4064d8:	f023 0301 	bic.w	r3, r3, #1
  4064dc:	623b      	str	r3, [r7, #32]
  4064de:	494e      	ldr	r1, [pc, #312]	; (406618 <udd_ep_interrupt+0x288>)
  4064e0:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  4064e4:	6a3a      	ldr	r2, [r7, #32]
  4064e6:	330c      	adds	r3, #12
  4064e8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  4064ec:	bf00      	nop
  4064ee:	4a4a      	ldr	r2, [pc, #296]	; (406618 <udd_ep_interrupt+0x288>)
  4064f0:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  4064f4:	330c      	adds	r3, #12
  4064f6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  4064fa:	f003 0301 	and.w	r3, r3, #1
  4064fe:	2b00      	cmp	r3, #0
  406500:	d1f5      	bne.n	4064ee <udd_ep_interrupt+0x15e>
					// Enable stall
					udd_enable_stall_handshake(ep);
  406502:	4a45      	ldr	r2, [pc, #276]	; (406618 <udd_ep_interrupt+0x288>)
  406504:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  406508:	330c      	adds	r3, #12
  40650a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  40650e:	61fb      	str	r3, [r7, #28]
  406510:	69fb      	ldr	r3, [r7, #28]
  406512:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  406516:	61fb      	str	r3, [r7, #28]
  406518:	69fb      	ldr	r3, [r7, #28]
  40651a:	f043 0320 	orr.w	r3, r3, #32
  40651e:	61fb      	str	r3, [r7, #28]
  406520:	493d      	ldr	r1, [pc, #244]	; (406618 <udd_ep_interrupt+0x288>)
  406522:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  406526:	69fa      	ldr	r2, [r7, #28]
  406528:	330c      	adds	r3, #12
  40652a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  40652e:	bf00      	nop
  406530:	4a39      	ldr	r2, [pc, #228]	; (406618 <udd_ep_interrupt+0x288>)
  406532:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  406536:	330c      	adds	r3, #12
  406538:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  40653c:	f003 0320 	and.w	r3, r3, #32
  406540:	2b20      	cmp	r3, #32
  406542:	d1f5      	bne.n	406530 <udd_ep_interrupt+0x1a0>
					// Halt executed
					ptr_job->b_stall_requested = false;
  406544:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  406546:	7c53      	ldrb	r3, [r2, #17]
  406548:	f36f 1345 	bfc	r3, #5, #1
  40654c:	7453      	strb	r3, [r2, #17]
				}
				return true;
  40654e:	2301      	movs	r3, #1
  406550:	e18c      	b.n	40686c <udd_ep_interrupt+0x4dc>
			}
			// Finish Job when buffer end
			if (ptr_job->b_buf_end) {
  406552:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  406554:	7c5b      	ldrb	r3, [r3, #17]
  406556:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
  40655a:	b2db      	uxtb	r3, r3
  40655c:	2b00      	cmp	r3, #0
  40655e:	d016      	beq.n	40658e <udd_ep_interrupt+0x1fe>
				ptr_job->b_buf_end = false;
  406560:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  406562:	7c53      	ldrb	r3, [r2, #17]
  406564:	f36f 13c7 	bfc	r3, #7, #1
  406568:	7453      	strb	r3, [r2, #17]
				ptr_job->buf_size = ptr_job->buf_cnt; // buf_size is passed to callback as XFR count
  40656a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  40656c:	68da      	ldr	r2, [r3, #12]
  40656e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  406570:	609a      	str	r2, [r3, #8]
                udd_disable_endpoint_interrupt(ep);
  406572:	4a29      	ldr	r2, [pc, #164]	; (406618 <udd_ep_interrupt+0x288>)
  406574:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  406578:	2101      	movs	r1, #1
  40657a:	fa01 f303 	lsl.w	r3, r1, r3
  40657e:	6153      	str	r3, [r2, #20]
                udd_ep_finish_job(ptr_job, UDD_EP_TRANSFER_OK, ep);
  406580:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  406584:	461a      	mov	r2, r3
  406586:	2100      	movs	r1, #0
  406588:	6b38      	ldr	r0, [r7, #48]	; 0x30
  40658a:	4b26      	ldr	r3, [pc, #152]	; (406624 <udd_ep_interrupt+0x294>)
  40658c:	4798      	blx	r3
			}
			if (ptr_job->buf_cnt >= ptr_job->buf_size &&
  40658e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  406590:	68da      	ldr	r2, [r3, #12]
  406592:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  406594:	689b      	ldr	r3, [r3, #8]
  406596:	429a      	cmp	r2, r3
  406598:	d34a      	bcc.n	406630 <udd_ep_interrupt+0x2a0>
					!ptr_job->b_shortpacket &&
  40659a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  40659c:	7c5b      	ldrb	r3, [r3, #17]
  40659e:	f003 0340 	and.w	r3, r3, #64	; 0x40
  4065a2:	b2db      	uxtb	r3, r3
			if (ptr_job->buf_cnt >= ptr_job->buf_size &&
  4065a4:	2b00      	cmp	r3, #0
  4065a6:	d143      	bne.n	406630 <udd_ep_interrupt+0x2a0>
					ptr_job->bank == 0) {
  4065a8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  4065aa:	7c5b      	ldrb	r3, [r3, #17]
  4065ac:	f003 030c 	and.w	r3, r3, #12
  4065b0:	b2db      	uxtb	r3, r3
					!ptr_job->b_shortpacket &&
  4065b2:	2b00      	cmp	r3, #0
  4065b4:	d13c      	bne.n	406630 <udd_ep_interrupt+0x2a0>
				// All transfer done, including ZLP
				irqflags_t flags = cpu_irq_save();
  4065b6:	4b1c      	ldr	r3, [pc, #112]	; (406628 <udd_ep_interrupt+0x298>)
  4065b8:	4798      	blx	r3
  4065ba:	62f8      	str	r0, [r7, #44]	; 0x2c
				udd_disable_endpoint_interrupt(ep);
  4065bc:	4a16      	ldr	r2, [pc, #88]	; (406618 <udd_ep_interrupt+0x288>)
  4065be:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  4065c2:	2101      	movs	r1, #1
  4065c4:	fa01 f303 	lsl.w	r3, r1, r3
  4065c8:	6153      	str	r3, [r2, #20]
				cpu_irq_restore(flags);
  4065ca:	6af8      	ldr	r0, [r7, #44]	; 0x2c
  4065cc:	4b17      	ldr	r3, [pc, #92]	; (40662c <udd_ep_interrupt+0x29c>)
  4065ce:	4798      	blx	r3
				// Ack last packet
				udd_ack_in_sent(ep);
  4065d0:	4a11      	ldr	r2, [pc, #68]	; (406618 <udd_ep_interrupt+0x288>)
  4065d2:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  4065d6:	330c      	adds	r3, #12
  4065d8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  4065dc:	61bb      	str	r3, [r7, #24]
  4065de:	69bb      	ldr	r3, [r7, #24]
  4065e0:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  4065e4:	61bb      	str	r3, [r7, #24]
  4065e6:	69bb      	ldr	r3, [r7, #24]
  4065e8:	f023 0301 	bic.w	r3, r3, #1
  4065ec:	61bb      	str	r3, [r7, #24]
  4065ee:	490a      	ldr	r1, [pc, #40]	; (406618 <udd_ep_interrupt+0x288>)
  4065f0:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  4065f4:	69ba      	ldr	r2, [r7, #24]
  4065f6:	330c      	adds	r3, #12
  4065f8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  4065fc:	bf00      	nop
  4065fe:	4a06      	ldr	r2, [pc, #24]	; (406618 <udd_ep_interrupt+0x288>)
  406600:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  406604:	330c      	adds	r3, #12
  406606:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  40660a:	f003 0301 	and.w	r3, r3, #1
  40660e:	2b00      	cmp	r3, #0
  406610:	d1f5      	bne.n	4065fe <udd_ep_interrupt+0x26e>
				return true;
  406612:	2301      	movs	r3, #1
  406614:	e12a      	b.n	40686c <udd_ep_interrupt+0x4dc>
  406616:	bf00      	nop
  406618:	40084000 	.word	0x40084000
  40661c:	20006c48 	.word	0x20006c48
  406620:	00406281 	.word	0x00406281
  406624:	00405e61 	.word	0x00405e61
  406628:	0040485d 	.word	0x0040485d
  40662c:	004048b5 	.word	0x004048b5
			} else if (udd_get_endpoint_bank_max_nbr(ep) > 1
  406630:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  406634:	2b00      	cmp	r3, #0
  406636:	d053      	beq.n	4066e0 <udd_ep_interrupt+0x350>
  406638:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  40663c:	2b03      	cmp	r3, #3
  40663e:	d04f      	beq.n	4066e0 <udd_ep_interrupt+0x350>
					&& ptr_job->bank > 0) {
  406640:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  406642:	7c5b      	ldrb	r3, [r3, #17]
  406644:	f3c3 0381 	ubfx	r3, r3, #2, #2
  406648:	b2db      	uxtb	r3, r3
  40664a:	2b00      	cmp	r3, #0
  40664c:	dd48      	ble.n	4066e0 <udd_ep_interrupt+0x350>
				// Already banks buffered, transmit while loading
				udd_set_transmit_ready(ep);
  40664e:	4a89      	ldr	r2, [pc, #548]	; (406874 <udd_ep_interrupt+0x4e4>)
  406650:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  406654:	330c      	adds	r3, #12
  406656:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  40665a:	617b      	str	r3, [r7, #20]
  40665c:	697b      	ldr	r3, [r7, #20]
  40665e:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  406662:	617b      	str	r3, [r7, #20]
  406664:	697b      	ldr	r3, [r7, #20]
  406666:	f043 0310 	orr.w	r3, r3, #16
  40666a:	617b      	str	r3, [r7, #20]
  40666c:	4981      	ldr	r1, [pc, #516]	; (406874 <udd_ep_interrupt+0x4e4>)
  40666e:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  406672:	697a      	ldr	r2, [r7, #20]
  406674:	330c      	adds	r3, #12
  406676:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  40667a:	bf00      	nop
  40667c:	4a7d      	ldr	r2, [pc, #500]	; (406874 <udd_ep_interrupt+0x4e4>)
  40667e:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  406682:	330c      	adds	r3, #12
  406684:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  406688:	f003 0310 	and.w	r3, r3, #16
  40668c:	2b10      	cmp	r3, #16
  40668e:	d1f5      	bne.n	40667c <udd_ep_interrupt+0x2ec>
				udd_ack_in_sent(ep);
  406690:	4a78      	ldr	r2, [pc, #480]	; (406874 <udd_ep_interrupt+0x4e4>)
  406692:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  406696:	330c      	adds	r3, #12
  406698:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  40669c:	613b      	str	r3, [r7, #16]
  40669e:	693b      	ldr	r3, [r7, #16]
  4066a0:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  4066a4:	613b      	str	r3, [r7, #16]
  4066a6:	693b      	ldr	r3, [r7, #16]
  4066a8:	f023 0301 	bic.w	r3, r3, #1
  4066ac:	613b      	str	r3, [r7, #16]
  4066ae:	4971      	ldr	r1, [pc, #452]	; (406874 <udd_ep_interrupt+0x4e4>)
  4066b0:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  4066b4:	693a      	ldr	r2, [r7, #16]
  4066b6:	330c      	adds	r3, #12
  4066b8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  4066bc:	bf00      	nop
  4066be:	4a6d      	ldr	r2, [pc, #436]	; (406874 <udd_ep_interrupt+0x4e4>)
  4066c0:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  4066c4:	330c      	adds	r3, #12
  4066c6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  4066ca:	f003 0301 	and.w	r3, r3, #1
  4066ce:	2b00      	cmp	r3, #0
  4066d0:	d1f5      	bne.n	4066be <udd_ep_interrupt+0x32e>
				udd_ep_in_sent(ep, false);
  4066d2:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  4066d6:	2100      	movs	r1, #0
  4066d8:	4618      	mov	r0, r3
  4066da:	4b67      	ldr	r3, [pc, #412]	; (406878 <udd_ep_interrupt+0x4e8>)
  4066dc:	4798      	blx	r3
  4066de:	e079      	b.n	4067d4 <udd_ep_interrupt+0x444>
			} else if (udd_get_endpoint_bank_max_nbr(ep) > 1) {
  4066e0:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  4066e4:	2b00      	cmp	r3, #0
  4066e6:	d04e      	beq.n	406786 <udd_ep_interrupt+0x3f6>
  4066e8:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  4066ec:	2b03      	cmp	r3, #3
  4066ee:	d04a      	beq.n	406786 <udd_ep_interrupt+0x3f6>
				// Still bank free, load and transmit
				if (!udd_ep_in_sent(ep, true)) {
  4066f0:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  4066f4:	2101      	movs	r1, #1
  4066f6:	4618      	mov	r0, r3
  4066f8:	4b5f      	ldr	r3, [pc, #380]	; (406878 <udd_ep_interrupt+0x4e8>)
  4066fa:	4798      	blx	r3
  4066fc:	4603      	mov	r3, r0
  4066fe:	f083 0301 	eor.w	r3, r3, #1
  406702:	b2db      	uxtb	r3, r3
  406704:	2b00      	cmp	r3, #0
  406706:	d016      	beq.n	406736 <udd_ep_interrupt+0x3a6>
					ptr_job->b_buf_end = false;
  406708:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  40670a:	7c53      	ldrb	r3, [r2, #17]
  40670c:	f36f 13c7 	bfc	r3, #7, #1
  406710:	7453      	strb	r3, [r2, #17]
					ptr_job->buf_size = ptr_job->buf_cnt; // buf_size is passed to callback as XFR count
  406712:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  406714:	68da      	ldr	r2, [r3, #12]
  406716:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  406718:	609a      	str	r2, [r3, #8]
                    udd_disable_endpoint_interrupt(ep);
  40671a:	4a56      	ldr	r2, [pc, #344]	; (406874 <udd_ep_interrupt+0x4e4>)
  40671c:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  406720:	2101      	movs	r1, #1
  406722:	fa01 f303 	lsl.w	r3, r1, r3
  406726:	6153      	str	r3, [r2, #20]
                    udd_ep_finish_job(ptr_job, UDD_EP_TRANSFER_OK, ep);
  406728:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  40672c:	461a      	mov	r2, r3
  40672e:	2100      	movs	r1, #0
  406730:	6b38      	ldr	r0, [r7, #48]	; 0x30
  406732:	4b52      	ldr	r3, [pc, #328]	; (40687c <udd_ep_interrupt+0x4ec>)
  406734:	4798      	blx	r3
				}
				udd_ack_in_sent(ep);
  406736:	4a4f      	ldr	r2, [pc, #316]	; (406874 <udd_ep_interrupt+0x4e4>)
  406738:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  40673c:	330c      	adds	r3, #12
  40673e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  406742:	60fb      	str	r3, [r7, #12]
  406744:	68fb      	ldr	r3, [r7, #12]
  406746:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  40674a:	60fb      	str	r3, [r7, #12]
  40674c:	68fb      	ldr	r3, [r7, #12]
  40674e:	f023 0301 	bic.w	r3, r3, #1
  406752:	60fb      	str	r3, [r7, #12]
  406754:	4947      	ldr	r1, [pc, #284]	; (406874 <udd_ep_interrupt+0x4e4>)
  406756:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  40675a:	68fa      	ldr	r2, [r7, #12]
  40675c:	330c      	adds	r3, #12
  40675e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  406762:	bf00      	nop
  406764:	4a43      	ldr	r2, [pc, #268]	; (406874 <udd_ep_interrupt+0x4e4>)
  406766:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  40676a:	330c      	adds	r3, #12
  40676c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  406770:	f003 0301 	and.w	r3, r3, #1
  406774:	2b00      	cmp	r3, #0
  406776:	d1f5      	bne.n	406764 <udd_ep_interrupt+0x3d4>
				udd_ep_in_sent(ep, false);
  406778:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  40677c:	2100      	movs	r1, #0
  40677e:	4618      	mov	r0, r3
  406780:	4b3d      	ldr	r3, [pc, #244]	; (406878 <udd_ep_interrupt+0x4e8>)
  406782:	4798      	blx	r3
  406784:	e026      	b.n	4067d4 <udd_ep_interrupt+0x444>
			} else {
				// Single bank transfer, ack when ready
				udd_ep_in_sent(ep, true);
  406786:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  40678a:	2101      	movs	r1, #1
  40678c:	4618      	mov	r0, r3
  40678e:	4b3a      	ldr	r3, [pc, #232]	; (406878 <udd_ep_interrupt+0x4e8>)
  406790:	4798      	blx	r3
				udd_ack_in_sent(ep);
  406792:	4a38      	ldr	r2, [pc, #224]	; (406874 <udd_ep_interrupt+0x4e4>)
  406794:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  406798:	330c      	adds	r3, #12
  40679a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  40679e:	60bb      	str	r3, [r7, #8]
  4067a0:	68bb      	ldr	r3, [r7, #8]
  4067a2:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  4067a6:	60bb      	str	r3, [r7, #8]
  4067a8:	68bb      	ldr	r3, [r7, #8]
  4067aa:	f023 0301 	bic.w	r3, r3, #1
  4067ae:	60bb      	str	r3, [r7, #8]
  4067b0:	4930      	ldr	r1, [pc, #192]	; (406874 <udd_ep_interrupt+0x4e4>)
  4067b2:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  4067b6:	68ba      	ldr	r2, [r7, #8]
  4067b8:	330c      	adds	r3, #12
  4067ba:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  4067be:	bf00      	nop
  4067c0:	4a2c      	ldr	r2, [pc, #176]	; (406874 <udd_ep_interrupt+0x4e4>)
  4067c2:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  4067c6:	330c      	adds	r3, #12
  4067c8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  4067cc:	f003 0301 	and.w	r3, r3, #1
  4067d0:	2b00      	cmp	r3, #0
  4067d2:	d1f5      	bne.n	4067c0 <udd_ep_interrupt+0x430>
			}
			return true;
  4067d4:	2301      	movs	r3, #1
  4067d6:	e049      	b.n	40686c <udd_ep_interrupt+0x4dc>
		}
		// Stall sent/CRC error
		if (Is_udd_stall(ep)) {
  4067d8:	4a26      	ldr	r2, [pc, #152]	; (406874 <udd_ep_interrupt+0x4e4>)
  4067da:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  4067de:	330c      	adds	r3, #12
  4067e0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  4067e4:	f003 0308 	and.w	r3, r3, #8
  4067e8:	2b00      	cmp	r3, #0
  4067ea:	d034      	beq.n	406856 <udd_ep_interrupt+0x4c6>
			udd_ack_stall(ep);
  4067ec:	4a21      	ldr	r2, [pc, #132]	; (406874 <udd_ep_interrupt+0x4e4>)
  4067ee:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  4067f2:	330c      	adds	r3, #12
  4067f4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  4067f8:	607b      	str	r3, [r7, #4]
  4067fa:	687b      	ldr	r3, [r7, #4]
  4067fc:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  406800:	607b      	str	r3, [r7, #4]
  406802:	687b      	ldr	r3, [r7, #4]
  406804:	f023 0308 	bic.w	r3, r3, #8
  406808:	607b      	str	r3, [r7, #4]
  40680a:	491a      	ldr	r1, [pc, #104]	; (406874 <udd_ep_interrupt+0x4e4>)
  40680c:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  406810:	687a      	ldr	r2, [r7, #4]
  406812:	330c      	adds	r3, #12
  406814:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  406818:	bf00      	nop
  40681a:	4a16      	ldr	r2, [pc, #88]	; (406874 <udd_ep_interrupt+0x4e4>)
  40681c:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  406820:	330c      	adds	r3, #12
  406822:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  406826:	f003 0308 	and.w	r3, r3, #8
  40682a:	2b00      	cmp	r3, #0
  40682c:	d1f5      	bne.n	40681a <udd_ep_interrupt+0x48a>
			if (udd_get_endpoint_type(ep) == UDP_CSR_EPTYPE_ISO_OUT ||
  40682e:	4a11      	ldr	r2, [pc, #68]	; (406874 <udd_ep_interrupt+0x4e4>)
  406830:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  406834:	330c      	adds	r3, #12
  406836:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  40683a:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
  40683e:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
  406842:	d005      	beq.n	406850 <udd_ep_interrupt+0x4c0>
				udd_get_endpoint_type(ep) == UDP_CSR_EPTYPE_ISO_IN) {
  406844:	4a0b      	ldr	r2, [pc, #44]	; (406874 <udd_ep_interrupt+0x4e4>)
  406846:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  40684a:	330c      	adds	r3, #12
  40684c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
			}
			return true;
  406850:	2301      	movs	r3, #1
  406852:	e00b      	b.n	40686c <udd_ep_interrupt+0x4dc>
			continue;
  406854:	bf00      	nop
	for (ep = 1; ep <= USB_DEVICE_MAX_EP; ep++) {
  406856:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  40685a:	3301      	adds	r3, #1
  40685c:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
  406860:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  406864:	2b02      	cmp	r3, #2
  406866:	f67f ad9a 	bls.w	40639e <udd_ep_interrupt+0xe>
		}
	}
	return false;
  40686a:	2300      	movs	r3, #0
}
  40686c:	4618      	mov	r0, r3
  40686e:	3738      	adds	r7, #56	; 0x38
  406870:	46bd      	mov	sp, r7
  406872:	bd80      	pop	{r7, pc}
  406874:	40084000 	.word	0x40084000
  406878:	0040617d 	.word	0x0040617d
  40687c:	00405e61 	.word	0x00405e61

00406880 <usart_set_async_baudrate>:
 * \retval 1 Baud rate set point is out of range for the given input clock
 * frequency.
 */
uint32_t usart_set_async_baudrate(Usart *p_usart,
		uint32_t baudrate, uint32_t ul_mck)
{
  406880:	b480      	push	{r7}
  406882:	b089      	sub	sp, #36	; 0x24
  406884:	af00      	add	r7, sp, #0
  406886:	60f8      	str	r0, [r7, #12]
  406888:	60b9      	str	r1, [r7, #8]
  40688a:	607a      	str	r2, [r7, #4]
	uint32_t cd_fp;
	uint32_t cd;
	uint32_t fp;

	/* Calculate the receiver sampling divide of baudrate clock. */
	if (ul_mck >= HIGH_FRQ_SAMPLE_DIV * baudrate) {
  40688c:	68bb      	ldr	r3, [r7, #8]
  40688e:	011a      	lsls	r2, r3, #4
  406890:	687b      	ldr	r3, [r7, #4]
  406892:	429a      	cmp	r2, r3
  406894:	d802      	bhi.n	40689c <usart_set_async_baudrate+0x1c>
		over = HIGH_FRQ_SAMPLE_DIV;
  406896:	2310      	movs	r3, #16
  406898:	61fb      	str	r3, [r7, #28]
  40689a:	e001      	b.n	4068a0 <usart_set_async_baudrate+0x20>
	} else {
		over = LOW_FRQ_SAMPLE_DIV;
  40689c:	2308      	movs	r3, #8
  40689e:	61fb      	str	r3, [r7, #28]
	}

	/* Calculate clock divider according to the fraction calculated formula. */
	cd_fp = (8 * ul_mck + (over * baudrate) / 2) / (over * baudrate);
  4068a0:	687b      	ldr	r3, [r7, #4]
  4068a2:	00da      	lsls	r2, r3, #3
  4068a4:	69fb      	ldr	r3, [r7, #28]
  4068a6:	68b9      	ldr	r1, [r7, #8]
  4068a8:	fb01 f303 	mul.w	r3, r1, r3
  4068ac:	085b      	lsrs	r3, r3, #1
  4068ae:	441a      	add	r2, r3
  4068b0:	69fb      	ldr	r3, [r7, #28]
  4068b2:	68b9      	ldr	r1, [r7, #8]
  4068b4:	fb01 f303 	mul.w	r3, r1, r3
  4068b8:	fbb2 f3f3 	udiv	r3, r2, r3
  4068bc:	61bb      	str	r3, [r7, #24]
	cd = cd_fp >> 3;
  4068be:	69bb      	ldr	r3, [r7, #24]
  4068c0:	08db      	lsrs	r3, r3, #3
  4068c2:	617b      	str	r3, [r7, #20]
	fp = cd_fp & 0x07;
  4068c4:	69bb      	ldr	r3, [r7, #24]
  4068c6:	f003 0307 	and.w	r3, r3, #7
  4068ca:	613b      	str	r3, [r7, #16]
	if (cd < MIN_CD_VALUE || cd > MAX_CD_VALUE) {
  4068cc:	697b      	ldr	r3, [r7, #20]
  4068ce:	2b00      	cmp	r3, #0
  4068d0:	d003      	beq.n	4068da <usart_set_async_baudrate+0x5a>
  4068d2:	697b      	ldr	r3, [r7, #20]
  4068d4:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
  4068d8:	d301      	bcc.n	4068de <usart_set_async_baudrate+0x5e>
		return 1;
  4068da:	2301      	movs	r3, #1
  4068dc:	e00f      	b.n	4068fe <usart_set_async_baudrate+0x7e>
	}

	/* Configure the OVER bit in MR register. */
	if (over == 8) {
  4068de:	69fb      	ldr	r3, [r7, #28]
  4068e0:	2b08      	cmp	r3, #8
  4068e2:	d105      	bne.n	4068f0 <usart_set_async_baudrate+0x70>
		p_usart->US_MR |= US_MR_OVER;
  4068e4:	68fb      	ldr	r3, [r7, #12]
  4068e6:	685b      	ldr	r3, [r3, #4]
  4068e8:	f443 2200 	orr.w	r2, r3, #524288	; 0x80000
  4068ec:	68fb      	ldr	r3, [r7, #12]
  4068ee:	605a      	str	r2, [r3, #4]
	}

	/* Configure the baudrate generate register. */
	p_usart->US_BRGR = (cd << US_BRGR_CD_Pos) | (fp << US_BRGR_FP_Pos);
  4068f0:	693b      	ldr	r3, [r7, #16]
  4068f2:	041a      	lsls	r2, r3, #16
  4068f4:	697b      	ldr	r3, [r7, #20]
  4068f6:	431a      	orrs	r2, r3
  4068f8:	68fb      	ldr	r3, [r7, #12]
  4068fa:	621a      	str	r2, [r3, #32]

	return 0;
  4068fc:	2300      	movs	r3, #0
}
  4068fe:	4618      	mov	r0, r3
  406900:	3724      	adds	r7, #36	; 0x24
  406902:	46bd      	mov	sp, r7
  406904:	f85d 7b04 	ldr.w	r7, [sp], #4
  406908:	4770      	bx	lr
	...

0040690c <usart_reset>:
 * \brief Reset the USART and disable TX and RX.
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_reset(Usart *p_usart)
{
  40690c:	b580      	push	{r7, lr}
  40690e:	b082      	sub	sp, #8
  406910:	af00      	add	r7, sp, #0
  406912:	6078      	str	r0, [r7, #4]
	/* Disable the Write Protect. */
	usart_disable_writeprotect(p_usart);
  406914:	6878      	ldr	r0, [r7, #4]
  406916:	4b0f      	ldr	r3, [pc, #60]	; (406954 <usart_reset+0x48>)
  406918:	4798      	blx	r3

	/* Reset registers that could cause unpredictable behavior after reset. */
	p_usart->US_MR = 0;
  40691a:	687b      	ldr	r3, [r7, #4]
  40691c:	2200      	movs	r2, #0
  40691e:	605a      	str	r2, [r3, #4]
	p_usart->US_RTOR = 0;
  406920:	687b      	ldr	r3, [r7, #4]
  406922:	2200      	movs	r2, #0
  406924:	625a      	str	r2, [r3, #36]	; 0x24
	p_usart->US_TTGR = 0;
  406926:	687b      	ldr	r3, [r7, #4]
  406928:	2200      	movs	r2, #0
  40692a:	629a      	str	r2, [r3, #40]	; 0x28

	/* Disable TX and RX. */
	usart_reset_tx(p_usart);
  40692c:	6878      	ldr	r0, [r7, #4]
  40692e:	4b0a      	ldr	r3, [pc, #40]	; (406958 <usart_reset+0x4c>)
  406930:	4798      	blx	r3
	usart_reset_rx(p_usart);
  406932:	6878      	ldr	r0, [r7, #4]
  406934:	4b09      	ldr	r3, [pc, #36]	; (40695c <usart_reset+0x50>)
  406936:	4798      	blx	r3
	/* Reset status bits. */
	usart_reset_status(p_usart);
  406938:	6878      	ldr	r0, [r7, #4]
  40693a:	4b09      	ldr	r3, [pc, #36]	; (406960 <usart_reset+0x54>)
  40693c:	4798      	blx	r3
	/* Turn off RTS and DTR if exist. */
	usart_drive_RTS_pin_high(p_usart);
  40693e:	6878      	ldr	r0, [r7, #4]
  406940:	4b08      	ldr	r3, [pc, #32]	; (406964 <usart_reset+0x58>)
  406942:	4798      	blx	r3
#if (SAM3S || SAM4S || SAM3U || SAM4L || SAM4E)
	usart_drive_DTR_pin_high(p_usart);
  406944:	6878      	ldr	r0, [r7, #4]
  406946:	4b08      	ldr	r3, [pc, #32]	; (406968 <usart_reset+0x5c>)
  406948:	4798      	blx	r3
#endif
}
  40694a:	bf00      	nop
  40694c:	3708      	adds	r7, #8
  40694e:	46bd      	mov	sp, r7
  406950:	bd80      	pop	{r7, pc}
  406952:	bf00      	nop
  406954:	00406b15 	.word	0x00406b15
  406958:	00406a0b 	.word	0x00406a0b
  40695c:	00406a3f 	.word	0x00406a3f
  406960:	00406a59 	.word	0x00406a59
  406964:	00406a91 	.word	0x00406a91
  406968:	00406a75 	.word	0x00406a75

0040696c <usart_init_rs232>:
 * \retval 0 on success.
 * \retval 1 on failure.
 */
uint32_t usart_init_rs232(Usart *p_usart,
		const sam_usart_opt_t *p_usart_opt, uint32_t ul_mck)
{
  40696c:	b580      	push	{r7, lr}
  40696e:	b084      	sub	sp, #16
  406970:	af00      	add	r7, sp, #0
  406972:	60f8      	str	r0, [r7, #12]
  406974:	60b9      	str	r1, [r7, #8]
  406976:	607a      	str	r2, [r7, #4]
	static uint32_t ul_reg_val;

	/* Reset the USART and shut down TX and RX. */
	usart_reset(p_usart);
  406978:	68f8      	ldr	r0, [r7, #12]
  40697a:	4b1a      	ldr	r3, [pc, #104]	; (4069e4 <usart_init_rs232+0x78>)
  40697c:	4798      	blx	r3

	ul_reg_val = 0;
  40697e:	4b1a      	ldr	r3, [pc, #104]	; (4069e8 <usart_init_rs232+0x7c>)
  406980:	2200      	movs	r2, #0
  406982:	601a      	str	r2, [r3, #0]
	/* Check whether the input values are legal. */
	if (!p_usart_opt || usart_set_async_baudrate(p_usart,
  406984:	68bb      	ldr	r3, [r7, #8]
  406986:	2b00      	cmp	r3, #0
  406988:	d009      	beq.n	40699e <usart_init_rs232+0x32>
  40698a:	68bb      	ldr	r3, [r7, #8]
  40698c:	681b      	ldr	r3, [r3, #0]
  40698e:	687a      	ldr	r2, [r7, #4]
  406990:	4619      	mov	r1, r3
  406992:	68f8      	ldr	r0, [r7, #12]
  406994:	4b15      	ldr	r3, [pc, #84]	; (4069ec <usart_init_rs232+0x80>)
  406996:	4798      	blx	r3
  406998:	4603      	mov	r3, r0
  40699a:	2b00      	cmp	r3, #0
  40699c:	d001      	beq.n	4069a2 <usart_init_rs232+0x36>
			p_usart_opt->baudrate, ul_mck)) {
		return 1;
  40699e:	2301      	movs	r3, #1
  4069a0:	e01b      	b.n	4069da <usart_init_rs232+0x6e>
	}

	/* Configure the USART option. */
	ul_reg_val |= p_usart_opt->char_length | p_usart_opt->parity_type |
  4069a2:	68bb      	ldr	r3, [r7, #8]
  4069a4:	685a      	ldr	r2, [r3, #4]
  4069a6:	68bb      	ldr	r3, [r7, #8]
  4069a8:	689b      	ldr	r3, [r3, #8]
  4069aa:	431a      	orrs	r2, r3
			p_usart_opt->channel_mode | p_usart_opt->stop_bits;
  4069ac:	68bb      	ldr	r3, [r7, #8]
  4069ae:	691b      	ldr	r3, [r3, #16]
	ul_reg_val |= p_usart_opt->char_length | p_usart_opt->parity_type |
  4069b0:	431a      	orrs	r2, r3
			p_usart_opt->channel_mode | p_usart_opt->stop_bits;
  4069b2:	68bb      	ldr	r3, [r7, #8]
  4069b4:	68db      	ldr	r3, [r3, #12]
  4069b6:	431a      	orrs	r2, r3
	ul_reg_val |= p_usart_opt->char_length | p_usart_opt->parity_type |
  4069b8:	4b0b      	ldr	r3, [pc, #44]	; (4069e8 <usart_init_rs232+0x7c>)
  4069ba:	681b      	ldr	r3, [r3, #0]
  4069bc:	4313      	orrs	r3, r2
  4069be:	4a0a      	ldr	r2, [pc, #40]	; (4069e8 <usart_init_rs232+0x7c>)
  4069c0:	6013      	str	r3, [r2, #0]

	/* Configure the USART mode as normal mode. */
	ul_reg_val |= US_MR_USART_MODE_NORMAL;
  4069c2:	4b09      	ldr	r3, [pc, #36]	; (4069e8 <usart_init_rs232+0x7c>)
  4069c4:	681b      	ldr	r3, [r3, #0]
  4069c6:	4a08      	ldr	r2, [pc, #32]	; (4069e8 <usart_init_rs232+0x7c>)
  4069c8:	6013      	str	r3, [r2, #0]

	p_usart->US_MR |= ul_reg_val;
  4069ca:	68fb      	ldr	r3, [r7, #12]
  4069cc:	685a      	ldr	r2, [r3, #4]
  4069ce:	4b06      	ldr	r3, [pc, #24]	; (4069e8 <usart_init_rs232+0x7c>)
  4069d0:	681b      	ldr	r3, [r3, #0]
  4069d2:	431a      	orrs	r2, r3
  4069d4:	68fb      	ldr	r3, [r7, #12]
  4069d6:	605a      	str	r2, [r3, #4]

	return 0;
  4069d8:	2300      	movs	r3, #0
}
  4069da:	4618      	mov	r0, r3
  4069dc:	3710      	adds	r7, #16
  4069de:	46bd      	mov	sp, r7
  4069e0:	bd80      	pop	{r7, pc}
  4069e2:	bf00      	nop
  4069e4:	0040690d 	.word	0x0040690d
  4069e8:	20006c74 	.word	0x20006c74
  4069ec:	00406881 	.word	0x00406881

004069f0 <usart_enable_tx>:
 * \brief Enable USART transmitter.
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_enable_tx(Usart *p_usart)
{
  4069f0:	b480      	push	{r7}
  4069f2:	b083      	sub	sp, #12
  4069f4:	af00      	add	r7, sp, #0
  4069f6:	6078      	str	r0, [r7, #4]
	p_usart->US_CR = US_CR_TXEN;
  4069f8:	687b      	ldr	r3, [r7, #4]
  4069fa:	2240      	movs	r2, #64	; 0x40
  4069fc:	601a      	str	r2, [r3, #0]
}
  4069fe:	bf00      	nop
  406a00:	370c      	adds	r7, #12
  406a02:	46bd      	mov	sp, r7
  406a04:	f85d 7b04 	ldr.w	r7, [sp], #4
  406a08:	4770      	bx	lr

00406a0a <usart_reset_tx>:
 * \brief Immediately stop and disable USART transmitter.
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_reset_tx(Usart *p_usart)
{
  406a0a:	b480      	push	{r7}
  406a0c:	b083      	sub	sp, #12
  406a0e:	af00      	add	r7, sp, #0
  406a10:	6078      	str	r0, [r7, #4]
	/* Reset transmitter */
	p_usart->US_CR = US_CR_RSTTX | US_CR_TXDIS;
  406a12:	687b      	ldr	r3, [r7, #4]
  406a14:	2288      	movs	r2, #136	; 0x88
  406a16:	601a      	str	r2, [r3, #0]
}
  406a18:	bf00      	nop
  406a1a:	370c      	adds	r7, #12
  406a1c:	46bd      	mov	sp, r7
  406a1e:	f85d 7b04 	ldr.w	r7, [sp], #4
  406a22:	4770      	bx	lr

00406a24 <usart_enable_rx>:
 * \brief Enable USART receiver.
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_enable_rx(Usart *p_usart)
{
  406a24:	b480      	push	{r7}
  406a26:	b083      	sub	sp, #12
  406a28:	af00      	add	r7, sp, #0
  406a2a:	6078      	str	r0, [r7, #4]
	p_usart->US_CR = US_CR_RXEN;
  406a2c:	687b      	ldr	r3, [r7, #4]
  406a2e:	2210      	movs	r2, #16
  406a30:	601a      	str	r2, [r3, #0]
}
  406a32:	bf00      	nop
  406a34:	370c      	adds	r7, #12
  406a36:	46bd      	mov	sp, r7
  406a38:	f85d 7b04 	ldr.w	r7, [sp], #4
  406a3c:	4770      	bx	lr

00406a3e <usart_reset_rx>:
 * \brief Immediately stop and disable USART receiver.
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_reset_rx(Usart *p_usart)
{
  406a3e:	b480      	push	{r7}
  406a40:	b083      	sub	sp, #12
  406a42:	af00      	add	r7, sp, #0
  406a44:	6078      	str	r0, [r7, #4]
	/* Reset Receiver */
	p_usart->US_CR = US_CR_RSTRX | US_CR_RXDIS;
  406a46:	687b      	ldr	r3, [r7, #4]
  406a48:	2224      	movs	r2, #36	; 0x24
  406a4a:	601a      	str	r2, [r3, #0]
}
  406a4c:	bf00      	nop
  406a4e:	370c      	adds	r7, #12
  406a50:	46bd      	mov	sp, r7
  406a52:	f85d 7b04 	ldr.w	r7, [sp], #4
  406a56:	4770      	bx	lr

00406a58 <usart_reset_status>:
 * \brief Reset status bits (PARE, OVER, MANERR, UNRE and PXBRK in US_CSR).
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_reset_status(Usart *p_usart)
{
  406a58:	b480      	push	{r7}
  406a5a:	b083      	sub	sp, #12
  406a5c:	af00      	add	r7, sp, #0
  406a5e:	6078      	str	r0, [r7, #4]
	p_usart->US_CR = US_CR_RSTSTA;
  406a60:	687b      	ldr	r3, [r7, #4]
  406a62:	f44f 7280 	mov.w	r2, #256	; 0x100
  406a66:	601a      	str	r2, [r3, #0]
}
  406a68:	bf00      	nop
  406a6a:	370c      	adds	r7, #12
  406a6c:	46bd      	mov	sp, r7
  406a6e:	f85d 7b04 	ldr.w	r7, [sp], #4
  406a72:	4770      	bx	lr

00406a74 <usart_drive_DTR_pin_high>:
 * \brief Drive the pin DTR to 1.
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_drive_DTR_pin_high(Usart *p_usart)
{
  406a74:	b480      	push	{r7}
  406a76:	b083      	sub	sp, #12
  406a78:	af00      	add	r7, sp, #0
  406a7a:	6078      	str	r0, [r7, #4]
	p_usart->US_CR = US_CR_DTRDIS;
  406a7c:	687b      	ldr	r3, [r7, #4]
  406a7e:	f44f 3200 	mov.w	r2, #131072	; 0x20000
  406a82:	601a      	str	r2, [r3, #0]
}
  406a84:	bf00      	nop
  406a86:	370c      	adds	r7, #12
  406a88:	46bd      	mov	sp, r7
  406a8a:	f85d 7b04 	ldr.w	r7, [sp], #4
  406a8e:	4770      	bx	lr

00406a90 <usart_drive_RTS_pin_high>:
 * \brief Drive the pin RTS to 1.
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_drive_RTS_pin_high(Usart *p_usart)
{
  406a90:	b480      	push	{r7}
  406a92:	b083      	sub	sp, #12
  406a94:	af00      	add	r7, sp, #0
  406a96:	6078      	str	r0, [r7, #4]
	p_usart->US_CR = US_CR_RTSDIS;
  406a98:	687b      	ldr	r3, [r7, #4]
  406a9a:	f44f 2200 	mov.w	r2, #524288	; 0x80000
  406a9e:	601a      	str	r2, [r3, #0]
}
  406aa0:	bf00      	nop
  406aa2:	370c      	adds	r7, #12
  406aa4:	46bd      	mov	sp, r7
  406aa6:	f85d 7b04 	ldr.w	r7, [sp], #4
  406aaa:	4770      	bx	lr

00406aac <usart_write>:
 *
 * \retval 0 on success.
 * \retval 1 on failure.
 */
uint32_t usart_write(Usart *p_usart, uint32_t c)
{
  406aac:	b480      	push	{r7}
  406aae:	b083      	sub	sp, #12
  406ab0:	af00      	add	r7, sp, #0
  406ab2:	6078      	str	r0, [r7, #4]
  406ab4:	6039      	str	r1, [r7, #0]
	if (!(p_usart->US_CSR & US_CSR_TXRDY)) {
  406ab6:	687b      	ldr	r3, [r7, #4]
  406ab8:	695b      	ldr	r3, [r3, #20]
  406aba:	f003 0302 	and.w	r3, r3, #2
  406abe:	2b00      	cmp	r3, #0
  406ac0:	d101      	bne.n	406ac6 <usart_write+0x1a>
		return 1;
  406ac2:	2301      	movs	r3, #1
  406ac4:	e005      	b.n	406ad2 <usart_write+0x26>
	}

	p_usart->US_THR = US_THR_TXCHR(c);
  406ac6:	683b      	ldr	r3, [r7, #0]
  406ac8:	f3c3 0208 	ubfx	r2, r3, #0, #9
  406acc:	687b      	ldr	r3, [r7, #4]
  406ace:	61da      	str	r2, [r3, #28]
	return 0;
  406ad0:	2300      	movs	r3, #0
}
  406ad2:	4618      	mov	r0, r3
  406ad4:	370c      	adds	r7, #12
  406ad6:	46bd      	mov	sp, r7
  406ad8:	f85d 7b04 	ldr.w	r7, [sp], #4
  406adc:	4770      	bx	lr

00406ade <usart_read>:
 *
 * \retval 0 on success.
 * \retval 1 if no data is available or errors.
 */
uint32_t usart_read(Usart *p_usart, uint32_t *c)
{
  406ade:	b480      	push	{r7}
  406ae0:	b083      	sub	sp, #12
  406ae2:	af00      	add	r7, sp, #0
  406ae4:	6078      	str	r0, [r7, #4]
  406ae6:	6039      	str	r1, [r7, #0]
	if (!(p_usart->US_CSR & US_CSR_RXRDY)) {
  406ae8:	687b      	ldr	r3, [r7, #4]
  406aea:	695b      	ldr	r3, [r3, #20]
  406aec:	f003 0301 	and.w	r3, r3, #1
  406af0:	2b00      	cmp	r3, #0
  406af2:	d101      	bne.n	406af8 <usart_read+0x1a>
		return 1;
  406af4:	2301      	movs	r3, #1
  406af6:	e006      	b.n	406b06 <usart_read+0x28>
	}

	/* Read character */
	*c = p_usart->US_RHR & US_RHR_RXCHR_Msk;
  406af8:	687b      	ldr	r3, [r7, #4]
  406afa:	699b      	ldr	r3, [r3, #24]
  406afc:	f3c3 0208 	ubfx	r2, r3, #0, #9
  406b00:	683b      	ldr	r3, [r7, #0]
  406b02:	601a      	str	r2, [r3, #0]

	return 0;
  406b04:	2300      	movs	r3, #0
}
  406b06:	4618      	mov	r0, r3
  406b08:	370c      	adds	r7, #12
  406b0a:	46bd      	mov	sp, r7
  406b0c:	f85d 7b04 	ldr.w	r7, [sp], #4
  406b10:	4770      	bx	lr
	...

00406b14 <usart_disable_writeprotect>:
 * \brief Disable write protect of USART registers.
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_disable_writeprotect(Usart *p_usart)
{
  406b14:	b480      	push	{r7}
  406b16:	b083      	sub	sp, #12
  406b18:	af00      	add	r7, sp, #0
  406b1a:	6078      	str	r0, [r7, #4]
	p_usart->US_WPMR = US_WPMR_WPKEY_PASSWD;
  406b1c:	687b      	ldr	r3, [r7, #4]
  406b1e:	4a04      	ldr	r2, [pc, #16]	; (406b30 <usart_disable_writeprotect+0x1c>)
  406b20:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
}
  406b24:	bf00      	nop
  406b26:	370c      	adds	r7, #12
  406b28:	46bd      	mov	sp, r7
  406b2a:	f85d 7b04 	ldr.w	r7, [sp], #4
  406b2e:	4770      	bx	lr
  406b30:	55534100 	.word	0x55534100

00406b34 <wdt_get_timeout_value>:
 *
 * \return If the desired period is beyond the watchdog period, this function
 * returns WDT_INVALID_ARGUMENT. Otherwise it returns valid value.
 */
uint32_t wdt_get_timeout_value(uint32_t ul_us, uint32_t ul_sclk)
{
  406b34:	b480      	push	{r7}
  406b36:	b085      	sub	sp, #20
  406b38:	af00      	add	r7, sp, #0
  406b3a:	6078      	str	r0, [r7, #4]
  406b3c:	6039      	str	r1, [r7, #0]
	uint32_t max, min;

	min = WDT_SLCK_DIV * 1000000 / ul_sclk;
  406b3e:	4a10      	ldr	r2, [pc, #64]	; (406b80 <wdt_get_timeout_value+0x4c>)
  406b40:	683b      	ldr	r3, [r7, #0]
  406b42:	fbb2 f3f3 	udiv	r3, r2, r3
  406b46:	60fb      	str	r3, [r7, #12]
	max = min * WDT_MAX_VALUE;
  406b48:	68fa      	ldr	r2, [r7, #12]
  406b4a:	4613      	mov	r3, r2
  406b4c:	031b      	lsls	r3, r3, #12
  406b4e:	1a9b      	subs	r3, r3, r2
  406b50:	60bb      	str	r3, [r7, #8]

	if ((ul_us < min) || (ul_us > max)) {
  406b52:	687a      	ldr	r2, [r7, #4]
  406b54:	68fb      	ldr	r3, [r7, #12]
  406b56:	429a      	cmp	r2, r3
  406b58:	d303      	bcc.n	406b62 <wdt_get_timeout_value+0x2e>
  406b5a:	687a      	ldr	r2, [r7, #4]
  406b5c:	68bb      	ldr	r3, [r7, #8]
  406b5e:	429a      	cmp	r2, r3
  406b60:	d902      	bls.n	406b68 <wdt_get_timeout_value+0x34>
		return WDT_INVALID_ARGUMENT;
  406b62:	f64f 73ff 	movw	r3, #65535	; 0xffff
  406b66:	e005      	b.n	406b74 <wdt_get_timeout_value+0x40>
	}

	return WDT_MR_WDV(ul_us / min);
  406b68:	687a      	ldr	r2, [r7, #4]
  406b6a:	68fb      	ldr	r3, [r7, #12]
  406b6c:	fbb2 f3f3 	udiv	r3, r2, r3
  406b70:	f3c3 030b 	ubfx	r3, r3, #0, #12
}
  406b74:	4618      	mov	r0, r3
  406b76:	3714      	adds	r7, #20
  406b78:	46bd      	mov	sp, r7
  406b7a:	f85d 7b04 	ldr.w	r7, [sp], #4
  406b7e:	4770      	bx	lr
  406b80:	07a12000 	.word	0x07a12000

00406b84 <wdt_init>:
 * \param us_counter The value loaded in the 12-bit Watchdog Counter.
 * \param us_delta The permitted range for reloading the Watchdog Timer.
 */
void wdt_init(Wdt *p_wdt, uint32_t ul_mode, uint16_t us_counter,
		uint16_t us_delta)
{
  406b84:	b480      	push	{r7}
  406b86:	b085      	sub	sp, #20
  406b88:	af00      	add	r7, sp, #0
  406b8a:	60f8      	str	r0, [r7, #12]
  406b8c:	60b9      	str	r1, [r7, #8]
  406b8e:	4611      	mov	r1, r2
  406b90:	461a      	mov	r2, r3
  406b92:	460b      	mov	r3, r1
  406b94:	80fb      	strh	r3, [r7, #6]
  406b96:	4613      	mov	r3, r2
  406b98:	80bb      	strh	r3, [r7, #4]
	2. The WDT_MR register values must not be modified within three slow clock periods following a restart of the watchdog
	performed by a write access in WDT_CR. Any modification will cause the watchdog to trigger an end of period earlier than
	expected 
	*/
	p_wdt->WDT_MR = ul_mode |
			WDT_MR_WDV(us_counter) | WDT_MR_WDD(us_delta);
  406b9a:	88fb      	ldrh	r3, [r7, #6]
  406b9c:	f3c3 020b 	ubfx	r2, r3, #0, #12
	p_wdt->WDT_MR = ul_mode |
  406ba0:	68bb      	ldr	r3, [r7, #8]
  406ba2:	431a      	orrs	r2, r3
			WDT_MR_WDV(us_counter) | WDT_MR_WDD(us_delta);
  406ba4:	88bb      	ldrh	r3, [r7, #4]
  406ba6:	041b      	lsls	r3, r3, #16
  406ba8:	4619      	mov	r1, r3
  406baa:	4b05      	ldr	r3, [pc, #20]	; (406bc0 <wdt_init+0x3c>)
  406bac:	400b      	ands	r3, r1
  406bae:	431a      	orrs	r2, r3
	p_wdt->WDT_MR = ul_mode |
  406bb0:	68fb      	ldr	r3, [r7, #12]
  406bb2:	605a      	str	r2, [r3, #4]
}
  406bb4:	bf00      	nop
  406bb6:	3714      	adds	r7, #20
  406bb8:	46bd      	mov	sp, r7
  406bba:	f85d 7b04 	ldr.w	r7, [sp], #4
  406bbe:	4770      	bx	lr
  406bc0:	0fff0000 	.word	0x0fff0000

00406bc4 <wdt_restart>:

/**
 * \brief Restart the watchdog timer.
 */
void wdt_restart(Wdt *p_wdt)
{
  406bc4:	b480      	push	{r7}
  406bc6:	b083      	sub	sp, #12
  406bc8:	af00      	add	r7, sp, #0
  406bca:	6078      	str	r0, [r7, #4]
	if (p_wdt == WDT) {
  406bcc:	687b      	ldr	r3, [r7, #4]
  406bce:	4a06      	ldr	r2, [pc, #24]	; (406be8 <wdt_restart+0x24>)
  406bd0:	4293      	cmp	r3, r2
  406bd2:	d102      	bne.n	406bda <wdt_restart+0x16>
		p_wdt->WDT_CR = WDT_KEY_PASSWORD | WDT_CR_WDRSTT;
  406bd4:	687b      	ldr	r3, [r7, #4]
  406bd6:	4a05      	ldr	r2, [pc, #20]	; (406bec <wdt_restart+0x28>)
  406bd8:	601a      	str	r2, [r3, #0]
#if (SAM4C || SAM4CM || SAM4CP)
	else {
		p_wdt->WDT_CR = RSWDT_CR_KEY(0xC4u) | RSWDT_CR_WDRSTT;
	}
#endif
}
  406bda:	bf00      	nop
  406bdc:	370c      	adds	r7, #12
  406bde:	46bd      	mov	sp, r7
  406be0:	f85d 7b04 	ldr.w	r7, [sp], #4
  406be4:	4770      	bx	lr
  406be6:	bf00      	nop
  406be8:	400e1850 	.word	0x400e1850
  406bec:	a5000001 	.word	0xa5000001

00406bf0 <wdt_get_status>:
 * \brief Check the watchdog timer status.
 *
 * \return Bitmask of watchdog timer status.
 */
uint32_t wdt_get_status(Wdt *p_wdt)
{
  406bf0:	b480      	push	{r7}
  406bf2:	b083      	sub	sp, #12
  406bf4:	af00      	add	r7, sp, #0
  406bf6:	6078      	str	r0, [r7, #4]
	return p_wdt->WDT_SR;
  406bf8:	687b      	ldr	r3, [r7, #4]
  406bfa:	689b      	ldr	r3, [r3, #8]
}
  406bfc:	4618      	mov	r0, r3
  406bfe:	370c      	adds	r7, #12
  406c00:	46bd      	mov	sp, r7
  406c02:	f85d 7b04 	ldr.w	r7, [sp], #4
  406c06:	4770      	bx	lr

00406c08 <wdt_get_us_timeout_period>:
 * \param ul_sclk The slow clock frequency (in Hz).
 *
 * \return The timeout period in microseconds.
 */
uint32_t wdt_get_us_timeout_period(Wdt *p_wdt, uint32_t ul_sclk)
{
  406c08:	b480      	push	{r7}
  406c0a:	b083      	sub	sp, #12
  406c0c:	af00      	add	r7, sp, #0
  406c0e:	6078      	str	r0, [r7, #4]
  406c10:	6039      	str	r1, [r7, #0]
	return WDT_MR_WDV(p_wdt->WDT_MR) * WDT_SLCK_DIV / ul_sclk * 1000000;
  406c12:	687b      	ldr	r3, [r7, #4]
  406c14:	685b      	ldr	r3, [r3, #4]
  406c16:	f3c3 030b 	ubfx	r3, r3, #0, #12
  406c1a:	01da      	lsls	r2, r3, #7
  406c1c:	683b      	ldr	r3, [r7, #0]
  406c1e:	fbb2 f3f3 	udiv	r3, r2, r3
  406c22:	4a04      	ldr	r2, [pc, #16]	; (406c34 <wdt_get_us_timeout_period+0x2c>)
  406c24:	fb02 f303 	mul.w	r3, r2, r3
}
  406c28:	4618      	mov	r0, r3
  406c2a:	370c      	adds	r7, #12
  406c2c:	46bd      	mov	sp, r7
  406c2e:	f85d 7b04 	ldr.w	r7, [sp], #4
  406c32:	4770      	bx	lr
  406c34:	000f4240 	.word	0x000f4240

00406c38 <Dummy_Handler>:
 */

volatile uint32_t phantomISR = 9999; // HICS debug

void Dummy_Handler(void)
{
  406c38:	b580      	push	{r7, lr}
  406c3a:	b082      	sub	sp, #8
  406c3c:	af00      	add	r7, sp, #0
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
  406c3e:	f3ef 8305 	mrs	r3, IPSR
  406c42:	607b      	str	r3, [r7, #4]
  return(result);
  406c44:	687b      	ldr	r3, [r7, #4]
	while (1) 
	{
		// HICS debug
		phantomISR = __get_IPSR(); 
  406c46:	4a04      	ldr	r2, [pc, #16]	; (406c58 <Dummy_Handler+0x20>)
  406c48:	6013      	str	r3, [r2, #0]
		extern void HICS_Debug_phantomISR(uint32_t phantomISR);
		HICS_Debug_phantomISR(phantomISR);
  406c4a:	4b03      	ldr	r3, [pc, #12]	; (406c58 <Dummy_Handler+0x20>)
  406c4c:	681b      	ldr	r3, [r3, #0]
  406c4e:	4618      	mov	r0, r3
  406c50:	4b02      	ldr	r3, [pc, #8]	; (406c5c <Dummy_Handler+0x24>)
  406c52:	4798      	blx	r3
	{
  406c54:	e7f3      	b.n	406c3e <Dummy_Handler+0x6>
  406c56:	bf00      	nop
  406c58:	200000c4 	.word	0x200000c4
  406c5c:	00413509 	.word	0x00413509

00406c60 <cpu_irq_save>:
{
  406c60:	b480      	push	{r7}
  406c62:	b083      	sub	sp, #12
  406c64:	af00      	add	r7, sp, #0
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
  406c66:	f3ef 8310 	mrs	r3, PRIMASK
  406c6a:	607b      	str	r3, [r7, #4]
  return(result);
  406c6c:	687b      	ldr	r3, [r7, #4]
	volatile irqflags_t flags = cpu_irq_is_enabled();
  406c6e:	2b00      	cmp	r3, #0
  406c70:	bf0c      	ite	eq
  406c72:	2301      	moveq	r3, #1
  406c74:	2300      	movne	r3, #0
  406c76:	b2db      	uxtb	r3, r3
  406c78:	603b      	str	r3, [r7, #0]
  __ASM volatile ("cpsid i" : : : "memory");
  406c7a:	b672      	cpsid	i
  406c7c:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
  406c80:	4b04      	ldr	r3, [pc, #16]	; (406c94 <cpu_irq_save+0x34>)
  406c82:	2200      	movs	r2, #0
  406c84:	701a      	strb	r2, [r3, #0]
	return flags;
  406c86:	683b      	ldr	r3, [r7, #0]
}
  406c88:	4618      	mov	r0, r3
  406c8a:	370c      	adds	r7, #12
  406c8c:	46bd      	mov	sp, r7
  406c8e:	f85d 7b04 	ldr.w	r7, [sp], #4
  406c92:	4770      	bx	lr
  406c94:	200000c2 	.word	0x200000c2

00406c98 <cpu_irq_is_enabled_flags>:
{
  406c98:	b480      	push	{r7}
  406c9a:	b083      	sub	sp, #12
  406c9c:	af00      	add	r7, sp, #0
  406c9e:	6078      	str	r0, [r7, #4]
	return (flags);
  406ca0:	687b      	ldr	r3, [r7, #4]
  406ca2:	2b00      	cmp	r3, #0
  406ca4:	bf14      	ite	ne
  406ca6:	2301      	movne	r3, #1
  406ca8:	2300      	moveq	r3, #0
  406caa:	b2db      	uxtb	r3, r3
}
  406cac:	4618      	mov	r0, r3
  406cae:	370c      	adds	r7, #12
  406cb0:	46bd      	mov	sp, r7
  406cb2:	f85d 7b04 	ldr.w	r7, [sp], #4
  406cb6:	4770      	bx	lr

00406cb8 <cpu_irq_restore>:
{
  406cb8:	b580      	push	{r7, lr}
  406cba:	b082      	sub	sp, #8
  406cbc:	af00      	add	r7, sp, #0
  406cbe:	6078      	str	r0, [r7, #4]
	if (cpu_irq_is_enabled_flags(flags))
  406cc0:	6878      	ldr	r0, [r7, #4]
  406cc2:	4b07      	ldr	r3, [pc, #28]	; (406ce0 <cpu_irq_restore+0x28>)
  406cc4:	4798      	blx	r3
  406cc6:	4603      	mov	r3, r0
  406cc8:	2b00      	cmp	r3, #0
  406cca:	d005      	beq.n	406cd8 <cpu_irq_restore+0x20>
		cpu_irq_enable();
  406ccc:	4b05      	ldr	r3, [pc, #20]	; (406ce4 <cpu_irq_restore+0x2c>)
  406cce:	2201      	movs	r2, #1
  406cd0:	701a      	strb	r2, [r3, #0]
  406cd2:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
  406cd6:	b662      	cpsie	i
}
  406cd8:	bf00      	nop
  406cda:	3708      	adds	r7, #8
  406cdc:	46bd      	mov	sp, r7
  406cde:	bd80      	pop	{r7, pc}
  406ce0:	00406c99 	.word	0x00406c99
  406ce4:	200000c2 	.word	0x200000c2

00406ce8 <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
  406ce8:	b580      	push	{r7, lr}
  406cea:	b084      	sub	sp, #16
  406cec:	af00      	add	r7, sp, #0
	uint32_t *pSrc, *pDest;

	/* Initialize the relocate segment */
	pSrc = &_etext;
  406cee:	4b1e      	ldr	r3, [pc, #120]	; (406d68 <Reset_Handler+0x80>)
  406cf0:	60fb      	str	r3, [r7, #12]
	pDest = &_srelocate;
  406cf2:	4b1e      	ldr	r3, [pc, #120]	; (406d6c <Reset_Handler+0x84>)
  406cf4:	60bb      	str	r3, [r7, #8]

	if (pSrc != pDest) {
  406cf6:	68fa      	ldr	r2, [r7, #12]
  406cf8:	68bb      	ldr	r3, [r7, #8]
  406cfa:	429a      	cmp	r2, r3
  406cfc:	d00c      	beq.n	406d18 <Reset_Handler+0x30>
		for (; pDest < &_erelocate;) {
  406cfe:	e007      	b.n	406d10 <Reset_Handler+0x28>
			*pDest++ = *pSrc++;
  406d00:	68bb      	ldr	r3, [r7, #8]
  406d02:	1d1a      	adds	r2, r3, #4
  406d04:	60ba      	str	r2, [r7, #8]
  406d06:	68fa      	ldr	r2, [r7, #12]
  406d08:	1d11      	adds	r1, r2, #4
  406d0a:	60f9      	str	r1, [r7, #12]
  406d0c:	6812      	ldr	r2, [r2, #0]
  406d0e:	601a      	str	r2, [r3, #0]
		for (; pDest < &_erelocate;) {
  406d10:	68bb      	ldr	r3, [r7, #8]
  406d12:	4a17      	ldr	r2, [pc, #92]	; (406d70 <Reset_Handler+0x88>)
  406d14:	4293      	cmp	r3, r2
  406d16:	d3f3      	bcc.n	406d00 <Reset_Handler+0x18>
		}
	}

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
  406d18:	4b16      	ldr	r3, [pc, #88]	; (406d74 <Reset_Handler+0x8c>)
  406d1a:	60bb      	str	r3, [r7, #8]
  406d1c:	e004      	b.n	406d28 <Reset_Handler+0x40>
		*pDest++ = 0;
  406d1e:	68bb      	ldr	r3, [r7, #8]
  406d20:	1d1a      	adds	r2, r3, #4
  406d22:	60ba      	str	r2, [r7, #8]
  406d24:	2200      	movs	r2, #0
  406d26:	601a      	str	r2, [r3, #0]
	for (pDest = &_szero; pDest < &_ezero;) {
  406d28:	68bb      	ldr	r3, [r7, #8]
  406d2a:	4a13      	ldr	r2, [pc, #76]	; (406d78 <Reset_Handler+0x90>)
  406d2c:	4293      	cmp	r3, r2
  406d2e:	d3f6      	bcc.n	406d1e <Reset_Handler+0x36>
	}

	/* Set the vector table base address */
	pSrc = (uint32_t *) & _sfixed;
  406d30:	4b12      	ldr	r3, [pc, #72]	; (406d7c <Reset_Handler+0x94>)
  406d32:	60fb      	str	r3, [r7, #12]
	SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
  406d34:	4a12      	ldr	r2, [pc, #72]	; (406d80 <Reset_Handler+0x98>)
  406d36:	68fb      	ldr	r3, [r7, #12]
  406d38:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
  406d3c:	6093      	str	r3, [r2, #8]
 * \brief Enable FPU
 */
__always_inline static void fpu_enable(void)
{
	irqflags_t flags;
	flags = cpu_irq_save();
  406d3e:	4b11      	ldr	r3, [pc, #68]	; (406d84 <Reset_Handler+0x9c>)
  406d40:	4798      	blx	r3
  406d42:	6078      	str	r0, [r7, #4]
	REG_CPACR |=  (0xFu << 20);
  406d44:	4a10      	ldr	r2, [pc, #64]	; (406d88 <Reset_Handler+0xa0>)
  406d46:	4b10      	ldr	r3, [pc, #64]	; (406d88 <Reset_Handler+0xa0>)
  406d48:	681b      	ldr	r3, [r3, #0]
  406d4a:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
  406d4e:	6013      	str	r3, [r2, #0]
  __ASM volatile ("dsb");
  406d50:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb");
  406d54:	f3bf 8f6f 	isb	sy
	__DSB();
	__ISB();
	cpu_irq_restore(flags);
  406d58:	6878      	ldr	r0, [r7, #4]
  406d5a:	4b0c      	ldr	r3, [pc, #48]	; (406d8c <Reset_Handler+0xa4>)
  406d5c:	4798      	blx	r3
#if __FPU_USED
	fpu_enable();
#endif

	/* Initialize the C library */
	__libc_init_array();
  406d5e:	4b0c      	ldr	r3, [pc, #48]	; (406d90 <Reset_Handler+0xa8>)
  406d60:	4798      	blx	r3

	/* Branch to main function */
	main();
  406d62:	4b0c      	ldr	r3, [pc, #48]	; (406d94 <Reset_Handler+0xac>)
  406d64:	4798      	blx	r3

	/* Infinite loop */
	while (1);
  406d66:	e7fe      	b.n	406d66 <Reset_Handler+0x7e>
  406d68:	0041eca4 	.word	0x0041eca4
  406d6c:	20000000 	.word	0x20000000
  406d70:	20000b28 	.word	0x20000b28
  406d74:	20000b28 	.word	0x20000b28
  406d78:	2000bd1c 	.word	0x2000bd1c
  406d7c:	00400000 	.word	0x00400000
  406d80:	e000ed00 	.word	0xe000ed00
  406d84:	00406c61 	.word	0x00406c61
  406d88:	e000ed88 	.word	0xe000ed88
  406d8c:	00406cb9 	.word	0x00406cb9
  406d90:	00416c2d 	.word	0x00416c2d
  406d94:	00415ef1 	.word	0x00415ef1

00406d98 <SystemCoreClockUpdate>:

	SystemCoreClock = CHIP_FREQ_CPU_MAX;
}

void SystemCoreClockUpdate( void )
{
  406d98:	b480      	push	{r7}
  406d9a:	af00      	add	r7, sp, #0
	/* Determine clock frequency according to clock register values */
	switch (PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) {
  406d9c:	4b52      	ldr	r3, [pc, #328]	; (406ee8 <SystemCoreClockUpdate+0x150>)
  406d9e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  406da0:	f003 0303 	and.w	r3, r3, #3
  406da4:	2b01      	cmp	r3, #1
  406da6:	d014      	beq.n	406dd2 <SystemCoreClockUpdate+0x3a>
  406da8:	2b01      	cmp	r3, #1
  406daa:	d302      	bcc.n	406db2 <SystemCoreClockUpdate+0x1a>
  406dac:	2b02      	cmp	r3, #2
  406dae:	d038      	beq.n	406e22 <SystemCoreClockUpdate+0x8a>
			SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk) >> CKGR_PLLAR_DIVA_Pos));
		}
		break;

	default:
		break;
  406db0:	e07a      	b.n	406ea8 <SystemCoreClockUpdate+0x110>
		if ( SUPC->SUPC_SR & SUPC_SR_OSCSEL ) {
  406db2:	4b4e      	ldr	r3, [pc, #312]	; (406eec <SystemCoreClockUpdate+0x154>)
  406db4:	695b      	ldr	r3, [r3, #20]
  406db6:	f003 0380 	and.w	r3, r3, #128	; 0x80
  406dba:	2b00      	cmp	r3, #0
  406dbc:	d004      	beq.n	406dc8 <SystemCoreClockUpdate+0x30>
			SystemCoreClock = CHIP_FREQ_XTAL_32K;
  406dbe:	4b4c      	ldr	r3, [pc, #304]	; (406ef0 <SystemCoreClockUpdate+0x158>)
  406dc0:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  406dc4:	601a      	str	r2, [r3, #0]
		break;
  406dc6:	e06f      	b.n	406ea8 <SystemCoreClockUpdate+0x110>
			SystemCoreClock = CHIP_FREQ_SLCK_RC;
  406dc8:	4b49      	ldr	r3, [pc, #292]	; (406ef0 <SystemCoreClockUpdate+0x158>)
  406dca:	f44f 42fa 	mov.w	r2, #32000	; 0x7d00
  406dce:	601a      	str	r2, [r3, #0]
		break;
  406dd0:	e06a      	b.n	406ea8 <SystemCoreClockUpdate+0x110>
		if ( PMC->CKGR_MOR & CKGR_MOR_MOSCSEL ) {
  406dd2:	4b45      	ldr	r3, [pc, #276]	; (406ee8 <SystemCoreClockUpdate+0x150>)
  406dd4:	6a1b      	ldr	r3, [r3, #32]
  406dd6:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
  406dda:	2b00      	cmp	r3, #0
  406ddc:	d003      	beq.n	406de6 <SystemCoreClockUpdate+0x4e>
			SystemCoreClock = CHIP_FREQ_XTAL_12M;
  406dde:	4b44      	ldr	r3, [pc, #272]	; (406ef0 <SystemCoreClockUpdate+0x158>)
  406de0:	4a44      	ldr	r2, [pc, #272]	; (406ef4 <SystemCoreClockUpdate+0x15c>)
  406de2:	601a      	str	r2, [r3, #0]
		break;
  406de4:	e060      	b.n	406ea8 <SystemCoreClockUpdate+0x110>
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
  406de6:	4b42      	ldr	r3, [pc, #264]	; (406ef0 <SystemCoreClockUpdate+0x158>)
  406de8:	4a43      	ldr	r2, [pc, #268]	; (406ef8 <SystemCoreClockUpdate+0x160>)
  406dea:	601a      	str	r2, [r3, #0]
			switch ( PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk ) {
  406dec:	4b3e      	ldr	r3, [pc, #248]	; (406ee8 <SystemCoreClockUpdate+0x150>)
  406dee:	6a1b      	ldr	r3, [r3, #32]
  406df0:	f003 0370 	and.w	r3, r3, #112	; 0x70
  406df4:	2b10      	cmp	r3, #16
  406df6:	d004      	beq.n	406e02 <SystemCoreClockUpdate+0x6a>
  406df8:	2b20      	cmp	r3, #32
  406dfa:	d008      	beq.n	406e0e <SystemCoreClockUpdate+0x76>
  406dfc:	2b00      	cmp	r3, #0
  406dfe:	d00e      	beq.n	406e1e <SystemCoreClockUpdate+0x86>
				break;
  406e00:	e00e      	b.n	406e20 <SystemCoreClockUpdate+0x88>
				SystemCoreClock *= 2U;
  406e02:	4b3b      	ldr	r3, [pc, #236]	; (406ef0 <SystemCoreClockUpdate+0x158>)
  406e04:	681b      	ldr	r3, [r3, #0]
  406e06:	005b      	lsls	r3, r3, #1
  406e08:	4a39      	ldr	r2, [pc, #228]	; (406ef0 <SystemCoreClockUpdate+0x158>)
  406e0a:	6013      	str	r3, [r2, #0]
				break;
  406e0c:	e008      	b.n	406e20 <SystemCoreClockUpdate+0x88>
				SystemCoreClock *= 3U;
  406e0e:	4b38      	ldr	r3, [pc, #224]	; (406ef0 <SystemCoreClockUpdate+0x158>)
  406e10:	681a      	ldr	r2, [r3, #0]
  406e12:	4613      	mov	r3, r2
  406e14:	005b      	lsls	r3, r3, #1
  406e16:	4413      	add	r3, r2
  406e18:	4a35      	ldr	r2, [pc, #212]	; (406ef0 <SystemCoreClockUpdate+0x158>)
  406e1a:	6013      	str	r3, [r2, #0]
				break;
  406e1c:	e000      	b.n	406e20 <SystemCoreClockUpdate+0x88>
				break;
  406e1e:	bf00      	nop
		break;
  406e20:	e042      	b.n	406ea8 <SystemCoreClockUpdate+0x110>
		if ( PMC->CKGR_MOR & CKGR_MOR_MOSCSEL ) {
  406e22:	4b31      	ldr	r3, [pc, #196]	; (406ee8 <SystemCoreClockUpdate+0x150>)
  406e24:	6a1b      	ldr	r3, [r3, #32]
  406e26:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
  406e2a:	2b00      	cmp	r3, #0
  406e2c:	d003      	beq.n	406e36 <SystemCoreClockUpdate+0x9e>
			SystemCoreClock = CHIP_FREQ_XTAL_12M ;
  406e2e:	4b30      	ldr	r3, [pc, #192]	; (406ef0 <SystemCoreClockUpdate+0x158>)
  406e30:	4a30      	ldr	r2, [pc, #192]	; (406ef4 <SystemCoreClockUpdate+0x15c>)
  406e32:	601a      	str	r2, [r3, #0]
  406e34:	e01c      	b.n	406e70 <SystemCoreClockUpdate+0xd8>
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
  406e36:	4b2e      	ldr	r3, [pc, #184]	; (406ef0 <SystemCoreClockUpdate+0x158>)
  406e38:	4a2f      	ldr	r2, [pc, #188]	; (406ef8 <SystemCoreClockUpdate+0x160>)
  406e3a:	601a      	str	r2, [r3, #0]
			switch ( PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk ) {
  406e3c:	4b2a      	ldr	r3, [pc, #168]	; (406ee8 <SystemCoreClockUpdate+0x150>)
  406e3e:	6a1b      	ldr	r3, [r3, #32]
  406e40:	f003 0370 	and.w	r3, r3, #112	; 0x70
  406e44:	2b10      	cmp	r3, #16
  406e46:	d004      	beq.n	406e52 <SystemCoreClockUpdate+0xba>
  406e48:	2b20      	cmp	r3, #32
  406e4a:	d008      	beq.n	406e5e <SystemCoreClockUpdate+0xc6>
  406e4c:	2b00      	cmp	r3, #0
  406e4e:	d00e      	beq.n	406e6e <SystemCoreClockUpdate+0xd6>
				break;
  406e50:	e00e      	b.n	406e70 <SystemCoreClockUpdate+0xd8>
				SystemCoreClock *= 2U;
  406e52:	4b27      	ldr	r3, [pc, #156]	; (406ef0 <SystemCoreClockUpdate+0x158>)
  406e54:	681b      	ldr	r3, [r3, #0]
  406e56:	005b      	lsls	r3, r3, #1
  406e58:	4a25      	ldr	r2, [pc, #148]	; (406ef0 <SystemCoreClockUpdate+0x158>)
  406e5a:	6013      	str	r3, [r2, #0]
				break;
  406e5c:	e008      	b.n	406e70 <SystemCoreClockUpdate+0xd8>
				SystemCoreClock *= 3U;
  406e5e:	4b24      	ldr	r3, [pc, #144]	; (406ef0 <SystemCoreClockUpdate+0x158>)
  406e60:	681a      	ldr	r2, [r3, #0]
  406e62:	4613      	mov	r3, r2
  406e64:	005b      	lsls	r3, r3, #1
  406e66:	4413      	add	r3, r2
  406e68:	4a21      	ldr	r2, [pc, #132]	; (406ef0 <SystemCoreClockUpdate+0x158>)
  406e6a:	6013      	str	r3, [r2, #0]
				break;
  406e6c:	e000      	b.n	406e70 <SystemCoreClockUpdate+0xd8>
				break;
  406e6e:	bf00      	nop
		if ((uint32_t) (PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) == PMC_MCKR_CSS_PLLA_CLK)
  406e70:	4b1d      	ldr	r3, [pc, #116]	; (406ee8 <SystemCoreClockUpdate+0x150>)
  406e72:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  406e74:	f003 0303 	and.w	r3, r3, #3
  406e78:	2b02      	cmp	r3, #2
  406e7a:	d114      	bne.n	406ea6 <SystemCoreClockUpdate+0x10e>
			SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> CKGR_PLLAR_MULA_Pos) + 1U);
  406e7c:	4b1a      	ldr	r3, [pc, #104]	; (406ee8 <SystemCoreClockUpdate+0x150>)
  406e7e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  406e80:	0c1b      	lsrs	r3, r3, #16
  406e82:	f3c3 030a 	ubfx	r3, r3, #0, #11
  406e86:	3301      	adds	r3, #1
  406e88:	4a19      	ldr	r2, [pc, #100]	; (406ef0 <SystemCoreClockUpdate+0x158>)
  406e8a:	6812      	ldr	r2, [r2, #0]
  406e8c:	fb02 f303 	mul.w	r3, r2, r3
  406e90:	4a17      	ldr	r2, [pc, #92]	; (406ef0 <SystemCoreClockUpdate+0x158>)
  406e92:	6013      	str	r3, [r2, #0]
			SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk) >> CKGR_PLLAR_DIVA_Pos));
  406e94:	4b14      	ldr	r3, [pc, #80]	; (406ee8 <SystemCoreClockUpdate+0x150>)
  406e96:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  406e98:	b2db      	uxtb	r3, r3
  406e9a:	4a15      	ldr	r2, [pc, #84]	; (406ef0 <SystemCoreClockUpdate+0x158>)
  406e9c:	6812      	ldr	r2, [r2, #0]
  406e9e:	fbb2 f3f3 	udiv	r3, r2, r3
  406ea2:	4a13      	ldr	r2, [pc, #76]	; (406ef0 <SystemCoreClockUpdate+0x158>)
  406ea4:	6013      	str	r3, [r2, #0]
		break;
  406ea6:	bf00      	nop
	}

	if ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3) {
  406ea8:	4b0f      	ldr	r3, [pc, #60]	; (406ee8 <SystemCoreClockUpdate+0x150>)
  406eaa:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  406eac:	f003 0370 	and.w	r3, r3, #112	; 0x70
  406eb0:	2b70      	cmp	r3, #112	; 0x70
  406eb2:	d108      	bne.n	406ec6 <SystemCoreClockUpdate+0x12e>
		SystemCoreClock /= 3U;
  406eb4:	4b0e      	ldr	r3, [pc, #56]	; (406ef0 <SystemCoreClockUpdate+0x158>)
  406eb6:	681b      	ldr	r3, [r3, #0]
  406eb8:	4a10      	ldr	r2, [pc, #64]	; (406efc <SystemCoreClockUpdate+0x164>)
  406eba:	fba2 2303 	umull	r2, r3, r2, r3
  406ebe:	085b      	lsrs	r3, r3, #1
  406ec0:	4a0b      	ldr	r2, [pc, #44]	; (406ef0 <SystemCoreClockUpdate+0x158>)
  406ec2:	6013      	str	r3, [r2, #0]
	} else {
		SystemCoreClock >>= ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) >>
				PMC_MCKR_PRES_Pos);
	}
}
  406ec4:	e00a      	b.n	406edc <SystemCoreClockUpdate+0x144>
		SystemCoreClock >>= ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) >>
  406ec6:	4b08      	ldr	r3, [pc, #32]	; (406ee8 <SystemCoreClockUpdate+0x150>)
  406ec8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  406eca:	091b      	lsrs	r3, r3, #4
  406ecc:	f003 0307 	and.w	r3, r3, #7
  406ed0:	4a07      	ldr	r2, [pc, #28]	; (406ef0 <SystemCoreClockUpdate+0x158>)
  406ed2:	6812      	ldr	r2, [r2, #0]
  406ed4:	fa22 f303 	lsr.w	r3, r2, r3
  406ed8:	4a05      	ldr	r2, [pc, #20]	; (406ef0 <SystemCoreClockUpdate+0x158>)
  406eda:	6013      	str	r3, [r2, #0]
}
  406edc:	bf00      	nop
  406ede:	46bd      	mov	sp, r7
  406ee0:	f85d 7b04 	ldr.w	r7, [sp], #4
  406ee4:	4770      	bx	lr
  406ee6:	bf00      	nop
  406ee8:	400e0400 	.word	0x400e0400
  406eec:	400e1810 	.word	0x400e1810
  406ef0:	200000c8 	.word	0x200000c8
  406ef4:	00b71b00 	.word	0x00b71b00
  406ef8:	003d0900 	.word	0x003d0900
  406efc:	aaaaaaab 	.word	0xaaaaaaab

00406f00 <system_init_flash>:

/**
 * Initialize flash.
 */
void system_init_flash( uint32_t ul_clk )
{
  406f00:	b480      	push	{r7}
  406f02:	b083      	sub	sp, #12
  406f04:	af00      	add	r7, sp, #0
  406f06:	6078      	str	r0, [r7, #4]
	/* Set FWS for embedded Flash access according to operating frequency */
	if ( ul_clk < CHIP_FREQ_FWS_0 ) {
  406f08:	687b      	ldr	r3, [r7, #4]
  406f0a:	4a19      	ldr	r2, [pc, #100]	; (406f70 <system_init_flash+0x70>)
  406f0c:	4293      	cmp	r3, r2
  406f0e:	d804      	bhi.n	406f1a <system_init_flash+0x1a>
		EFC->EEFC_FMR = EEFC_FMR_FWS(0)|EEFC_FMR_CLOE;
  406f10:	4b18      	ldr	r3, [pc, #96]	; (406f74 <system_init_flash+0x74>)
  406f12:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
  406f16:	601a      	str	r2, [r3, #0]
					}
				}
			}
		}
	}
}
  406f18:	e023      	b.n	406f62 <system_init_flash+0x62>
		if (ul_clk < CHIP_FREQ_FWS_1) {
  406f1a:	687b      	ldr	r3, [r7, #4]
  406f1c:	4a16      	ldr	r2, [pc, #88]	; (406f78 <system_init_flash+0x78>)
  406f1e:	4293      	cmp	r3, r2
  406f20:	d803      	bhi.n	406f2a <system_init_flash+0x2a>
			EFC->EEFC_FMR = EEFC_FMR_FWS(1)|EEFC_FMR_CLOE;
  406f22:	4b14      	ldr	r3, [pc, #80]	; (406f74 <system_init_flash+0x74>)
  406f24:	4a15      	ldr	r2, [pc, #84]	; (406f7c <system_init_flash+0x7c>)
  406f26:	601a      	str	r2, [r3, #0]
}
  406f28:	e01b      	b.n	406f62 <system_init_flash+0x62>
			if (ul_clk < CHIP_FREQ_FWS_2) {
  406f2a:	687b      	ldr	r3, [r7, #4]
  406f2c:	4a14      	ldr	r2, [pc, #80]	; (406f80 <system_init_flash+0x80>)
  406f2e:	4293      	cmp	r3, r2
  406f30:	d803      	bhi.n	406f3a <system_init_flash+0x3a>
				EFC->EEFC_FMR = EEFC_FMR_FWS(2)|EEFC_FMR_CLOE;
  406f32:	4b10      	ldr	r3, [pc, #64]	; (406f74 <system_init_flash+0x74>)
  406f34:	4a13      	ldr	r2, [pc, #76]	; (406f84 <system_init_flash+0x84>)
  406f36:	601a      	str	r2, [r3, #0]
}
  406f38:	e013      	b.n	406f62 <system_init_flash+0x62>
				if ( ul_clk < CHIP_FREQ_FWS_3 ) {
  406f3a:	687b      	ldr	r3, [r7, #4]
  406f3c:	4a12      	ldr	r2, [pc, #72]	; (406f88 <system_init_flash+0x88>)
  406f3e:	4293      	cmp	r3, r2
  406f40:	d803      	bhi.n	406f4a <system_init_flash+0x4a>
					EFC->EEFC_FMR = EEFC_FMR_FWS(3)|EEFC_FMR_CLOE;
  406f42:	4b0c      	ldr	r3, [pc, #48]	; (406f74 <system_init_flash+0x74>)
  406f44:	4a11      	ldr	r2, [pc, #68]	; (406f8c <system_init_flash+0x8c>)
  406f46:	601a      	str	r2, [r3, #0]
}
  406f48:	e00b      	b.n	406f62 <system_init_flash+0x62>
					if ( ul_clk < CHIP_FREQ_FWS_4 ) {
  406f4a:	687b      	ldr	r3, [r7, #4]
  406f4c:	4a10      	ldr	r2, [pc, #64]	; (406f90 <system_init_flash+0x90>)
  406f4e:	4293      	cmp	r3, r2
  406f50:	d804      	bhi.n	406f5c <system_init_flash+0x5c>
						EFC->EEFC_FMR = EEFC_FMR_FWS(4)|EEFC_FMR_CLOE;
  406f52:	4b08      	ldr	r3, [pc, #32]	; (406f74 <system_init_flash+0x74>)
  406f54:	f04f 2204 	mov.w	r2, #67109888	; 0x4000400
  406f58:	601a      	str	r2, [r3, #0]
}
  406f5a:	e002      	b.n	406f62 <system_init_flash+0x62>
						EFC->EEFC_FMR = EEFC_FMR_FWS(5)|EEFC_FMR_CLOE;
  406f5c:	4b05      	ldr	r3, [pc, #20]	; (406f74 <system_init_flash+0x74>)
  406f5e:	4a0d      	ldr	r2, [pc, #52]	; (406f94 <system_init_flash+0x94>)
  406f60:	601a      	str	r2, [r3, #0]
}
  406f62:	bf00      	nop
  406f64:	370c      	adds	r7, #12
  406f66:	46bd      	mov	sp, r7
  406f68:	f85d 7b04 	ldr.w	r7, [sp], #4
  406f6c:	4770      	bx	lr
  406f6e:	bf00      	nop
  406f70:	01312cff 	.word	0x01312cff
  406f74:	400e0a00 	.word	0x400e0a00
  406f78:	026259ff 	.word	0x026259ff
  406f7c:	04000100 	.word	0x04000100
  406f80:	039386ff 	.word	0x039386ff
  406f84:	04000200 	.word	0x04000200
  406f88:	04c4b3ff 	.word	0x04c4b3ff
  406f8c:	04000300 	.word	0x04000300
  406f90:	05f5e0ff 	.word	0x05f5e0ff
  406f94:	04000500 	.word	0x04000500

00406f98 <_sbrk>:
extern void _exit(int status);
extern void _kill(int pid, int sig);
extern int _getpid(void);

extern caddr_t _sbrk(int incr)
{
  406f98:	b480      	push	{r7}
  406f9a:	b085      	sub	sp, #20
  406f9c:	af00      	add	r7, sp, #0
  406f9e:	6078      	str	r0, [r7, #4]
	static unsigned char *heap = NULL;
	unsigned char *prev_heap;
	int ramend = (int)&__ram_end__;
  406fa0:	4b10      	ldr	r3, [pc, #64]	; (406fe4 <_sbrk+0x4c>)
  406fa2:	60fb      	str	r3, [r7, #12]

	if (heap == NULL) {
  406fa4:	4b10      	ldr	r3, [pc, #64]	; (406fe8 <_sbrk+0x50>)
  406fa6:	681b      	ldr	r3, [r3, #0]
  406fa8:	2b00      	cmp	r3, #0
  406faa:	d102      	bne.n	406fb2 <_sbrk+0x1a>
		heap = (unsigned char *)&_end;
  406fac:	4b0e      	ldr	r3, [pc, #56]	; (406fe8 <_sbrk+0x50>)
  406fae:	4a0f      	ldr	r2, [pc, #60]	; (406fec <_sbrk+0x54>)
  406fb0:	601a      	str	r2, [r3, #0]
	}
	prev_heap = heap;
  406fb2:	4b0d      	ldr	r3, [pc, #52]	; (406fe8 <_sbrk+0x50>)
  406fb4:	681b      	ldr	r3, [r3, #0]
  406fb6:	60bb      	str	r3, [r7, #8]

	if (((int)prev_heap + incr) > ramend) {
  406fb8:	68ba      	ldr	r2, [r7, #8]
  406fba:	687b      	ldr	r3, [r7, #4]
  406fbc:	441a      	add	r2, r3
  406fbe:	68fb      	ldr	r3, [r7, #12]
  406fc0:	429a      	cmp	r2, r3
  406fc2:	dd02      	ble.n	406fca <_sbrk+0x32>
		return (caddr_t) -1;	
  406fc4:	f04f 33ff 	mov.w	r3, #4294967295
  406fc8:	e006      	b.n	406fd8 <_sbrk+0x40>
	}

	heap += incr;
  406fca:	4b07      	ldr	r3, [pc, #28]	; (406fe8 <_sbrk+0x50>)
  406fcc:	681a      	ldr	r2, [r3, #0]
  406fce:	687b      	ldr	r3, [r7, #4]
  406fd0:	4413      	add	r3, r2
  406fd2:	4a05      	ldr	r2, [pc, #20]	; (406fe8 <_sbrk+0x50>)
  406fd4:	6013      	str	r3, [r2, #0]

	return (caddr_t) prev_heap;
  406fd6:	68bb      	ldr	r3, [r7, #8]
}
  406fd8:	4618      	mov	r0, r3
  406fda:	3714      	adds	r7, #20
  406fdc:	46bd      	mov	sp, r7
  406fde:	f85d 7b04 	ldr.w	r7, [sp], #4
  406fe2:	4770      	bx	lr
  406fe4:	2001fffc 	.word	0x2001fffc
  406fe8:	20006c78 	.word	0x20006c78
  406fec:	2000ed20 	.word	0x2000ed20

00406ff0 <_close>:
{
	return -1;
}

extern int _close(int file)
{
  406ff0:	b480      	push	{r7}
  406ff2:	b083      	sub	sp, #12
  406ff4:	af00      	add	r7, sp, #0
  406ff6:	6078      	str	r0, [r7, #4]
	return -1;
  406ff8:	f04f 33ff 	mov.w	r3, #4294967295
}
  406ffc:	4618      	mov	r0, r3
  406ffe:	370c      	adds	r7, #12
  407000:	46bd      	mov	sp, r7
  407002:	f85d 7b04 	ldr.w	r7, [sp], #4
  407006:	4770      	bx	lr

00407008 <_fstat>:

extern int _fstat(int file, struct stat *st)
{
  407008:	b480      	push	{r7}
  40700a:	b083      	sub	sp, #12
  40700c:	af00      	add	r7, sp, #0
  40700e:	6078      	str	r0, [r7, #4]
  407010:	6039      	str	r1, [r7, #0]
	st->st_mode = S_IFCHR;
  407012:	683b      	ldr	r3, [r7, #0]
  407014:	f44f 5200 	mov.w	r2, #8192	; 0x2000
  407018:	605a      	str	r2, [r3, #4]

	return 0;
  40701a:	2300      	movs	r3, #0
}
  40701c:	4618      	mov	r0, r3
  40701e:	370c      	adds	r7, #12
  407020:	46bd      	mov	sp, r7
  407022:	f85d 7b04 	ldr.w	r7, [sp], #4
  407026:	4770      	bx	lr

00407028 <_isatty>:

extern int _isatty(int file)
{
  407028:	b480      	push	{r7}
  40702a:	b083      	sub	sp, #12
  40702c:	af00      	add	r7, sp, #0
  40702e:	6078      	str	r0, [r7, #4]
	return 1;
  407030:	2301      	movs	r3, #1
}
  407032:	4618      	mov	r0, r3
  407034:	370c      	adds	r7, #12
  407036:	46bd      	mov	sp, r7
  407038:	f85d 7b04 	ldr.w	r7, [sp], #4
  40703c:	4770      	bx	lr

0040703e <_lseek>:

extern int _lseek(int file, int ptr, int dir)
{
  40703e:	b480      	push	{r7}
  407040:	b085      	sub	sp, #20
  407042:	af00      	add	r7, sp, #0
  407044:	60f8      	str	r0, [r7, #12]
  407046:	60b9      	str	r1, [r7, #8]
  407048:	607a      	str	r2, [r7, #4]
	return 0;
  40704a:	2300      	movs	r3, #0
}
  40704c:	4618      	mov	r0, r3
  40704e:	3714      	adds	r7, #20
  407050:	46bd      	mov	sp, r7
  407052:	f85d 7b04 	ldr.w	r7, [sp], #4
  407056:	4770      	bx	lr

00407058 <eARPProcessPacket>:
};

/*-----------------------------------------------------------*/

eFrameProcessingResult_t eARPProcessPacket( ARPPacket_t * const pxARPFrame )
{
  407058:	b580      	push	{r7, lr}
  40705a:	b086      	sub	sp, #24
  40705c:	af00      	add	r7, sp, #0
  40705e:	6078      	str	r0, [r7, #4]
eFrameProcessingResult_t eReturn = eReleaseBuffer;
  407060:	2300      	movs	r3, #0
  407062:	75fb      	strb	r3, [r7, #23]
ARPHeader_t *pxARPHeader;
uint32_t ulTargetProtocolAddress, ulSenderProtocolAddress;

	pxARPHeader = &( pxARPFrame->xARPHeader );
  407064:	687b      	ldr	r3, [r7, #4]
  407066:	330e      	adds	r3, #14
  407068:	613b      	str	r3, [r7, #16]

	/* The field ulSenderProtocolAddress is badly aligned, copy byte-by-byte. */
	memcpy( ( void *)&( ulSenderProtocolAddress ), ( void * )pxARPHeader->ucSenderProtocolAddress, sizeof( ulSenderProtocolAddress ) );
  40706a:	693b      	ldr	r3, [r7, #16]
  40706c:	330e      	adds	r3, #14
  40706e:	681b      	ldr	r3, [r3, #0]
  407070:	60bb      	str	r3, [r7, #8]
	/* The field ulTargetProtocolAddress is well-aligned, a 32-bits copy. */
	ulTargetProtocolAddress = pxARPHeader->ulTargetProtocolAddress;
  407072:	693b      	ldr	r3, [r7, #16]
  407074:	699b      	ldr	r3, [r3, #24]
  407076:	60fb      	str	r3, [r7, #12]

	traceARP_PACKET_RECEIVED();

	/* Don't do anything if the local IP address is zero because
	that means a DHCP request has not completed. */
	if( *ipLOCAL_IP_ADDRESS_POINTER != 0UL )
  407078:	4b32      	ldr	r3, [pc, #200]	; (407144 <eARPProcessPacket+0xec>)
  40707a:	695b      	ldr	r3, [r3, #20]
  40707c:	2b00      	cmp	r3, #0
  40707e:	d05c      	beq.n	40713a <eARPProcessPacket+0xe2>
	{
		switch( pxARPHeader->usOperation )
  407080:	693b      	ldr	r3, [r7, #16]
  407082:	88db      	ldrh	r3, [r3, #6]
  407084:	b29b      	uxth	r3, r3
  407086:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
  40708a:	d003      	beq.n	407094 <eARPProcessPacket+0x3c>
  40708c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
  407090:	d04a      	beq.n	407128 <eARPProcessPacket+0xd0>
				#endif /* ipconfigARP_USE_CLASH_DETECTION */
				break;

			default :
				/* Invalid. */
				break;
  407092:	e052      	b.n	40713a <eARPProcessPacket+0xe2>
				if( ulTargetProtocolAddress == *ipLOCAL_IP_ADDRESS_POINTER )
  407094:	4b2b      	ldr	r3, [pc, #172]	; (407144 <eARPProcessPacket+0xec>)
  407096:	695a      	ldr	r2, [r3, #20]
  407098:	68fb      	ldr	r3, [r7, #12]
  40709a:	429a      	cmp	r2, r3
  40709c:	d14c      	bne.n	407138 <eARPProcessPacket+0xe0>
					vARPRefreshCacheEntry( &( pxARPHeader->xSenderHardwareAddress ), ulSenderProtocolAddress );
  40709e:	693b      	ldr	r3, [r7, #16]
  4070a0:	3308      	adds	r3, #8
  4070a2:	68ba      	ldr	r2, [r7, #8]
  4070a4:	4611      	mov	r1, r2
  4070a6:	4618      	mov	r0, r3
  4070a8:	4b27      	ldr	r3, [pc, #156]	; (407148 <eARPProcessPacket+0xf0>)
  4070aa:	4798      	blx	r3
					pxARPHeader->usOperation = ( uint16_t ) ipARP_REPLY;
  4070ac:	693b      	ldr	r3, [r7, #16]
  4070ae:	2200      	movs	r2, #0
  4070b0:	719a      	strb	r2, [r3, #6]
  4070b2:	2200      	movs	r2, #0
  4070b4:	f042 0202 	orr.w	r2, r2, #2
  4070b8:	71da      	strb	r2, [r3, #7]
					if( ulTargetProtocolAddress == ulSenderProtocolAddress )
  4070ba:	68bb      	ldr	r3, [r7, #8]
  4070bc:	68fa      	ldr	r2, [r7, #12]
  4070be:	429a      	cmp	r2, r3
  4070c0:	d117      	bne.n	4070f2 <eARPProcessPacket+0x9a>
						memcpy( pxARPFrame->xEthernetHeader.xSourceAddress.ucBytes, xBroadcastMACAddress.ucBytes, sizeof( xBroadcastMACAddress ) );
  4070c2:	687b      	ldr	r3, [r7, #4]
  4070c4:	3306      	adds	r3, #6
  4070c6:	4a21      	ldr	r2, [pc, #132]	; (40714c <eARPProcessPacket+0xf4>)
  4070c8:	6811      	ldr	r1, [r2, #0]
  4070ca:	6019      	str	r1, [r3, #0]
  4070cc:	8892      	ldrh	r2, [r2, #4]
  4070ce:	809a      	strh	r2, [r3, #4]
						memset( pxARPHeader->xTargetHardwareAddress.ucBytes, '\0', sizeof( MACAddress_t ) );
  4070d0:	693b      	ldr	r3, [r7, #16]
  4070d2:	3312      	adds	r3, #18
  4070d4:	2206      	movs	r2, #6
  4070d6:	2100      	movs	r1, #0
  4070d8:	4618      	mov	r0, r3
  4070da:	4b1d      	ldr	r3, [pc, #116]	; (407150 <eARPProcessPacket+0xf8>)
  4070dc:	4798      	blx	r3
						pxARPHeader->ulTargetProtocolAddress = 0UL;
  4070de:	693b      	ldr	r3, [r7, #16]
  4070e0:	2200      	movs	r2, #0
  4070e2:	761a      	strb	r2, [r3, #24]
  4070e4:	2200      	movs	r2, #0
  4070e6:	765a      	strb	r2, [r3, #25]
  4070e8:	2200      	movs	r2, #0
  4070ea:	769a      	strb	r2, [r3, #26]
  4070ec:	2200      	movs	r2, #0
  4070ee:	76da      	strb	r2, [r3, #27]
  4070f0:	e00b      	b.n	40710a <eARPProcessPacket+0xb2>
						memcpy( pxARPHeader->xTargetHardwareAddress.ucBytes, pxARPHeader->xSenderHardwareAddress.ucBytes, sizeof( MACAddress_t ) );
  4070f2:	693b      	ldr	r3, [r7, #16]
  4070f4:	f103 0012 	add.w	r0, r3, #18
  4070f8:	693b      	ldr	r3, [r7, #16]
  4070fa:	3308      	adds	r3, #8
  4070fc:	2206      	movs	r2, #6
  4070fe:	4619      	mov	r1, r3
  407100:	4b14      	ldr	r3, [pc, #80]	; (407154 <eARPProcessPacket+0xfc>)
  407102:	4798      	blx	r3
						pxARPHeader->ulTargetProtocolAddress = ulSenderProtocolAddress;
  407104:	68ba      	ldr	r2, [r7, #8]
  407106:	693b      	ldr	r3, [r7, #16]
  407108:	619a      	str	r2, [r3, #24]
					memcpy( pxARPHeader->xSenderHardwareAddress.ucBytes, ( void * ) ipLOCAL_MAC_ADDRESS, sizeof( MACAddress_t ) );
  40710a:	693b      	ldr	r3, [r7, #16]
  40710c:	3308      	adds	r3, #8
  40710e:	2206      	movs	r2, #6
  407110:	490c      	ldr	r1, [pc, #48]	; (407144 <eARPProcessPacket+0xec>)
  407112:	4618      	mov	r0, r3
  407114:	4b0f      	ldr	r3, [pc, #60]	; (407154 <eARPProcessPacket+0xfc>)
  407116:	4798      	blx	r3
					memcpy( ( void* )pxARPHeader->ucSenderProtocolAddress, ( void* )ipLOCAL_IP_ADDRESS_POINTER, sizeof( pxARPHeader->ucSenderProtocolAddress ) );
  407118:	693b      	ldr	r3, [r7, #16]
  40711a:	330e      	adds	r3, #14
  40711c:	4a09      	ldr	r2, [pc, #36]	; (407144 <eARPProcessPacket+0xec>)
  40711e:	6952      	ldr	r2, [r2, #20]
  407120:	601a      	str	r2, [r3, #0]
					eReturn = eReturnEthernetFrame;
  407122:	2302      	movs	r3, #2
  407124:	75fb      	strb	r3, [r7, #23]
				break;
  407126:	e007      	b.n	407138 <eARPProcessPacket+0xe0>
				vARPRefreshCacheEntry( &( pxARPHeader->xSenderHardwareAddress ), ulSenderProtocolAddress );
  407128:	693b      	ldr	r3, [r7, #16]
  40712a:	3308      	adds	r3, #8
  40712c:	68ba      	ldr	r2, [r7, #8]
  40712e:	4611      	mov	r1, r2
  407130:	4618      	mov	r0, r3
  407132:	4b05      	ldr	r3, [pc, #20]	; (407148 <eARPProcessPacket+0xf0>)
  407134:	4798      	blx	r3
				break;
  407136:	e000      	b.n	40713a <eARPProcessPacket+0xe2>
				break;
  407138:	bf00      	nop
		}
	}

	return eReturn;
  40713a:	7dfb      	ldrb	r3, [r7, #23]
}
  40713c:	4618      	mov	r0, r3
  40713e:	3718      	adds	r7, #24
  407140:	46bd      	mov	sp, r7
  407142:	bd80      	pop	{r7, pc}
  407144:	20000108 	.word	0x20000108
  407148:	00407159 	.word	0x00407159
  40714c:	0041ca10 	.word	0x0041ca10
  407150:	00416f01 	.word	0x00416f01
  407154:	00416d05 	.word	0x00416d05

00407158 <vARPRefreshCacheEntry>:

#endif	/* ipconfigUSE_ARP_REMOVE_ENTRY != 0 */
/*-----------------------------------------------------------*/

void vARPRefreshCacheEntry( const MACAddress_t * pxMACAddress, const uint32_t ulIPAddress )
{
  407158:	b580      	push	{r7, lr}
  40715a:	b088      	sub	sp, #32
  40715c:	af00      	add	r7, sp, #0
  40715e:	6078      	str	r0, [r7, #4]
  407160:	6039      	str	r1, [r7, #0]
BaseType_t x = 0;
  407162:	2300      	movs	r3, #0
  407164:	61fb      	str	r3, [r7, #28]
BaseType_t xIpEntry = -1;
  407166:	f04f 33ff 	mov.w	r3, #4294967295
  40716a:	61bb      	str	r3, [r7, #24]
BaseType_t xMacEntry = -1;
  40716c:	f04f 33ff 	mov.w	r3, #4294967295
  407170:	617b      	str	r3, [r7, #20]
BaseType_t xUseEntry = 0;
  407172:	2300      	movs	r3, #0
  407174:	613b      	str	r3, [r7, #16]
uint8_t ucMinAgeFound = 0U;
  407176:	2300      	movs	r3, #0
  407178:	73fb      	strb	r3, [r7, #15]

	#if( ipconfigARP_STORES_REMOTE_ADDRESSES == 0 )
		/* Only process the IP address if it is on the local network.
		Unless: when '*ipLOCAL_IP_ADDRESS_POINTER' equals zero, the IP-address
		and netmask are still unknown. */
		if( ( ( ulIPAddress & xNetworkAddressing.ulNetMask ) == ( ( *ipLOCAL_IP_ADDRESS_POINTER ) & xNetworkAddressing.ulNetMask ) ) ||
  40717a:	4b71      	ldr	r3, [pc, #452]	; (407340 <vARPRefreshCacheEntry+0x1e8>)
  40717c:	695a      	ldr	r2, [r3, #20]
  40717e:	683b      	ldr	r3, [r7, #0]
  407180:	405a      	eors	r2, r3
  407182:	4b70      	ldr	r3, [pc, #448]	; (407344 <vARPRefreshCacheEntry+0x1ec>)
  407184:	685b      	ldr	r3, [r3, #4]
  407186:	4013      	ands	r3, r2
  407188:	2b00      	cmp	r3, #0
  40718a:	d004      	beq.n	407196 <vARPRefreshCacheEntry+0x3e>
			( *ipLOCAL_IP_ADDRESS_POINTER == 0ul ) )
  40718c:	4b6c      	ldr	r3, [pc, #432]	; (407340 <vARPRefreshCacheEntry+0x1e8>)
  40718e:	695b      	ldr	r3, [r3, #20]
		if( ( ( ulIPAddress & xNetworkAddressing.ulNetMask ) == ( ( *ipLOCAL_IP_ADDRESS_POINTER ) & xNetworkAddressing.ulNetMask ) ) ||
  407190:	2b00      	cmp	r3, #0
  407192:	f040 80d2 	bne.w	40733a <vARPRefreshCacheEntry+0x1e2>
		zero the the gateway address is the only option. */
		if( pdTRUE )
	#endif
	{
		/* Start with the maximum possible number. */
		ucMinAgeFound--;
  407196:	7bfb      	ldrb	r3, [r7, #15]
  407198:	3b01      	subs	r3, #1
  40719a:	73fb      	strb	r3, [r7, #15]

		/* For each entry in the ARP cache table. */
		for( x = 0; x < ipconfigARP_CACHE_ENTRIES; x++ )
  40719c:	2300      	movs	r3, #0
  40719e:	61fb      	str	r3, [r7, #28]
  4071a0:	e069      	b.n	407276 <vARPRefreshCacheEntry+0x11e>
		{
			/* Does this line in the cache table hold an entry for the IP
			address	being queried? */
			if( xARPCache[ x ].ulIPAddress == ulIPAddress )
  4071a2:	4969      	ldr	r1, [pc, #420]	; (407348 <vARPRefreshCacheEntry+0x1f0>)
  4071a4:	69fa      	ldr	r2, [r7, #28]
  4071a6:	4613      	mov	r3, r2
  4071a8:	005b      	lsls	r3, r3, #1
  4071aa:	4413      	add	r3, r2
  4071ac:	009b      	lsls	r3, r3, #2
  4071ae:	440b      	add	r3, r1
  4071b0:	681a      	ldr	r2, [r3, #0]
  4071b2:	683b      	ldr	r3, [r7, #0]
  4071b4:	429a      	cmp	r2, r3
  4071b6:	d12d      	bne.n	407214 <vARPRefreshCacheEntry+0xbc>
			{
				if( pxMACAddress == NULL )
  4071b8:	687b      	ldr	r3, [r7, #4]
  4071ba:	2b00      	cmp	r3, #0
  4071bc:	d102      	bne.n	4071c4 <vARPRefreshCacheEntry+0x6c>
				{
					/* In case the parameter pxMACAddress is NULL, an entry will be reserved to
					indicate that there is an outstanding ARP request, This entry will have
					"ucValid == pdFALSE". */
					xIpEntry = x;
  4071be:	69fb      	ldr	r3, [r7, #28]
  4071c0:	61bb      	str	r3, [r7, #24]
					break;
  4071c2:	e05b      	b.n	40727c <vARPRefreshCacheEntry+0x124>
				}

				/* See if the MAC-address also matches. */
				if( memcmp( xARPCache[ x ].xMACAddress.ucBytes, pxMACAddress->ucBytes, sizeof( pxMACAddress->ucBytes ) ) == 0 )
  4071c4:	69fa      	ldr	r2, [r7, #28]
  4071c6:	4613      	mov	r3, r2
  4071c8:	005b      	lsls	r3, r3, #1
  4071ca:	4413      	add	r3, r2
  4071cc:	009b      	lsls	r3, r3, #2
  4071ce:	4a5e      	ldr	r2, [pc, #376]	; (407348 <vARPRefreshCacheEntry+0x1f0>)
  4071d0:	4413      	add	r3, r2
  4071d2:	3304      	adds	r3, #4
  4071d4:	6879      	ldr	r1, [r7, #4]
  4071d6:	2206      	movs	r2, #6
  4071d8:	4618      	mov	r0, r3
  4071da:	4b5c      	ldr	r3, [pc, #368]	; (40734c <vARPRefreshCacheEntry+0x1f4>)
  4071dc:	4798      	blx	r3
  4071de:	4603      	mov	r3, r0
  4071e0:	2b00      	cmp	r3, #0
  4071e2:	d114      	bne.n	40720e <vARPRefreshCacheEntry+0xb6>
				{
					/* This function will be called for each received packet
					As this is by far the most common path the coding standard
					is relaxed in this case and a return is permitted as an
					optimisation. */
					xARPCache[ x ].ucAge = ( uint8_t ) ipconfigMAX_ARP_AGE;
  4071e4:	4958      	ldr	r1, [pc, #352]	; (407348 <vARPRefreshCacheEntry+0x1f0>)
  4071e6:	69fa      	ldr	r2, [r7, #28]
  4071e8:	4613      	mov	r3, r2
  4071ea:	005b      	lsls	r3, r3, #1
  4071ec:	4413      	add	r3, r2
  4071ee:	009b      	lsls	r3, r3, #2
  4071f0:	440b      	add	r3, r1
  4071f2:	330a      	adds	r3, #10
  4071f4:	2296      	movs	r2, #150	; 0x96
  4071f6:	701a      	strb	r2, [r3, #0]
					xARPCache[ x ].ucValid = ( uint8_t ) pdTRUE;
  4071f8:	4953      	ldr	r1, [pc, #332]	; (407348 <vARPRefreshCacheEntry+0x1f0>)
  4071fa:	69fa      	ldr	r2, [r7, #28]
  4071fc:	4613      	mov	r3, r2
  4071fe:	005b      	lsls	r3, r3, #1
  407200:	4413      	add	r3, r2
  407202:	009b      	lsls	r3, r3, #2
  407204:	440b      	add	r3, r1
  407206:	330b      	adds	r3, #11
  407208:	2201      	movs	r2, #1
  40720a:	701a      	strb	r2, [r3, #0]
					return;
  40720c:	e095      	b.n	40733a <vARPRefreshCacheEntry+0x1e2>
				/* Found an entry containing ulIPAddress, but the MAC address
				doesn't match.  Might be an entry with ucValid=pdFALSE, waiting
				for an ARP reply.  Still want to see if there is match with the
				given MAC address.ucBytes.  If found, either of the two entries
				must be cleared. */
				xIpEntry = x;
  40720e:	69fb      	ldr	r3, [r7, #28]
  407210:	61bb      	str	r3, [r7, #24]
  407212:	e02d      	b.n	407270 <vARPRefreshCacheEntry+0x118>
			}
			else if( ( pxMACAddress != NULL ) && ( memcmp( xARPCache[ x ].xMACAddress.ucBytes, pxMACAddress->ucBytes, sizeof( pxMACAddress->ucBytes ) ) == 0 ) )
  407214:	687b      	ldr	r3, [r7, #4]
  407216:	2b00      	cmp	r3, #0
  407218:	d012      	beq.n	407240 <vARPRefreshCacheEntry+0xe8>
  40721a:	69fa      	ldr	r2, [r7, #28]
  40721c:	4613      	mov	r3, r2
  40721e:	005b      	lsls	r3, r3, #1
  407220:	4413      	add	r3, r2
  407222:	009b      	lsls	r3, r3, #2
  407224:	4a48      	ldr	r2, [pc, #288]	; (407348 <vARPRefreshCacheEntry+0x1f0>)
  407226:	4413      	add	r3, r2
  407228:	3304      	adds	r3, #4
  40722a:	6879      	ldr	r1, [r7, #4]
  40722c:	2206      	movs	r2, #6
  40722e:	4618      	mov	r0, r3
  407230:	4b46      	ldr	r3, [pc, #280]	; (40734c <vARPRefreshCacheEntry+0x1f4>)
  407232:	4798      	blx	r3
  407234:	4603      	mov	r3, r0
  407236:	2b00      	cmp	r3, #0
  407238:	d102      	bne.n	407240 <vARPRefreshCacheEntry+0xe8>
				if( bIsLocal[ 0 ] == bIsLocal[ 1 ] )
				{
					xMacEntry = x;
				}
	#else
				xMacEntry = x;
  40723a:	69fb      	ldr	r3, [r7, #28]
  40723c:	617b      	str	r3, [r7, #20]
  40723e:	e017      	b.n	407270 <vARPRefreshCacheEntry+0x118>
	#endif
			}
			/* _HT_
			Shouldn't we test for xARPCache[ x ].ucValid == pdFALSE here ? */
			else if( xARPCache[ x ].ucAge < ucMinAgeFound )
  407240:	4941      	ldr	r1, [pc, #260]	; (407348 <vARPRefreshCacheEntry+0x1f0>)
  407242:	69fa      	ldr	r2, [r7, #28]
  407244:	4613      	mov	r3, r2
  407246:	005b      	lsls	r3, r3, #1
  407248:	4413      	add	r3, r2
  40724a:	009b      	lsls	r3, r3, #2
  40724c:	440b      	add	r3, r1
  40724e:	330a      	adds	r3, #10
  407250:	781b      	ldrb	r3, [r3, #0]
  407252:	7bfa      	ldrb	r2, [r7, #15]
  407254:	429a      	cmp	r2, r3
  407256:	d90b      	bls.n	407270 <vARPRefreshCacheEntry+0x118>
			{
				/* As the table is traversed, remember the table row that
				contains the oldest entry (the lowest age count, as ages are
				decremented to zero) so the row can be re-used if this function
				needs to add an entry that does not already exist. */
				ucMinAgeFound = xARPCache[ x ].ucAge;
  407258:	493b      	ldr	r1, [pc, #236]	; (407348 <vARPRefreshCacheEntry+0x1f0>)
  40725a:	69fa      	ldr	r2, [r7, #28]
  40725c:	4613      	mov	r3, r2
  40725e:	005b      	lsls	r3, r3, #1
  407260:	4413      	add	r3, r2
  407262:	009b      	lsls	r3, r3, #2
  407264:	440b      	add	r3, r1
  407266:	330a      	adds	r3, #10
  407268:	781b      	ldrb	r3, [r3, #0]
  40726a:	73fb      	strb	r3, [r7, #15]
				xUseEntry = x;
  40726c:	69fb      	ldr	r3, [r7, #28]
  40726e:	613b      	str	r3, [r7, #16]
		for( x = 0; x < ipconfigARP_CACHE_ENTRIES; x++ )
  407270:	69fb      	ldr	r3, [r7, #28]
  407272:	3301      	adds	r3, #1
  407274:	61fb      	str	r3, [r7, #28]
  407276:	69fb      	ldr	r3, [r7, #28]
  407278:	2b05      	cmp	r3, #5
  40727a:	dd92      	ble.n	4071a2 <vARPRefreshCacheEntry+0x4a>
			}
		}

		if( xMacEntry >= 0 )
  40727c:	697b      	ldr	r3, [r7, #20]
  40727e:	2b00      	cmp	r3, #0
  407280:	db11      	blt.n	4072a6 <vARPRefreshCacheEntry+0x14e>
		{
			xUseEntry = xMacEntry;
  407282:	697b      	ldr	r3, [r7, #20]
  407284:	613b      	str	r3, [r7, #16]

			if( xIpEntry >= 0 )
  407286:	69bb      	ldr	r3, [r7, #24]
  407288:	2b00      	cmp	r3, #0
  40728a:	db11      	blt.n	4072b0 <vARPRefreshCacheEntry+0x158>
			{
				/* Both the MAC address as well as the IP address were found in
				different locations: clear the entry which matches the
				IP-address */
				memset( &xARPCache[ xIpEntry ], '\0', sizeof( xARPCache[ xIpEntry ] ) );
  40728c:	69ba      	ldr	r2, [r7, #24]
  40728e:	4613      	mov	r3, r2
  407290:	005b      	lsls	r3, r3, #1
  407292:	4413      	add	r3, r2
  407294:	009b      	lsls	r3, r3, #2
  407296:	4a2c      	ldr	r2, [pc, #176]	; (407348 <vARPRefreshCacheEntry+0x1f0>)
  407298:	4413      	add	r3, r2
  40729a:	220c      	movs	r2, #12
  40729c:	2100      	movs	r1, #0
  40729e:	4618      	mov	r0, r3
  4072a0:	4b2b      	ldr	r3, [pc, #172]	; (407350 <vARPRefreshCacheEntry+0x1f8>)
  4072a2:	4798      	blx	r3
  4072a4:	e004      	b.n	4072b0 <vARPRefreshCacheEntry+0x158>
			}
		}
		else if( xIpEntry >= 0 )
  4072a6:	69bb      	ldr	r3, [r7, #24]
  4072a8:	2b00      	cmp	r3, #0
  4072aa:	db01      	blt.n	4072b0 <vARPRefreshCacheEntry+0x158>
		{
			/* An entry containing the IP-address was found, but it had a different MAC address */
			xUseEntry = xIpEntry;
  4072ac:	69bb      	ldr	r3, [r7, #24]
  4072ae:	613b      	str	r3, [r7, #16]
		}

		/* If the entry was not found, we use the oldest entry and set the IPaddress */
		xARPCache[ xUseEntry ].ulIPAddress = ulIPAddress;
  4072b0:	4925      	ldr	r1, [pc, #148]	; (407348 <vARPRefreshCacheEntry+0x1f0>)
  4072b2:	693a      	ldr	r2, [r7, #16]
  4072b4:	4613      	mov	r3, r2
  4072b6:	005b      	lsls	r3, r3, #1
  4072b8:	4413      	add	r3, r2
  4072ba:	009b      	lsls	r3, r3, #2
  4072bc:	440b      	add	r3, r1
  4072be:	683a      	ldr	r2, [r7, #0]
  4072c0:	601a      	str	r2, [r3, #0]

		if( pxMACAddress != NULL )
  4072c2:	687b      	ldr	r3, [r7, #4]
  4072c4:	2b00      	cmp	r3, #0
  4072c6:	d021      	beq.n	40730c <vARPRefreshCacheEntry+0x1b4>
		{
			memcpy( xARPCache[ xUseEntry ].xMACAddress.ucBytes, pxMACAddress->ucBytes, sizeof( pxMACAddress->ucBytes ) );
  4072c8:	693a      	ldr	r2, [r7, #16]
  4072ca:	4613      	mov	r3, r2
  4072cc:	005b      	lsls	r3, r3, #1
  4072ce:	4413      	add	r3, r2
  4072d0:	009b      	lsls	r3, r3, #2
  4072d2:	4a1d      	ldr	r2, [pc, #116]	; (407348 <vARPRefreshCacheEntry+0x1f0>)
  4072d4:	4413      	add	r3, r2
  4072d6:	3304      	adds	r3, #4
  4072d8:	6879      	ldr	r1, [r7, #4]
  4072da:	2206      	movs	r2, #6
  4072dc:	4618      	mov	r0, r3
  4072de:	4b1d      	ldr	r3, [pc, #116]	; (407354 <vARPRefreshCacheEntry+0x1fc>)
  4072e0:	4798      	blx	r3

			iptraceARP_TABLE_ENTRY_CREATED( ulIPAddress, (*pxMACAddress) );
			/* And this entry does not need immediate attention */
			xARPCache[ xUseEntry ].ucAge = ( uint8_t ) ipconfigMAX_ARP_AGE;
  4072e2:	4919      	ldr	r1, [pc, #100]	; (407348 <vARPRefreshCacheEntry+0x1f0>)
  4072e4:	693a      	ldr	r2, [r7, #16]
  4072e6:	4613      	mov	r3, r2
  4072e8:	005b      	lsls	r3, r3, #1
  4072ea:	4413      	add	r3, r2
  4072ec:	009b      	lsls	r3, r3, #2
  4072ee:	440b      	add	r3, r1
  4072f0:	330a      	adds	r3, #10
  4072f2:	2296      	movs	r2, #150	; 0x96
  4072f4:	701a      	strb	r2, [r3, #0]
			xARPCache[ xUseEntry ].ucValid = ( uint8_t ) pdTRUE;
  4072f6:	4914      	ldr	r1, [pc, #80]	; (407348 <vARPRefreshCacheEntry+0x1f0>)
  4072f8:	693a      	ldr	r2, [r7, #16]
  4072fa:	4613      	mov	r3, r2
  4072fc:	005b      	lsls	r3, r3, #1
  4072fe:	4413      	add	r3, r2
  407300:	009b      	lsls	r3, r3, #2
  407302:	440b      	add	r3, r1
  407304:	330b      	adds	r3, #11
  407306:	2201      	movs	r2, #1
  407308:	701a      	strb	r2, [r3, #0]
  40730a:	e016      	b.n	40733a <vARPRefreshCacheEntry+0x1e2>
		}
		else if( xIpEntry < 0 )
  40730c:	69bb      	ldr	r3, [r7, #24]
  40730e:	2b00      	cmp	r3, #0
  407310:	da13      	bge.n	40733a <vARPRefreshCacheEntry+0x1e2>
		{
			xARPCache[ xUseEntry ].ucAge = ( uint8_t ) ipconfigMAX_ARP_RETRANSMISSIONS;
  407312:	490d      	ldr	r1, [pc, #52]	; (407348 <vARPRefreshCacheEntry+0x1f0>)
  407314:	693a      	ldr	r2, [r7, #16]
  407316:	4613      	mov	r3, r2
  407318:	005b      	lsls	r3, r3, #1
  40731a:	4413      	add	r3, r2
  40731c:	009b      	lsls	r3, r3, #2
  40731e:	440b      	add	r3, r1
  407320:	330a      	adds	r3, #10
  407322:	2205      	movs	r2, #5
  407324:	701a      	strb	r2, [r3, #0]
			xARPCache[ xUseEntry ].ucValid = ( uint8_t ) pdFALSE;
  407326:	4908      	ldr	r1, [pc, #32]	; (407348 <vARPRefreshCacheEntry+0x1f0>)
  407328:	693a      	ldr	r2, [r7, #16]
  40732a:	4613      	mov	r3, r2
  40732c:	005b      	lsls	r3, r3, #1
  40732e:	4413      	add	r3, r2
  407330:	009b      	lsls	r3, r3, #2
  407332:	440b      	add	r3, r1
  407334:	330b      	adds	r3, #11
  407336:	2200      	movs	r2, #0
  407338:	701a      	strb	r2, [r3, #0]
		}
	}
}
  40733a:	3720      	adds	r7, #32
  40733c:	46bd      	mov	sp, r7
  40733e:	bd80      	pop	{r7, pc}
  407340:	20000108 	.word	0x20000108
  407344:	20006cd0 	.word	0x20006cd0
  407348:	20006c7c 	.word	0x20006c7c
  40734c:	00416ca5 	.word	0x00416ca5
  407350:	00416f01 	.word	0x00416f01
  407354:	00416d05 	.word	0x00416d05

00407358 <eARPGetCacheEntry>:
#endif /* ipconfigUSE_ARP_REVERSED_LOOKUP */

/*-----------------------------------------------------------*/

eARPLookupResult_t eARPGetCacheEntry( uint32_t *pulIPAddress, MACAddress_t * const pxMACAddress )
{
  407358:	b580      	push	{r7, lr}
  40735a:	b084      	sub	sp, #16
  40735c:	af00      	add	r7, sp, #0
  40735e:	6078      	str	r0, [r7, #4]
  407360:	6039      	str	r1, [r7, #0]
		memcpy( pxMACAddress->ucBytes, xLLMNR_MacAdress.ucBytes, sizeof( MACAddress_t ) );
		eReturn = eARPCacheHit;
	}
	else
#endif
	if( ( *pulIPAddress == ipBROADCAST_IP_ADDRESS ) ||	/* Is it the general broadcast address 255.255.255.255? */
  407362:	687b      	ldr	r3, [r7, #4]
  407364:	681b      	ldr	r3, [r3, #0]
  407366:	f1b3 3fff 	cmp.w	r3, #4294967295
  40736a:	d005      	beq.n	407378 <eARPGetCacheEntry+0x20>
		( *pulIPAddress == xNetworkAddressing.ulBroadcastAddress ) )/* Or a local broadcast address, eg 192.168.1.255? */
  40736c:	687b      	ldr	r3, [r7, #4]
  40736e:	681a      	ldr	r2, [r3, #0]
  407370:	4b24      	ldr	r3, [pc, #144]	; (407404 <eARPGetCacheEntry+0xac>)
  407372:	691b      	ldr	r3, [r3, #16]
	if( ( *pulIPAddress == ipBROADCAST_IP_ADDRESS ) ||	/* Is it the general broadcast address 255.255.255.255? */
  407374:	429a      	cmp	r2, r3
  407376:	d108      	bne.n	40738a <eARPGetCacheEntry+0x32>
	{
		/* This is a broadcast so uses the broadcast MAC address. */
		memcpy( pxMACAddress->ucBytes, xBroadcastMACAddress.ucBytes, sizeof( MACAddress_t ) );
  407378:	683b      	ldr	r3, [r7, #0]
  40737a:	4a23      	ldr	r2, [pc, #140]	; (407408 <eARPGetCacheEntry+0xb0>)
  40737c:	6811      	ldr	r1, [r2, #0]
  40737e:	6019      	str	r1, [r3, #0]
  407380:	8892      	ldrh	r2, [r2, #4]
  407382:	809a      	strh	r2, [r3, #4]
		eReturn = eARPCacheHit;
  407384:	2301      	movs	r3, #1
  407386:	73fb      	strb	r3, [r7, #15]
  407388:	e036      	b.n	4073f8 <eARPGetCacheEntry+0xa0>
	}
	else if( *ipLOCAL_IP_ADDRESS_POINTER == 0UL )
  40738a:	4b20      	ldr	r3, [pc, #128]	; (40740c <eARPGetCacheEntry+0xb4>)
  40738c:	695b      	ldr	r3, [r3, #20]
  40738e:	2b00      	cmp	r3, #0
  407390:	d102      	bne.n	407398 <eARPGetCacheEntry+0x40>
	{
		/* The IP address has not yet been assigned, so there is nothing that
		can be done. */
		eReturn = eCantSendPacket;
  407392:	2302      	movs	r3, #2
  407394:	73fb      	strb	r3, [r7, #15]
  407396:	e02f      	b.n	4073f8 <eARPGetCacheEntry+0xa0>
	}
	else
	{
		eReturn = eARPCacheMiss;
  407398:	2300      	movs	r3, #0
  40739a:	73fb      	strb	r3, [r7, #15]

		if( ( *pulIPAddress & xNetworkAddressing.ulNetMask ) != ( ( *ipLOCAL_IP_ADDRESS_POINTER ) & xNetworkAddressing.ulNetMask ) )
  40739c:	687b      	ldr	r3, [r7, #4]
  40739e:	681a      	ldr	r2, [r3, #0]
  4073a0:	4b1a      	ldr	r3, [pc, #104]	; (40740c <eARPGetCacheEntry+0xb4>)
  4073a2:	695b      	ldr	r3, [r3, #20]
  4073a4:	405a      	eors	r2, r3
  4073a6:	4b17      	ldr	r3, [pc, #92]	; (407404 <eARPGetCacheEntry+0xac>)
  4073a8:	685b      	ldr	r3, [r3, #4]
  4073aa:	4013      	ands	r3, r2
  4073ac:	2b00      	cmp	r3, #0
  4073ae:	d00b      	beq.n	4073c8 <eARPGetCacheEntry+0x70>
			else
#endif
			{
				/* The IP address is off the local network, so look up the
				hardware address of the router, if any. */
				if( xNetworkAddressing.ulGatewayAddress != ( uint32_t )0u )
  4073b0:	4b14      	ldr	r3, [pc, #80]	; (407404 <eARPGetCacheEntry+0xac>)
  4073b2:	689b      	ldr	r3, [r3, #8]
  4073b4:	2b00      	cmp	r3, #0
  4073b6:	d003      	beq.n	4073c0 <eARPGetCacheEntry+0x68>
				{
					ulAddressToLookup = xNetworkAddressing.ulGatewayAddress;
  4073b8:	4b12      	ldr	r3, [pc, #72]	; (407404 <eARPGetCacheEntry+0xac>)
  4073ba:	689b      	ldr	r3, [r3, #8]
  4073bc:	60bb      	str	r3, [r7, #8]
  4073be:	e006      	b.n	4073ce <eARPGetCacheEntry+0x76>
				}
				else
				{
					ulAddressToLookup = *pulIPAddress;
  4073c0:	687b      	ldr	r3, [r7, #4]
  4073c2:	681b      	ldr	r3, [r3, #0]
  4073c4:	60bb      	str	r3, [r7, #8]
  4073c6:	e002      	b.n	4073ce <eARPGetCacheEntry+0x76>
		}
		else
		{
			/* The IP address is on the local network, so lookup the requested
			IP address directly. */
			ulAddressToLookup = *pulIPAddress;
  4073c8:	687b      	ldr	r3, [r7, #4]
  4073ca:	681b      	ldr	r3, [r3, #0]
  4073cc:	60bb      	str	r3, [r7, #8]
		}

		if( eReturn == eARPCacheMiss )
  4073ce:	7bfb      	ldrb	r3, [r7, #15]
  4073d0:	2b00      	cmp	r3, #0
  4073d2:	d111      	bne.n	4073f8 <eARPGetCacheEntry+0xa0>
		{
			if( ulAddressToLookup == 0UL )
  4073d4:	68bb      	ldr	r3, [r7, #8]
  4073d6:	2b00      	cmp	r3, #0
  4073d8:	d102      	bne.n	4073e0 <eARPGetCacheEntry+0x88>
			{
				/* The address is not on the local network, and there is not a
				router. */
				eReturn = eCantSendPacket;
  4073da:	2302      	movs	r3, #2
  4073dc:	73fb      	strb	r3, [r7, #15]
  4073de:	e00b      	b.n	4073f8 <eARPGetCacheEntry+0xa0>
			}
			else
			{
				eReturn = prvCacheLookup( ulAddressToLookup, pxMACAddress );
  4073e0:	6839      	ldr	r1, [r7, #0]
  4073e2:	68b8      	ldr	r0, [r7, #8]
  4073e4:	4b0a      	ldr	r3, [pc, #40]	; (407410 <eARPGetCacheEntry+0xb8>)
  4073e6:	4798      	blx	r3
  4073e8:	4603      	mov	r3, r0
  4073ea:	73fb      	strb	r3, [r7, #15]

				if( eReturn == eARPCacheMiss )
  4073ec:	7bfb      	ldrb	r3, [r7, #15]
  4073ee:	2b00      	cmp	r3, #0
  4073f0:	d102      	bne.n	4073f8 <eARPGetCacheEntry+0xa0>
				{
					/* It might be that the ARP has to go to the gateway. */
					*pulIPAddress = ulAddressToLookup;
  4073f2:	687b      	ldr	r3, [r7, #4]
  4073f4:	68ba      	ldr	r2, [r7, #8]
  4073f6:	601a      	str	r2, [r3, #0]
				}
			}
		}
	}

	return eReturn;
  4073f8:	7bfb      	ldrb	r3, [r7, #15]
}
  4073fa:	4618      	mov	r0, r3
  4073fc:	3710      	adds	r7, #16
  4073fe:	46bd      	mov	sp, r7
  407400:	bd80      	pop	{r7, pc}
  407402:	bf00      	nop
  407404:	20006cd0 	.word	0x20006cd0
  407408:	0041ca10 	.word	0x0041ca10
  40740c:	20000108 	.word	0x20000108
  407410:	00407415 	.word	0x00407415

00407414 <prvCacheLookup>:

/*-----------------------------------------------------------*/

static eARPLookupResult_t prvCacheLookup( uint32_t ulAddressToLookup, MACAddress_t * const pxMACAddress )
{
  407414:	b580      	push	{r7, lr}
  407416:	b084      	sub	sp, #16
  407418:	af00      	add	r7, sp, #0
  40741a:	6078      	str	r0, [r7, #4]
  40741c:	6039      	str	r1, [r7, #0]
BaseType_t x;
eARPLookupResult_t eReturn = eARPCacheMiss;
  40741e:	2300      	movs	r3, #0
  407420:	72fb      	strb	r3, [r7, #11]

	/* Loop through each entry in the ARP cache. */
	for( x = 0; x < ipconfigARP_CACHE_ENTRIES; x++ )
  407422:	2300      	movs	r3, #0
  407424:	60fb      	str	r3, [r7, #12]
  407426:	e02b      	b.n	407480 <prvCacheLookup+0x6c>
	{
		/* Does this row in the ARP cache table hold an entry for the IP address
		being queried? */
		if( xARPCache[ x ].ulIPAddress == ulAddressToLookup )
  407428:	4919      	ldr	r1, [pc, #100]	; (407490 <prvCacheLookup+0x7c>)
  40742a:	68fa      	ldr	r2, [r7, #12]
  40742c:	4613      	mov	r3, r2
  40742e:	005b      	lsls	r3, r3, #1
  407430:	4413      	add	r3, r2
  407432:	009b      	lsls	r3, r3, #2
  407434:	440b      	add	r3, r1
  407436:	681a      	ldr	r2, [r3, #0]
  407438:	687b      	ldr	r3, [r7, #4]
  40743a:	429a      	cmp	r2, r3
  40743c:	d11d      	bne.n	40747a <prvCacheLookup+0x66>
		{
			/* A matching valid entry was found. */
			if( xARPCache[ x ].ucValid == ( uint8_t ) pdFALSE )
  40743e:	4914      	ldr	r1, [pc, #80]	; (407490 <prvCacheLookup+0x7c>)
  407440:	68fa      	ldr	r2, [r7, #12]
  407442:	4613      	mov	r3, r2
  407444:	005b      	lsls	r3, r3, #1
  407446:	4413      	add	r3, r2
  407448:	009b      	lsls	r3, r3, #2
  40744a:	440b      	add	r3, r1
  40744c:	330b      	adds	r3, #11
  40744e:	781b      	ldrb	r3, [r3, #0]
  407450:	2b00      	cmp	r3, #0
  407452:	d102      	bne.n	40745a <prvCacheLookup+0x46>
			{
				/* This entry is waiting an ARP reply, so is not valid. */
				eReturn = eCantSendPacket;
  407454:	2302      	movs	r3, #2
  407456:	72fb      	strb	r3, [r7, #11]
			{
				/* A valid entry was found. */
				memcpy( pxMACAddress->ucBytes, xARPCache[ x ].xMACAddress.ucBytes, sizeof( MACAddress_t ) );
				eReturn = eARPCacheHit;
			}
			break;
  407458:	e015      	b.n	407486 <prvCacheLookup+0x72>
				memcpy( pxMACAddress->ucBytes, xARPCache[ x ].xMACAddress.ucBytes, sizeof( MACAddress_t ) );
  40745a:	6838      	ldr	r0, [r7, #0]
  40745c:	68fa      	ldr	r2, [r7, #12]
  40745e:	4613      	mov	r3, r2
  407460:	005b      	lsls	r3, r3, #1
  407462:	4413      	add	r3, r2
  407464:	009b      	lsls	r3, r3, #2
  407466:	4a0a      	ldr	r2, [pc, #40]	; (407490 <prvCacheLookup+0x7c>)
  407468:	4413      	add	r3, r2
  40746a:	3304      	adds	r3, #4
  40746c:	2206      	movs	r2, #6
  40746e:	4619      	mov	r1, r3
  407470:	4b08      	ldr	r3, [pc, #32]	; (407494 <prvCacheLookup+0x80>)
  407472:	4798      	blx	r3
				eReturn = eARPCacheHit;
  407474:	2301      	movs	r3, #1
  407476:	72fb      	strb	r3, [r7, #11]
			break;
  407478:	e005      	b.n	407486 <prvCacheLookup+0x72>
	for( x = 0; x < ipconfigARP_CACHE_ENTRIES; x++ )
  40747a:	68fb      	ldr	r3, [r7, #12]
  40747c:	3301      	adds	r3, #1
  40747e:	60fb      	str	r3, [r7, #12]
  407480:	68fb      	ldr	r3, [r7, #12]
  407482:	2b05      	cmp	r3, #5
  407484:	ddd0      	ble.n	407428 <prvCacheLookup+0x14>
		}
	}

	return eReturn;
  407486:	7afb      	ldrb	r3, [r7, #11]
}
  407488:	4618      	mov	r0, r3
  40748a:	3710      	adds	r7, #16
  40748c:	46bd      	mov	sp, r7
  40748e:	bd80      	pop	{r7, pc}
  407490:	20006c7c 	.word	0x20006c7c
  407494:	00416d05 	.word	0x00416d05

00407498 <vARPAgeCache>:
/*-----------------------------------------------------------*/

void vARPAgeCache( void )
{
  407498:	b580      	push	{r7, lr}
  40749a:	b082      	sub	sp, #8
  40749c:	af00      	add	r7, sp, #0
BaseType_t x;
TickType_t xTimeNow;

	/* Loop through each entry in the ARP cache. */
	for( x = 0; x < ipconfigARP_CACHE_ENTRIES; x++ )
  40749e:	2300      	movs	r3, #0
  4074a0:	607b      	str	r3, [r7, #4]
  4074a2:	e063      	b.n	40756c <vARPAgeCache+0xd4>
	{
		/* If the entry is valid (its age is greater than zero). */
		if( xARPCache[ x ].ucAge > 0U )
  4074a4:	4940      	ldr	r1, [pc, #256]	; (4075a8 <vARPAgeCache+0x110>)
  4074a6:	687a      	ldr	r2, [r7, #4]
  4074a8:	4613      	mov	r3, r2
  4074aa:	005b      	lsls	r3, r3, #1
  4074ac:	4413      	add	r3, r2
  4074ae:	009b      	lsls	r3, r3, #2
  4074b0:	440b      	add	r3, r1
  4074b2:	330a      	adds	r3, #10
  4074b4:	781b      	ldrb	r3, [r3, #0]
  4074b6:	2b00      	cmp	r3, #0
  4074b8:	d055      	beq.n	407566 <vARPAgeCache+0xce>
		{
			/* Decrement the age value of the entry in this ARP cache table row.
			When the age reaches zero it is no longer considered valid. */
			( xARPCache[ x ].ucAge )--;
  4074ba:	493b      	ldr	r1, [pc, #236]	; (4075a8 <vARPAgeCache+0x110>)
  4074bc:	687a      	ldr	r2, [r7, #4]
  4074be:	4613      	mov	r3, r2
  4074c0:	005b      	lsls	r3, r3, #1
  4074c2:	4413      	add	r3, r2
  4074c4:	009b      	lsls	r3, r3, #2
  4074c6:	440b      	add	r3, r1
  4074c8:	330a      	adds	r3, #10
  4074ca:	781b      	ldrb	r3, [r3, #0]
  4074cc:	3b01      	subs	r3, #1
  4074ce:	b2d8      	uxtb	r0, r3
  4074d0:	4935      	ldr	r1, [pc, #212]	; (4075a8 <vARPAgeCache+0x110>)
  4074d2:	687a      	ldr	r2, [r7, #4]
  4074d4:	4613      	mov	r3, r2
  4074d6:	005b      	lsls	r3, r3, #1
  4074d8:	4413      	add	r3, r2
  4074da:	009b      	lsls	r3, r3, #2
  4074dc:	440b      	add	r3, r1
  4074de:	330a      	adds	r3, #10
  4074e0:	4602      	mov	r2, r0
  4074e2:	701a      	strb	r2, [r3, #0]

			/* If the entry is not yet valid, then it is waiting an ARP
			reply, and the ARP request should be retransmitted. */
			if( xARPCache[ x ].ucValid == ( uint8_t ) pdFALSE )
  4074e4:	4930      	ldr	r1, [pc, #192]	; (4075a8 <vARPAgeCache+0x110>)
  4074e6:	687a      	ldr	r2, [r7, #4]
  4074e8:	4613      	mov	r3, r2
  4074ea:	005b      	lsls	r3, r3, #1
  4074ec:	4413      	add	r3, r2
  4074ee:	009b      	lsls	r3, r3, #2
  4074f0:	440b      	add	r3, r1
  4074f2:	330b      	adds	r3, #11
  4074f4:	781b      	ldrb	r3, [r3, #0]
  4074f6:	2b00      	cmp	r3, #0
  4074f8:	d10b      	bne.n	407512 <vARPAgeCache+0x7a>
			{
				FreeRTOS_OutputARPRequest( xARPCache[ x ].ulIPAddress );
  4074fa:	492b      	ldr	r1, [pc, #172]	; (4075a8 <vARPAgeCache+0x110>)
  4074fc:	687a      	ldr	r2, [r7, #4]
  4074fe:	4613      	mov	r3, r2
  407500:	005b      	lsls	r3, r3, #1
  407502:	4413      	add	r3, r2
  407504:	009b      	lsls	r3, r3, #2
  407506:	440b      	add	r3, r1
  407508:	681b      	ldr	r3, [r3, #0]
  40750a:	4618      	mov	r0, r3
  40750c:	4b27      	ldr	r3, [pc, #156]	; (4075ac <vARPAgeCache+0x114>)
  40750e:	4798      	blx	r3
  407510:	e015      	b.n	40753e <vARPAgeCache+0xa6>
			}
			else if( xARPCache[ x ].ucAge <= ( uint8_t ) arpMAX_ARP_AGE_BEFORE_NEW_ARP_REQUEST )
  407512:	4925      	ldr	r1, [pc, #148]	; (4075a8 <vARPAgeCache+0x110>)
  407514:	687a      	ldr	r2, [r7, #4]
  407516:	4613      	mov	r3, r2
  407518:	005b      	lsls	r3, r3, #1
  40751a:	4413      	add	r3, r2
  40751c:	009b      	lsls	r3, r3, #2
  40751e:	440b      	add	r3, r1
  407520:	330a      	adds	r3, #10
  407522:	781b      	ldrb	r3, [r3, #0]
  407524:	2b03      	cmp	r3, #3
  407526:	d80a      	bhi.n	40753e <vARPAgeCache+0xa6>
			{
				/* This entry will get removed soon.  See if the MAC address is
				still valid to prevent this happening. */
				iptraceARP_TABLE_ENTRY_WILL_EXPIRE( xARPCache[ x ].ulIPAddress );
				FreeRTOS_OutputARPRequest( xARPCache[ x ].ulIPAddress );
  407528:	491f      	ldr	r1, [pc, #124]	; (4075a8 <vARPAgeCache+0x110>)
  40752a:	687a      	ldr	r2, [r7, #4]
  40752c:	4613      	mov	r3, r2
  40752e:	005b      	lsls	r3, r3, #1
  407530:	4413      	add	r3, r2
  407532:	009b      	lsls	r3, r3, #2
  407534:	440b      	add	r3, r1
  407536:	681b      	ldr	r3, [r3, #0]
  407538:	4618      	mov	r0, r3
  40753a:	4b1c      	ldr	r3, [pc, #112]	; (4075ac <vARPAgeCache+0x114>)
  40753c:	4798      	blx	r3
			else
			{
				/* The age has just ticked down, with nothing to do. */
			}

			if( xARPCache[ x ].ucAge == 0u )
  40753e:	491a      	ldr	r1, [pc, #104]	; (4075a8 <vARPAgeCache+0x110>)
  407540:	687a      	ldr	r2, [r7, #4]
  407542:	4613      	mov	r3, r2
  407544:	005b      	lsls	r3, r3, #1
  407546:	4413      	add	r3, r2
  407548:	009b      	lsls	r3, r3, #2
  40754a:	440b      	add	r3, r1
  40754c:	330a      	adds	r3, #10
  40754e:	781b      	ldrb	r3, [r3, #0]
  407550:	2b00      	cmp	r3, #0
  407552:	d108      	bne.n	407566 <vARPAgeCache+0xce>
			{
				/* The entry is no longer valid.  Wipe it out. */
				iptraceARP_TABLE_ENTRY_EXPIRED( xARPCache[ x ].ulIPAddress );
				xARPCache[ x ].ulIPAddress = 0UL;
  407554:	4914      	ldr	r1, [pc, #80]	; (4075a8 <vARPAgeCache+0x110>)
  407556:	687a      	ldr	r2, [r7, #4]
  407558:	4613      	mov	r3, r2
  40755a:	005b      	lsls	r3, r3, #1
  40755c:	4413      	add	r3, r2
  40755e:	009b      	lsls	r3, r3, #2
  407560:	440b      	add	r3, r1
  407562:	2200      	movs	r2, #0
  407564:	601a      	str	r2, [r3, #0]
	for( x = 0; x < ipconfigARP_CACHE_ENTRIES; x++ )
  407566:	687b      	ldr	r3, [r7, #4]
  407568:	3301      	adds	r3, #1
  40756a:	607b      	str	r3, [r7, #4]
  40756c:	687b      	ldr	r3, [r7, #4]
  40756e:	2b05      	cmp	r3, #5
  407570:	dd98      	ble.n	4074a4 <vARPAgeCache+0xc>
			}
		}
	}

	xTimeNow = xTaskGetTickCount ();
  407572:	4b0f      	ldr	r3, [pc, #60]	; (4075b0 <vARPAgeCache+0x118>)
  407574:	4798      	blx	r3
  407576:	6038      	str	r0, [r7, #0]

	if( ( xLastGratuitousARPTime == ( TickType_t ) 0 ) || ( ( xTimeNow - xLastGratuitousARPTime ) > ( TickType_t ) arpGRATUITOUS_ARP_PERIOD ) )
  407578:	4b0e      	ldr	r3, [pc, #56]	; (4075b4 <vARPAgeCache+0x11c>)
  40757a:	681b      	ldr	r3, [r3, #0]
  40757c:	2b00      	cmp	r3, #0
  40757e:	d007      	beq.n	407590 <vARPAgeCache+0xf8>
  407580:	4b0c      	ldr	r3, [pc, #48]	; (4075b4 <vARPAgeCache+0x11c>)
  407582:	681b      	ldr	r3, [r3, #0]
  407584:	683a      	ldr	r2, [r7, #0]
  407586:	1ad3      	subs	r3, r2, r3
  407588:	f644 6220 	movw	r2, #20000	; 0x4e20
  40758c:	4293      	cmp	r3, r2
  40758e:	d907      	bls.n	4075a0 <vARPAgeCache+0x108>
	{
		FreeRTOS_OutputARPRequest( *ipLOCAL_IP_ADDRESS_POINTER );
  407590:	4b09      	ldr	r3, [pc, #36]	; (4075b8 <vARPAgeCache+0x120>)
  407592:	695b      	ldr	r3, [r3, #20]
  407594:	4618      	mov	r0, r3
  407596:	4b05      	ldr	r3, [pc, #20]	; (4075ac <vARPAgeCache+0x114>)
  407598:	4798      	blx	r3
		xLastGratuitousARPTime = xTimeNow;
  40759a:	4a06      	ldr	r2, [pc, #24]	; (4075b4 <vARPAgeCache+0x11c>)
  40759c:	683b      	ldr	r3, [r7, #0]
  40759e:	6013      	str	r3, [r2, #0]
	}
}
  4075a0:	bf00      	nop
  4075a2:	3708      	adds	r7, #8
  4075a4:	46bd      	mov	sp, r7
  4075a6:	bd80      	pop	{r7, pc}
  4075a8:	20006c7c 	.word	0x20006c7c
  4075ac:	004075bd 	.word	0x004075bd
  4075b0:	004127d1 	.word	0x004127d1
  4075b4:	20006cc4 	.word	0x20006cc4
  4075b8:	20000108 	.word	0x20000108

004075bc <FreeRTOS_OutputARPRequest>:
	xSendEventToIPTask( eARPTimerEvent );
}

/*-----------------------------------------------------------*/
void FreeRTOS_OutputARPRequest( uint32_t ulIPAddress )
{
  4075bc:	b580      	push	{r7, lr}
  4075be:	b086      	sub	sp, #24
  4075c0:	af00      	add	r7, sp, #0
  4075c2:	6078      	str	r0, [r7, #4]
NetworkBufferDescriptor_t *pxNetworkBuffer;

	/* This is called from the context of the IP event task, so a block time
	must not be used. */

	pxNetworkBuffer = pxGetNetworkBufferWithDescriptor( sizeof( ARPPacket_t ), ( TickType_t ) 0 );
  4075c4:	2100      	movs	r1, #0
  4075c6:	202a      	movs	r0, #42	; 0x2a
  4075c8:	4b15      	ldr	r3, [pc, #84]	; (407620 <FreeRTOS_OutputARPRequest+0x64>)
  4075ca:	4798      	blx	r3
  4075cc:	6178      	str	r0, [r7, #20]

	if( pxNetworkBuffer != NULL )
  4075ce:	697b      	ldr	r3, [r7, #20]
  4075d0:	2b00      	cmp	r3, #0
  4075d2:	d020      	beq.n	407616 <FreeRTOS_OutputARPRequest+0x5a>
	{
		pxNetworkBuffer->ulIPAddress = ulIPAddress;
  4075d4:	697b      	ldr	r3, [r7, #20]
  4075d6:	687a      	ldr	r2, [r7, #4]
  4075d8:	615a      	str	r2, [r3, #20]
		vARPGenerateRequestPacket( pxNetworkBuffer );
  4075da:	6978      	ldr	r0, [r7, #20]
  4075dc:	4b11      	ldr	r3, [pc, #68]	; (407624 <FreeRTOS_OutputARPRequest+0x68>)
  4075de:	4798      	blx	r3
				}
				pxNetworkBuffer->xDataLength = ( size_t ) ipconfigETHERNET_MINIMUM_PACKET_BYTES;
			}
		}
		#endif
		if( xIsCallingFromIPTask() != 0 )
  4075e0:	4b11      	ldr	r3, [pc, #68]	; (407628 <FreeRTOS_OutputARPRequest+0x6c>)
  4075e2:	4798      	blx	r3
  4075e4:	4603      	mov	r3, r0
  4075e6:	2b00      	cmp	r3, #0
  4075e8:	d004      	beq.n	4075f4 <FreeRTOS_OutputARPRequest+0x38>
		{
			/* Only the IP-task is allowed to call this function directly. */
			xNetworkInterfaceOutput( pxNetworkBuffer, pdTRUE );
  4075ea:	2101      	movs	r1, #1
  4075ec:	6978      	ldr	r0, [r7, #20]
  4075ee:	4b0f      	ldr	r3, [pc, #60]	; (40762c <FreeRTOS_OutputARPRequest+0x70>)
  4075f0:	4798      	blx	r3
				/* Failed to send the message, so release the network buffer. */
				vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
			}
		}
	}
}
  4075f2:	e010      	b.n	407616 <FreeRTOS_OutputARPRequest+0x5a>
			xSendEvent.eEventType = eNetworkTxEvent;
  4075f4:	2302      	movs	r3, #2
  4075f6:	733b      	strb	r3, [r7, #12]
			xSendEvent.pvData = ( void * ) pxNetworkBuffer;
  4075f8:	697b      	ldr	r3, [r7, #20]
  4075fa:	613b      	str	r3, [r7, #16]
			if( xSendEventStructToIPTask( &xSendEvent, ( TickType_t ) portMAX_DELAY ) == pdFAIL )
  4075fc:	f107 030c 	add.w	r3, r7, #12
  407600:	f04f 31ff 	mov.w	r1, #4294967295
  407604:	4618      	mov	r0, r3
  407606:	4b0a      	ldr	r3, [pc, #40]	; (407630 <FreeRTOS_OutputARPRequest+0x74>)
  407608:	4798      	blx	r3
  40760a:	4603      	mov	r3, r0
  40760c:	2b00      	cmp	r3, #0
  40760e:	d102      	bne.n	407616 <FreeRTOS_OutputARPRequest+0x5a>
				vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
  407610:	6978      	ldr	r0, [r7, #20]
  407612:	4b08      	ldr	r3, [pc, #32]	; (407634 <FreeRTOS_OutputARPRequest+0x78>)
  407614:	4798      	blx	r3
}
  407616:	bf00      	nop
  407618:	3718      	adds	r7, #24
  40761a:	46bd      	mov	sp, r7
  40761c:	bd80      	pop	{r7, pc}
  40761e:	bf00      	nop
  407620:	0040f1d5 	.word	0x0040f1d5
  407624:	00407639 	.word	0x00407639
  407628:	00407909 	.word	0x00407909
  40762c:	004102dd 	.word	0x004102dd
  407630:	00407e49 	.word	0x00407e49
  407634:	0040f2ed 	.word	0x0040f2ed

00407638 <vARPGenerateRequestPacket>:

void vARPGenerateRequestPacket( NetworkBufferDescriptor_t * const pxNetworkBuffer )
{
  407638:	b5f0      	push	{r4, r5, r6, r7, lr}
  40763a:	b085      	sub	sp, #20
  40763c:	af00      	add	r7, sp, #0
  40763e:	6078      	str	r0, [r7, #4]
ARPPacket_t *pxARPPacket;

	/* Buffer allocation ensures that buffers always have space
	for an ARP packet. See buffer allocation implementations 1
	and 2 under portable/BufferManagement. */
	configASSERT( pxNetworkBuffer );
  407640:	687b      	ldr	r3, [r7, #4]
  407642:	2b00      	cmp	r3, #0
  407644:	d105      	bne.n	407652 <vARPGenerateRequestPacket+0x1a>
  407646:	f44f 7219 	mov.w	r2, #612	; 0x264
  40764a:	4924      	ldr	r1, [pc, #144]	; (4076dc <vARPGenerateRequestPacket+0xa4>)
  40764c:	4824      	ldr	r0, [pc, #144]	; (4076e0 <vARPGenerateRequestPacket+0xa8>)
  40764e:	4b25      	ldr	r3, [pc, #148]	; (4076e4 <vARPGenerateRequestPacket+0xac>)
  407650:	4798      	blx	r3
	configASSERT( pxNetworkBuffer->xDataLength >= sizeof(ARPPacket_t) );
  407652:	687b      	ldr	r3, [r7, #4]
  407654:	69db      	ldr	r3, [r3, #28]
  407656:	2b29      	cmp	r3, #41	; 0x29
  407658:	d805      	bhi.n	407666 <vARPGenerateRequestPacket+0x2e>
  40765a:	f240 2265 	movw	r2, #613	; 0x265
  40765e:	491f      	ldr	r1, [pc, #124]	; (4076dc <vARPGenerateRequestPacket+0xa4>)
  407660:	481f      	ldr	r0, [pc, #124]	; (4076e0 <vARPGenerateRequestPacket+0xa8>)
  407662:	4b20      	ldr	r3, [pc, #128]	; (4076e4 <vARPGenerateRequestPacket+0xac>)
  407664:	4798      	blx	r3

	pxARPPacket = ( ARPPacket_t * ) pxNetworkBuffer->pucEthernetBuffer;
  407666:	687b      	ldr	r3, [r7, #4]
  407668:	699b      	ldr	r3, [r3, #24]
  40766a:	60fb      	str	r3, [r7, #12]
		xARPHeader.ucHardwareAddressLength;
		xARPHeader.ucProtocolAddressLength;
		xARPHeader.usOperation;
		xARPHeader.xTargetHardwareAddress;
	*/
	memcpy( ( void * ) pxARPPacket, ( void * ) xDefaultPartARPPacketHeader, sizeof( xDefaultPartARPPacketHeader ) );
  40766c:	68fb      	ldr	r3, [r7, #12]
  40766e:	4a1e      	ldr	r2, [pc, #120]	; (4076e8 <vARPGenerateRequestPacket+0xb0>)
  407670:	4614      	mov	r4, r2
  407672:	469e      	mov	lr, r3
  407674:	f104 0c20 	add.w	ip, r4, #32
  407678:	4675      	mov	r5, lr
  40767a:	4626      	mov	r6, r4
  40767c:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
  40767e:	6028      	str	r0, [r5, #0]
  407680:	6069      	str	r1, [r5, #4]
  407682:	60aa      	str	r2, [r5, #8]
  407684:	60eb      	str	r3, [r5, #12]
  407686:	3410      	adds	r4, #16
  407688:	f10e 0e10 	add.w	lr, lr, #16
  40768c:	4564      	cmp	r4, ip
  40768e:	d1f3      	bne.n	407678 <vARPGenerateRequestPacket+0x40>
  407690:	4673      	mov	r3, lr
  407692:	4622      	mov	r2, r4
  407694:	6810      	ldr	r0, [r2, #0]
  407696:	6018      	str	r0, [r3, #0]
  407698:	8892      	ldrh	r2, [r2, #4]
  40769a:	809a      	strh	r2, [r3, #4]
	memcpy( ( void * ) pxARPPacket->xEthernetHeader.xSourceAddress.ucBytes , ( void * ) ipLOCAL_MAC_ADDRESS, ( size_t ) ipMAC_ADDRESS_LENGTH_BYTES );
  40769c:	68fb      	ldr	r3, [r7, #12]
  40769e:	3306      	adds	r3, #6
  4076a0:	2206      	movs	r2, #6
  4076a2:	4912      	ldr	r1, [pc, #72]	; (4076ec <vARPGenerateRequestPacket+0xb4>)
  4076a4:	4618      	mov	r0, r3
  4076a6:	4b12      	ldr	r3, [pc, #72]	; (4076f0 <vARPGenerateRequestPacket+0xb8>)
  4076a8:	4798      	blx	r3
	memcpy( ( void * ) pxARPPacket->xARPHeader.xSenderHardwareAddress.ucBytes, ( void * ) ipLOCAL_MAC_ADDRESS, ( size_t ) ipMAC_ADDRESS_LENGTH_BYTES );
  4076aa:	68fb      	ldr	r3, [r7, #12]
  4076ac:	3316      	adds	r3, #22
  4076ae:	2206      	movs	r2, #6
  4076b0:	490e      	ldr	r1, [pc, #56]	; (4076ec <vARPGenerateRequestPacket+0xb4>)
  4076b2:	4618      	mov	r0, r3
  4076b4:	4b0e      	ldr	r3, [pc, #56]	; (4076f0 <vARPGenerateRequestPacket+0xb8>)
  4076b6:	4798      	blx	r3

	memcpy( ( void* )pxARPPacket->xARPHeader.ucSenderProtocolAddress, ( void* )ipLOCAL_IP_ADDRESS_POINTER, sizeof( pxARPPacket->xARPHeader.ucSenderProtocolAddress ) );
  4076b8:	68fb      	ldr	r3, [r7, #12]
  4076ba:	331c      	adds	r3, #28
  4076bc:	4a0b      	ldr	r2, [pc, #44]	; (4076ec <vARPGenerateRequestPacket+0xb4>)
  4076be:	6952      	ldr	r2, [r2, #20]
  4076c0:	601a      	str	r2, [r3, #0]
	pxARPPacket->xARPHeader.ulTargetProtocolAddress = pxNetworkBuffer->ulIPAddress;
  4076c2:	687b      	ldr	r3, [r7, #4]
  4076c4:	695a      	ldr	r2, [r3, #20]
  4076c6:	68fb      	ldr	r3, [r7, #12]
  4076c8:	f8c3 2026 	str.w	r2, [r3, #38]	; 0x26

	pxNetworkBuffer->xDataLength = sizeof( ARPPacket_t );
  4076cc:	687b      	ldr	r3, [r7, #4]
  4076ce:	222a      	movs	r2, #42	; 0x2a
  4076d0:	61da      	str	r2, [r3, #28]

	iptraceCREATING_ARP_REQUEST( pxNetworkBuffer->ulIPAddress );
}
  4076d2:	bf00      	nop
  4076d4:	3714      	adds	r7, #20
  4076d6:	46bd      	mov	sp, r7
  4076d8:	bdf0      	pop	{r4, r5, r6, r7, pc}
  4076da:	bf00      	nop
  4076dc:	0041c954 	.word	0x0041c954
  4076e0:	0041c9ac 	.word	0x0041c9ac
  4076e4:	00416c7d 	.word	0x00416c7d
  4076e8:	0041c92c 	.word	0x0041c92c
  4076ec:	20000108 	.word	0x20000108
  4076f0:	00416d05 	.word	0x00416d05

004076f4 <FreeRTOS_ClearARP>:
/*-----------------------------------------------------------*/

void FreeRTOS_ClearARP( void )
{
  4076f4:	b580      	push	{r7, lr}
  4076f6:	af00      	add	r7, sp, #0
	memset( xARPCache, '\0', sizeof( xARPCache ) );
  4076f8:	2248      	movs	r2, #72	; 0x48
  4076fa:	2100      	movs	r1, #0
  4076fc:	4802      	ldr	r0, [pc, #8]	; (407708 <FreeRTOS_ClearARP+0x14>)
  4076fe:	4b03      	ldr	r3, [pc, #12]	; (40770c <FreeRTOS_ClearARP+0x18>)
  407700:	4798      	blx	r3
}
  407702:	bf00      	nop
  407704:	bd80      	pop	{r7, pc}
  407706:	bf00      	nop
  407708:	20006c7c 	.word	0x20006c7c
  40770c:	00416f01 	.word	0x00416f01

00407710 <prvIPTask>:
#endif

/*-----------------------------------------------------------*/

static void prvIPTask( void *pvParameters )
{
  407710:	b590      	push	{r4, r7, lr}
  407712:	b08b      	sub	sp, #44	; 0x2c
  407714:	af00      	add	r7, sp, #0
  407716:	6078      	str	r0, [r7, #4]

	/* Generate a dummy message to say that the network connection has gone
	down.  This will cause this task to initialise the network interface.  After
	this it is the responsibility of the network interface hardware driver to
	send this message if a previously connected network is disconnected. */
	FreeRTOS_NetworkDown();
  407718:	4b61      	ldr	r3, [pc, #388]	; (4078a0 <prvIPTask+0x190>)
  40771a:	4798      	blx	r3

	#if( ipconfigUSE_TCP == 1 )
	{
		/* Initialise the TCP timer. */
		prvIPTimerReload( &xTCPTimer, pdMS_TO_TICKS( ipTCP_TIMER_PERIOD_MS ) );
  40771c:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
  407720:	4860      	ldr	r0, [pc, #384]	; (4078a4 <prvIPTask+0x194>)
  407722:	4b61      	ldr	r3, [pc, #388]	; (4078a8 <prvIPTask+0x198>)
  407724:	4798      	blx	r3
	}
	#endif

	/* Initialisation is complete and events can now be processed. */
	xIPTaskInitialised = pdTRUE;
  407726:	4b61      	ldr	r3, [pc, #388]	; (4078ac <prvIPTask+0x19c>)
  407728:	2201      	movs	r2, #1
  40772a:	601a      	str	r2, [r3, #0]

	FreeRTOS_debug_printf( ( "prvIPTask started\n" ) );
  40772c:	4860      	ldr	r0, [pc, #384]	; (4078b0 <prvIPTask+0x1a0>)
  40772e:	4b61      	ldr	r3, [pc, #388]	; (4078b4 <prvIPTask+0x1a4>)
  407730:	4798      	blx	r3

	/* Loop, processing IP events. */
	for( ;; )
	{
		ipconfigWATCHDOG_TIMER();
  407732:	4b61      	ldr	r3, [pc, #388]	; (4078b8 <prvIPTask+0x1a8>)
  407734:	2201      	movs	r2, #1
  407736:	701a      	strb	r2, [r3, #0]

		/* Check the ARP, DHCP and TCP timers to see if there is any periodic
		or timeout processing to perform. */
		prvCheckNetworkTimers();
  407738:	4b60      	ldr	r3, [pc, #384]	; (4078bc <prvIPTask+0x1ac>)
  40773a:	4798      	blx	r3

		/* Calculate the acceptable maximum sleep time. */
		xNextIPSleep = prvCalculateSleepTime();
  40773c:	4b60      	ldr	r3, [pc, #384]	; (4078c0 <prvIPTask+0x1b0>)
  40773e:	4798      	blx	r3
  407740:	6278      	str	r0, [r7, #36]	; 0x24

		/* Wait until there is something to do. If the following call exits
		 * due to a time out rather than a message being received, set a
		 * 'NoEvent' value. */
		if ( xQueueReceive( xNetworkEventQueue, ( void * ) &xReceivedEvent, xNextIPSleep ) == pdFALSE ) 
  407742:	4b60      	ldr	r3, [pc, #384]	; (4078c4 <prvIPTask+0x1b4>)
  407744:	681b      	ldr	r3, [r3, #0]
  407746:	f107 0114 	add.w	r1, r7, #20
  40774a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  40774c:	4618      	mov	r0, r3
  40774e:	4b5e      	ldr	r3, [pc, #376]	; (4078c8 <prvIPTask+0x1b8>)
  407750:	4798      	blx	r3
  407752:	4603      	mov	r3, r0
  407754:	2b00      	cmp	r3, #0
  407756:	d101      	bne.n	40775c <prvIPTask+0x4c>
		{
			xReceivedEvent.eEventType = eNoEvent;
  407758:	23ff      	movs	r3, #255	; 0xff
  40775a:	753b      	strb	r3, [r7, #20]
		}

		#if( ipconfigCHECK_IP_QUEUE_SPACE != 0 )
		{
			if( xReceivedEvent.eEventType != eNoEvent )
  40775c:	f997 3014 	ldrsb.w	r3, [r7, #20]
  407760:	f1b3 3fff 	cmp.w	r3, #4294967295
  407764:	d00d      	beq.n	407782 <prvIPTask+0x72>
			{
			UBaseType_t uxCount;

				uxCount = uxQueueSpacesAvailable( xNetworkEventQueue );
  407766:	4b57      	ldr	r3, [pc, #348]	; (4078c4 <prvIPTask+0x1b4>)
  407768:	681b      	ldr	r3, [r3, #0]
  40776a:	4618      	mov	r0, r3
  40776c:	4b57      	ldr	r3, [pc, #348]	; (4078cc <prvIPTask+0x1bc>)
  40776e:	4798      	blx	r3
  407770:	6238      	str	r0, [r7, #32]
				if( uxQueueMinimumSpace > uxCount )
  407772:	4b57      	ldr	r3, [pc, #348]	; (4078d0 <prvIPTask+0x1c0>)
  407774:	681a      	ldr	r2, [r3, #0]
  407776:	6a3b      	ldr	r3, [r7, #32]
  407778:	429a      	cmp	r2, r3
  40777a:	d902      	bls.n	407782 <prvIPTask+0x72>
				{
					uxQueueMinimumSpace = uxCount;
  40777c:	4a54      	ldr	r2, [pc, #336]	; (4078d0 <prvIPTask+0x1c0>)
  40777e:	6a3b      	ldr	r3, [r7, #32]
  407780:	6013      	str	r3, [r2, #0]
		}
		#endif /* ipconfigCHECK_IP_QUEUE_SPACE */

		iptraceNETWORK_EVENT_RECEIVED( xReceivedEvent.eEventType );

		switch( xReceivedEvent.eEventType )
  407782:	f997 3014 	ldrsb.w	r3, [r7, #20]
  407786:	2b0c      	cmp	r3, #12
  407788:	d87f      	bhi.n	40788a <prvIPTask+0x17a>
  40778a:	a201      	add	r2, pc, #4	; (adr r2, 407790 <prvIPTask+0x80>)
  40778c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  407790:	004077c5 	.word	0x004077c5
  407794:	004077d1 	.word	0x004077d1
  407798:	004077db 	.word	0x004077db
  40779c:	004077e7 	.word	0x004077e7
  4077a0:	00407841 	.word	0x00407841
  4077a4:	0040788b 	.word	0x0040788b
  4077a8:	00407855 	.word	0x00407855
  4077ac:	00407861 	.word	0x00407861
  4077b0:	00407885 	.word	0x00407885
  4077b4:	004077ed 	.word	0x004077ed
  4077b8:	00407837 	.word	0x00407837
  4077bc:	0040784b 	.word	0x0040784b
  4077c0:	0040788b 	.word	0x0040788b
		{
			case eNetworkDownEvent :
				/* Attempt to establish a connection. */
				xNetworkUp = pdFALSE;
  4077c4:	4b43      	ldr	r3, [pc, #268]	; (4078d4 <prvIPTask+0x1c4>)
  4077c6:	2200      	movs	r2, #0
  4077c8:	601a      	str	r2, [r3, #0]
				prvProcessNetworkDownEvent();
  4077ca:	4b43      	ldr	r3, [pc, #268]	; (4078d8 <prvIPTask+0x1c8>)
  4077cc:	4798      	blx	r3
				break;
  4077ce:	e05f      	b.n	407890 <prvIPTask+0x180>

			case eNetworkRxEvent:
				/* The network hardware driver has received a new packet.  A
				pointer to the received buffer is located in the pvData member
				of the received event structure. */
				prvHandleEthernetPacket( ( NetworkBufferDescriptor_t * ) ( xReceivedEvent.pvData ) );
  4077d0:	69bb      	ldr	r3, [r7, #24]
  4077d2:	4618      	mov	r0, r3
  4077d4:	4b41      	ldr	r3, [pc, #260]	; (4078dc <prvIPTask+0x1cc>)
  4077d6:	4798      	blx	r3
				break;
  4077d8:	e05a      	b.n	407890 <prvIPTask+0x180>

			case eNetworkTxEvent:
				/* Send a network packet. The ownership will  be transferred to
				the driver, which will release it after delivery. */
				xNetworkInterfaceOutput( ( NetworkBufferDescriptor_t * ) ( xReceivedEvent.pvData ), pdTRUE );
  4077da:	69bb      	ldr	r3, [r7, #24]
  4077dc:	2101      	movs	r1, #1
  4077de:	4618      	mov	r0, r3
  4077e0:	4b3f      	ldr	r3, [pc, #252]	; (4078e0 <prvIPTask+0x1d0>)
  4077e2:	4798      	blx	r3
				break;
  4077e4:	e054      	b.n	407890 <prvIPTask+0x180>

			case eARPTimerEvent :
				/* The ARP timer has expired, process the ARP cache. */
				vARPAgeCache();
  4077e6:	4b3f      	ldr	r3, [pc, #252]	; (4078e4 <prvIPTask+0x1d4>)
  4077e8:	4798      	blx	r3
				break;
  4077ea:	e051      	b.n	407890 <prvIPTask+0x180>
				/* FreeRTOS_bind (a user API) wants the IP-task to bind a socket
				to a port. The port number is communicated in the socket field
				usLocalPort. vSocketBind() will actually bind the socket and the
				API will unblock as soon as the eSOCKET_BOUND event is
				triggered. */
				pxSocket = ( FreeRTOS_Socket_t * ) ( xReceivedEvent.pvData );
  4077ec:	69bb      	ldr	r3, [r7, #24]
  4077ee:	61fb      	str	r3, [r7, #28]
				xAddress.sin_addr = 0u;	/* For the moment. */
  4077f0:	2300      	movs	r3, #0
  4077f2:	613b      	str	r3, [r7, #16]
				xAddress.sin_port = FreeRTOS_ntohs( pxSocket->usLocalPort );
  4077f4:	69fb      	ldr	r3, [r7, #28]
  4077f6:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
  4077f8:	021b      	lsls	r3, r3, #8
  4077fa:	b21a      	sxth	r2, r3
  4077fc:	69fb      	ldr	r3, [r7, #28]
  4077fe:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
  407800:	0a1b      	lsrs	r3, r3, #8
  407802:	b29b      	uxth	r3, r3
  407804:	b21b      	sxth	r3, r3
  407806:	4313      	orrs	r3, r2
  407808:	b21b      	sxth	r3, r3
  40780a:	b29b      	uxth	r3, r3
  40780c:	81fb      	strh	r3, [r7, #14]
				pxSocket->usLocalPort = 0u;
  40780e:	69fb      	ldr	r3, [r7, #28]
  407810:	2200      	movs	r2, #0
  407812:	849a      	strh	r2, [r3, #36]	; 0x24
				vSocketBind( pxSocket, &xAddress, sizeof( xAddress ), pdFALSE );
  407814:	f107 010c 	add.w	r1, r7, #12
  407818:	2300      	movs	r3, #0
  40781a:	2208      	movs	r2, #8
  40781c:	69f8      	ldr	r0, [r7, #28]
  40781e:	4c32      	ldr	r4, [pc, #200]	; (4078e8 <prvIPTask+0x1d8>)
  407820:	47a0      	blx	r4

				/* Before 'eSocketBindEvent' was sent it was tested that
				( xEventGroup != NULL ) so it can be used now to wake up the
				user. */
				pxSocket->xEventBits |= eSOCKET_BOUND;
  407822:	69fb      	ldr	r3, [r7, #28]
  407824:	681b      	ldr	r3, [r3, #0]
  407826:	f043 0210 	orr.w	r2, r3, #16
  40782a:	69fb      	ldr	r3, [r7, #28]
  40782c:	601a      	str	r2, [r3, #0]
				vSocketWakeUpUser( pxSocket );
  40782e:	69f8      	ldr	r0, [r7, #28]
  407830:	4b2e      	ldr	r3, [pc, #184]	; (4078ec <prvIPTask+0x1dc>)
  407832:	4798      	blx	r3
				break;
  407834:	e02c      	b.n	407890 <prvIPTask+0x180>
			case eSocketCloseEvent :
				/* The user API FreeRTOS_closesocket() has sent a message to the
				IP-task to actually close a socket. This is handled in
				vSocketClose().  As the socket gets closed, there is no way to
				report back to the API, so the API won't wait for the result */
				vSocketClose( ( FreeRTOS_Socket_t * ) ( xReceivedEvent.pvData ) );
  407836:	69bb      	ldr	r3, [r7, #24]
  407838:	4618      	mov	r0, r3
  40783a:	4b2d      	ldr	r3, [pc, #180]	; (4078f0 <prvIPTask+0x1e0>)
  40783c:	4798      	blx	r3
				break;
  40783e:	e027      	b.n	407890 <prvIPTask+0x180>

			case eStackTxEvent :
				/* The network stack has generated a packet to send.  A
				pointer to the generated buffer is located in the pvData
				member of the received event structure. */
				vProcessGeneratedUDPPacket( ( NetworkBufferDescriptor_t * ) ( xReceivedEvent.pvData ) );
  407840:	69bb      	ldr	r3, [r7, #24]
  407842:	4618      	mov	r0, r3
  407844:	4b2b      	ldr	r3, [pc, #172]	; (4078f4 <prvIPTask+0x1e4>)
  407846:	4798      	blx	r3
				break;
  407848:	e022      	b.n	407890 <prvIPTask+0x180>
				/* FreeRTOS_select() has got unblocked by a socket event,
				vSocketSelect() will check which sockets actually have an event
				and update the socket field xSocketBits. */
				#if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
				{
					vSocketSelect( ( SocketSelect_t * ) ( xReceivedEvent.pvData ) );
  40784a:	69bb      	ldr	r3, [r7, #24]
  40784c:	4618      	mov	r0, r3
  40784e:	4b2a      	ldr	r3, [pc, #168]	; (4078f8 <prvIPTask+0x1e8>)
  407850:	4798      	blx	r3
				}
				#endif /* ipconfigSUPPORT_SELECT_FUNCTION == 1 */
				break;
  407852:	e01d      	b.n	407890 <prvIPTask+0x180>
			case eTCPTimerEvent :
				#if( ipconfigUSE_TCP == 1 )
				{
					/* Simply mark the TCP timer as expired so it gets processed
					the next time prvCheckNetworkTimers() is called. */
					xTCPTimer.bExpired = pdTRUE_UNSIGNED;
  407854:	4a13      	ldr	r2, [pc, #76]	; (4078a4 <prvIPTask+0x194>)
  407856:	7813      	ldrb	r3, [r2, #0]
  407858:	f043 0302 	orr.w	r3, r3, #2
  40785c:	7013      	strb	r3, [r2, #0]
				}
				#endif /* ipconfigUSE_TCP */
				break;
  40785e:	e017      	b.n	407890 <prvIPTask+0x180>
				/* The API FreeRTOS_accept() was called, the IP-task will now
				check if the listening socket (communicated in pvData) actually
				received a new connection. */
				#if( ipconfigUSE_TCP == 1 )
				{
					pxSocket = ( FreeRTOS_Socket_t * ) ( xReceivedEvent.pvData );
  407860:	69bb      	ldr	r3, [r7, #24]
  407862:	61fb      	str	r3, [r7, #28]

					if( xTCPCheckNewClient( pxSocket ) != pdFALSE )
  407864:	69f8      	ldr	r0, [r7, #28]
  407866:	4b25      	ldr	r3, [pc, #148]	; (4078fc <prvIPTask+0x1ec>)
  407868:	4798      	blx	r3
  40786a:	4603      	mov	r3, r0
  40786c:	2b00      	cmp	r3, #0
  40786e:	d00e      	beq.n	40788e <prvIPTask+0x17e>
					{
						pxSocket->xEventBits |= eSOCKET_ACCEPT;
  407870:	69fb      	ldr	r3, [r7, #28]
  407872:	681b      	ldr	r3, [r3, #0]
  407874:	f043 0204 	orr.w	r2, r3, #4
  407878:	69fb      	ldr	r3, [r7, #28]
  40787a:	601a      	str	r2, [r3, #0]
						vSocketWakeUpUser( pxSocket );
  40787c:	69f8      	ldr	r0, [r7, #28]
  40787e:	4b1b      	ldr	r3, [pc, #108]	; (4078ec <prvIPTask+0x1dc>)
  407880:	4798      	blx	r3
					}
				}
				#endif /* ipconfigUSE_TCP */
				break;
  407882:	e004      	b.n	40788e <prvIPTask+0x17e>
			case eTCPNetStat:
				/* FreeRTOS_netstat() was called to have the IP-task print an
				overview of all sockets and their connections */
				#if( ( ipconfigUSE_TCP == 1 ) && ( ipconfigHAS_PRINTF == 1 ) )
				{
					vTCPNetStat();
  407884:	4b1e      	ldr	r3, [pc, #120]	; (407900 <prvIPTask+0x1f0>)
  407886:	4798      	blx	r3
				}
				#endif /* ipconfigUSE_TCP */
				break;
  407888:	e002      	b.n	407890 <prvIPTask+0x180>

			default :
				/* Should not get here. */
				break;
  40788a:	bf00      	nop
  40788c:	e000      	b.n	407890 <prvIPTask+0x180>
				break;
  40788e:	bf00      	nop
		}

		if( xNetworkDownEventPending != pdFALSE )
  407890:	4b1c      	ldr	r3, [pc, #112]	; (407904 <prvIPTask+0x1f4>)
  407892:	681b      	ldr	r3, [r3, #0]
  407894:	2b00      	cmp	r3, #0
  407896:	f43f af4c 	beq.w	407732 <prvIPTask+0x22>
		{
			/* A network down event could not be posted to the network event
			queue because the queue was full.  Try posting again. */
			FreeRTOS_NetworkDown();
  40789a:	4b01      	ldr	r3, [pc, #4]	; (4078a0 <prvIPTask+0x190>)
  40789c:	4798      	blx	r3
		ipconfigWATCHDOG_TIMER();
  40789e:	e748      	b.n	407732 <prvIPTask+0x22>
  4078a0:	00407b25 	.word	0x00407b25
  4078a4:	20006d1c 	.word	0x20006d1c
  4078a8:	00407a99 	.word	0x00407a99
  4078ac:	20006d30 	.word	0x20006d30
  4078b0:	0041ca18 	.word	0x0041ca18
  4078b4:	00416c7d 	.word	0x00416c7d
  4078b8:	2000b537 	.word	0x2000b537
  4078bc:	004079b9 	.word	0x004079b9
  4078c0:	00407969 	.word	0x00407969
  4078c4:	20006cc8 	.word	0x20006cc8
  4078c8:	00411c15 	.word	0x00411c15
  4078cc:	00411ff1 	.word	0x00411ff1
  4078d0:	200000cc 	.word	0x200000cc
  4078d4:	20006d04 	.word	0x20006d04
  4078d8:	00407f91 	.word	0x00407f91
  4078dc:	00407939 	.word	0x00407939
  4078e0:	004102dd 	.word	0x004102dd
  4078e4:	00407499 	.word	0x00407499
  4078e8:	00409005 	.word	0x00409005
  4078ec:	00409611 	.word	0x00409611
  4078f0:	004091e9 	.word	0x004091e9
  4078f4:	0040edf5 	.word	0x0040edf5
  4078f8:	0040a3d5 	.word	0x0040a3d5
  4078fc:	0040d8e1 	.word	0x0040d8e1
  407900:	0040a219 	.word	0x0040a219
  407904:	20006cf8 	.word	0x20006cf8

00407908 <xIsCallingFromIPTask>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xIsCallingFromIPTask( void )
{
  407908:	b580      	push	{r7, lr}
  40790a:	b082      	sub	sp, #8
  40790c:	af00      	add	r7, sp, #0
BaseType_t xReturn;

	if( xTaskGetCurrentTaskHandle() == xIPTaskHandle )
  40790e:	4b08      	ldr	r3, [pc, #32]	; (407930 <xIsCallingFromIPTask+0x28>)
  407910:	4798      	blx	r3
  407912:	4602      	mov	r2, r0
  407914:	4b07      	ldr	r3, [pc, #28]	; (407934 <xIsCallingFromIPTask+0x2c>)
  407916:	681b      	ldr	r3, [r3, #0]
  407918:	429a      	cmp	r2, r3
  40791a:	d102      	bne.n	407922 <xIsCallingFromIPTask+0x1a>
	{
		xReturn = pdTRUE;
  40791c:	2301      	movs	r3, #1
  40791e:	607b      	str	r3, [r7, #4]
  407920:	e001      	b.n	407926 <xIsCallingFromIPTask+0x1e>
	}
	else
	{
		xReturn = pdFALSE;
  407922:	2300      	movs	r3, #0
  407924:	607b      	str	r3, [r7, #4]
	}

	return xReturn;
  407926:	687b      	ldr	r3, [r7, #4]
}
  407928:	4618      	mov	r0, r3
  40792a:	3708      	adds	r7, #8
  40792c:	46bd      	mov	sp, r7
  40792e:	bd80      	pop	{r7, pc}
  407930:	00412ee5 	.word	0x00412ee5
  407934:	20006cfc 	.word	0x20006cfc

00407938 <prvHandleEthernetPacket>:
/*-----------------------------------------------------------*/

static void prvHandleEthernetPacket( NetworkBufferDescriptor_t *pxBuffer )
{
  407938:	b580      	push	{r7, lr}
  40793a:	b084      	sub	sp, #16
  40793c:	af00      	add	r7, sp, #0
  40793e:	6078      	str	r0, [r7, #4]
		member.  The loop below walks through the chain processing each packet
		in the chain in turn. */
		do
		{
			/* Store a pointer to the buffer after pxBuffer for use later on. */
			pxNextBuffer = pxBuffer->pxNextBuffer;
  407940:	687b      	ldr	r3, [r7, #4]
  407942:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  407944:	60fb      	str	r3, [r7, #12]

			/* Make it NULL to avoid using it later on. */
			pxBuffer->pxNextBuffer = NULL;
  407946:	687b      	ldr	r3, [r7, #4]
  407948:	2200      	movs	r2, #0
  40794a:	625a      	str	r2, [r3, #36]	; 0x24

			prvProcessEthernetPacket( pxBuffer );
  40794c:	6878      	ldr	r0, [r7, #4]
  40794e:	4b05      	ldr	r3, [pc, #20]	; (407964 <prvHandleEthernetPacket+0x2c>)
  407950:	4798      	blx	r3
			pxBuffer = pxNextBuffer;
  407952:	68fb      	ldr	r3, [r7, #12]
  407954:	607b      	str	r3, [r7, #4]

		/* While there is another packet in the chain. */
		} while( pxBuffer != NULL );
  407956:	687b      	ldr	r3, [r7, #4]
  407958:	2b00      	cmp	r3, #0
  40795a:	d1f1      	bne.n	407940 <prvHandleEthernetPacket+0x8>
	}
	#endif /* ipconfigUSE_LINKED_RX_MESSAGES */
}
  40795c:	bf00      	nop
  40795e:	3710      	adds	r7, #16
  407960:	46bd      	mov	sp, r7
  407962:	bd80      	pop	{r7, pc}
  407964:	00408029 	.word	0x00408029

00407968 <prvCalculateSleepTime>:
/*-----------------------------------------------------------*/

static TickType_t prvCalculateSleepTime( void )
{
  407968:	b480      	push	{r7}
  40796a:	b083      	sub	sp, #12
  40796c:	af00      	add	r7, sp, #0
TickType_t xMaximumSleepTime;

	/* Start with the maximum sleep time, then check this against the remaining
	time in any other timers that are active. */
	xMaximumSleepTime = ipconfigMAX_IP_TASK_SLEEP_TIME;
  40796e:	f242 7310 	movw	r3, #10000	; 0x2710
  407972:	607b      	str	r3, [r7, #4]

	if( xARPTimer.bActive != pdFALSE_UNSIGNED )
  407974:	4b0e      	ldr	r3, [pc, #56]	; (4079b0 <prvCalculateSleepTime+0x48>)
  407976:	781b      	ldrb	r3, [r3, #0]
  407978:	f003 0301 	and.w	r3, r3, #1
  40797c:	b2db      	uxtb	r3, r3
  40797e:	2b00      	cmp	r3, #0
  407980:	d007      	beq.n	407992 <prvCalculateSleepTime+0x2a>
	{
		if( xARPTimer.ulRemainingTime < xMaximumSleepTime )
  407982:	4b0b      	ldr	r3, [pc, #44]	; (4079b0 <prvCalculateSleepTime+0x48>)
  407984:	68da      	ldr	r2, [r3, #12]
  407986:	687b      	ldr	r3, [r7, #4]
  407988:	429a      	cmp	r2, r3
  40798a:	d202      	bcs.n	407992 <prvCalculateSleepTime+0x2a>
		{
			xMaximumSleepTime = xARPTimer.ulReloadTime;
  40798c:	4b08      	ldr	r3, [pc, #32]	; (4079b0 <prvCalculateSleepTime+0x48>)
  40798e:	691b      	ldr	r3, [r3, #16]
  407990:	607b      	str	r3, [r7, #4]
	}
	#endif /* ipconfigUSE_DHCP */

	#if( ipconfigUSE_TCP == 1 )
	{
		if( xTCPTimer.ulRemainingTime < xMaximumSleepTime )
  407992:	4b08      	ldr	r3, [pc, #32]	; (4079b4 <prvCalculateSleepTime+0x4c>)
  407994:	68da      	ldr	r2, [r3, #12]
  407996:	687b      	ldr	r3, [r7, #4]
  407998:	429a      	cmp	r2, r3
  40799a:	d202      	bcs.n	4079a2 <prvCalculateSleepTime+0x3a>
		{
			xMaximumSleepTime = xTCPTimer.ulRemainingTime;
  40799c:	4b05      	ldr	r3, [pc, #20]	; (4079b4 <prvCalculateSleepTime+0x4c>)
  40799e:	68db      	ldr	r3, [r3, #12]
  4079a0:	607b      	str	r3, [r7, #4]
			}
		}
	}
	#endif

	return xMaximumSleepTime;
  4079a2:	687b      	ldr	r3, [r7, #4]
}
  4079a4:	4618      	mov	r0, r3
  4079a6:	370c      	adds	r7, #12
  4079a8:	46bd      	mov	sp, r7
  4079aa:	f85d 7b04 	ldr.w	r7, [sp], #4
  4079ae:	4770      	bx	lr
  4079b0:	20006d08 	.word	0x20006d08
  4079b4:	20006d1c 	.word	0x20006d1c

004079b8 <prvCheckNetworkTimers>:
/*-----------------------------------------------------------*/

static void prvCheckNetworkTimers( void )
{
  4079b8:	b580      	push	{r7, lr}
  4079ba:	b084      	sub	sp, #16
  4079bc:	af00      	add	r7, sp, #0
	/* Is it time for ARP processing? */
	if( prvIPTimerCheck( &xARPTimer ) != pdFALSE )
  4079be:	481a      	ldr	r0, [pc, #104]	; (407a28 <prvCheckNetworkTimers+0x70>)
  4079c0:	4b1a      	ldr	r3, [pc, #104]	; (407a2c <prvCheckNetworkTimers+0x74>)
  4079c2:	4798      	blx	r3
  4079c4:	4603      	mov	r3, r0
  4079c6:	2b00      	cmp	r3, #0
  4079c8:	d002      	beq.n	4079d0 <prvCheckNetworkTimers+0x18>
	{
		xSendEventToIPTask( eARPTimerEvent );
  4079ca:	2003      	movs	r0, #3
  4079cc:	4b18      	ldr	r3, [pc, #96]	; (407a30 <prvCheckNetworkTimers+0x78>)
  4079ce:	4798      	blx	r3
	{
	BaseType_t xWillSleep;
	TickType_t xNextTime;
	BaseType_t xCheckTCPSockets;

		if( uxQueueMessagesWaiting( xNetworkEventQueue ) == 0u )
  4079d0:	4b18      	ldr	r3, [pc, #96]	; (407a34 <prvCheckNetworkTimers+0x7c>)
  4079d2:	681b      	ldr	r3, [r3, #0]
  4079d4:	4618      	mov	r0, r3
  4079d6:	4b18      	ldr	r3, [pc, #96]	; (407a38 <prvCheckNetworkTimers+0x80>)
  4079d8:	4798      	blx	r3
  4079da:	4603      	mov	r3, r0
  4079dc:	2b00      	cmp	r3, #0
  4079de:	d102      	bne.n	4079e6 <prvCheckNetworkTimers+0x2e>
		{
			xWillSleep = pdTRUE;
  4079e0:	2301      	movs	r3, #1
  4079e2:	60fb      	str	r3, [r7, #12]
  4079e4:	e001      	b.n	4079ea <prvCheckNetworkTimers+0x32>
		}
		else
		{
			xWillSleep = pdFALSE;
  4079e6:	2300      	movs	r3, #0
  4079e8:	60fb      	str	r3, [r7, #12]
		}

		/* Sockets need to be checked if the TCP timer has expired. */
		xCheckTCPSockets = prvIPTimerCheck( &xTCPTimer );
  4079ea:	4814      	ldr	r0, [pc, #80]	; (407a3c <prvCheckNetworkTimers+0x84>)
  4079ec:	4b0f      	ldr	r3, [pc, #60]	; (407a2c <prvCheckNetworkTimers+0x74>)
  4079ee:	4798      	blx	r3
  4079f0:	60b8      	str	r0, [r7, #8]

		/* Sockets will also be checked if there are TCP messages but the
		message queue is empty (indicated by xWillSleep being true). */
		if( ( xProcessedTCPMessage != pdFALSE ) && ( xWillSleep != pdFALSE ) )
  4079f2:	4b13      	ldr	r3, [pc, #76]	; (407a40 <prvCheckNetworkTimers+0x88>)
  4079f4:	681b      	ldr	r3, [r3, #0]
  4079f6:	2b00      	cmp	r3, #0
  4079f8:	d004      	beq.n	407a04 <prvCheckNetworkTimers+0x4c>
  4079fa:	68fb      	ldr	r3, [r7, #12]
  4079fc:	2b00      	cmp	r3, #0
  4079fe:	d001      	beq.n	407a04 <prvCheckNetworkTimers+0x4c>
		{
			xCheckTCPSockets = pdTRUE;
  407a00:	2301      	movs	r3, #1
  407a02:	60bb      	str	r3, [r7, #8]
		}

		if( xCheckTCPSockets != pdFALSE )
  407a04:	68bb      	ldr	r3, [r7, #8]
  407a06:	2b00      	cmp	r3, #0
  407a08:	d00a      	beq.n	407a20 <prvCheckNetworkTimers+0x68>
		{
			/* Attend to the sockets, returning the period after which the
			check must be repeated. */
			xNextTime = xTCPTimerCheck( xWillSleep );
  407a0a:	68f8      	ldr	r0, [r7, #12]
  407a0c:	4b0d      	ldr	r3, [pc, #52]	; (407a44 <prvCheckNetworkTimers+0x8c>)
  407a0e:	4798      	blx	r3
  407a10:	6078      	str	r0, [r7, #4]
			prvIPTimerStart( &xTCPTimer, xNextTime );
  407a12:	6879      	ldr	r1, [r7, #4]
  407a14:	4809      	ldr	r0, [pc, #36]	; (407a3c <prvCheckNetworkTimers+0x84>)
  407a16:	4b0c      	ldr	r3, [pc, #48]	; (407a48 <prvCheckNetworkTimers+0x90>)
  407a18:	4798      	blx	r3
			xProcessedTCPMessage = 0;
  407a1a:	4b09      	ldr	r3, [pc, #36]	; (407a40 <prvCheckNetworkTimers+0x88>)
  407a1c:	2200      	movs	r2, #0
  407a1e:	601a      	str	r2, [r3, #0]
		}
	}
	#endif /* ipconfigUSE_TCP == 1 */
}
  407a20:	bf00      	nop
  407a22:	3710      	adds	r7, #16
  407a24:	46bd      	mov	sp, r7
  407a26:	bd80      	pop	{r7, pc}
  407a28:	20006d08 	.word	0x20006d08
  407a2c:	00407abd 	.word	0x00407abd
  407a30:	00407e19 	.word	0x00407e19
  407a34:	20006cc8 	.word	0x20006cc8
  407a38:	00411fa9 	.word	0x00411fa9
  407a3c:	20006d1c 	.word	0x20006d1c
  407a40:	20006d00 	.word	0x20006d00
  407a44:	00409da1 	.word	0x00409da1
  407a48:	00407a4d 	.word	0x00407a4d

00407a4c <prvIPTimerStart>:
/*-----------------------------------------------------------*/

static void prvIPTimerStart( IPTimer_t *pxTimer, TickType_t xTime )
{
  407a4c:	b580      	push	{r7, lr}
  407a4e:	b082      	sub	sp, #8
  407a50:	af00      	add	r7, sp, #0
  407a52:	6078      	str	r0, [r7, #4]
  407a54:	6039      	str	r1, [r7, #0]
	vTaskSetTimeOutState( &pxTimer->xTimeOut );
  407a56:	687b      	ldr	r3, [r7, #4]
  407a58:	3304      	adds	r3, #4
  407a5a:	4618      	mov	r0, r3
  407a5c:	4b0d      	ldr	r3, [pc, #52]	; (407a94 <prvIPTimerStart+0x48>)
  407a5e:	4798      	blx	r3
	pxTimer->ulRemainingTime = xTime;
  407a60:	687b      	ldr	r3, [r7, #4]
  407a62:	683a      	ldr	r2, [r7, #0]
  407a64:	60da      	str	r2, [r3, #12]

	if( xTime == ( TickType_t ) 0 )
  407a66:	683b      	ldr	r3, [r7, #0]
  407a68:	2b00      	cmp	r3, #0
  407a6a:	d105      	bne.n	407a78 <prvIPTimerStart+0x2c>
	{
		pxTimer->bExpired = pdTRUE_UNSIGNED;
  407a6c:	687a      	ldr	r2, [r7, #4]
  407a6e:	7813      	ldrb	r3, [r2, #0]
  407a70:	f043 0302 	orr.w	r3, r3, #2
  407a74:	7013      	strb	r3, [r2, #0]
  407a76:	e004      	b.n	407a82 <prvIPTimerStart+0x36>
	}
	else
	{
		pxTimer->bExpired = pdFALSE_UNSIGNED;
  407a78:	687a      	ldr	r2, [r7, #4]
  407a7a:	7813      	ldrb	r3, [r2, #0]
  407a7c:	f36f 0341 	bfc	r3, #1, #1
  407a80:	7013      	strb	r3, [r2, #0]
	}

	pxTimer->bActive = pdTRUE_UNSIGNED;
  407a82:	687a      	ldr	r2, [r7, #4]
  407a84:	7813      	ldrb	r3, [r2, #0]
  407a86:	f043 0301 	orr.w	r3, r3, #1
  407a8a:	7013      	strb	r3, [r2, #0]
}
  407a8c:	bf00      	nop
  407a8e:	3708      	adds	r7, #8
  407a90:	46bd      	mov	sp, r7
  407a92:	bd80      	pop	{r7, pc}
  407a94:	00412c89 	.word	0x00412c89

00407a98 <prvIPTimerReload>:
/*-----------------------------------------------------------*/

static void prvIPTimerReload( IPTimer_t *pxTimer, TickType_t xTime )
{
  407a98:	b580      	push	{r7, lr}
  407a9a:	b082      	sub	sp, #8
  407a9c:	af00      	add	r7, sp, #0
  407a9e:	6078      	str	r0, [r7, #4]
  407aa0:	6039      	str	r1, [r7, #0]
	pxTimer->ulReloadTime = xTime;
  407aa2:	687b      	ldr	r3, [r7, #4]
  407aa4:	683a      	ldr	r2, [r7, #0]
  407aa6:	611a      	str	r2, [r3, #16]
	prvIPTimerStart( pxTimer, xTime );
  407aa8:	6839      	ldr	r1, [r7, #0]
  407aaa:	6878      	ldr	r0, [r7, #4]
  407aac:	4b02      	ldr	r3, [pc, #8]	; (407ab8 <prvIPTimerReload+0x20>)
  407aae:	4798      	blx	r3
}
  407ab0:	bf00      	nop
  407ab2:	3708      	adds	r7, #8
  407ab4:	46bd      	mov	sp, r7
  407ab6:	bd80      	pop	{r7, pc}
  407ab8:	00407a4d 	.word	0x00407a4d

00407abc <prvIPTimerCheck>:
/*-----------------------------------------------------------*/

static BaseType_t prvIPTimerCheck( IPTimer_t *pxTimer )
{
  407abc:	b580      	push	{r7, lr}
  407abe:	b084      	sub	sp, #16
  407ac0:	af00      	add	r7, sp, #0
  407ac2:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	if( pxTimer->bActive == pdFALSE_UNSIGNED )
  407ac4:	687b      	ldr	r3, [r7, #4]
  407ac6:	781b      	ldrb	r3, [r3, #0]
  407ac8:	f003 0301 	and.w	r3, r3, #1
  407acc:	b2db      	uxtb	r3, r3
  407ace:	2b00      	cmp	r3, #0
  407ad0:	d102      	bne.n	407ad8 <prvIPTimerCheck+0x1c>
	{
		/* The timer is not enabled. */
		xReturn = pdFALSE;
  407ad2:	2300      	movs	r3, #0
  407ad4:	60fb      	str	r3, [r7, #12]
  407ad6:	e01c      	b.n	407b12 <prvIPTimerCheck+0x56>
	}
	else
	{
		/* The timer might have set the bExpired flag already, if not, check the
		value of xTimeOut against ulRemainingTime. */
		if( ( pxTimer->bExpired != pdFALSE_UNSIGNED ) ||
  407ad8:	687b      	ldr	r3, [r7, #4]
  407ada:	781b      	ldrb	r3, [r3, #0]
  407adc:	f003 0302 	and.w	r3, r3, #2
  407ae0:	b2db      	uxtb	r3, r3
  407ae2:	2b00      	cmp	r3, #0
  407ae4:	d10a      	bne.n	407afc <prvIPTimerCheck+0x40>
			( xTaskCheckForTimeOut( &( pxTimer->xTimeOut ), &( pxTimer->ulRemainingTime ) ) != pdFALSE ) )
  407ae6:	687b      	ldr	r3, [r7, #4]
  407ae8:	1d1a      	adds	r2, r3, #4
  407aea:	687b      	ldr	r3, [r7, #4]
  407aec:	330c      	adds	r3, #12
  407aee:	4619      	mov	r1, r3
  407af0:	4610      	mov	r0, r2
  407af2:	4b0a      	ldr	r3, [pc, #40]	; (407b1c <prvIPTimerCheck+0x60>)
  407af4:	4798      	blx	r3
  407af6:	4603      	mov	r3, r0
		if( ( pxTimer->bExpired != pdFALSE_UNSIGNED ) ||
  407af8:	2b00      	cmp	r3, #0
  407afa:	d008      	beq.n	407b0e <prvIPTimerCheck+0x52>
		{
			prvIPTimerStart( pxTimer, pxTimer->ulReloadTime );
  407afc:	687b      	ldr	r3, [r7, #4]
  407afe:	691b      	ldr	r3, [r3, #16]
  407b00:	4619      	mov	r1, r3
  407b02:	6878      	ldr	r0, [r7, #4]
  407b04:	4b06      	ldr	r3, [pc, #24]	; (407b20 <prvIPTimerCheck+0x64>)
  407b06:	4798      	blx	r3
			xReturn = pdTRUE;
  407b08:	2301      	movs	r3, #1
  407b0a:	60fb      	str	r3, [r7, #12]
  407b0c:	e001      	b.n	407b12 <prvIPTimerCheck+0x56>
		}
		else
		{
			xReturn = pdFALSE;
  407b0e:	2300      	movs	r3, #0
  407b10:	60fb      	str	r3, [r7, #12]
		}
	}

	return xReturn;
  407b12:	68fb      	ldr	r3, [r7, #12]
}
  407b14:	4618      	mov	r0, r3
  407b16:	3710      	adds	r7, #16
  407b18:	46bd      	mov	sp, r7
  407b1a:	bd80      	pop	{r7, pc}
  407b1c:	00412d0d 	.word	0x00412d0d
  407b20:	00407a4d 	.word	0x00407a4d

00407b24 <FreeRTOS_NetworkDown>:
/*-----------------------------------------------------------*/

void FreeRTOS_NetworkDown( void )
{
  407b24:	b580      	push	{r7, lr}
  407b26:	b082      	sub	sp, #8
  407b28:	af00      	add	r7, sp, #0
static const IPStackEvent_t xNetworkDownEvent = { eNetworkDownEvent, NULL };
const TickType_t xDontBlock = ( TickType_t ) 0;
  407b2a:	2300      	movs	r3, #0
  407b2c:	607b      	str	r3, [r7, #4]

	/* Simply send the network task the appropriate event. */
	if( xSendEventStructToIPTask( &xNetworkDownEvent, xDontBlock ) != pdPASS )
  407b2e:	6879      	ldr	r1, [r7, #4]
  407b30:	4808      	ldr	r0, [pc, #32]	; (407b54 <FreeRTOS_NetworkDown+0x30>)
  407b32:	4b09      	ldr	r3, [pc, #36]	; (407b58 <FreeRTOS_NetworkDown+0x34>)
  407b34:	4798      	blx	r3
  407b36:	4603      	mov	r3, r0
  407b38:	2b01      	cmp	r3, #1
  407b3a:	d003      	beq.n	407b44 <FreeRTOS_NetworkDown+0x20>
	{
		/* Could not send the message, so it is still pending. */
		xNetworkDownEventPending = pdTRUE;
  407b3c:	4b07      	ldr	r3, [pc, #28]	; (407b5c <FreeRTOS_NetworkDown+0x38>)
  407b3e:	2201      	movs	r2, #1
  407b40:	601a      	str	r2, [r3, #0]
		/* Message was sent so it is not pending. */
		xNetworkDownEventPending = pdFALSE;
	}

	iptraceNETWORK_DOWN();
}
  407b42:	e002      	b.n	407b4a <FreeRTOS_NetworkDown+0x26>
		xNetworkDownEventPending = pdFALSE;
  407b44:	4b05      	ldr	r3, [pc, #20]	; (407b5c <FreeRTOS_NetworkDown+0x38>)
  407b46:	2200      	movs	r2, #0
  407b48:	601a      	str	r2, [r3, #0]
}
  407b4a:	bf00      	nop
  407b4c:	3708      	adds	r7, #8
  407b4e:	46bd      	mov	sp, r7
  407b50:	bd80      	pop	{r7, pc}
  407b52:	bf00      	nop
  407b54:	0041cc00 	.word	0x0041cc00
  407b58:	00407e49 	.word	0x00407e49
  407b5c:	20006cf8 	.word	0x20006cf8

00407b60 <pxUDPPayloadBuffer_to_NetworkBuffer>:

#endif /* ipconfigZERO_COPY_TX_DRIVER != 0 */
/*-----------------------------------------------------------*/

NetworkBufferDescriptor_t *pxUDPPayloadBuffer_to_NetworkBuffer( void *pvBuffer )
{
  407b60:	b480      	push	{r7}
  407b62:	b085      	sub	sp, #20
  407b64:	af00      	add	r7, sp, #0
  407b66:	6078      	str	r0, [r7, #4]
uint8_t *pucBuffer;
NetworkBufferDescriptor_t *pxResult;

	if( pvBuffer == NULL )
  407b68:	687b      	ldr	r3, [r7, #4]
  407b6a:	2b00      	cmp	r3, #0
  407b6c:	d102      	bne.n	407b74 <pxUDPPayloadBuffer_to_NetworkBuffer+0x14>
	{
		pxResult = NULL;
  407b6e:	2300      	movs	r3, #0
  407b70:	60fb      	str	r3, [r7, #12]
  407b72:	e00f      	b.n	407b94 <pxUDPPayloadBuffer_to_NetworkBuffer+0x34>
	}
	else
	{
		/* Obtain the network buffer from the zero copy pointer. */
		pucBuffer = ( uint8_t * ) pvBuffer;
  407b74:	687b      	ldr	r3, [r7, #4]
  407b76:	60bb      	str	r3, [r7, #8]

		/* The input here is a pointer to a payload buffer.  Subtract
		the total size of a UDP/IP header plus the size of the header in
		the network buffer, usually 8 + 2 bytes. */
		pucBuffer -= ( sizeof( UDPPacket_t ) + ipBUFFER_PADDING );
  407b78:	68bb      	ldr	r3, [r7, #8]
  407b7a:	3b34      	subs	r3, #52	; 0x34
  407b7c:	60bb      	str	r3, [r7, #8]

		/* Here a pointer was placed to the network descriptor,
		As a pointer is dereferenced, make sure it is well aligned */
		if( ( ( ( uint32_t ) pucBuffer ) & ( sizeof( pucBuffer ) - 1 ) ) == 0 )
  407b7e:	68bb      	ldr	r3, [r7, #8]
  407b80:	f003 0303 	and.w	r3, r3, #3
  407b84:	2b00      	cmp	r3, #0
  407b86:	d103      	bne.n	407b90 <pxUDPPayloadBuffer_to_NetworkBuffer+0x30>
		{
			/* The following statement may trigger a:
			warning: cast increases required alignment of target type [-Wcast-align].
			It has been confirmed though that the alignment is suitable. */
			pxResult = * ( ( NetworkBufferDescriptor_t ** ) pucBuffer );
  407b88:	68bb      	ldr	r3, [r7, #8]
  407b8a:	681b      	ldr	r3, [r3, #0]
  407b8c:	60fb      	str	r3, [r7, #12]
  407b8e:	e001      	b.n	407b94 <pxUDPPayloadBuffer_to_NetworkBuffer+0x34>
		}
		else
		{
			pxResult = NULL;
  407b90:	2300      	movs	r3, #0
  407b92:	60fb      	str	r3, [r7, #12]
		}
	}

	return pxResult;
  407b94:	68fb      	ldr	r3, [r7, #12]
}
  407b96:	4618      	mov	r0, r3
  407b98:	3714      	adds	r7, #20
  407b9a:	46bd      	mov	sp, r7
  407b9c:	f85d 7b04 	ldr.w	r7, [sp], #4
  407ba0:	4770      	bx	lr
	...

00407ba4 <FreeRTOS_IPInit>:
/*_RB_ Should we add an error or assert if the task priorities are set such that the servers won't function as expected? */
/*_HT_ There was a bug in FreeRTOS_TCP_IP.c that only occurred when the applications' priority was too high.
 As that bug has been repaired, there is not an urgent reason to warn.
 It is better though to use the advised priority scheme. */
BaseType_t FreeRTOS_IPInit( const uint8_t ucIPAddress[ ipIP_ADDRESS_LENGTH_BYTES ], const uint8_t ucNetMask[ ipIP_ADDRESS_LENGTH_BYTES ], const uint8_t ucGatewayAddress[ ipIP_ADDRESS_LENGTH_BYTES ], const uint8_t ucDNSServerAddress[ ipIP_ADDRESS_LENGTH_BYTES ], const uint8_t ucMACAddress[ ipMAC_ADDRESS_LENGTH_BYTES ] )
{
  407ba4:	b5b0      	push	{r4, r5, r7, lr}
  407ba6:	b088      	sub	sp, #32
  407ba8:	af02      	add	r7, sp, #8
  407baa:	60f8      	str	r0, [r7, #12]
  407bac:	60b9      	str	r1, [r7, #8]
  407bae:	607a      	str	r2, [r7, #4]
  407bb0:	603b      	str	r3, [r7, #0]
BaseType_t xReturn = pdFALSE;
  407bb2:	2300      	movs	r3, #0
  407bb4:	617b      	str	r3, [r7, #20]

	/* This function should only be called once. */
	configASSERT( xIPIsNetworkTaskReady() == pdFALSE );
  407bb6:	4b6e      	ldr	r3, [pc, #440]	; (407d70 <FreeRTOS_IPInit+0x1cc>)
  407bb8:	4798      	blx	r3
  407bba:	4603      	mov	r3, r0
  407bbc:	2b00      	cmp	r3, #0
  407bbe:	d005      	beq.n	407bcc <FreeRTOS_IPInit+0x28>
  407bc0:	f240 32b7 	movw	r2, #951	; 0x3b7
  407bc4:	496b      	ldr	r1, [pc, #428]	; (407d74 <FreeRTOS_IPInit+0x1d0>)
  407bc6:	486c      	ldr	r0, [pc, #432]	; (407d78 <FreeRTOS_IPInit+0x1d4>)
  407bc8:	4b6c      	ldr	r3, [pc, #432]	; (407d7c <FreeRTOS_IPInit+0x1d8>)
  407bca:	4798      	blx	r3
	configASSERT( xNetworkEventQueue == NULL );
  407bcc:	4b6c      	ldr	r3, [pc, #432]	; (407d80 <FreeRTOS_IPInit+0x1dc>)
  407bce:	681b      	ldr	r3, [r3, #0]
  407bd0:	2b00      	cmp	r3, #0
  407bd2:	d005      	beq.n	407be0 <FreeRTOS_IPInit+0x3c>
  407bd4:	f44f 726e 	mov.w	r2, #952	; 0x3b8
  407bd8:	4966      	ldr	r1, [pc, #408]	; (407d74 <FreeRTOS_IPInit+0x1d0>)
  407bda:	4867      	ldr	r0, [pc, #412]	; (407d78 <FreeRTOS_IPInit+0x1d4>)
  407bdc:	4b67      	ldr	r3, [pc, #412]	; (407d7c <FreeRTOS_IPInit+0x1d8>)
  407bde:	4798      	blx	r3
	configASSERT( xIPTaskHandle == NULL );
  407be0:	4b68      	ldr	r3, [pc, #416]	; (407d84 <FreeRTOS_IPInit+0x1e0>)
  407be2:	681b      	ldr	r3, [r3, #0]
  407be4:	2b00      	cmp	r3, #0
  407be6:	d005      	beq.n	407bf4 <FreeRTOS_IPInit+0x50>
  407be8:	f240 32b9 	movw	r2, #953	; 0x3b9
  407bec:	4961      	ldr	r1, [pc, #388]	; (407d74 <FreeRTOS_IPInit+0x1d0>)
  407bee:	4862      	ldr	r0, [pc, #392]	; (407d78 <FreeRTOS_IPInit+0x1d4>)
  407bf0:	4b62      	ldr	r3, [pc, #392]	; (407d7c <FreeRTOS_IPInit+0x1d8>)
  407bf2:	4798      	blx	r3
	configASSERT( sizeof( IPHeader_t ) == ipEXPECTED_IPHeader_t_SIZE );
	configASSERT( sizeof( ICMPHeader_t ) == ipEXPECTED_ICMPHeader_t_SIZE );
	configASSERT( sizeof( UDPHeader_t ) == ipEXPECTED_UDPHeader_t_SIZE );

	/* Attempt to create the queue used to communicate with the IP task. */
	xNetworkEventQueue = xQueueCreate( ( UBaseType_t ) ipconfigEVENT_QUEUE_LENGTH, ( UBaseType_t ) sizeof( IPStackEvent_t ) );
  407bf4:	2200      	movs	r2, #0
  407bf6:	2108      	movs	r1, #8
  407bf8:	2046      	movs	r0, #70	; 0x46
  407bfa:	4b63      	ldr	r3, [pc, #396]	; (407d88 <FreeRTOS_IPInit+0x1e4>)
  407bfc:	4798      	blx	r3
  407bfe:	4602      	mov	r2, r0
  407c00:	4b5f      	ldr	r3, [pc, #380]	; (407d80 <FreeRTOS_IPInit+0x1dc>)
  407c02:	601a      	str	r2, [r3, #0]
	configASSERT( xNetworkEventQueue );
  407c04:	4b5e      	ldr	r3, [pc, #376]	; (407d80 <FreeRTOS_IPInit+0x1dc>)
  407c06:	681b      	ldr	r3, [r3, #0]
  407c08:	2b00      	cmp	r3, #0
  407c0a:	d105      	bne.n	407c18 <FreeRTOS_IPInit+0x74>
  407c0c:	f44f 7271 	mov.w	r2, #964	; 0x3c4
  407c10:	4958      	ldr	r1, [pc, #352]	; (407d74 <FreeRTOS_IPInit+0x1d0>)
  407c12:	4859      	ldr	r0, [pc, #356]	; (407d78 <FreeRTOS_IPInit+0x1d4>)
  407c14:	4b59      	ldr	r3, [pc, #356]	; (407d7c <FreeRTOS_IPInit+0x1d8>)
  407c16:	4798      	blx	r3

	if( xNetworkEventQueue != NULL )
  407c18:	4b59      	ldr	r3, [pc, #356]	; (407d80 <FreeRTOS_IPInit+0x1dc>)
  407c1a:	681b      	ldr	r3, [r3, #0]
  407c1c:	2b00      	cmp	r3, #0
  407c1e:	f000 809e 	beq.w	407d5e <FreeRTOS_IPInit+0x1ba>
			to show information about the network event queue. */
			vQueueAddToRegistry( xNetworkEventQueue, "NetEvnt" );
		}
		#endif /* configQUEUE_REGISTRY_SIZE */

		if( xNetworkBuffersInitialise() == pdPASS )
  407c22:	4b5a      	ldr	r3, [pc, #360]	; (407d8c <FreeRTOS_IPInit+0x1e8>)
  407c24:	4798      	blx	r3
  407c26:	4603      	mov	r3, r0
  407c28:	2b01      	cmp	r3, #1
  407c2a:	f040 808c 	bne.w	407d46 <FreeRTOS_IPInit+0x1a2>
		{
			/* Store the local IP and MAC address. */
			xNetworkAddressing.ulDefaultIPAddress = FreeRTOS_inet_addr_quick( ucIPAddress[ 0 ], ucIPAddress[ 1 ], ucIPAddress[ 2 ], ucIPAddress[ 3 ] );
  407c2e:	68fb      	ldr	r3, [r7, #12]
  407c30:	3303      	adds	r3, #3
  407c32:	781b      	ldrb	r3, [r3, #0]
  407c34:	061a      	lsls	r2, r3, #24
  407c36:	68fb      	ldr	r3, [r7, #12]
  407c38:	3302      	adds	r3, #2
  407c3a:	781b      	ldrb	r3, [r3, #0]
  407c3c:	041b      	lsls	r3, r3, #16
  407c3e:	431a      	orrs	r2, r3
  407c40:	68fb      	ldr	r3, [r7, #12]
  407c42:	3301      	adds	r3, #1
  407c44:	781b      	ldrb	r3, [r3, #0]
  407c46:	021b      	lsls	r3, r3, #8
  407c48:	4313      	orrs	r3, r2
  407c4a:	68fa      	ldr	r2, [r7, #12]
  407c4c:	7812      	ldrb	r2, [r2, #0]
  407c4e:	4313      	orrs	r3, r2
  407c50:	4a4f      	ldr	r2, [pc, #316]	; (407d90 <FreeRTOS_IPInit+0x1ec>)
  407c52:	6013      	str	r3, [r2, #0]
			xNetworkAddressing.ulNetMask = FreeRTOS_inet_addr_quick( ucNetMask[ 0 ], ucNetMask[ 1 ], ucNetMask[ 2 ], ucNetMask[ 3 ] );
  407c54:	68bb      	ldr	r3, [r7, #8]
  407c56:	3303      	adds	r3, #3
  407c58:	781b      	ldrb	r3, [r3, #0]
  407c5a:	061a      	lsls	r2, r3, #24
  407c5c:	68bb      	ldr	r3, [r7, #8]
  407c5e:	3302      	adds	r3, #2
  407c60:	781b      	ldrb	r3, [r3, #0]
  407c62:	041b      	lsls	r3, r3, #16
  407c64:	431a      	orrs	r2, r3
  407c66:	68bb      	ldr	r3, [r7, #8]
  407c68:	3301      	adds	r3, #1
  407c6a:	781b      	ldrb	r3, [r3, #0]
  407c6c:	021b      	lsls	r3, r3, #8
  407c6e:	4313      	orrs	r3, r2
  407c70:	68ba      	ldr	r2, [r7, #8]
  407c72:	7812      	ldrb	r2, [r2, #0]
  407c74:	4313      	orrs	r3, r2
  407c76:	4a46      	ldr	r2, [pc, #280]	; (407d90 <FreeRTOS_IPInit+0x1ec>)
  407c78:	6053      	str	r3, [r2, #4]
			xNetworkAddressing.ulGatewayAddress = FreeRTOS_inet_addr_quick( ucGatewayAddress[ 0 ], ucGatewayAddress[ 1 ], ucGatewayAddress[ 2 ], ucGatewayAddress[ 3 ] );
  407c7a:	687b      	ldr	r3, [r7, #4]
  407c7c:	3303      	adds	r3, #3
  407c7e:	781b      	ldrb	r3, [r3, #0]
  407c80:	061a      	lsls	r2, r3, #24
  407c82:	687b      	ldr	r3, [r7, #4]
  407c84:	3302      	adds	r3, #2
  407c86:	781b      	ldrb	r3, [r3, #0]
  407c88:	041b      	lsls	r3, r3, #16
  407c8a:	431a      	orrs	r2, r3
  407c8c:	687b      	ldr	r3, [r7, #4]
  407c8e:	3301      	adds	r3, #1
  407c90:	781b      	ldrb	r3, [r3, #0]
  407c92:	021b      	lsls	r3, r3, #8
  407c94:	4313      	orrs	r3, r2
  407c96:	687a      	ldr	r2, [r7, #4]
  407c98:	7812      	ldrb	r2, [r2, #0]
  407c9a:	4313      	orrs	r3, r2
  407c9c:	4a3c      	ldr	r2, [pc, #240]	; (407d90 <FreeRTOS_IPInit+0x1ec>)
  407c9e:	6093      	str	r3, [r2, #8]
			xNetworkAddressing.ulDNSServerAddress = FreeRTOS_inet_addr_quick( ucDNSServerAddress[ 0 ], ucDNSServerAddress[ 1 ], ucDNSServerAddress[ 2 ], ucDNSServerAddress[ 3 ] );
  407ca0:	683b      	ldr	r3, [r7, #0]
  407ca2:	3303      	adds	r3, #3
  407ca4:	781b      	ldrb	r3, [r3, #0]
  407ca6:	061a      	lsls	r2, r3, #24
  407ca8:	683b      	ldr	r3, [r7, #0]
  407caa:	3302      	adds	r3, #2
  407cac:	781b      	ldrb	r3, [r3, #0]
  407cae:	041b      	lsls	r3, r3, #16
  407cb0:	431a      	orrs	r2, r3
  407cb2:	683b      	ldr	r3, [r7, #0]
  407cb4:	3301      	adds	r3, #1
  407cb6:	781b      	ldrb	r3, [r3, #0]
  407cb8:	021b      	lsls	r3, r3, #8
  407cba:	4313      	orrs	r3, r2
  407cbc:	683a      	ldr	r2, [r7, #0]
  407cbe:	7812      	ldrb	r2, [r2, #0]
  407cc0:	4313      	orrs	r3, r2
  407cc2:	4a33      	ldr	r2, [pc, #204]	; (407d90 <FreeRTOS_IPInit+0x1ec>)
  407cc4:	60d3      	str	r3, [r2, #12]
			xNetworkAddressing.ulBroadcastAddress = ( xNetworkAddressing.ulDefaultIPAddress & xNetworkAddressing.ulNetMask ) |  ~xNetworkAddressing.ulNetMask;
  407cc6:	4b32      	ldr	r3, [pc, #200]	; (407d90 <FreeRTOS_IPInit+0x1ec>)
  407cc8:	681a      	ldr	r2, [r3, #0]
  407cca:	4b31      	ldr	r3, [pc, #196]	; (407d90 <FreeRTOS_IPInit+0x1ec>)
  407ccc:	685b      	ldr	r3, [r3, #4]
  407cce:	43db      	mvns	r3, r3
  407cd0:	4313      	orrs	r3, r2
  407cd2:	4a2f      	ldr	r2, [pc, #188]	; (407d90 <FreeRTOS_IPInit+0x1ec>)
  407cd4:	6113      	str	r3, [r2, #16]

			memcpy( &xDefaultAddressing, &xNetworkAddressing, sizeof( xDefaultAddressing ) );
  407cd6:	4a2f      	ldr	r2, [pc, #188]	; (407d94 <FreeRTOS_IPInit+0x1f0>)
  407cd8:	4b2d      	ldr	r3, [pc, #180]	; (407d90 <FreeRTOS_IPInit+0x1ec>)
  407cda:	4614      	mov	r4, r2
  407cdc:	461d      	mov	r5, r3
  407cde:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  407ce0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  407ce2:	682b      	ldr	r3, [r5, #0]
  407ce4:	6023      	str	r3, [r4, #0]
				*ipLOCAL_IP_ADDRESS_POINTER = 0x00UL;
			}
			#else
			{
				/* The IP address is set from the value passed in. */
				*ipLOCAL_IP_ADDRESS_POINTER = xNetworkAddressing.ulDefaultIPAddress;
  407ce6:	4b2a      	ldr	r3, [pc, #168]	; (407d90 <FreeRTOS_IPInit+0x1ec>)
  407ce8:	681b      	ldr	r3, [r3, #0]
  407cea:	4a2b      	ldr	r2, [pc, #172]	; (407d98 <FreeRTOS_IPInit+0x1f4>)
  407cec:	6153      	str	r3, [r2, #20]

				/* Added to prevent ARP flood to gateway.  Ensure the
				gateway is on the same subnet as the IP	address. */
				if( xNetworkAddressing.ulGatewayAddress != 0ul )
  407cee:	4b28      	ldr	r3, [pc, #160]	; (407d90 <FreeRTOS_IPInit+0x1ec>)
  407cf0:	689b      	ldr	r3, [r3, #8]
  407cf2:	2b00      	cmp	r3, #0
  407cf4:	d00f      	beq.n	407d16 <FreeRTOS_IPInit+0x172>
				{
					configASSERT( ( ( *ipLOCAL_IP_ADDRESS_POINTER ) & xNetworkAddressing.ulNetMask ) == ( xNetworkAddressing.ulGatewayAddress & xNetworkAddressing.ulNetMask ) );
  407cf6:	4b28      	ldr	r3, [pc, #160]	; (407d98 <FreeRTOS_IPInit+0x1f4>)
  407cf8:	695a      	ldr	r2, [r3, #20]
  407cfa:	4b25      	ldr	r3, [pc, #148]	; (407d90 <FreeRTOS_IPInit+0x1ec>)
  407cfc:	689b      	ldr	r3, [r3, #8]
  407cfe:	405a      	eors	r2, r3
  407d00:	4b23      	ldr	r3, [pc, #140]	; (407d90 <FreeRTOS_IPInit+0x1ec>)
  407d02:	685b      	ldr	r3, [r3, #4]
  407d04:	4013      	ands	r3, r2
  407d06:	2b00      	cmp	r3, #0
  407d08:	d005      	beq.n	407d16 <FreeRTOS_IPInit+0x172>
  407d0a:	f240 32ea 	movw	r2, #1002	; 0x3ea
  407d0e:	4919      	ldr	r1, [pc, #100]	; (407d74 <FreeRTOS_IPInit+0x1d0>)
  407d10:	4819      	ldr	r0, [pc, #100]	; (407d78 <FreeRTOS_IPInit+0x1d4>)
  407d12:	4b1a      	ldr	r3, [pc, #104]	; (407d7c <FreeRTOS_IPInit+0x1d8>)
  407d14:	4798      	blx	r3
			}
			#endif /* ipconfigUSE_DHCP == 1 */

			/* The MAC address is stored in the start of the default packet
			header fragment, which is used when sending UDP packets. */
			memcpy( ( void * ) ipLOCAL_MAC_ADDRESS, ( void * ) ucMACAddress, ( size_t ) ipMAC_ADDRESS_LENGTH_BYTES );
  407d16:	2206      	movs	r2, #6
  407d18:	6ab9      	ldr	r1, [r7, #40]	; 0x28
  407d1a:	481f      	ldr	r0, [pc, #124]	; (407d98 <FreeRTOS_IPInit+0x1f4>)
  407d1c:	4b1f      	ldr	r3, [pc, #124]	; (407d9c <FreeRTOS_IPInit+0x1f8>)
  407d1e:	4798      	blx	r3

			/* Prepare the sockets interface. */
			xReturn = vNetworkSocketsInit();
  407d20:	4b1f      	ldr	r3, [pc, #124]	; (407da0 <FreeRTOS_IPInit+0x1fc>)
  407d22:	4798      	blx	r3
  407d24:	6178      	str	r0, [r7, #20]

			if( pdTRUE == xReturn )
  407d26:	697b      	ldr	r3, [r7, #20]
  407d28:	2b01      	cmp	r3, #1
  407d2a:	d11b      	bne.n	407d64 <FreeRTOS_IPInit+0x1c0>
			{
				/* Create the task that processes Ethernet and stack events. */
				xReturn = xTaskCreate( prvIPTask, "IP-task", ( uint16_t )ipconfigIP_TASK_STACK_SIZE_WORDS, NULL, ( UBaseType_t )ipconfigIP_TASK_PRIORITY, &xIPTaskHandle );
  407d2c:	4b15      	ldr	r3, [pc, #84]	; (407d84 <FreeRTOS_IPInit+0x1e0>)
  407d2e:	9301      	str	r3, [sp, #4]
  407d30:	2302      	movs	r3, #2
  407d32:	9300      	str	r3, [sp, #0]
  407d34:	2300      	movs	r3, #0
  407d36:	f44f 52a0 	mov.w	r2, #5120	; 0x1400
  407d3a:	491a      	ldr	r1, [pc, #104]	; (407da4 <FreeRTOS_IPInit+0x200>)
  407d3c:	481a      	ldr	r0, [pc, #104]	; (407da8 <FreeRTOS_IPInit+0x204>)
  407d3e:	4c1b      	ldr	r4, [pc, #108]	; (407dac <FreeRTOS_IPInit+0x208>)
  407d40:	47a0      	blx	r4
  407d42:	6178      	str	r0, [r7, #20]
  407d44:	e00e      	b.n	407d64 <FreeRTOS_IPInit+0x1c0>
			}
		}
		else
		{
			FreeRTOS_debug_printf( ( "FreeRTOS_IPInit: xNetworkBuffersInitialise() failed\n") );
  407d46:	481a      	ldr	r0, [pc, #104]	; (407db0 <FreeRTOS_IPInit+0x20c>)
  407d48:	4b0c      	ldr	r3, [pc, #48]	; (407d7c <FreeRTOS_IPInit+0x1d8>)
  407d4a:	4798      	blx	r3

			/* Clean up. */
			vQueueDelete( xNetworkEventQueue );
  407d4c:	4b0c      	ldr	r3, [pc, #48]	; (407d80 <FreeRTOS_IPInit+0x1dc>)
  407d4e:	681b      	ldr	r3, [r3, #0]
  407d50:	4618      	mov	r0, r3
  407d52:	4b18      	ldr	r3, [pc, #96]	; (407db4 <FreeRTOS_IPInit+0x210>)
  407d54:	4798      	blx	r3
			xNetworkEventQueue = NULL;
  407d56:	4b0a      	ldr	r3, [pc, #40]	; (407d80 <FreeRTOS_IPInit+0x1dc>)
  407d58:	2200      	movs	r2, #0
  407d5a:	601a      	str	r2, [r3, #0]
  407d5c:	e002      	b.n	407d64 <FreeRTOS_IPInit+0x1c0>
		}
	}
	else
	{
		FreeRTOS_debug_printf( ( "FreeRTOS_IPInit: Network event queue could not be created\n") );
  407d5e:	4816      	ldr	r0, [pc, #88]	; (407db8 <FreeRTOS_IPInit+0x214>)
  407d60:	4b06      	ldr	r3, [pc, #24]	; (407d7c <FreeRTOS_IPInit+0x1d8>)
  407d62:	4798      	blx	r3
	}

	return xReturn;
  407d64:	697b      	ldr	r3, [r7, #20]
}
  407d66:	4618      	mov	r0, r3
  407d68:	3718      	adds	r7, #24
  407d6a:	46bd      	mov	sp, r7
  407d6c:	bdb0      	pop	{r4, r5, r7, pc}
  407d6e:	bf00      	nop
  407d70:	004087b5 	.word	0x004087b5
  407d74:	0041ca2c 	.word	0x0041ca2c
  407d78:	0041ca80 	.word	0x0041ca80
  407d7c:	00416c7d 	.word	0x00416c7d
  407d80:	20006cc8 	.word	0x20006cc8
  407d84:	20006cfc 	.word	0x20006cfc
  407d88:	00411711 	.word	0x00411711
  407d8c:	0040f0b1 	.word	0x0040f0b1
  407d90:	20006cd0 	.word	0x20006cd0
  407d94:	20006ce4 	.word	0x20006ce4
  407d98:	20000108 	.word	0x20000108
  407d9c:	00416d05 	.word	0x00416d05
  407da0:	004089ed 	.word	0x004089ed
  407da4:	0041ca90 	.word	0x0041ca90
  407da8:	00407711 	.word	0x00407711
  407dac:	004122f9 	.word	0x004122f9
  407db0:	0041ca98 	.word	0x0041ca98
  407db4:	00412041 	.word	0x00412041
  407db8:	0041cad0 	.word	0x0041cad0

00407dbc <FreeRTOS_GetAddressConfiguration>:
/*-----------------------------------------------------------*/

void FreeRTOS_GetAddressConfiguration( uint32_t *pulIPAddress, uint32_t *pulNetMask, uint32_t *pulGatewayAddress, uint32_t *pulDNSServerAddress )
{
  407dbc:	b480      	push	{r7}
  407dbe:	b085      	sub	sp, #20
  407dc0:	af00      	add	r7, sp, #0
  407dc2:	60f8      	str	r0, [r7, #12]
  407dc4:	60b9      	str	r1, [r7, #8]
  407dc6:	607a      	str	r2, [r7, #4]
  407dc8:	603b      	str	r3, [r7, #0]
	/* Return the address configuration to the caller. */

	if( pulIPAddress != NULL )
  407dca:	68fb      	ldr	r3, [r7, #12]
  407dcc:	2b00      	cmp	r3, #0
  407dce:	d003      	beq.n	407dd8 <FreeRTOS_GetAddressConfiguration+0x1c>
	{
		*pulIPAddress = *ipLOCAL_IP_ADDRESS_POINTER;
  407dd0:	4b0f      	ldr	r3, [pc, #60]	; (407e10 <FreeRTOS_GetAddressConfiguration+0x54>)
  407dd2:	695a      	ldr	r2, [r3, #20]
  407dd4:	68fb      	ldr	r3, [r7, #12]
  407dd6:	601a      	str	r2, [r3, #0]
	}

	if( pulNetMask != NULL )
  407dd8:	68bb      	ldr	r3, [r7, #8]
  407dda:	2b00      	cmp	r3, #0
  407ddc:	d003      	beq.n	407de6 <FreeRTOS_GetAddressConfiguration+0x2a>
	{
		*pulNetMask = xNetworkAddressing.ulNetMask;
  407dde:	4b0d      	ldr	r3, [pc, #52]	; (407e14 <FreeRTOS_GetAddressConfiguration+0x58>)
  407de0:	685a      	ldr	r2, [r3, #4]
  407de2:	68bb      	ldr	r3, [r7, #8]
  407de4:	601a      	str	r2, [r3, #0]
	}

	if( pulGatewayAddress != NULL )
  407de6:	687b      	ldr	r3, [r7, #4]
  407de8:	2b00      	cmp	r3, #0
  407dea:	d003      	beq.n	407df4 <FreeRTOS_GetAddressConfiguration+0x38>
	{
		*pulGatewayAddress = xNetworkAddressing.ulGatewayAddress;
  407dec:	4b09      	ldr	r3, [pc, #36]	; (407e14 <FreeRTOS_GetAddressConfiguration+0x58>)
  407dee:	689a      	ldr	r2, [r3, #8]
  407df0:	687b      	ldr	r3, [r7, #4]
  407df2:	601a      	str	r2, [r3, #0]
	}

	if( pulDNSServerAddress != NULL )
  407df4:	683b      	ldr	r3, [r7, #0]
  407df6:	2b00      	cmp	r3, #0
  407df8:	d003      	beq.n	407e02 <FreeRTOS_GetAddressConfiguration+0x46>
	{
		*pulDNSServerAddress = xNetworkAddressing.ulDNSServerAddress;
  407dfa:	4b06      	ldr	r3, [pc, #24]	; (407e14 <FreeRTOS_GetAddressConfiguration+0x58>)
  407dfc:	68da      	ldr	r2, [r3, #12]
  407dfe:	683b      	ldr	r3, [r7, #0]
  407e00:	601a      	str	r2, [r3, #0]
	}
}
  407e02:	bf00      	nop
  407e04:	3714      	adds	r7, #20
  407e06:	46bd      	mov	sp, r7
  407e08:	f85d 7b04 	ldr.w	r7, [sp], #4
  407e0c:	4770      	bx	lr
  407e0e:	bf00      	nop
  407e10:	20000108 	.word	0x20000108
  407e14:	20006cd0 	.word	0x20006cd0

00407e18 <xSendEventToIPTask>:

#endif /* ipconfigSUPPORT_OUTGOING_PINGS == 1 */
/*-----------------------------------------------------------*/

BaseType_t xSendEventToIPTask( eIPEvent_t eEvent )
{
  407e18:	b580      	push	{r7, lr}
  407e1a:	b086      	sub	sp, #24
  407e1c:	af00      	add	r7, sp, #0
  407e1e:	4603      	mov	r3, r0
  407e20:	71fb      	strb	r3, [r7, #7]
IPStackEvent_t xEventMessage;
const TickType_t xDontBlock = ( TickType_t ) 0;
  407e22:	2300      	movs	r3, #0
  407e24:	617b      	str	r3, [r7, #20]

	xEventMessage.eEventType = eEvent;
  407e26:	79fb      	ldrb	r3, [r7, #7]
  407e28:	733b      	strb	r3, [r7, #12]
	xEventMessage.pvData = ( void* )NULL;
  407e2a:	2300      	movs	r3, #0
  407e2c:	613b      	str	r3, [r7, #16]

	return xSendEventStructToIPTask( &xEventMessage, xDontBlock );
  407e2e:	f107 030c 	add.w	r3, r7, #12
  407e32:	6979      	ldr	r1, [r7, #20]
  407e34:	4618      	mov	r0, r3
  407e36:	4b03      	ldr	r3, [pc, #12]	; (407e44 <xSendEventToIPTask+0x2c>)
  407e38:	4798      	blx	r3
  407e3a:	4603      	mov	r3, r0
}
  407e3c:	4618      	mov	r0, r3
  407e3e:	3718      	adds	r7, #24
  407e40:	46bd      	mov	sp, r7
  407e42:	bd80      	pop	{r7, pc}
  407e44:	00407e49 	.word	0x00407e49

00407e48 <xSendEventStructToIPTask>:
/*-----------------------------------------------------------*/

BaseType_t xSendEventStructToIPTask( const IPStackEvent_t *pxEvent, TickType_t xTimeout )
{
  407e48:	b590      	push	{r4, r7, lr}
  407e4a:	b085      	sub	sp, #20
  407e4c:	af00      	add	r7, sp, #0
  407e4e:	6078      	str	r0, [r7, #4]
  407e50:	6039      	str	r1, [r7, #0]
BaseType_t xReturn, xSendMessage;

	if( ( xIPIsNetworkTaskReady() == pdFALSE ) && ( pxEvent->eEventType != eNetworkDownEvent ) )
  407e52:	4b25      	ldr	r3, [pc, #148]	; (407ee8 <xSendEventStructToIPTask+0xa0>)
  407e54:	4798      	blx	r3
  407e56:	4603      	mov	r3, r0
  407e58:	2b00      	cmp	r3, #0
  407e5a:	d107      	bne.n	407e6c <xSendEventStructToIPTask+0x24>
  407e5c:	687b      	ldr	r3, [r7, #4]
  407e5e:	f993 3000 	ldrsb.w	r3, [r3]
  407e62:	2b00      	cmp	r3, #0
  407e64:	d002      	beq.n	407e6c <xSendEventStructToIPTask+0x24>
	{
		/* Only allow eNetworkDownEvent events if the IP task is not ready
		yet.  Not going to attempt to send the message so the send failed. */
		xReturn = pdFAIL;
  407e66:	2300      	movs	r3, #0
  407e68:	60fb      	str	r3, [r7, #12]
  407e6a:	e037      	b.n	407edc <xSendEventStructToIPTask+0x94>
	}
	else
	{
		xSendMessage = pdTRUE;
  407e6c:	2301      	movs	r3, #1
  407e6e:	60bb      	str	r3, [r7, #8]

		#if( ipconfigUSE_TCP == 1 )
		{
			if( pxEvent->eEventType == eTCPTimerEvent )
  407e70:	687b      	ldr	r3, [r7, #4]
  407e72:	f993 3000 	ldrsb.w	r3, [r3]
  407e76:	2b06      	cmp	r3, #6
  407e78:	d10e      	bne.n	407e98 <xSendEventStructToIPTask+0x50>
			{
				/* TCP timer events are sent to wake the timer task when
				xTCPTimer has expired, but there is no point sending them if the
				IP task is already awake processing other message. */
				xTCPTimer.bExpired = pdTRUE_UNSIGNED;
  407e7a:	4a1c      	ldr	r2, [pc, #112]	; (407eec <xSendEventStructToIPTask+0xa4>)
  407e7c:	7813      	ldrb	r3, [r2, #0]
  407e7e:	f043 0302 	orr.w	r3, r3, #2
  407e82:	7013      	strb	r3, [r2, #0]

				if( uxQueueMessagesWaiting( xNetworkEventQueue ) != 0u )
  407e84:	4b1a      	ldr	r3, [pc, #104]	; (407ef0 <xSendEventStructToIPTask+0xa8>)
  407e86:	681b      	ldr	r3, [r3, #0]
  407e88:	4618      	mov	r0, r3
  407e8a:	4b1a      	ldr	r3, [pc, #104]	; (407ef4 <xSendEventStructToIPTask+0xac>)
  407e8c:	4798      	blx	r3
  407e8e:	4603      	mov	r3, r0
  407e90:	2b00      	cmp	r3, #0
  407e92:	d001      	beq.n	407e98 <xSendEventStructToIPTask+0x50>
				{
					/* Not actually going to send the message but this is not a
					failure as the message didn't need to be sent. */
					xSendMessage = pdFALSE;
  407e94:	2300      	movs	r3, #0
  407e96:	60bb      	str	r3, [r7, #8]
				}
			}
		}
		#endif /* ipconfigUSE_TCP */

		if( xSendMessage != pdFALSE )
  407e98:	68bb      	ldr	r3, [r7, #8]
  407e9a:	2b00      	cmp	r3, #0
  407e9c:	d01c      	beq.n	407ed8 <xSendEventStructToIPTask+0x90>
		{
			/* The IP task cannot block itself while waiting for itself to
			respond. */
			if( ( xIsCallingFromIPTask() == pdTRUE ) && ( xTimeout > ( TickType_t ) 0 ) )
  407e9e:	4b16      	ldr	r3, [pc, #88]	; (407ef8 <xSendEventStructToIPTask+0xb0>)
  407ea0:	4798      	blx	r3
  407ea2:	4603      	mov	r3, r0
  407ea4:	2b01      	cmp	r3, #1
  407ea6:	d104      	bne.n	407eb2 <xSendEventStructToIPTask+0x6a>
  407ea8:	683b      	ldr	r3, [r7, #0]
  407eaa:	2b00      	cmp	r3, #0
  407eac:	d001      	beq.n	407eb2 <xSendEventStructToIPTask+0x6a>
			{
				xTimeout = ( TickType_t ) 0;
  407eae:	2300      	movs	r3, #0
  407eb0:	603b      	str	r3, [r7, #0]
			}

			xReturn = xQueueSendToBack( xNetworkEventQueue, pxEvent, xTimeout );
  407eb2:	4b0f      	ldr	r3, [pc, #60]	; (407ef0 <xSendEventStructToIPTask+0xa8>)
  407eb4:	6818      	ldr	r0, [r3, #0]
  407eb6:	2300      	movs	r3, #0
  407eb8:	683a      	ldr	r2, [r7, #0]
  407eba:	6879      	ldr	r1, [r7, #4]
  407ebc:	4c0f      	ldr	r4, [pc, #60]	; (407efc <xSendEventStructToIPTask+0xb4>)
  407ebe:	47a0      	blx	r4
  407ec0:	60f8      	str	r0, [r7, #12]

			if( xReturn == pdFAIL )
  407ec2:	68fb      	ldr	r3, [r7, #12]
  407ec4:	2b00      	cmp	r3, #0
  407ec6:	d109      	bne.n	407edc <xSendEventStructToIPTask+0x94>
			{
				/* A message should have been sent to the IP task, but wasn't. */
				FreeRTOS_debug_printf( ( "xSendEventStructToIPTask: CAN NOT ADD %d\n", pxEvent->eEventType ) );
  407ec8:	687b      	ldr	r3, [r7, #4]
  407eca:	f993 3000 	ldrsb.w	r3, [r3]
  407ece:	4619      	mov	r1, r3
  407ed0:	480b      	ldr	r0, [pc, #44]	; (407f00 <xSendEventStructToIPTask+0xb8>)
  407ed2:	4b0c      	ldr	r3, [pc, #48]	; (407f04 <xSendEventStructToIPTask+0xbc>)
  407ed4:	4798      	blx	r3
  407ed6:	e001      	b.n	407edc <xSendEventStructToIPTask+0x94>
		}
		else
		{
			/* It was not necessary to send the message to process the event so
			even though the message was not sent the call was successful. */
			xReturn = pdPASS;
  407ed8:	2301      	movs	r3, #1
  407eda:	60fb      	str	r3, [r7, #12]
		}
	}

	return xReturn;
  407edc:	68fb      	ldr	r3, [r7, #12]
}
  407ede:	4618      	mov	r0, r3
  407ee0:	3714      	adds	r7, #20
  407ee2:	46bd      	mov	sp, r7
  407ee4:	bd90      	pop	{r4, r7, pc}
  407ee6:	bf00      	nop
  407ee8:	004087b5 	.word	0x004087b5
  407eec:	20006d1c 	.word	0x20006d1c
  407ef0:	20006cc8 	.word	0x20006cc8
  407ef4:	00411fa9 	.word	0x00411fa9
  407ef8:	00407909 	.word	0x00407909
  407efc:	00411831 	.word	0x00411831
  407f00:	0041cb0c 	.word	0x0041cb0c
  407f04:	00416c7d 	.word	0x00416c7d

00407f08 <eConsiderFrameForProcessing>:
/*-----------------------------------------------------------*/

eFrameProcessingResult_t eConsiderFrameForProcessing( const uint8_t * const pucEthernetBuffer )
{
  407f08:	b580      	push	{r7, lr}
  407f0a:	b086      	sub	sp, #24
  407f0c:	af00      	add	r7, sp, #0
  407f0e:	6078      	str	r0, [r7, #4]
eFrameProcessingResult_t eReturn;
const EthernetHeader_t *pxEthernetHeader;

	pxEthernetHeader = ( const EthernetHeader_t * ) pucEthernetBuffer;
  407f10:	687b      	ldr	r3, [r7, #4]
  407f12:	613b      	str	r3, [r7, #16]

	if( memcmp( ( void * ) ipLOCAL_MAC_ADDRESS, ( void * ) &( pxEthernetHeader->xDestinationAddress ), sizeof( MACAddress_t ) ) == 0 )
  407f14:	693b      	ldr	r3, [r7, #16]
  407f16:	2206      	movs	r2, #6
  407f18:	4619      	mov	r1, r3
  407f1a:	481a      	ldr	r0, [pc, #104]	; (407f84 <eConsiderFrameForProcessing+0x7c>)
  407f1c:	4b1a      	ldr	r3, [pc, #104]	; (407f88 <eConsiderFrameForProcessing+0x80>)
  407f1e:	4798      	blx	r3
  407f20:	4603      	mov	r3, r0
  407f22:	2b00      	cmp	r3, #0
  407f24:	d102      	bne.n	407f2c <eConsiderFrameForProcessing+0x24>
	{
		/* The packet was directed to this node directly - process it. */
		eReturn = eProcessBuffer;
  407f26:	2301      	movs	r3, #1
  407f28:	75fb      	strb	r3, [r7, #23]
  407f2a:	e00d      	b.n	407f48 <eConsiderFrameForProcessing+0x40>
	}
	else if( memcmp( ( void * ) xBroadcastMACAddress.ucBytes, ( void * ) pxEthernetHeader->xDestinationAddress.ucBytes, sizeof( MACAddress_t ) ) == 0 )
  407f2c:	693b      	ldr	r3, [r7, #16]
  407f2e:	2206      	movs	r2, #6
  407f30:	4619      	mov	r1, r3
  407f32:	4816      	ldr	r0, [pc, #88]	; (407f8c <eConsiderFrameForProcessing+0x84>)
  407f34:	4b14      	ldr	r3, [pc, #80]	; (407f88 <eConsiderFrameForProcessing+0x80>)
  407f36:	4798      	blx	r3
  407f38:	4603      	mov	r3, r0
  407f3a:	2b00      	cmp	r3, #0
  407f3c:	d102      	bne.n	407f44 <eConsiderFrameForProcessing+0x3c>
	{
		/* The packet was a broadcast - process it. */
		eReturn = eProcessBuffer;
  407f3e:	2301      	movs	r3, #1
  407f40:	75fb      	strb	r3, [r7, #23]
  407f42:	e001      	b.n	407f48 <eConsiderFrameForProcessing+0x40>
	else
#endif /* ipconfigUSE_LLMNR */
	{
		/* The packet was not a broadcast, or for this node, just release
		the buffer without taking any other action. */
		eReturn = eReleaseBuffer;
  407f44:	2300      	movs	r3, #0
  407f46:	75fb      	strb	r3, [r7, #23]

	#if( ipconfigFILTER_OUT_NON_ETHERNET_II_FRAMES == 1 )
	{
	uint16_t usFrameType;

		if( eReturn == eProcessBuffer )
  407f48:	7dfb      	ldrb	r3, [r7, #23]
  407f4a:	2b01      	cmp	r3, #1
  407f4c:	d115      	bne.n	407f7a <eConsiderFrameForProcessing+0x72>
		{
			usFrameType = pxEthernetHeader->usFrameType;
  407f4e:	693b      	ldr	r3, [r7, #16]
  407f50:	7b1a      	ldrb	r2, [r3, #12]
  407f52:	7b5b      	ldrb	r3, [r3, #13]
  407f54:	021b      	lsls	r3, r3, #8
  407f56:	4313      	orrs	r3, r2
  407f58:	81fb      	strh	r3, [r7, #14]
			usFrameType = FreeRTOS_ntohs( usFrameType );
  407f5a:	89fb      	ldrh	r3, [r7, #14]
  407f5c:	021b      	lsls	r3, r3, #8
  407f5e:	b21a      	sxth	r2, r3
  407f60:	89fb      	ldrh	r3, [r7, #14]
  407f62:	0a1b      	lsrs	r3, r3, #8
  407f64:	b29b      	uxth	r3, r3
  407f66:	b21b      	sxth	r3, r3
  407f68:	4313      	orrs	r3, r2
  407f6a:	b21b      	sxth	r3, r3
  407f6c:	81fb      	strh	r3, [r7, #14]

			if( usFrameType <= 0x600U )
  407f6e:	89fb      	ldrh	r3, [r7, #14]
  407f70:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
  407f74:	d801      	bhi.n	407f7a <eConsiderFrameForProcessing+0x72>
			{
				/* Not an Ethernet II frame. */
				eReturn = eReleaseBuffer;
  407f76:	2300      	movs	r3, #0
  407f78:	75fb      	strb	r3, [r7, #23]
			}
		}
	}
	#endif /* ipconfigFILTER_OUT_NON_ETHERNET_II_FRAMES == 1  */

	return eReturn;
  407f7a:	7dfb      	ldrb	r3, [r7, #23]
}
  407f7c:	4618      	mov	r0, r3
  407f7e:	3718      	adds	r7, #24
  407f80:	46bd      	mov	sp, r7
  407f82:	bd80      	pop	{r7, pc}
  407f84:	20000108 	.word	0x20000108
  407f88:	00416ca5 	.word	0x00416ca5
  407f8c:	0041ca10 	.word	0x0041ca10

00407f90 <prvProcessNetworkDownEvent>:
/*-----------------------------------------------------------*/

static void prvProcessNetworkDownEvent( void )
{
  407f90:	b580      	push	{r7, lr}
  407f92:	af00      	add	r7, sp, #0
	/* Stop the ARP timer while there is no network. */
	xARPTimer.bActive = pdFALSE_UNSIGNED;
  407f94:	4a10      	ldr	r2, [pc, #64]	; (407fd8 <prvProcessNetworkDownEvent+0x48>)
  407f96:	7813      	ldrb	r3, [r2, #0]
  407f98:	f36f 0300 	bfc	r3, #0, #1
  407f9c:	7013      	strb	r3, [r2, #0]
		static BaseType_t xCallEventHook = pdFALSE;

		/* The first network down event is generated by the IP stack itself to
		initialise the network hardware, so do not call the network down event
		the first time through. */
		if( xCallEventHook == pdTRUE )
  407f9e:	4b0f      	ldr	r3, [pc, #60]	; (407fdc <prvProcessNetworkDownEvent+0x4c>)
  407fa0:	681b      	ldr	r3, [r3, #0]
  407fa2:	2b01      	cmp	r3, #1
  407fa4:	d102      	bne.n	407fac <prvProcessNetworkDownEvent+0x1c>
		{
			vApplicationIPNetworkEventHook( eNetworkDown );
  407fa6:	2001      	movs	r0, #1
  407fa8:	4b0d      	ldr	r3, [pc, #52]	; (407fe0 <prvProcessNetworkDownEvent+0x50>)
  407faa:	4798      	blx	r3
		}
		xCallEventHook = pdTRUE;
  407fac:	4b0b      	ldr	r3, [pc, #44]	; (407fdc <prvProcessNetworkDownEvent+0x4c>)
  407fae:	2201      	movs	r2, #1
  407fb0:	601a      	str	r2, [r3, #0]
	#endif

	/* Per the ARP Cache Validation section of https://tools.ietf.org/html/rfc1122, 
	treat network down as a "delivery problem" and flush the ARP cache for this
	interface. */
	FreeRTOS_ClearARP( );
  407fb2:	4b0c      	ldr	r3, [pc, #48]	; (407fe4 <prvProcessNetworkDownEvent+0x54>)
  407fb4:	4798      	blx	r3

	/* The network has been disconnected (or is being initialised for the first
	time).  Perform whatever hardware processing is necessary to bring it up
	again, or wait for it to be available again.  This is hardware dependent. */
	if( xNetworkInterfaceInitialise() != pdPASS )
  407fb6:	4b0c      	ldr	r3, [pc, #48]	; (407fe8 <prvProcessNetworkDownEvent+0x58>)
  407fb8:	4798      	blx	r3
  407fba:	4603      	mov	r3, r0
  407fbc:	2b01      	cmp	r3, #1
  407fbe:	d006      	beq.n	407fce <prvProcessNetworkDownEvent+0x3e>
	{
		/* Ideally the network interface initialisation function will only
		return when the network is available.  In case this is not the case,
		wait a while before retrying the initialisation. */
		vTaskDelay( ipINITIALISATION_RETRY_DELAY );
  407fc0:	f640 30b8 	movw	r0, #3000	; 0xbb8
  407fc4:	4b09      	ldr	r3, [pc, #36]	; (407fec <prvProcessNetworkDownEvent+0x5c>)
  407fc6:	4798      	blx	r3
		FreeRTOS_NetworkDown();
  407fc8:	4b09      	ldr	r3, [pc, #36]	; (407ff0 <prvProcessNetworkDownEvent+0x60>)
  407fca:	4798      	blx	r3
			/* Perform any necessary 'network up' processing. */
			vIPNetworkUpCalls();
		}
		#endif
	}
}
  407fcc:	e001      	b.n	407fd2 <prvProcessNetworkDownEvent+0x42>
			vIPNetworkUpCalls();
  407fce:	4b09      	ldr	r3, [pc, #36]	; (407ff4 <prvProcessNetworkDownEvent+0x64>)
  407fd0:	4798      	blx	r3
}
  407fd2:	bf00      	nop
  407fd4:	bd80      	pop	{r7, pc}
  407fd6:	bf00      	nop
  407fd8:	20006d08 	.word	0x20006d08
  407fdc:	20006d34 	.word	0x20006d34
  407fe0:	0041614d 	.word	0x0041614d
  407fe4:	004076f5 	.word	0x004076f5
  407fe8:	004101dd 	.word	0x004101dd
  407fec:	0041256d 	.word	0x0041256d
  407ff0:	00407b25 	.word	0x00407b25
  407ff4:	00407ff9 	.word	0x00407ff9

00407ff8 <vIPNetworkUpCalls>:
/*-----------------------------------------------------------*/

void vIPNetworkUpCalls( void )
{
  407ff8:	b580      	push	{r7, lr}
  407ffa:	af00      	add	r7, sp, #0
	xNetworkUp = pdTRUE;
  407ffc:	4b06      	ldr	r3, [pc, #24]	; (408018 <vIPNetworkUpCalls+0x20>)
  407ffe:	2201      	movs	r2, #1
  408000:	601a      	str	r2, [r3, #0]

	#if( ipconfigUSE_NETWORK_EVENT_HOOK == 1 )
	{
		vApplicationIPNetworkEventHook( eNetworkUp );
  408002:	2000      	movs	r0, #0
  408004:	4b05      	ldr	r3, [pc, #20]	; (40801c <vIPNetworkUpCalls+0x24>)
  408006:	4798      	blx	r3
		vDNSInitialise();
	}
	#endif /* ipconfigDNS_USE_CALLBACKS != 0 */

	/* Set remaining time to 0 so it will become active immediately. */
	prvIPTimerReload( &xARPTimer, pdMS_TO_TICKS( ipARP_TIMER_PERIOD_MS ) );
  408008:	f242 7110 	movw	r1, #10000	; 0x2710
  40800c:	4804      	ldr	r0, [pc, #16]	; (408020 <vIPNetworkUpCalls+0x28>)
  40800e:	4b05      	ldr	r3, [pc, #20]	; (408024 <vIPNetworkUpCalls+0x2c>)
  408010:	4798      	blx	r3
}
  408012:	bf00      	nop
  408014:	bd80      	pop	{r7, pc}
  408016:	bf00      	nop
  408018:	20006d04 	.word	0x20006d04
  40801c:	0041614d 	.word	0x0041614d
  408020:	20006d08 	.word	0x20006d08
  408024:	00407a99 	.word	0x00407a99

00408028 <prvProcessEthernetPacket>:
/*-----------------------------------------------------------*/

static void prvProcessEthernetPacket( NetworkBufferDescriptor_t * const pxNetworkBuffer )
{
  408028:	b580      	push	{r7, lr}
  40802a:	b084      	sub	sp, #16
  40802c:	af00      	add	r7, sp, #0
  40802e:	6078      	str	r0, [r7, #4]
EthernetHeader_t *pxEthernetHeader;
eFrameProcessingResult_t eReturned = eReleaseBuffer;
  408030:	2300      	movs	r3, #0
  408032:	73fb      	strb	r3, [r7, #15]

	configASSERT( pxNetworkBuffer );
  408034:	687b      	ldr	r3, [r7, #4]
  408036:	2b00      	cmp	r3, #0
  408038:	d105      	bne.n	408046 <prvProcessEthernetPacket+0x1e>
  40803a:	f240 525a 	movw	r2, #1370	; 0x55a
  40803e:	4929      	ldr	r1, [pc, #164]	; (4080e4 <prvProcessEthernetPacket+0xbc>)
  408040:	4829      	ldr	r0, [pc, #164]	; (4080e8 <prvProcessEthernetPacket+0xc0>)
  408042:	4b2a      	ldr	r3, [pc, #168]	; (4080ec <prvProcessEthernetPacket+0xc4>)
  408044:	4798      	blx	r3

	/* Interpret the Ethernet frame. */
	if( pxNetworkBuffer->xDataLength >= sizeof( EthernetHeader_t ) )
  408046:	687b      	ldr	r3, [r7, #4]
  408048:	69db      	ldr	r3, [r3, #28]
  40804a:	2b0d      	cmp	r3, #13
  40804c:	d936      	bls.n	4080bc <prvProcessEthernetPacket+0x94>
	{
		eReturned = ipCONSIDER_FRAME_FOR_PROCESSING( pxNetworkBuffer->pucEthernetBuffer );
  40804e:	687b      	ldr	r3, [r7, #4]
  408050:	699b      	ldr	r3, [r3, #24]
  408052:	4618      	mov	r0, r3
  408054:	4b26      	ldr	r3, [pc, #152]	; (4080f0 <prvProcessEthernetPacket+0xc8>)
  408056:	4798      	blx	r3
  408058:	4603      	mov	r3, r0
  40805a:	73fb      	strb	r3, [r7, #15]
		pxEthernetHeader = ( EthernetHeader_t * )( pxNetworkBuffer->pucEthernetBuffer );
  40805c:	687b      	ldr	r3, [r7, #4]
  40805e:	699b      	ldr	r3, [r3, #24]
  408060:	60bb      	str	r3, [r7, #8]

		if( eReturned == eProcessBuffer )
  408062:	7bfb      	ldrb	r3, [r7, #15]
  408064:	2b01      	cmp	r3, #1
  408066:	d129      	bne.n	4080bc <prvProcessEthernetPacket+0x94>
		{
			/* Interpret the received Ethernet packet. */
			switch( pxEthernetHeader->usFrameType )
  408068:	68bb      	ldr	r3, [r7, #8]
  40806a:	899b      	ldrh	r3, [r3, #12]
  40806c:	b29b      	uxth	r3, r3
  40806e:	2b08      	cmp	r3, #8
  408070:	d011      	beq.n	408096 <prvProcessEthernetPacket+0x6e>
  408072:	f5b3 6fc1 	cmp.w	r3, #1544	; 0x608
  408076:	d11e      	bne.n	4080b6 <prvProcessEthernetPacket+0x8e>
			{
			case ipARP_FRAME_TYPE:
				/* The Ethernet frame contains an ARP packet. */
				if( pxNetworkBuffer->xDataLength >= sizeof( ARPPacket_t ) )
  408078:	687b      	ldr	r3, [r7, #4]
  40807a:	69db      	ldr	r3, [r3, #28]
  40807c:	2b29      	cmp	r3, #41	; 0x29
  40807e:	d907      	bls.n	408090 <prvProcessEthernetPacket+0x68>
				{
					eReturned = eARPProcessPacket( ( ARPPacket_t * )pxNetworkBuffer->pucEthernetBuffer );
  408080:	687b      	ldr	r3, [r7, #4]
  408082:	699b      	ldr	r3, [r3, #24]
  408084:	4618      	mov	r0, r3
  408086:	4b1b      	ldr	r3, [pc, #108]	; (4080f4 <prvProcessEthernetPacket+0xcc>)
  408088:	4798      	blx	r3
  40808a:	4603      	mov	r3, r0
  40808c:	73fb      	strb	r3, [r7, #15]
				}
				else
				{
					eReturned = eReleaseBuffer;
				}
				break;
  40808e:	e015      	b.n	4080bc <prvProcessEthernetPacket+0x94>
					eReturned = eReleaseBuffer;
  408090:	2300      	movs	r3, #0
  408092:	73fb      	strb	r3, [r7, #15]
				break;
  408094:	e012      	b.n	4080bc <prvProcessEthernetPacket+0x94>

			case ipIPv4_FRAME_TYPE:
				/* The Ethernet frame contains an IP packet. */
				if( pxNetworkBuffer->xDataLength >= sizeof( IPPacket_t ) )
  408096:	687b      	ldr	r3, [r7, #4]
  408098:	69db      	ldr	r3, [r3, #28]
  40809a:	2b21      	cmp	r3, #33	; 0x21
  40809c:	d908      	bls.n	4080b0 <prvProcessEthernetPacket+0x88>
				{
					eReturned = prvProcessIPPacket( ( IPPacket_t * )pxNetworkBuffer->pucEthernetBuffer, pxNetworkBuffer );
  40809e:	687b      	ldr	r3, [r7, #4]
  4080a0:	699b      	ldr	r3, [r3, #24]
  4080a2:	6879      	ldr	r1, [r7, #4]
  4080a4:	4618      	mov	r0, r3
  4080a6:	4b14      	ldr	r3, [pc, #80]	; (4080f8 <prvProcessEthernetPacket+0xd0>)
  4080a8:	4798      	blx	r3
  4080aa:	4603      	mov	r3, r0
  4080ac:	73fb      	strb	r3, [r7, #15]
				}
				else
				{
					eReturned = eReleaseBuffer;
				}
				break;
  4080ae:	e005      	b.n	4080bc <prvProcessEthernetPacket+0x94>
					eReturned = eReleaseBuffer;
  4080b0:	2300      	movs	r3, #0
  4080b2:	73fb      	strb	r3, [r7, #15]
				break;
  4080b4:	e002      	b.n	4080bc <prvProcessEthernetPacket+0x94>

			default:
				/* No other packet types are handled.  Nothing to do. */
				eReturned = eReleaseBuffer;
  4080b6:	2300      	movs	r3, #0
  4080b8:	73fb      	strb	r3, [r7, #15]
				break;
  4080ba:	bf00      	nop
			}
		}
	}

	/* Perform any actions that resulted from processing the Ethernet frame. */
	switch( eReturned )
  4080bc:	7bfb      	ldrb	r3, [r7, #15]
  4080be:	2b02      	cmp	r3, #2
  4080c0:	d002      	beq.n	4080c8 <prvProcessEthernetPacket+0xa0>
  4080c2:	2b03      	cmp	r3, #3
  4080c4:	d009      	beq.n	4080da <prvProcessEthernetPacket+0xb2>
  4080c6:	e004      	b.n	4080d2 <prvProcessEthernetPacket+0xaa>
	{
		case eReturnEthernetFrame :
			/* The Ethernet frame will have been updated (maybe it was
			an ARP request or a PING request?) and should be sent back to
			its source. */
			vReturnEthernetFrame( pxNetworkBuffer, pdTRUE );
  4080c8:	2101      	movs	r1, #1
  4080ca:	6878      	ldr	r0, [r7, #4]
  4080cc:	4b0b      	ldr	r3, [pc, #44]	; (4080fc <prvProcessEthernetPacket+0xd4>)
  4080ce:	4798      	blx	r3
			/* parameter pdTRUE: the buffer must be released once
			the frame has been transmitted */
			break;
  4080d0:	e004      	b.n	4080dc <prvProcessEthernetPacket+0xb4>

		default :
			/* The frame is not being used anywhere, and the
			NetworkBufferDescriptor_t structure containing the frame should
			just be	released back to the list of free buffers. */
			vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
  4080d2:	6878      	ldr	r0, [r7, #4]
  4080d4:	4b0a      	ldr	r3, [pc, #40]	; (408100 <prvProcessEthernetPacket+0xd8>)
  4080d6:	4798      	blx	r3
			break;
  4080d8:	e000      	b.n	4080dc <prvProcessEthernetPacket+0xb4>
			break;
  4080da:	bf00      	nop
	}
}
  4080dc:	bf00      	nop
  4080de:	3710      	adds	r7, #16
  4080e0:	46bd      	mov	sp, r7
  4080e2:	bd80      	pop	{r7, pc}
  4080e4:	0041ca2c 	.word	0x0041ca2c
  4080e8:	0041ca80 	.word	0x0041ca80
  4080ec:	00416c7d 	.word	0x00416c7d
  4080f0:	00407f09 	.word	0x00407f09
  4080f4:	00407059 	.word	0x00407059
  4080f8:	00408125 	.word	0x00408125
  4080fc:	0040876d 	.word	0x0040876d
  408100:	0040f2ed 	.word	0x0040f2ed

00408104 <prvAllowIPPacket>:
/*-----------------------------------------------------------*/

static eFrameProcessingResult_t prvAllowIPPacket( const IPPacket_t * const pxIPPacket,
	NetworkBufferDescriptor_t * const pxNetworkBuffer, UBaseType_t uxHeaderLength )
{
  408104:	b480      	push	{r7}
  408106:	b087      	sub	sp, #28
  408108:	af00      	add	r7, sp, #0
  40810a:	60f8      	str	r0, [r7, #12]
  40810c:	60b9      	str	r1, [r7, #8]
  40810e:	607a      	str	r2, [r7, #4]
eFrameProcessingResult_t eReturn = eProcessBuffer;
  408110:	2301      	movs	r3, #1
  408112:	75fb      	strb	r3, [r7, #23]
		( void ) pxNetworkBuffer;
		( void ) uxHeaderLength;
	}
	#endif /* ipconfigDRIVER_INCLUDED_RX_IP_CHECKSUM == 0 */

	return eReturn;
  408114:	7dfb      	ldrb	r3, [r7, #23]
}
  408116:	4618      	mov	r0, r3
  408118:	371c      	adds	r7, #28
  40811a:	46bd      	mov	sp, r7
  40811c:	f85d 7b04 	ldr.w	r7, [sp], #4
  408120:	4770      	bx	lr
	...

00408124 <prvProcessIPPacket>:
/*-----------------------------------------------------------*/

static eFrameProcessingResult_t prvProcessIPPacket( IPPacket_t * const pxIPPacket, NetworkBufferDescriptor_t * const pxNetworkBuffer )
{
  408124:	b580      	push	{r7, lr}
  408126:	b08e      	sub	sp, #56	; 0x38
  408128:	af00      	add	r7, sp, #0
  40812a:	6078      	str	r0, [r7, #4]
  40812c:	6039      	str	r1, [r7, #0]
eFrameProcessingResult_t eReturn;
IPHeader_t * pxIPHeader = &( pxIPPacket->xIPHeader );
  40812e:	687b      	ldr	r3, [r7, #4]
  408130:	330e      	adds	r3, #14
  408132:	633b      	str	r3, [r7, #48]	; 0x30
UBaseType_t uxHeaderLength = ( UBaseType_t ) ( ( pxIPHeader->ucVersionHeaderLength & 0x0Fu ) << 2 );
  408134:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  408136:	781b      	ldrb	r3, [r3, #0]
  408138:	009b      	lsls	r3, r3, #2
  40813a:	f003 033c 	and.w	r3, r3, #60	; 0x3c
  40813e:	62fb      	str	r3, [r7, #44]	; 0x2c
uint8_t ucProtocol;

	/* Bound the calculated header length: take away the Ethernet header size,
	then check if the IP header is claiming to be longer than the remaining
	total packet size. Also check for minimal header field length. */
	if( ( uxHeaderLength > ( pxNetworkBuffer->xDataLength - ipSIZE_OF_ETH_HEADER ) ) ||
  408140:	683b      	ldr	r3, [r7, #0]
  408142:	69db      	ldr	r3, [r3, #28]
  408144:	f1a3 020e 	sub.w	r2, r3, #14
  408148:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40814a:	429a      	cmp	r2, r3
  40814c:	d302      	bcc.n	408154 <prvProcessIPPacket+0x30>
  40814e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  408150:	2b13      	cmp	r3, #19
  408152:	d801      	bhi.n	408158 <prvProcessIPPacket+0x34>
		( uxHeaderLength < ipSIZE_OF_IPv4_HEADER ) )
	{
		return eReleaseBuffer;
  408154:	2300      	movs	r3, #0
  408156:	e0b4      	b.n	4082c2 <prvProcessIPPacket+0x19e>
	}

	ucProtocol = pxIPPacket->xIPHeader.ucProtocol;
  408158:	687b      	ldr	r3, [r7, #4]
  40815a:	7ddb      	ldrb	r3, [r3, #23]
  40815c:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
	/* Check if the IP headers are acceptable and if it has our destination. */
	eReturn = prvAllowIPPacket( pxIPPacket, pxNetworkBuffer, uxHeaderLength );
  408160:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  408162:	6839      	ldr	r1, [r7, #0]
  408164:	6878      	ldr	r0, [r7, #4]
  408166:	4b59      	ldr	r3, [pc, #356]	; (4082cc <prvProcessIPPacket+0x1a8>)
  408168:	4798      	blx	r3
  40816a:	4603      	mov	r3, r0
  40816c:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37

	if( eReturn == eProcessBuffer )
  408170:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  408174:	2b01      	cmp	r3, #1
  408176:	f040 80a2 	bne.w	4082be <prvProcessIPPacket+0x19a>
	{
		if( uxHeaderLength > ipSIZE_OF_IPv4_HEADER )
  40817a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40817c:	2b14      	cmp	r3, #20
  40817e:	d927      	bls.n	4081d0 <prvProcessIPPacket+0xac>
		{
			/* All structs of headers expect a IP header size of 20 bytes
			 * IP header options were included, we'll ignore them and cut them out
			 * Note: IP options are mostly use in Multi-cast protocols */
			const size_t optlen = ( ( size_t ) uxHeaderLength ) - ipSIZE_OF_IPv4_HEADER;
  408180:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  408182:	3b14      	subs	r3, #20
  408184:	627b      	str	r3, [r7, #36]	; 0x24
			/* From: the previous start of UDP/ICMP/TCP data */
			uint8_t *pucSource = ( uint8_t* )(pxNetworkBuffer->pucEthernetBuffer + sizeof( EthernetHeader_t ) + uxHeaderLength);
  408186:	683b      	ldr	r3, [r7, #0]
  408188:	699a      	ldr	r2, [r3, #24]
  40818a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40818c:	330e      	adds	r3, #14
  40818e:	4413      	add	r3, r2
  408190:	623b      	str	r3, [r7, #32]
			/* To: the usual start of UDP/ICMP/TCP data at offset 20 from IP header */
			uint8_t *pucTarget = ( uint8_t* )(pxNetworkBuffer->pucEthernetBuffer + sizeof( EthernetHeader_t ) + ipSIZE_OF_IPv4_HEADER);
  408192:	683b      	ldr	r3, [r7, #0]
  408194:	699b      	ldr	r3, [r3, #24]
  408196:	3322      	adds	r3, #34	; 0x22
  408198:	61fb      	str	r3, [r7, #28]
			/* How many: total length minus the options and the lower headers */
			const size_t  xMoveLen = pxNetworkBuffer->xDataLength - optlen - ipSIZE_OF_IPv4_HEADER - ipSIZE_OF_ETH_HEADER;
  40819a:	683b      	ldr	r3, [r7, #0]
  40819c:	69da      	ldr	r2, [r3, #28]
  40819e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4081a0:	1ad3      	subs	r3, r2, r3
  4081a2:	3b22      	subs	r3, #34	; 0x22
  4081a4:	61bb      	str	r3, [r7, #24]

			memmove( pucTarget, pucSource, xMoveLen );
  4081a6:	69ba      	ldr	r2, [r7, #24]
  4081a8:	6a39      	ldr	r1, [r7, #32]
  4081aa:	69f8      	ldr	r0, [r7, #28]
  4081ac:	4b48      	ldr	r3, [pc, #288]	; (4082d0 <prvProcessIPPacket+0x1ac>)
  4081ae:	4798      	blx	r3
			pxNetworkBuffer->xDataLength -= optlen;
  4081b0:	683b      	ldr	r3, [r7, #0]
  4081b2:	69da      	ldr	r2, [r3, #28]
  4081b4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4081b6:	1ad2      	subs	r2, r2, r3
  4081b8:	683b      	ldr	r3, [r7, #0]
  4081ba:	61da      	str	r2, [r3, #28]

			/* Fix-up new version/header length field in IP packet. */
			pxIPHeader->ucVersionHeaderLength = ( pxIPHeader->ucVersionHeaderLength & 0xF0 ) | /* High nibble is the version. */
  4081bc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  4081be:	781b      	ldrb	r3, [r3, #0]
  4081c0:	f023 030f 	bic.w	r3, r3, #15
  4081c4:	b2db      	uxtb	r3, r3
  4081c6:	f043 0305 	orr.w	r3, r3, #5
  4081ca:	b2da      	uxtb	r2, r3
  4081cc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  4081ce:	701a      	strb	r2, [r3, #0]
		}

		/* Add the IP and MAC addresses to the ARP table if they are not
		already there - otherwise refresh the age of the existing
		entry. */
		if( ucProtocol != ( uint8_t ) ipPROTOCOL_UDP )
  4081d0:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
  4081d4:	2b11      	cmp	r3, #17
  4081d6:	d007      	beq.n	4081e8 <prvProcessIPPacket+0xc4>
			 * For UDP packets, this will be done later in xProcessReceivedUDPPacket()
			 * as soon as know that the message will be handled by someone
			 * This will prevent that the ARP cache will get overwritten
			 * with the IP-address of useless broadcast packets
			 */
			vARPRefreshCacheEntry( &( pxIPPacket->xEthernetHeader.xSourceAddress ), pxIPHeader->ulSourceIPAddress );
  4081d8:	687b      	ldr	r3, [r7, #4]
  4081da:	1d9a      	adds	r2, r3, #6
  4081dc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  4081de:	68db      	ldr	r3, [r3, #12]
  4081e0:	4619      	mov	r1, r3
  4081e2:	4610      	mov	r0, r2
  4081e4:	4b3b      	ldr	r3, [pc, #236]	; (4082d4 <prvProcessIPPacket+0x1b0>)
  4081e6:	4798      	blx	r3
		}
		switch( ucProtocol )
  4081e8:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
  4081ec:	2b06      	cmp	r3, #6
  4081ee:	d056      	beq.n	40829e <prvProcessIPPacket+0x17a>
  4081f0:	2b11      	cmp	r3, #17
  4081f2:	d002      	beq.n	4081fa <prvProcessIPPacket+0xd6>
  4081f4:	2b01      	cmp	r3, #1
  4081f6:	d061      	beq.n	4082bc <prvProcessIPPacket+0x198>
				}
				break;
#endif
			default	:
				/* Not a supported frame type. */
				break;
  4081f8:	e061      	b.n	4082be <prvProcessIPPacket+0x19a>
					UDPPacket_t *pxUDPPacket = ( UDPPacket_t * ) ( pxNetworkBuffer->pucEthernetBuffer );
  4081fa:	683b      	ldr	r3, [r7, #0]
  4081fc:	699b      	ldr	r3, [r3, #24]
  4081fe:	617b      	str	r3, [r7, #20]
					if ( ( pxNetworkBuffer->xDataLength >= sizeof( UDPPacket_t ) ) && ( FreeRTOS_ntohs( pxUDPPacket->xUDPHeader.usLength ) >= sizeof( UDPHeader_t ) ) )
  408200:	683b      	ldr	r3, [r7, #0]
  408202:	69db      	ldr	r3, [r3, #28]
  408204:	2b29      	cmp	r3, #41	; 0x29
  408206:	d944      	bls.n	408292 <prvProcessIPPacket+0x16e>
  408208:	697b      	ldr	r3, [r7, #20]
  40820a:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
  40820c:	b29b      	uxth	r3, r3
  40820e:	021b      	lsls	r3, r3, #8
  408210:	b21a      	sxth	r2, r3
  408212:	697b      	ldr	r3, [r7, #20]
  408214:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
  408216:	b29b      	uxth	r3, r3
  408218:	0a1b      	lsrs	r3, r3, #8
  40821a:	b29b      	uxth	r3, r3
  40821c:	b21b      	sxth	r3, r3
  40821e:	4313      	orrs	r3, r2
  408220:	b21b      	sxth	r3, r3
  408222:	b29b      	uxth	r3, r3
  408224:	2b07      	cmp	r3, #7
  408226:	d934      	bls.n	408292 <prvProcessIPPacket+0x16e>
						uxPayloadSize_1 = pxNetworkBuffer->xDataLength - sizeof( UDPPacket_t );
  408228:	683b      	ldr	r3, [r7, #0]
  40822a:	69db      	ldr	r3, [r3, #28]
  40822c:	3b2a      	subs	r3, #42	; 0x2a
  40822e:	613b      	str	r3, [r7, #16]
						uxPayloadSize_2 = FreeRTOS_ntohs( pxUDPPacket->xUDPHeader.usLength ) - sizeof( UDPHeader_t );
  408230:	697b      	ldr	r3, [r7, #20]
  408232:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
  408234:	b29b      	uxth	r3, r3
  408236:	021b      	lsls	r3, r3, #8
  408238:	b21a      	sxth	r2, r3
  40823a:	697b      	ldr	r3, [r7, #20]
  40823c:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
  40823e:	b29b      	uxth	r3, r3
  408240:	0a1b      	lsrs	r3, r3, #8
  408242:	b29b      	uxth	r3, r3
  408244:	b21b      	sxth	r3, r3
  408246:	4313      	orrs	r3, r2
  408248:	b21b      	sxth	r3, r3
  40824a:	b29b      	uxth	r3, r3
  40824c:	3b08      	subs	r3, #8
  40824e:	60fb      	str	r3, [r7, #12]
						if( uxPayloadSize_1 > uxPayloadSize_2 )
  408250:	693a      	ldr	r2, [r7, #16]
  408252:	68fb      	ldr	r3, [r7, #12]
  408254:	429a      	cmp	r2, r3
  408256:	d904      	bls.n	408262 <prvProcessIPPacket+0x13e>
							pxNetworkBuffer->xDataLength = uxPayloadSize_2 + sizeof( UDPPacket_t );
  408258:	68fb      	ldr	r3, [r7, #12]
  40825a:	f103 022a 	add.w	r2, r3, #42	; 0x2a
  40825e:	683b      	ldr	r3, [r7, #0]
  408260:	61da      	str	r2, [r3, #28]
						pxNetworkBuffer->usPort = pxUDPPacket->xUDPHeader.usSourcePort;
  408262:	697b      	ldr	r3, [r7, #20]
  408264:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
  408266:	b29a      	uxth	r2, r3
  408268:	683b      	ldr	r3, [r7, #0]
  40826a:	841a      	strh	r2, [r3, #32]
						pxNetworkBuffer->ulIPAddress = pxUDPPacket->xIPHeader.ulSourceIPAddress;
  40826c:	697b      	ldr	r3, [r7, #20]
  40826e:	f8d3 201a 	ldr.w	r2, [r3, #26]
  408272:	683b      	ldr	r3, [r7, #0]
  408274:	615a      	str	r2, [r3, #20]
						if( xProcessReceivedUDPPacket( pxNetworkBuffer,
  408276:	697b      	ldr	r3, [r7, #20]
  408278:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
  40827a:	b29b      	uxth	r3, r3
  40827c:	4619      	mov	r1, r3
  40827e:	6838      	ldr	r0, [r7, #0]
  408280:	4b15      	ldr	r3, [pc, #84]	; (4082d8 <prvProcessIPPacket+0x1b4>)
  408282:	4798      	blx	r3
  408284:	4603      	mov	r3, r0
  408286:	2b01      	cmp	r3, #1
  408288:	d107      	bne.n	40829a <prvProcessIPPacket+0x176>
							eReturn = eFrameConsumed;
  40828a:	2303      	movs	r3, #3
  40828c:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
					{
  408290:	e003      	b.n	40829a <prvProcessIPPacket+0x176>
						eReturn = eReleaseBuffer;
  408292:	2300      	movs	r3, #0
  408294:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
				break;
  408298:	e011      	b.n	4082be <prvProcessIPPacket+0x19a>
					{
  40829a:	bf00      	nop
				break;
  40829c:	e00f      	b.n	4082be <prvProcessIPPacket+0x19a>
					if( xProcessReceivedTCPPacket( pxNetworkBuffer ) == pdPASS )
  40829e:	6838      	ldr	r0, [r7, #0]
  4082a0:	4b0e      	ldr	r3, [pc, #56]	; (4082dc <prvProcessIPPacket+0x1b8>)
  4082a2:	4798      	blx	r3
  4082a4:	4603      	mov	r3, r0
  4082a6:	2b01      	cmp	r3, #1
  4082a8:	d102      	bne.n	4082b0 <prvProcessIPPacket+0x18c>
						eReturn = eFrameConsumed;
  4082aa:	2303      	movs	r3, #3
  4082ac:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
					xProcessedTCPMessage++;
  4082b0:	4b0b      	ldr	r3, [pc, #44]	; (4082e0 <prvProcessIPPacket+0x1bc>)
  4082b2:	681b      	ldr	r3, [r3, #0]
  4082b4:	3301      	adds	r3, #1
  4082b6:	4a0a      	ldr	r2, [pc, #40]	; (4082e0 <prvProcessIPPacket+0x1bc>)
  4082b8:	6013      	str	r3, [r2, #0]
				break;
  4082ba:	e000      	b.n	4082be <prvProcessIPPacket+0x19a>
				break;
  4082bc:	bf00      	nop
		}
	}

	return eReturn;
  4082be:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
}
  4082c2:	4618      	mov	r0, r3
  4082c4:	3738      	adds	r7, #56	; 0x38
  4082c6:	46bd      	mov	sp, r7
  4082c8:	bd80      	pop	{r7, pc}
  4082ca:	bf00      	nop
  4082cc:	00408105 	.word	0x00408105
  4082d0:	00416e39 	.word	0x00416e39
  4082d4:	00407159 	.word	0x00407159
  4082d8:	0040efb9 	.word	0x0040efb9
  4082dc:	0040d1dd 	.word	0x0040d1dd
  4082e0:	20006d00 	.word	0x20006d00

004082e4 <usGenerateProtocolChecksum>:

#endif /* ( ipconfigREPLY_TO_INCOMING_PINGS == 1 ) || ( ipconfigSUPPORT_OUTGOING_PINGS == 1 ) */
/*-----------------------------------------------------------*/

uint16_t usGenerateProtocolChecksum( const uint8_t * const pucEthernetBuffer, size_t uxBufferLength, BaseType_t xOutgoingPacket )
{
  4082e4:	b590      	push	{r4, r7, lr}
  4082e6:	b08f      	sub	sp, #60	; 0x3c
  4082e8:	af02      	add	r7, sp, #8
  4082ea:	60f8      	str	r0, [r7, #12]
  4082ec:	60b9      	str	r1, [r7, #8]
  4082ee:	607a      	str	r2, [r7, #4]
#if( ipconfigHAS_DEBUG_PRINTF != 0 )
	const char *pcType;
#endif

	/* Check for minimum packet size. */
	if( uxBufferLength < sizeof( IPPacket_t ) )
  4082f0:	68bb      	ldr	r3, [r7, #8]
  4082f2:	2b21      	cmp	r3, #33	; 0x21
  4082f4:	d802      	bhi.n	4082fc <usGenerateProtocolChecksum+0x18>
	{
		return ipINVALID_LENGTH;
  4082f6:	f241 2334 	movw	r3, #4660	; 0x1234
  4082fa:	e14d      	b.n	408598 <usGenerateProtocolChecksum+0x2b4>
	}

	/* Parse the packet length. */
	pxIPPacket = ( const IPPacket_t * ) pucEthernetBuffer;
  4082fc:	68fb      	ldr	r3, [r7, #12]
  4082fe:	623b      	str	r3, [r7, #32]

	/* Per https://tools.ietf.org/html/rfc791, the four-bit Internet Header
	Length field contains the length of the internet header in 32-bit words. */
	uxIPHeaderLength = ( UBaseType_t ) ( sizeof( uint32_t ) * ( pxIPPacket->xIPHeader.ucVersionHeaderLength & 0x0Fu ) );
  408300:	6a3b      	ldr	r3, [r7, #32]
  408302:	7b9b      	ldrb	r3, [r3, #14]
  408304:	f003 030f 	and.w	r3, r3, #15
  408308:	009b      	lsls	r3, r3, #2
  40830a:	61fb      	str	r3, [r7, #28]

	/* Check for minimum packet size. */
	if( uxBufferLength < sizeof( IPPacket_t ) + uxIPHeaderLength - ipSIZE_OF_IPv4_HEADER )
  40830c:	69fb      	ldr	r3, [r7, #28]
  40830e:	f103 020e 	add.w	r2, r3, #14
  408312:	68bb      	ldr	r3, [r7, #8]
  408314:	429a      	cmp	r2, r3
  408316:	d902      	bls.n	40831e <usGenerateProtocolChecksum+0x3a>
	{
		return ipINVALID_LENGTH;
  408318:	f241 2334 	movw	r3, #4660	; 0x1234
  40831c:	e13c      	b.n	408598 <usGenerateProtocolChecksum+0x2b4>
	}
	if( uxBufferLength < ( size_t ) ( ipSIZE_OF_ETH_HEADER + FreeRTOS_ntohs( pxIPPacket->xIPHeader.usLength ) ) )
  40831e:	6a3b      	ldr	r3, [r7, #32]
  408320:	8a1b      	ldrh	r3, [r3, #16]
  408322:	b29b      	uxth	r3, r3
  408324:	021b      	lsls	r3, r3, #8
  408326:	b21a      	sxth	r2, r3
  408328:	6a3b      	ldr	r3, [r7, #32]
  40832a:	8a1b      	ldrh	r3, [r3, #16]
  40832c:	b29b      	uxth	r3, r3
  40832e:	0a1b      	lsrs	r3, r3, #8
  408330:	b29b      	uxth	r3, r3
  408332:	b21b      	sxth	r3, r3
  408334:	4313      	orrs	r3, r2
  408336:	b21b      	sxth	r3, r3
  408338:	b29b      	uxth	r3, r3
  40833a:	f103 020e 	add.w	r2, r3, #14
  40833e:	68bb      	ldr	r3, [r7, #8]
  408340:	429a      	cmp	r2, r3
  408342:	d902      	bls.n	40834a <usGenerateProtocolChecksum+0x66>
	{
		return ipINVALID_LENGTH;
  408344:	f241 2334 	movw	r3, #4660	; 0x1234
  408348:	e126      	b.n	408598 <usGenerateProtocolChecksum+0x2b4>
	}

	/* Identify the next protocol. */
	ucProtocol = pxIPPacket->xIPHeader.ucProtocol;
  40834a:	6a3b      	ldr	r3, [r7, #32]
  40834c:	7ddb      	ldrb	r3, [r3, #23]
  40834e:	76fb      	strb	r3, [r7, #27]
	/* N.B., if this IP packet header includes Options, then the following
	assignment results in a pointer into the protocol packet with the Ethernet
	and IP headers incorrectly aligned. However, either way, the "third"
	protocol (Layer 3 or 4) header will be aligned, which is the convenience
	of this calculation. */
	pxProtPack = ( ProtocolPacket_t * ) ( pucEthernetBuffer + ( uxIPHeaderLength - ipSIZE_OF_IPv4_HEADER ) );
  408350:	69fb      	ldr	r3, [r7, #28]
  408352:	3b14      	subs	r3, #20
  408354:	68fa      	ldr	r2, [r7, #12]
  408356:	4413      	add	r3, r2
  408358:	617b      	str	r3, [r7, #20]

	/* Switch on the Layer 3/4 protocol. */
	if( ucProtocol == ( uint8_t ) ipPROTOCOL_UDP )
  40835a:	7efb      	ldrb	r3, [r7, #27]
  40835c:	2b11      	cmp	r3, #17
  40835e:	d10e      	bne.n	40837e <usGenerateProtocolChecksum+0x9a>
	{
		if( uxBufferLength < ( uxIPHeaderLength + ipSIZE_OF_ETH_HEADER + ipSIZE_OF_UDP_HEADER ) )
  408360:	69fb      	ldr	r3, [r7, #28]
  408362:	f103 0216 	add.w	r2, r3, #22
  408366:	68bb      	ldr	r3, [r7, #8]
  408368:	429a      	cmp	r2, r3
  40836a:	d902      	bls.n	408372 <usGenerateProtocolChecksum+0x8e>
		{
			return ipINVALID_LENGTH;
  40836c:	f241 2334 	movw	r3, #4660	; 0x1234
  408370:	e112      	b.n	408598 <usGenerateProtocolChecksum+0x2b4>
		}

		pusChecksum = ( uint16_t * ) ( &( pxProtPack->xUDPPacket.xUDPHeader.usChecksum ) );
  408372:	697b      	ldr	r3, [r7, #20]
  408374:	3328      	adds	r3, #40	; 0x28
  408376:	62bb      	str	r3, [r7, #40]	; 0x28
		#if( ipconfigHAS_DEBUG_PRINTF != 0 )
		{
			pcType = "UDP";
  408378:	4b89      	ldr	r3, [pc, #548]	; (4085a0 <usGenerateProtocolChecksum+0x2bc>)
  40837a:	627b      	str	r3, [r7, #36]	; 0x24
  40837c:	e02f      	b.n	4083de <usGenerateProtocolChecksum+0xfa>
		}
		#endif	/* ipconfigHAS_DEBUG_PRINTF != 0 */
	}
	else if( ucProtocol == ( uint8_t ) ipPROTOCOL_TCP )
  40837e:	7efb      	ldrb	r3, [r7, #27]
  408380:	2b06      	cmp	r3, #6
  408382:	d10e      	bne.n	4083a2 <usGenerateProtocolChecksum+0xbe>
	{
		if( uxBufferLength < ( uxIPHeaderLength + ipSIZE_OF_ETH_HEADER + ipSIZE_OF_TCP_HEADER ) )
  408384:	69fb      	ldr	r3, [r7, #28]
  408386:	f103 0222 	add.w	r2, r3, #34	; 0x22
  40838a:	68bb      	ldr	r3, [r7, #8]
  40838c:	429a      	cmp	r2, r3
  40838e:	d902      	bls.n	408396 <usGenerateProtocolChecksum+0xb2>
		{
			return ipINVALID_LENGTH;
  408390:	f241 2334 	movw	r3, #4660	; 0x1234
  408394:	e100      	b.n	408598 <usGenerateProtocolChecksum+0x2b4>
		}

		pusChecksum = ( uint16_t * ) ( &( pxProtPack->xTCPPacket.xTCPHeader.usChecksum ) );
  408396:	697b      	ldr	r3, [r7, #20]
  408398:	3332      	adds	r3, #50	; 0x32
  40839a:	62bb      	str	r3, [r7, #40]	; 0x28
		#if( ipconfigHAS_DEBUG_PRINTF != 0 )
		{
			pcType = "TCP";
  40839c:	4b81      	ldr	r3, [pc, #516]	; (4085a4 <usGenerateProtocolChecksum+0x2c0>)
  40839e:	627b      	str	r3, [r7, #36]	; 0x24
  4083a0:	e01d      	b.n	4083de <usGenerateProtocolChecksum+0xfa>
		}
		#endif	/* ipconfigHAS_DEBUG_PRINTF != 0 */
	}
	else if( ( ucProtocol == ( uint8_t ) ipPROTOCOL_ICMP ) ||
  4083a2:	7efb      	ldrb	r3, [r7, #27]
  4083a4:	2b01      	cmp	r3, #1
  4083a6:	d002      	beq.n	4083ae <usGenerateProtocolChecksum+0xca>
  4083a8:	7efb      	ldrb	r3, [r7, #27]
  4083aa:	2b02      	cmp	r3, #2
  4083ac:	d114      	bne.n	4083d8 <usGenerateProtocolChecksum+0xf4>
			( ucProtocol == ( uint8_t ) ipPROTOCOL_IGMP ) )
	{
		if( uxBufferLength < ( uxIPHeaderLength + ipSIZE_OF_ETH_HEADER + ipSIZE_OF_ICMP_HEADER ) )
  4083ae:	69fb      	ldr	r3, [r7, #28]
  4083b0:	f103 0216 	add.w	r2, r3, #22
  4083b4:	68bb      	ldr	r3, [r7, #8]
  4083b6:	429a      	cmp	r2, r3
  4083b8:	d902      	bls.n	4083c0 <usGenerateProtocolChecksum+0xdc>
		{
			return ipINVALID_LENGTH;
  4083ba:	f241 2334 	movw	r3, #4660	; 0x1234
  4083be:	e0eb      	b.n	408598 <usGenerateProtocolChecksum+0x2b4>
		}

		pusChecksum = ( uint16_t * ) ( &( pxProtPack->xICMPPacket.xICMPHeader.usChecksum ) );
  4083c0:	697b      	ldr	r3, [r7, #20]
  4083c2:	3324      	adds	r3, #36	; 0x24
  4083c4:	62bb      	str	r3, [r7, #40]	; 0x28
		#if( ipconfigHAS_DEBUG_PRINTF != 0 )
		{
			if( ucProtocol == ( uint8_t ) ipPROTOCOL_ICMP )
  4083c6:	7efb      	ldrb	r3, [r7, #27]
  4083c8:	2b01      	cmp	r3, #1
  4083ca:	d102      	bne.n	4083d2 <usGenerateProtocolChecksum+0xee>
			{
				pcType = "ICMP";
  4083cc:	4b76      	ldr	r3, [pc, #472]	; (4085a8 <usGenerateProtocolChecksum+0x2c4>)
  4083ce:	627b      	str	r3, [r7, #36]	; 0x24
			if( ucProtocol == ( uint8_t ) ipPROTOCOL_ICMP )
  4083d0:	e005      	b.n	4083de <usGenerateProtocolChecksum+0xfa>
			}
			else
			{
				pcType = "IGMP";
  4083d2:	4b76      	ldr	r3, [pc, #472]	; (4085ac <usGenerateProtocolChecksum+0x2c8>)
  4083d4:	627b      	str	r3, [r7, #36]	; 0x24
			if( ucProtocol == ( uint8_t ) ipPROTOCOL_ICMP )
  4083d6:	e002      	b.n	4083de <usGenerateProtocolChecksum+0xfa>
		#endif	/* ipconfigHAS_DEBUG_PRINTF != 0 */
	}
	else
	{
		/* Unhandled protocol, other than ICMP, IGMP, UDP, or TCP. */
		return ipUNHANDLED_PROTOCOL;
  4083d8:	f244 3321 	movw	r3, #17185	; 0x4321
  4083dc:	e0dc      	b.n	408598 <usGenerateProtocolChecksum+0x2b4>
	}

	/* The protocol and checksum field have been identified. Check the direction
	of the packet. */
	if( xOutgoingPacket != pdFALSE )
  4083de:	687b      	ldr	r3, [r7, #4]
  4083e0:	2b00      	cmp	r3, #0
  4083e2:	d003      	beq.n	4083ec <usGenerateProtocolChecksum+0x108>
	{
		/* This is an outgoing packet. Before calculating the checksum, set it
		to zero. */
		*( pusChecksum ) = 0u;
  4083e4:	6abb      	ldr	r3, [r7, #40]	; 0x28
  4083e6:	2200      	movs	r2, #0
  4083e8:	801a      	strh	r2, [r3, #0]
  4083ea:	e009      	b.n	408400 <usGenerateProtocolChecksum+0x11c>
	}
	else if( ( *pusChecksum == 0u ) && ( ucProtocol == ( uint8_t ) ipPROTOCOL_UDP ) )
  4083ec:	6abb      	ldr	r3, [r7, #40]	; 0x28
  4083ee:	881b      	ldrh	r3, [r3, #0]
  4083f0:	2b00      	cmp	r3, #0
  4083f2:	d105      	bne.n	408400 <usGenerateProtocolChecksum+0x11c>
  4083f4:	7efb      	ldrb	r3, [r7, #27]
  4083f6:	2b11      	cmp	r3, #17
  4083f8:	d102      	bne.n	408400 <usGenerateProtocolChecksum+0x11c>
	{
		/* Sender hasn't set the checksum, no use to calculate it. */
		return ipCORRECT_CRC;
  4083fa:	f64f 73ff 	movw	r3, #65535	; 0xffff
  4083fe:	e0cb      	b.n	408598 <usGenerateProtocolChecksum+0x2b4>
	}

	ulLength = ( uint32_t )
		( FreeRTOS_ntohs( pxIPPacket->xIPHeader.usLength ) - ( ( uint16_t ) uxIPHeaderLength ) ); /* normally minus 20 */
  408400:	6a3b      	ldr	r3, [r7, #32]
  408402:	8a1b      	ldrh	r3, [r3, #16]
  408404:	b29b      	uxth	r3, r3
  408406:	021b      	lsls	r3, r3, #8
  408408:	b21a      	sxth	r2, r3
  40840a:	6a3b      	ldr	r3, [r7, #32]
  40840c:	8a1b      	ldrh	r3, [r3, #16]
  40840e:	b29b      	uxth	r3, r3
  408410:	0a1b      	lsrs	r3, r3, #8
  408412:	b29b      	uxth	r3, r3
  408414:	b21b      	sxth	r3, r3
  408416:	4313      	orrs	r3, r2
  408418:	b21b      	sxth	r3, r3
  40841a:	b29b      	uxth	r3, r3
  40841c:	461a      	mov	r2, r3
  40841e:	69fb      	ldr	r3, [r7, #28]
  408420:	b29b      	uxth	r3, r3
  408422:	1ad3      	subs	r3, r2, r3
	ulLength = ( uint32_t )
  408424:	613b      	str	r3, [r7, #16]

	if( ( ulLength < sizeof( pxProtPack->xUDPPacket.xUDPHeader ) ) ||
  408426:	693b      	ldr	r3, [r7, #16]
  408428:	2b07      	cmp	r3, #7
  40842a:	d905      	bls.n	408438 <usGenerateProtocolChecksum+0x154>
		( ulLength > ( uint32_t )( ipconfigNETWORK_MTU - uxIPHeaderLength ) ) )
  40842c:	69fb      	ldr	r3, [r7, #28]
  40842e:	f5c3 62af 	rsb	r2, r3, #1400	; 0x578
	if( ( ulLength < sizeof( pxProtPack->xUDPPacket.xUDPHeader ) ) ||
  408432:	693b      	ldr	r3, [r7, #16]
  408434:	429a      	cmp	r2, r3
  408436:	d207      	bcs.n	408448 <usGenerateProtocolChecksum+0x164>
	{
		#if( ipconfigHAS_DEBUG_PRINTF != 0 )
		{
			FreeRTOS_debug_printf( ( "usGenerateProtocolChecksum[%s]: len invalid: %lu\n", pcType, ulLength ) );
  408438:	693a      	ldr	r2, [r7, #16]
  40843a:	6a79      	ldr	r1, [r7, #36]	; 0x24
  40843c:	485c      	ldr	r0, [pc, #368]	; (4085b0 <usGenerateProtocolChecksum+0x2cc>)
  40843e:	4b5d      	ldr	r3, [pc, #372]	; (4085b4 <usGenerateProtocolChecksum+0x2d0>)
  408440:	4798      	blx	r3

		/* Again, in a 16-bit return value there is no space to indicate an
		error.  For incoming packets, 0x1234 will cause dropping of the packet.
		For outgoing packets, there is a serious problem with the
		format/length */
		return ipINVALID_LENGTH;
  408442:	f241 2334 	movw	r3, #4660	; 0x1234
  408446:	e0a7      	b.n	408598 <usGenerateProtocolChecksum+0x2b4>
	}
	if( ucProtocol <= ( uint8_t ) ipPROTOCOL_IGMP )
  408448:	7efb      	ldrb	r3, [r7, #27]
  40844a:	2b02      	cmp	r3, #2
  40844c:	d80a      	bhi.n	408464 <usGenerateProtocolChecksum+0x180>
	{
		/* ICMP/IGMP do not have a pseudo header for CRC-calculation. */
		usChecksum = ( uint16_t )
			( ~usGenerateChecksum( 0UL,
				( uint8_t * ) &( pxProtPack->xTCPPacket.xTCPHeader ), ( size_t ) ulLength ) );
  40844e:	697b      	ldr	r3, [r7, #20]
  408450:	3322      	adds	r3, #34	; 0x22
			( ~usGenerateChecksum( 0UL,
  408452:	693a      	ldr	r2, [r7, #16]
  408454:	4619      	mov	r1, r3
  408456:	2000      	movs	r0, #0
  408458:	4b57      	ldr	r3, [pc, #348]	; (4085b8 <usGenerateProtocolChecksum+0x2d4>)
  40845a:	4798      	blx	r3
  40845c:	4603      	mov	r3, r0
		usChecksum = ( uint16_t )
  40845e:	43db      	mvns	r3, r3
  408460:	85fb      	strh	r3, [r7, #46]	; 0x2e
  408462:	e011      	b.n	408488 <usGenerateProtocolChecksum+0x1a4>
	}
	else
	{
		/* For UDP and TCP, sum the pseudo header, i.e. IP protocol + length
		fields */
		usChecksum = ( uint16_t ) ( ulLength + ( ( uint16_t ) ucProtocol ) );
  408464:	693b      	ldr	r3, [r7, #16]
  408466:	b29a      	uxth	r2, r3
  408468:	7efb      	ldrb	r3, [r7, #27]
  40846a:	b29b      	uxth	r3, r3
  40846c:	4413      	add	r3, r2
  40846e:	85fb      	strh	r3, [r7, #46]	; 0x2e

		/* And then continue at the IPv4 source and destination addresses. */
		usChecksum = ( uint16_t )
			( ~usGenerateChecksum( ( uint32_t ) usChecksum, ( uint8_t * )&( pxIPPacket->xIPHeader.ulSourceIPAddress ),
  408470:	8df8      	ldrh	r0, [r7, #46]	; 0x2e
  408472:	6a3b      	ldr	r3, [r7, #32]
  408474:	f103 011a 	add.w	r1, r3, #26
				( 2u * sizeof( pxIPPacket->xIPHeader.ulSourceIPAddress ) + ulLength ) ) );
  408478:	693b      	ldr	r3, [r7, #16]
  40847a:	3308      	adds	r3, #8
			( ~usGenerateChecksum( ( uint32_t ) usChecksum, ( uint8_t * )&( pxIPPacket->xIPHeader.ulSourceIPAddress ),
  40847c:	461a      	mov	r2, r3
  40847e:	4b4e      	ldr	r3, [pc, #312]	; (4085b8 <usGenerateProtocolChecksum+0x2d4>)
  408480:	4798      	blx	r3
  408482:	4603      	mov	r3, r0
		usChecksum = ( uint16_t )
  408484:	43db      	mvns	r3, r3
  408486:	85fb      	strh	r3, [r7, #46]	; 0x2e

		/* Sum TCP header and data. */
	}

	if( xOutgoingPacket == pdFALSE )
  408488:	687b      	ldr	r3, [r7, #4]
  40848a:	2b00      	cmp	r3, #0
  40848c:	d106      	bne.n	40849c <usGenerateProtocolChecksum+0x1b8>
	{
		/* This is in incoming packet. If the CRC is correct, it should be zero. */
		if( usChecksum == 0u )
  40848e:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
  408490:	2b00      	cmp	r3, #0
  408492:	d115      	bne.n	4084c0 <usGenerateProtocolChecksum+0x1dc>
		{
			usChecksum = ( uint16_t )ipCORRECT_CRC;
  408494:	f64f 73ff 	movw	r3, #65535	; 0xffff
  408498:	85fb      	strh	r3, [r7, #46]	; 0x2e
  40849a:	e011      	b.n	4084c0 <usGenerateProtocolChecksum+0x1dc>
		}
	}
	else
	{
		if( ( usChecksum == 0u ) && ( ucProtocol == ( uint8_t ) ipPROTOCOL_UDP ) )
  40849c:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
  40849e:	2b00      	cmp	r3, #0
  4084a0:	d10e      	bne.n	4084c0 <usGenerateProtocolChecksum+0x1dc>
  4084a2:	7efb      	ldrb	r3, [r7, #27]
  4084a4:	2b11      	cmp	r3, #17
  4084a6:	d10b      	bne.n	4084c0 <usGenerateProtocolChecksum+0x1dc>
		{
			/* In case of UDP, a calculated checksum of 0x0000 is transmitted
			as 0xffff. A value of zero would mean that the checksum is not used. */
			#if( ipconfigHAS_DEBUG_PRINTF != 0 )
			{
				if( xOutgoingPacket != pdFALSE )
  4084a8:	687b      	ldr	r3, [r7, #4]
  4084aa:	2b00      	cmp	r3, #0
  4084ac:	d005      	beq.n	4084ba <usGenerateProtocolChecksum+0x1d6>
				{
					FreeRTOS_debug_printf( ( "usGenerateProtocolChecksum[%s]: crc swap: %04X\n", pcType, usChecksum ) );
  4084ae:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
  4084b0:	461a      	mov	r2, r3
  4084b2:	6a79      	ldr	r1, [r7, #36]	; 0x24
  4084b4:	4841      	ldr	r0, [pc, #260]	; (4085bc <usGenerateProtocolChecksum+0x2d8>)
  4084b6:	4b3f      	ldr	r3, [pc, #252]	; (4085b4 <usGenerateProtocolChecksum+0x2d0>)
  4084b8:	4798      	blx	r3
				}
			}
			#endif	/* ipconfigHAS_DEBUG_PRINTF != 0 */

			usChecksum = ( uint16_t )0xffffu;
  4084ba:	f64f 73ff 	movw	r3, #65535	; 0xffff
  4084be:	85fb      	strh	r3, [r7, #46]	; 0x2e
		}
	}
	usChecksum = FreeRTOS_htons( usChecksum );
  4084c0:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
  4084c2:	021b      	lsls	r3, r3, #8
  4084c4:	b21a      	sxth	r2, r3
  4084c6:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
  4084c8:	0a1b      	lsrs	r3, r3, #8
  4084ca:	b29b      	uxth	r3, r3
  4084cc:	b21b      	sxth	r3, r3
  4084ce:	4313      	orrs	r3, r2
  4084d0:	b21b      	sxth	r3, r3
  4084d2:	85fb      	strh	r3, [r7, #46]	; 0x2e

	if( xOutgoingPacket != pdFALSE )
  4084d4:	687b      	ldr	r3, [r7, #4]
  4084d6:	2b00      	cmp	r3, #0
  4084d8:	d003      	beq.n	4084e2 <usGenerateProtocolChecksum+0x1fe>
	{
		*( pusChecksum ) = usChecksum;
  4084da:	6abb      	ldr	r3, [r7, #40]	; 0x28
  4084dc:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
  4084de:	801a      	strh	r2, [r3, #0]
  4084e0:	e059      	b.n	408596 <usGenerateProtocolChecksum+0x2b2>
	}
	#if( ipconfigHAS_DEBUG_PRINTF != 0 )
	else if( ( xOutgoingPacket == pdFALSE ) && ( usChecksum != ipCORRECT_CRC ) )
  4084e2:	687b      	ldr	r3, [r7, #4]
  4084e4:	2b00      	cmp	r3, #0
  4084e6:	d156      	bne.n	408596 <usGenerateProtocolChecksum+0x2b2>
  4084e8:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
  4084ea:	f64f 72ff 	movw	r2, #65535	; 0xffff
  4084ee:	4293      	cmp	r3, r2
  4084f0:	d051      	beq.n	408596 <usGenerateProtocolChecksum+0x2b2>
	{
		FreeRTOS_debug_printf( ( "usGenerateProtocolChecksum[%s]: ID %04X: from %lxip to %lxip bad crc: %04X\n",
  4084f2:	6a3b      	ldr	r3, [r7, #32]
  4084f4:	8a5b      	ldrh	r3, [r3, #18]
  4084f6:	b29b      	uxth	r3, r3
  4084f8:	021b      	lsls	r3, r3, #8
  4084fa:	b21a      	sxth	r2, r3
  4084fc:	6a3b      	ldr	r3, [r7, #32]
  4084fe:	8a5b      	ldrh	r3, [r3, #18]
  408500:	b29b      	uxth	r3, r3
  408502:	0a1b      	lsrs	r3, r3, #8
  408504:	b29b      	uxth	r3, r3
  408506:	b21b      	sxth	r3, r3
  408508:	4313      	orrs	r3, r2
  40850a:	b21b      	sxth	r3, r3
  40850c:	b29b      	uxth	r3, r3
  40850e:	461c      	mov	r4, r3
  408510:	6a3b      	ldr	r3, [r7, #32]
  408512:	f8d3 301a 	ldr.w	r3, [r3, #26]
  408516:	061a      	lsls	r2, r3, #24
  408518:	6a3b      	ldr	r3, [r7, #32]
  40851a:	f8d3 301a 	ldr.w	r3, [r3, #26]
  40851e:	021b      	lsls	r3, r3, #8
  408520:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
  408524:	431a      	orrs	r2, r3
  408526:	6a3b      	ldr	r3, [r7, #32]
  408528:	f8d3 301a 	ldr.w	r3, [r3, #26]
  40852c:	0a1b      	lsrs	r3, r3, #8
  40852e:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
  408532:	431a      	orrs	r2, r3
  408534:	6a3b      	ldr	r3, [r7, #32]
  408536:	f8d3 301a 	ldr.w	r3, [r3, #26]
  40853a:	0e1b      	lsrs	r3, r3, #24
  40853c:	ea42 0003 	orr.w	r0, r2, r3
  408540:	6a3b      	ldr	r3, [r7, #32]
  408542:	f8d3 301e 	ldr.w	r3, [r3, #30]
  408546:	061a      	lsls	r2, r3, #24
  408548:	6a3b      	ldr	r3, [r7, #32]
  40854a:	f8d3 301e 	ldr.w	r3, [r3, #30]
  40854e:	021b      	lsls	r3, r3, #8
  408550:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
  408554:	431a      	orrs	r2, r3
  408556:	6a3b      	ldr	r3, [r7, #32]
  408558:	f8d3 301e 	ldr.w	r3, [r3, #30]
  40855c:	0a1b      	lsrs	r3, r3, #8
  40855e:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
  408562:	431a      	orrs	r2, r3
  408564:	6a3b      	ldr	r3, [r7, #32]
  408566:	f8d3 301e 	ldr.w	r3, [r3, #30]
  40856a:	0e1b      	lsrs	r3, r3, #24
  40856c:	4313      	orrs	r3, r2
  40856e:	6aba      	ldr	r2, [r7, #40]	; 0x28
  408570:	8812      	ldrh	r2, [r2, #0]
  408572:	0212      	lsls	r2, r2, #8
  408574:	b211      	sxth	r1, r2
  408576:	6aba      	ldr	r2, [r7, #40]	; 0x28
  408578:	8812      	ldrh	r2, [r2, #0]
  40857a:	0a12      	lsrs	r2, r2, #8
  40857c:	b292      	uxth	r2, r2
  40857e:	b212      	sxth	r2, r2
  408580:	430a      	orrs	r2, r1
  408582:	b212      	sxth	r2, r2
  408584:	b292      	uxth	r2, r2
  408586:	9201      	str	r2, [sp, #4]
  408588:	9300      	str	r3, [sp, #0]
  40858a:	4603      	mov	r3, r0
  40858c:	4622      	mov	r2, r4
  40858e:	6a79      	ldr	r1, [r7, #36]	; 0x24
  408590:	480b      	ldr	r0, [pc, #44]	; (4085c0 <usGenerateProtocolChecksum+0x2dc>)
  408592:	4c08      	ldr	r4, [pc, #32]	; (4085b4 <usGenerateProtocolChecksum+0x2d0>)
  408594:	47a0      	blx	r4
			FreeRTOS_ntohl( pxIPPacket->xIPHeader.ulDestinationIPAddress ),
			FreeRTOS_ntohs( *pusChecksum ) ) );
	}
	#endif	/* ipconfigHAS_DEBUG_PRINTF != 0 */

	return usChecksum;
  408596:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
}
  408598:	4618      	mov	r0, r3
  40859a:	3734      	adds	r7, #52	; 0x34
  40859c:	46bd      	mov	sp, r7
  40859e:	bd90      	pop	{r4, r7, pc}
  4085a0:	0041cb38 	.word	0x0041cb38
  4085a4:	0041cb3c 	.word	0x0041cb3c
  4085a8:	0041cb40 	.word	0x0041cb40
  4085ac:	0041cb48 	.word	0x0041cb48
  4085b0:	0041cb50 	.word	0x0041cb50
  4085b4:	00416c7d 	.word	0x00416c7d
  4085b8:	004085c5 	.word	0x004085c5
  4085bc:	0041cb84 	.word	0x0041cb84
  4085c0:	0041cbb4 	.word	0x0041cbb4

004085c4 <usGenerateChecksum>:
 *	 method should process. The method's memory iterator is initialized to this value.
 *   uxDataLengthBytes: This argument contains the number of bytes that this method
 *	 should process.
 */
uint16_t usGenerateChecksum( uint32_t ulSum, const uint8_t * pucNextData, size_t uxDataLengthBytes )
{
  4085c4:	b480      	push	{r7}
  4085c6:	b08d      	sub	sp, #52	; 0x34
  4085c8:	af00      	add	r7, sp, #0
  4085ca:	60f8      	str	r0, [r7, #12]
  4085cc:	60b9      	str	r1, [r7, #8]
  4085ce:	607a      	str	r2, [r7, #4]
xUnion32 xSum2, xSum, xTerm;
xUnionPtr xSource;		/* Points to first byte */
xUnionPtr xLastSource;	/* Points to last byte plus one */
uint32_t ulAlignBits, ulCarry = 0ul;
  4085d0:	2300      	movs	r3, #0
  4085d2:	62fb      	str	r3, [r7, #44]	; 0x2c
	/* Small MCUs often spend up to 30% of the time doing checksum calculations
	This function is optimised for 32-bit CPUs; Each time it will try to fetch
	32-bits, sums it with an accumulator and counts the number of carries. */

	/* Swap the input (little endian platform only). */
	xSum.u32 = FreeRTOS_ntohs( ulSum );
  4085d4:	68fb      	ldr	r3, [r7, #12]
  4085d6:	b29b      	uxth	r3, r3
  4085d8:	021b      	lsls	r3, r3, #8
  4085da:	b29a      	uxth	r2, r3
  4085dc:	68fb      	ldr	r3, [r7, #12]
  4085de:	0a1b      	lsrs	r3, r3, #8
  4085e0:	b29b      	uxth	r3, r3
  4085e2:	4313      	orrs	r3, r2
  4085e4:	b29b      	uxth	r3, r3
  4085e6:	623b      	str	r3, [r7, #32]
	xTerm.u32 = 0ul;
  4085e8:	2300      	movs	r3, #0
  4085ea:	61fb      	str	r3, [r7, #28]

	xSource.u8ptr = ( uint8_t * ) pucNextData;
  4085ec:	68bb      	ldr	r3, [r7, #8]
  4085ee:	61bb      	str	r3, [r7, #24]
	ulAlignBits = ( ( ( uint32_t ) pucNextData ) & 0x03u ); /* gives 0, 1, 2, or 3 */
  4085f0:	68bb      	ldr	r3, [r7, #8]
  4085f2:	f003 0303 	and.w	r3, r3, #3
  4085f6:	62bb      	str	r3, [r7, #40]	; 0x28

	/* If byte (8-bit) aligned... */
	if( ( ( ulAlignBits & 1ul ) != 0ul ) && ( uxDataLengthBytes >= ( size_t ) 1 ) )
  4085f8:	6abb      	ldr	r3, [r7, #40]	; 0x28
  4085fa:	f003 0301 	and.w	r3, r3, #1
  4085fe:	2b00      	cmp	r3, #0
  408600:	d00b      	beq.n	40861a <usGenerateChecksum+0x56>
  408602:	687b      	ldr	r3, [r7, #4]
  408604:	2b00      	cmp	r3, #0
  408606:	d008      	beq.n	40861a <usGenerateChecksum+0x56>
	{
		xTerm.u8[ 1 ] = *( xSource.u8ptr );
  408608:	69bb      	ldr	r3, [r7, #24]
  40860a:	781b      	ldrb	r3, [r3, #0]
  40860c:	777b      	strb	r3, [r7, #29]
		( xSource.u8ptr )++;
  40860e:	69bb      	ldr	r3, [r7, #24]
  408610:	3301      	adds	r3, #1
  408612:	61bb      	str	r3, [r7, #24]
		uxDataLengthBytes--;
  408614:	687b      	ldr	r3, [r7, #4]
  408616:	3b01      	subs	r3, #1
  408618:	607b      	str	r3, [r7, #4]
		/* Now xSource is word (16-bit) aligned. */
	}

	/* If half-word (16-bit) aligned... */
	if( ( ( ulAlignBits == 1u ) || ( ulAlignBits == 2u ) ) && ( uxDataLengthBytes >= 2u ) )
  40861a:	6abb      	ldr	r3, [r7, #40]	; 0x28
  40861c:	2b01      	cmp	r3, #1
  40861e:	d002      	beq.n	408626 <usGenerateChecksum+0x62>
  408620:	6abb      	ldr	r3, [r7, #40]	; 0x28
  408622:	2b02      	cmp	r3, #2
  408624:	d10d      	bne.n	408642 <usGenerateChecksum+0x7e>
  408626:	687b      	ldr	r3, [r7, #4]
  408628:	2b01      	cmp	r3, #1
  40862a:	d90a      	bls.n	408642 <usGenerateChecksum+0x7e>
	{
		xSum.u32 += *(xSource.u16ptr);
  40862c:	6a3b      	ldr	r3, [r7, #32]
  40862e:	69ba      	ldr	r2, [r7, #24]
  408630:	8812      	ldrh	r2, [r2, #0]
  408632:	4413      	add	r3, r2
  408634:	623b      	str	r3, [r7, #32]
		( xSource.u16ptr )++;
  408636:	69bb      	ldr	r3, [r7, #24]
  408638:	3302      	adds	r3, #2
  40863a:	61bb      	str	r3, [r7, #24]
		uxDataLengthBytes -= 2u;
  40863c:	687b      	ldr	r3, [r7, #4]
  40863e:	3b02      	subs	r3, #2
  408640:	607b      	str	r3, [r7, #4]
		/* Now xSource is word (32-bit) aligned. */
	}

	/* Word (32-bit) aligned, do the most part. */
	xLastSource.u32ptr = ( xSource.u32ptr + ( uxDataLengthBytes / 4u ) ) - 3u;
  408642:	69ba      	ldr	r2, [r7, #24]
  408644:	687b      	ldr	r3, [r7, #4]
  408646:	f023 0303 	bic.w	r3, r3, #3
  40864a:	3b0c      	subs	r3, #12
  40864c:	4413      	add	r3, r2
  40864e:	617b      	str	r3, [r7, #20]

	/* In this loop, four 32-bit additions will be done, in total 16 bytes.
	Indexing with constants (0,1,2,3) gives faster code than using
	post-increments. */
	while( xSource.u32ptr < xLastSource.u32ptr )
  408650:	e035      	b.n	4086be <usGenerateChecksum+0xfa>
	{
		/* Use a secondary Sum2, just to see if the addition produced an
		overflow. */
		xSum2.u32 = xSum.u32 + xSource.u32ptr[ 0 ];
  408652:	6a3a      	ldr	r2, [r7, #32]
  408654:	69bb      	ldr	r3, [r7, #24]
  408656:	681b      	ldr	r3, [r3, #0]
  408658:	4413      	add	r3, r2
  40865a:	627b      	str	r3, [r7, #36]	; 0x24
		if( xSum2.u32 < xSum.u32 )
  40865c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  40865e:	6a3b      	ldr	r3, [r7, #32]
  408660:	429a      	cmp	r2, r3
  408662:	d202      	bcs.n	40866a <usGenerateChecksum+0xa6>
		{
			ulCarry++;
  408664:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  408666:	3301      	adds	r3, #1
  408668:	62fb      	str	r3, [r7, #44]	; 0x2c
		}

		/* Now add the secondary sum to the major sum, and remember if there was
		a carry. */
		xSum.u32 = xSum2.u32 + xSource.u32ptr[ 1 ];
  40866a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  40866c:	69bb      	ldr	r3, [r7, #24]
  40866e:	3304      	adds	r3, #4
  408670:	681b      	ldr	r3, [r3, #0]
  408672:	4413      	add	r3, r2
  408674:	623b      	str	r3, [r7, #32]
		if( xSum2.u32 > xSum.u32 )
  408676:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  408678:	6a3b      	ldr	r3, [r7, #32]
  40867a:	429a      	cmp	r2, r3
  40867c:	d902      	bls.n	408684 <usGenerateChecksum+0xc0>
		{
			ulCarry++;
  40867e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  408680:	3301      	adds	r3, #1
  408682:	62fb      	str	r3, [r7, #44]	; 0x2c
		}

		/* And do the same trick once again for indexes 2 and 3 */
		xSum2.u32 = xSum.u32 + xSource.u32ptr[ 2 ];
  408684:	6a3a      	ldr	r2, [r7, #32]
  408686:	69bb      	ldr	r3, [r7, #24]
  408688:	3308      	adds	r3, #8
  40868a:	681b      	ldr	r3, [r3, #0]
  40868c:	4413      	add	r3, r2
  40868e:	627b      	str	r3, [r7, #36]	; 0x24
		if( xSum2.u32 < xSum.u32 )
  408690:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  408692:	6a3b      	ldr	r3, [r7, #32]
  408694:	429a      	cmp	r2, r3
  408696:	d202      	bcs.n	40869e <usGenerateChecksum+0xda>
		{
			ulCarry++;
  408698:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40869a:	3301      	adds	r3, #1
  40869c:	62fb      	str	r3, [r7, #44]	; 0x2c
		}

		xSum.u32 = xSum2.u32 + xSource.u32ptr[ 3 ];
  40869e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  4086a0:	69bb      	ldr	r3, [r7, #24]
  4086a2:	330c      	adds	r3, #12
  4086a4:	681b      	ldr	r3, [r3, #0]
  4086a6:	4413      	add	r3, r2
  4086a8:	623b      	str	r3, [r7, #32]

		if( xSum2.u32 > xSum.u32 )
  4086aa:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  4086ac:	6a3b      	ldr	r3, [r7, #32]
  4086ae:	429a      	cmp	r2, r3
  4086b0:	d902      	bls.n	4086b8 <usGenerateChecksum+0xf4>
		{
			ulCarry++;
  4086b2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  4086b4:	3301      	adds	r3, #1
  4086b6:	62fb      	str	r3, [r7, #44]	; 0x2c
		}

		/* And finally advance the pointer 4 * 4 = 16 bytes. */
		xSource.u32ptr += 4;
  4086b8:	69bb      	ldr	r3, [r7, #24]
  4086ba:	3310      	adds	r3, #16
  4086bc:	61bb      	str	r3, [r7, #24]
	while( xSource.u32ptr < xLastSource.u32ptr )
  4086be:	69ba      	ldr	r2, [r7, #24]
  4086c0:	697b      	ldr	r3, [r7, #20]
  4086c2:	429a      	cmp	r2, r3
  4086c4:	d3c5      	bcc.n	408652 <usGenerateChecksum+0x8e>
	}

	/* Now add all carries. */
	xSum.u32 = ( uint32_t )xSum.u16[ 0 ] + xSum.u16[ 1 ] + ulCarry;
  4086c6:	8c3b      	ldrh	r3, [r7, #32]
  4086c8:	461a      	mov	r2, r3
  4086ca:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
  4086cc:	441a      	add	r2, r3
  4086ce:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  4086d0:	4413      	add	r3, r2
  4086d2:	623b      	str	r3, [r7, #32]

	uxDataLengthBytes %= 16u;
  4086d4:	687b      	ldr	r3, [r7, #4]
  4086d6:	f003 030f 	and.w	r3, r3, #15
  4086da:	607b      	str	r3, [r7, #4]
	xLastSource.u8ptr = ( uint8_t * ) ( xSource.u8ptr + ( uxDataLengthBytes & ~( ( size_t ) 1 ) ) );
  4086dc:	69ba      	ldr	r2, [r7, #24]
  4086de:	687b      	ldr	r3, [r7, #4]
  4086e0:	f023 0301 	bic.w	r3, r3, #1
  4086e4:	4413      	add	r3, r2
  4086e6:	617b      	str	r3, [r7, #20]

	/* Half-word aligned. */
	while( xSource.u16ptr < xLastSource.u16ptr )
  4086e8:	e007      	b.n	4086fa <usGenerateChecksum+0x136>
	{
		/* At least one more short. */
		xSum.u32 += xSource.u16ptr[ 0 ];
  4086ea:	6a3b      	ldr	r3, [r7, #32]
  4086ec:	69ba      	ldr	r2, [r7, #24]
  4086ee:	8812      	ldrh	r2, [r2, #0]
  4086f0:	4413      	add	r3, r2
  4086f2:	623b      	str	r3, [r7, #32]
		xSource.u16ptr++;
  4086f4:	69bb      	ldr	r3, [r7, #24]
  4086f6:	3302      	adds	r3, #2
  4086f8:	61bb      	str	r3, [r7, #24]
	while( xSource.u16ptr < xLastSource.u16ptr )
  4086fa:	69ba      	ldr	r2, [r7, #24]
  4086fc:	697b      	ldr	r3, [r7, #20]
  4086fe:	429a      	cmp	r2, r3
  408700:	d3f3      	bcc.n	4086ea <usGenerateChecksum+0x126>
	}

	if( ( uxDataLengthBytes & ( size_t ) 1 ) != 0u )	/* Maybe one more ? */
  408702:	687b      	ldr	r3, [r7, #4]
  408704:	f003 0301 	and.w	r3, r3, #1
  408708:	2b00      	cmp	r3, #0
  40870a:	d002      	beq.n	408712 <usGenerateChecksum+0x14e>
	{
		xTerm.u8[ 0 ] = xSource.u8ptr[ 0 ];
  40870c:	69bb      	ldr	r3, [r7, #24]
  40870e:	781b      	ldrb	r3, [r3, #0]
  408710:	773b      	strb	r3, [r7, #28]
	}
	xSum.u32 += xTerm.u32;
  408712:	6a3a      	ldr	r2, [r7, #32]
  408714:	69fb      	ldr	r3, [r7, #28]
  408716:	4413      	add	r3, r2
  408718:	623b      	str	r3, [r7, #32]

	/* Now add all carries again. */
	xSum.u32 = ( uint32_t ) xSum.u16[ 0 ] + xSum.u16[ 1 ];
  40871a:	8c3b      	ldrh	r3, [r7, #32]
  40871c:	461a      	mov	r2, r3
  40871e:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
  408720:	4413      	add	r3, r2
  408722:	623b      	str	r3, [r7, #32]

	/* The previous summation might have given a 16-bit carry. */
	xSum.u32 = ( uint32_t ) xSum.u16[ 0 ] + xSum.u16[ 1 ];
  408724:	8c3b      	ldrh	r3, [r7, #32]
  408726:	461a      	mov	r2, r3
  408728:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
  40872a:	4413      	add	r3, r2
  40872c:	623b      	str	r3, [r7, #32]

	if( ( ulAlignBits & 1u ) != 0u )
  40872e:	6abb      	ldr	r3, [r7, #40]	; 0x28
  408730:	f003 0301 	and.w	r3, r3, #1
  408734:	2b00      	cmp	r3, #0
  408736:	d007      	beq.n	408748 <usGenerateChecksum+0x184>
	{
		/* Quite unlikely, but pucNextData might be non-aligned, which would
		 mean that a checksum is calculated starting at an odd position. */
		xSum.u32 = ( ( xSum.u32 & 0xffu ) << 8 ) | ( ( xSum.u32 & 0xff00u ) >> 8 );
  408738:	6a3b      	ldr	r3, [r7, #32]
  40873a:	021b      	lsls	r3, r3, #8
  40873c:	b29a      	uxth	r2, r3
  40873e:	6a3b      	ldr	r3, [r7, #32]
  408740:	0a1b      	lsrs	r3, r3, #8
  408742:	b2db      	uxtb	r3, r3
  408744:	4313      	orrs	r3, r2
  408746:	623b      	str	r3, [r7, #32]
	}

	/* swap the output (little endian platform only). */
	return FreeRTOS_htons( ( (uint16_t) xSum.u32 ) );
  408748:	6a3b      	ldr	r3, [r7, #32]
  40874a:	b29b      	uxth	r3, r3
  40874c:	021b      	lsls	r3, r3, #8
  40874e:	b21a      	sxth	r2, r3
  408750:	6a3b      	ldr	r3, [r7, #32]
  408752:	b29b      	uxth	r3, r3
  408754:	0a1b      	lsrs	r3, r3, #8
  408756:	b29b      	uxth	r3, r3
  408758:	b21b      	sxth	r3, r3
  40875a:	4313      	orrs	r3, r2
  40875c:	b21b      	sxth	r3, r3
  40875e:	b29b      	uxth	r3, r3
}
  408760:	4618      	mov	r0, r3
  408762:	3734      	adds	r7, #52	; 0x34
  408764:	46bd      	mov	sp, r7
  408766:	f85d 7b04 	ldr.w	r7, [sp], #4
  40876a:	4770      	bx	lr

0040876c <vReturnEthernetFrame>:
/*-----------------------------------------------------------*/

void vReturnEthernetFrame( NetworkBufferDescriptor_t * pxNetworkBuffer, BaseType_t xReleaseAfterSend )
{
  40876c:	b580      	push	{r7, lr}
  40876e:	b084      	sub	sp, #16
  408770:	af00      	add	r7, sp, #0
  408772:	6078      	str	r0, [r7, #4]
  408774:	6039      	str	r1, [r7, #0]
	}

	if( pxNetworkBuffer != NULL )
#endif
	{
		pxEthernetHeader = ( EthernetHeader_t * ) ( pxNetworkBuffer->pucEthernetBuffer );
  408776:	687b      	ldr	r3, [r7, #4]
  408778:	699b      	ldr	r3, [r3, #24]
  40877a:	60fb      	str	r3, [r7, #12]

		/* Swap source and destination MAC addresses. */
		memcpy( ( void * ) &( pxEthernetHeader->xDestinationAddress ), ( void * ) &( pxEthernetHeader->xSourceAddress ), sizeof( pxEthernetHeader->xDestinationAddress ) );
  40877c:	68f8      	ldr	r0, [r7, #12]
  40877e:	68fb      	ldr	r3, [r7, #12]
  408780:	3306      	adds	r3, #6
  408782:	2206      	movs	r2, #6
  408784:	4619      	mov	r1, r3
  408786:	4b08      	ldr	r3, [pc, #32]	; (4087a8 <vReturnEthernetFrame+0x3c>)
  408788:	4798      	blx	r3
		memcpy( ( void * ) &( pxEthernetHeader->xSourceAddress) , ( void * ) ipLOCAL_MAC_ADDRESS, ( size_t ) ipMAC_ADDRESS_LENGTH_BYTES );
  40878a:	68fb      	ldr	r3, [r7, #12]
  40878c:	3306      	adds	r3, #6
  40878e:	2206      	movs	r2, #6
  408790:	4906      	ldr	r1, [pc, #24]	; (4087ac <vReturnEthernetFrame+0x40>)
  408792:	4618      	mov	r0, r3
  408794:	4b04      	ldr	r3, [pc, #16]	; (4087a8 <vReturnEthernetFrame+0x3c>)
  408796:	4798      	blx	r3

		/* Send! */
		xNetworkInterfaceOutput( pxNetworkBuffer, xReleaseAfterSend );
  408798:	6839      	ldr	r1, [r7, #0]
  40879a:	6878      	ldr	r0, [r7, #4]
  40879c:	4b04      	ldr	r3, [pc, #16]	; (4087b0 <vReturnEthernetFrame+0x44>)
  40879e:	4798      	blx	r3
	}
}
  4087a0:	bf00      	nop
  4087a2:	3710      	adds	r7, #16
  4087a4:	46bd      	mov	sp, r7
  4087a6:	bd80      	pop	{r7, pc}
  4087a8:	00416d05 	.word	0x00416d05
  4087ac:	20000108 	.word	0x20000108
  4087b0:	004102dd 	.word	0x004102dd

004087b4 <xIPIsNetworkTaskReady>:
	}
#endif /* ipconfigDNS_USE_CALLBACKS != 0 */
/*-----------------------------------------------------------*/

BaseType_t xIPIsNetworkTaskReady( void )
{
  4087b4:	b480      	push	{r7}
  4087b6:	af00      	add	r7, sp, #0
	return xIPTaskInitialised;
  4087b8:	4b03      	ldr	r3, [pc, #12]	; (4087c8 <xIPIsNetworkTaskReady+0x14>)
  4087ba:	681b      	ldr	r3, [r3, #0]
}
  4087bc:	4618      	mov	r0, r3
  4087be:	46bd      	mov	sp, r7
  4087c0:	f85d 7b04 	ldr.w	r7, [sp], #4
  4087c4:	4770      	bx	lr
  4087c6:	bf00      	nop
  4087c8:	20006d30 	.word	0x20006d30

004087cc <uxGetMinimumIPQueueSpace>:
}
/*-----------------------------------------------------------*/

#if( ipconfigCHECK_IP_QUEUE_SPACE != 0 )
	UBaseType_t uxGetMinimumIPQueueSpace( void )
	{
  4087cc:	b480      	push	{r7}
  4087ce:	af00      	add	r7, sp, #0
		return uxQueueMinimumSpace;
  4087d0:	4b03      	ldr	r3, [pc, #12]	; (4087e0 <uxGetMinimumIPQueueSpace+0x14>)
  4087d2:	681b      	ldr	r3, [r3, #0]
	}
  4087d4:	4618      	mov	r0, r3
  4087d6:	46bd      	mov	sp, r7
  4087d8:	f85d 7b04 	ldr.w	r7, [sp], #4
  4087dc:	4770      	bx	lr
  4087de:	bf00      	nop
  4087e0:	200000cc 	.word	0x200000cc

004087e4 <FreeRTOS_max_uint32>:
	static portINLINE UBaseType_t FreeRTOS_max_UBaseType (UBaseType_t a, UBaseType_t b);
	static portINLINE UBaseType_t  	FreeRTOS_min_UBaseType (UBaseType_t  a, UBaseType_t  b);


	static portINLINE int32_t  FreeRTOS_max_int32  (int32_t  a, int32_t  b) { return a >= b ? a : b; }
	static portINLINE uint32_t FreeRTOS_max_uint32 (uint32_t a, uint32_t b) { return a >= b ? a : b; }
  4087e4:	b480      	push	{r7}
  4087e6:	b083      	sub	sp, #12
  4087e8:	af00      	add	r7, sp, #0
  4087ea:	6078      	str	r0, [r7, #4]
  4087ec:	6039      	str	r1, [r7, #0]
  4087ee:	687a      	ldr	r2, [r7, #4]
  4087f0:	683b      	ldr	r3, [r7, #0]
  4087f2:	4293      	cmp	r3, r2
  4087f4:	bf38      	it	cc
  4087f6:	4613      	movcc	r3, r2
  4087f8:	4618      	mov	r0, r3
  4087fa:	370c      	adds	r7, #12
  4087fc:	46bd      	mov	sp, r7
  4087fe:	f85d 7b04 	ldr.w	r7, [sp], #4
  408802:	4770      	bx	lr

00408804 <FreeRTOS_min_uint32>:
	static portINLINE int32_t  FreeRTOS_min_int32  (int32_t  a, int32_t  b) { return a <= b ? a : b; }
	static portINLINE uint32_t FreeRTOS_min_uint32 (uint32_t a, uint32_t b) { return a <= b ? a : b; }
  408804:	b480      	push	{r7}
  408806:	b083      	sub	sp, #12
  408808:	af00      	add	r7, sp, #0
  40880a:	6078      	str	r0, [r7, #4]
  40880c:	6039      	str	r1, [r7, #0]
  40880e:	687a      	ldr	r2, [r7, #4]
  408810:	683b      	ldr	r3, [r7, #0]
  408812:	4293      	cmp	r3, r2
  408814:	bf28      	it	cs
  408816:	4613      	movcs	r3, r2
  408818:	4618      	mov	r0, r3
  40881a:	370c      	adds	r7, #12
  40881c:	46bd      	mov	sp, r7
  40881e:	f85d 7b04 	ldr.w	r7, [sp], #4
  408822:	4770      	bx	lr

00408824 <FreeRTOS_round_up>:
	static portINLINE uint32_t FreeRTOS_round_up   (uint32_t a, uint32_t d) { return d * ( ( a + d - 1u ) / d ); }
  408824:	b480      	push	{r7}
  408826:	b083      	sub	sp, #12
  408828:	af00      	add	r7, sp, #0
  40882a:	6078      	str	r0, [r7, #4]
  40882c:	6039      	str	r1, [r7, #0]
  40882e:	687a      	ldr	r2, [r7, #4]
  408830:	683b      	ldr	r3, [r7, #0]
  408832:	4413      	add	r3, r2
  408834:	1e5a      	subs	r2, r3, #1
  408836:	683b      	ldr	r3, [r7, #0]
  408838:	fbb2 f3f3 	udiv	r3, r2, r3
  40883c:	683a      	ldr	r2, [r7, #0]
  40883e:	fb02 f303 	mul.w	r3, r2, r3
  408842:	4618      	mov	r0, r3
  408844:	370c      	adds	r7, #12
  408846:	46bd      	mov	sp, r7
  408848:	f85d 7b04 	ldr.w	r7, [sp], #4
  40884c:	4770      	bx	lr

0040884e <uxStreamBufferSpace>:
}
/*-----------------------------------------------------------*/

static portINLINE size_t uxStreamBufferSpace( const StreamBuffer_t *pxBuffer, const size_t uxLower, const size_t uxUpper );
static portINLINE size_t uxStreamBufferSpace( const StreamBuffer_t *pxBuffer, const size_t uxLower, const size_t uxUpper )
{
  40884e:	b480      	push	{r7}
  408850:	b087      	sub	sp, #28
  408852:	af00      	add	r7, sp, #0
  408854:	60f8      	str	r0, [r7, #12]
  408856:	60b9      	str	r1, [r7, #8]
  408858:	607a      	str	r2, [r7, #4]
/* Returns the space between uxLower and uxUpper, which equals to the distance minus 1 */
size_t uxCount;

	uxCount = pxBuffer->LENGTH + uxUpper - uxLower - 1u;
  40885a:	68fb      	ldr	r3, [r7, #12]
  40885c:	691a      	ldr	r2, [r3, #16]
  40885e:	687b      	ldr	r3, [r7, #4]
  408860:	441a      	add	r2, r3
  408862:	68bb      	ldr	r3, [r7, #8]
  408864:	1ad3      	subs	r3, r2, r3
  408866:	3b01      	subs	r3, #1
  408868:	617b      	str	r3, [r7, #20]
	if( uxCount >= pxBuffer->LENGTH )
  40886a:	68fb      	ldr	r3, [r7, #12]
  40886c:	691a      	ldr	r2, [r3, #16]
  40886e:	697b      	ldr	r3, [r7, #20]
  408870:	429a      	cmp	r2, r3
  408872:	d804      	bhi.n	40887e <uxStreamBufferSpace+0x30>
	{
		uxCount -= pxBuffer->LENGTH;
  408874:	68fb      	ldr	r3, [r7, #12]
  408876:	691b      	ldr	r3, [r3, #16]
  408878:	697a      	ldr	r2, [r7, #20]
  40887a:	1ad3      	subs	r3, r2, r3
  40887c:	617b      	str	r3, [r7, #20]
	}

	return uxCount;
  40887e:	697b      	ldr	r3, [r7, #20]
}
  408880:	4618      	mov	r0, r3
  408882:	371c      	adds	r7, #28
  408884:	46bd      	mov	sp, r7
  408886:	f85d 7b04 	ldr.w	r7, [sp], #4
  40888a:	4770      	bx	lr

0040888c <uxStreamBufferDistance>:
/*-----------------------------------------------------------*/

static portINLINE size_t uxStreamBufferDistance( const StreamBuffer_t *pxBuffer, const size_t uxLower, const size_t uxUpper );
static portINLINE size_t uxStreamBufferDistance( const StreamBuffer_t *pxBuffer, const size_t uxLower, const size_t uxUpper )
{
  40888c:	b480      	push	{r7}
  40888e:	b087      	sub	sp, #28
  408890:	af00      	add	r7, sp, #0
  408892:	60f8      	str	r0, [r7, #12]
  408894:	60b9      	str	r1, [r7, #8]
  408896:	607a      	str	r2, [r7, #4]
/* Returns the distance between uxLower and uxUpper */
size_t uxCount;

	uxCount = pxBuffer->LENGTH + uxUpper - uxLower;
  408898:	68fb      	ldr	r3, [r7, #12]
  40889a:	691a      	ldr	r2, [r3, #16]
  40889c:	687b      	ldr	r3, [r7, #4]
  40889e:	441a      	add	r2, r3
  4088a0:	68bb      	ldr	r3, [r7, #8]
  4088a2:	1ad3      	subs	r3, r2, r3
  4088a4:	617b      	str	r3, [r7, #20]
	if ( uxCount >= pxBuffer->LENGTH )
  4088a6:	68fb      	ldr	r3, [r7, #12]
  4088a8:	691a      	ldr	r2, [r3, #16]
  4088aa:	697b      	ldr	r3, [r7, #20]
  4088ac:	429a      	cmp	r2, r3
  4088ae:	d804      	bhi.n	4088ba <uxStreamBufferDistance+0x2e>
	{
		uxCount -= pxBuffer->LENGTH;
  4088b0:	68fb      	ldr	r3, [r7, #12]
  4088b2:	691b      	ldr	r3, [r3, #16]
  4088b4:	697a      	ldr	r2, [r7, #20]
  4088b6:	1ad3      	subs	r3, r2, r3
  4088b8:	617b      	str	r3, [r7, #20]
	}

	return uxCount;
  4088ba:	697b      	ldr	r3, [r7, #20]
}
  4088bc:	4618      	mov	r0, r3
  4088be:	371c      	adds	r7, #28
  4088c0:	46bd      	mov	sp, r7
  4088c2:	f85d 7b04 	ldr.w	r7, [sp], #4
  4088c6:	4770      	bx	lr

004088c8 <uxStreamBufferGetSpace>:
/*-----------------------------------------------------------*/

static portINLINE size_t uxStreamBufferGetSpace( const StreamBuffer_t *pxBuffer );
static portINLINE size_t uxStreamBufferGetSpace( const StreamBuffer_t *pxBuffer )
{
  4088c8:	b580      	push	{r7, lr}
  4088ca:	b084      	sub	sp, #16
  4088cc:	af00      	add	r7, sp, #0
  4088ce:	6078      	str	r0, [r7, #4]
/* Returns the number of items which can still be added to uxHead
before hitting on uxTail */
size_t uxHead = pxBuffer->uxHead;
  4088d0:	687b      	ldr	r3, [r7, #4]
  4088d2:	689b      	ldr	r3, [r3, #8]
  4088d4:	60fb      	str	r3, [r7, #12]
size_t uxTail = pxBuffer->uxTail;
  4088d6:	687b      	ldr	r3, [r7, #4]
  4088d8:	681b      	ldr	r3, [r3, #0]
  4088da:	60bb      	str	r3, [r7, #8]

	return uxStreamBufferSpace( pxBuffer, uxHead, uxTail );
  4088dc:	68ba      	ldr	r2, [r7, #8]
  4088de:	68f9      	ldr	r1, [r7, #12]
  4088e0:	6878      	ldr	r0, [r7, #4]
  4088e2:	4b03      	ldr	r3, [pc, #12]	; (4088f0 <uxStreamBufferGetSpace+0x28>)
  4088e4:	4798      	blx	r3
  4088e6:	4603      	mov	r3, r0
}
  4088e8:	4618      	mov	r0, r3
  4088ea:	3710      	adds	r7, #16
  4088ec:	46bd      	mov	sp, r7
  4088ee:	bd80      	pop	{r7, pc}
  4088f0:	0040884f 	.word	0x0040884f

004088f4 <uxStreamBufferFrontSpace>:
/*-----------------------------------------------------------*/

static portINLINE size_t uxStreamBufferFrontSpace( const StreamBuffer_t *pxBuffer );
static portINLINE size_t uxStreamBufferFrontSpace( const StreamBuffer_t *pxBuffer )
{
  4088f4:	b580      	push	{r7, lr}
  4088f6:	b084      	sub	sp, #16
  4088f8:	af00      	add	r7, sp, #0
  4088fa:	6078      	str	r0, [r7, #4]
/* Distance between uxFront and uxTail
or the number of items which can still be added to uxFront,
before hitting on uxTail */

size_t uxFront = pxBuffer->uxFront;
  4088fc:	687b      	ldr	r3, [r7, #4]
  4088fe:	68db      	ldr	r3, [r3, #12]
  408900:	60fb      	str	r3, [r7, #12]
size_t uxTail = pxBuffer->uxTail;
  408902:	687b      	ldr	r3, [r7, #4]
  408904:	681b      	ldr	r3, [r3, #0]
  408906:	60bb      	str	r3, [r7, #8]

	return uxStreamBufferSpace( pxBuffer, uxFront, uxTail );
  408908:	68ba      	ldr	r2, [r7, #8]
  40890a:	68f9      	ldr	r1, [r7, #12]
  40890c:	6878      	ldr	r0, [r7, #4]
  40890e:	4b03      	ldr	r3, [pc, #12]	; (40891c <uxStreamBufferFrontSpace+0x28>)
  408910:	4798      	blx	r3
  408912:	4603      	mov	r3, r0
}
  408914:	4618      	mov	r0, r3
  408916:	3710      	adds	r7, #16
  408918:	46bd      	mov	sp, r7
  40891a:	bd80      	pop	{r7, pc}
  40891c:	0040884f 	.word	0x0040884f

00408920 <uxStreamBufferGetSize>:
/*-----------------------------------------------------------*/

static portINLINE size_t uxStreamBufferGetSize( const StreamBuffer_t *pxBuffer );
static portINLINE size_t uxStreamBufferGetSize( const StreamBuffer_t *pxBuffer )
{
  408920:	b580      	push	{r7, lr}
  408922:	b084      	sub	sp, #16
  408924:	af00      	add	r7, sp, #0
  408926:	6078      	str	r0, [r7, #4]
/* Returns the number of items which can be read from uxTail
before reaching uxHead */
size_t uxHead = pxBuffer->uxHead;
  408928:	687b      	ldr	r3, [r7, #4]
  40892a:	689b      	ldr	r3, [r3, #8]
  40892c:	60fb      	str	r3, [r7, #12]
size_t uxTail = pxBuffer->uxTail;
  40892e:	687b      	ldr	r3, [r7, #4]
  408930:	681b      	ldr	r3, [r3, #0]
  408932:	60bb      	str	r3, [r7, #8]

	return uxStreamBufferDistance( pxBuffer, uxTail, uxHead );
  408934:	68fa      	ldr	r2, [r7, #12]
  408936:	68b9      	ldr	r1, [r7, #8]
  408938:	6878      	ldr	r0, [r7, #4]
  40893a:	4b03      	ldr	r3, [pc, #12]	; (408948 <uxStreamBufferGetSize+0x28>)
  40893c:	4798      	blx	r3
  40893e:	4603      	mov	r3, r0
}
  408940:	4618      	mov	r0, r3
  408942:	3710      	adds	r7, #16
  408944:	46bd      	mov	sp, r7
  408946:	bd80      	pop	{r7, pc}
  408948:	0040888d 	.word	0x0040888d

0040894c <uxStreamBufferGetPtr>:
}
/*-----------------------------------------------------------*/

static portINLINE size_t uxStreamBufferGetPtr( StreamBuffer_t *pxBuffer, uint8_t **ppucData );
static portINLINE size_t uxStreamBufferGetPtr( StreamBuffer_t *pxBuffer, uint8_t **ppucData )
{
  40894c:	b580      	push	{r7, lr}
  40894e:	b084      	sub	sp, #16
  408950:	af00      	add	r7, sp, #0
  408952:	6078      	str	r0, [r7, #4]
  408954:	6039      	str	r1, [r7, #0]
size_t uxNextTail = pxBuffer->uxTail;
  408956:	687b      	ldr	r3, [r7, #4]
  408958:	681b      	ldr	r3, [r3, #0]
  40895a:	60fb      	str	r3, [r7, #12]
size_t uxSize = uxStreamBufferGetSize( pxBuffer );
  40895c:	6878      	ldr	r0, [r7, #4]
  40895e:	4b0b      	ldr	r3, [pc, #44]	; (40898c <uxStreamBufferGetPtr+0x40>)
  408960:	4798      	blx	r3
  408962:	60b8      	str	r0, [r7, #8]

	*ppucData = pxBuffer->ucArray + uxNextTail;
  408964:	687b      	ldr	r3, [r7, #4]
  408966:	f103 0214 	add.w	r2, r3, #20
  40896a:	68fb      	ldr	r3, [r7, #12]
  40896c:	441a      	add	r2, r3
  40896e:	683b      	ldr	r3, [r7, #0]
  408970:	601a      	str	r2, [r3, #0]

	return FreeRTOS_min_uint32( uxSize, pxBuffer->LENGTH - uxNextTail );
  408972:	687b      	ldr	r3, [r7, #4]
  408974:	691a      	ldr	r2, [r3, #16]
  408976:	68fb      	ldr	r3, [r7, #12]
  408978:	1ad3      	subs	r3, r2, r3
  40897a:	4619      	mov	r1, r3
  40897c:	68b8      	ldr	r0, [r7, #8]
  40897e:	4b04      	ldr	r3, [pc, #16]	; (408990 <uxStreamBufferGetPtr+0x44>)
  408980:	4798      	blx	r3
  408982:	4603      	mov	r3, r0
}
  408984:	4618      	mov	r0, r3
  408986:	3710      	adds	r7, #16
  408988:	46bd      	mov	sp, r7
  40898a:	bd80      	pop	{r7, pc}
  40898c:	00408921 	.word	0x00408921
  408990:	00408805 	.word	0x00408805

00408994 <prvValidSocket>:
#endif /* ipconfigUSE_TCP == 1 */

/*-----------------------------------------------------------*/

static BaseType_t prvValidSocket( FreeRTOS_Socket_t *pxSocket, BaseType_t xProtocol, BaseType_t xIsBound )
{
  408994:	b480      	push	{r7}
  408996:	b087      	sub	sp, #28
  408998:	af00      	add	r7, sp, #0
  40899a:	60f8      	str	r0, [r7, #12]
  40899c:	60b9      	str	r1, [r7, #8]
  40899e:	607a      	str	r2, [r7, #4]
BaseType_t xReturn = pdTRUE;
  4089a0:	2301      	movs	r3, #1
  4089a2:	617b      	str	r3, [r7, #20]

	if( ( pxSocket == NULL ) || ( pxSocket == FREERTOS_INVALID_SOCKET ) )
  4089a4:	68fb      	ldr	r3, [r7, #12]
  4089a6:	2b00      	cmp	r3, #0
  4089a8:	d003      	beq.n	4089b2 <prvValidSocket+0x1e>
  4089aa:	68fb      	ldr	r3, [r7, #12]
  4089ac:	f1b3 3fff 	cmp.w	r3, #4294967295
  4089b0:	d102      	bne.n	4089b8 <prvValidSocket+0x24>
	{
		xReturn = pdFALSE;
  4089b2:	2300      	movs	r3, #0
  4089b4:	617b      	str	r3, [r7, #20]
  4089b6:	e012      	b.n	4089de <prvValidSocket+0x4a>
	}
	else if( ( xIsBound != pdFALSE ) && ( socketSOCKET_IS_BOUND( pxSocket ) == pdFALSE ) )
  4089b8:	687b      	ldr	r3, [r7, #4]
  4089ba:	2b00      	cmp	r3, #0
  4089bc:	d006      	beq.n	4089cc <prvValidSocket+0x38>
  4089be:	68fb      	ldr	r3, [r7, #12]
  4089c0:	699b      	ldr	r3, [r3, #24]
  4089c2:	2b00      	cmp	r3, #0
  4089c4:	d102      	bne.n	4089cc <prvValidSocket+0x38>
	{
		/* The caller expects the socket to be bound, but it isn't. */
		xReturn = pdFALSE;
  4089c6:	2300      	movs	r3, #0
  4089c8:	617b      	str	r3, [r7, #20]
  4089ca:	e008      	b.n	4089de <prvValidSocket+0x4a>
	}
	else if( pxSocket->ucProtocol != ( uint8_t ) xProtocol )
  4089cc:	68fb      	ldr	r3, [r7, #12]
  4089ce:	f893 2027 	ldrb.w	r2, [r3, #39]	; 0x27
  4089d2:	68bb      	ldr	r3, [r7, #8]
  4089d4:	b2db      	uxtb	r3, r3
  4089d6:	429a      	cmp	r2, r3
  4089d8:	d001      	beq.n	4089de <prvValidSocket+0x4a>
	{
		/* Socket has a wrong type (UDP != TCP). */
		xReturn = pdFALSE;
  4089da:	2300      	movs	r3, #0
  4089dc:	617b      	str	r3, [r7, #20]
	}

	return xReturn;
  4089de:	697b      	ldr	r3, [r7, #20]
}
  4089e0:	4618      	mov	r0, r3
  4089e2:	371c      	adds	r7, #28
  4089e4:	46bd      	mov	sp, r7
  4089e6:	f85d 7b04 	ldr.w	r7, [sp], #4
  4089ea:	4770      	bx	lr

004089ec <vNetworkSocketsInit>:
/*-----------------------------------------------------------*/

BaseType_t vNetworkSocketsInit( void )
{
  4089ec:	b580      	push	{r7, lr}
  4089ee:	af00      	add	r7, sp, #0
	vListInitialise( &xBoundUDPSocketsList );
  4089f0:	4804      	ldr	r0, [pc, #16]	; (408a04 <vNetworkSocketsInit+0x18>)
  4089f2:	4b05      	ldr	r3, [pc, #20]	; (408a08 <vNetworkSocketsInit+0x1c>)
  4089f4:	4798      	blx	r3

	#if( ipconfigUSE_TCP == 1 )
	{
		vListInitialise( &xBoundTCPSocketsList );
  4089f6:	4805      	ldr	r0, [pc, #20]	; (408a0c <vNetworkSocketsInit+0x20>)
  4089f8:	4b03      	ldr	r3, [pc, #12]	; (408a08 <vNetworkSocketsInit+0x1c>)
  4089fa:	4798      	blx	r3
	}
	#endif  /* ipconfigUSE_TCP == 1 */

	return pdTRUE;
  4089fc:	2301      	movs	r3, #1
}
  4089fe:	4618      	mov	r0, r3
  408a00:	bd80      	pop	{r7, pc}
  408a02:	bf00      	nop
  408a04:	2000b5c4 	.word	0x2000b5c4
  408a08:	00410ce1 	.word	0x00410ce1
  408a0c:	2000b5b0 	.word	0x2000b5b0

00408a10 <prvDetermineSocketSize>:
/*-----------------------------------------------------------*/

static BaseType_t prvDetermineSocketSize( BaseType_t xDomain, BaseType_t xType, BaseType_t xProtocol, size_t *pxSocketSize )
{
  408a10:	b580      	push	{r7, lr}
  408a12:	b086      	sub	sp, #24
  408a14:	af00      	add	r7, sp, #0
  408a16:	60f8      	str	r0, [r7, #12]
  408a18:	60b9      	str	r1, [r7, #8]
  408a1a:	607a      	str	r2, [r7, #4]
  408a1c:	603b      	str	r3, [r7, #0]
BaseType_t xReturn = pdPASS;
  408a1e:	2301      	movs	r3, #1
  408a20:	617b      	str	r3, [r7, #20]
FreeRTOS_Socket_t *pxSocket;

	/* Asserts must not appear before it has been determined that the network
	task is ready - otherwise the asserts will fail. */
	if( xIPIsNetworkTaskReady() == pdFALSE )
  408a22:	4b2e      	ldr	r3, [pc, #184]	; (408adc <prvDetermineSocketSize+0xcc>)
  408a24:	4798      	blx	r3
  408a26:	4603      	mov	r3, r0
  408a28:	2b00      	cmp	r3, #0
  408a2a:	d102      	bne.n	408a32 <prvDetermineSocketSize+0x22>
	{
		xReturn = pdFAIL;
  408a2c:	2300      	movs	r3, #0
  408a2e:	617b      	str	r3, [r7, #20]
  408a30:	e04f      	b.n	408ad2 <prvDetermineSocketSize+0xc2>
	}
	else
	{
		/* Only Ethernet is currently supported. */
		configASSERT( xDomain == FREERTOS_AF_INET );
  408a32:	68fb      	ldr	r3, [r7, #12]
  408a34:	2b02      	cmp	r3, #2
  408a36:	d004      	beq.n	408a42 <prvDetermineSocketSize+0x32>
  408a38:	22e2      	movs	r2, #226	; 0xe2
  408a3a:	4929      	ldr	r1, [pc, #164]	; (408ae0 <prvDetermineSocketSize+0xd0>)
  408a3c:	4829      	ldr	r0, [pc, #164]	; (408ae4 <prvDetermineSocketSize+0xd4>)
  408a3e:	4b2a      	ldr	r3, [pc, #168]	; (408ae8 <prvDetermineSocketSize+0xd8>)
  408a40:	4798      	blx	r3

		/* Check if the UDP socket-list has been initialised. */
		configASSERT( listLIST_IS_INITIALISED( &xBoundUDPSocketsList ) );
  408a42:	4b2a      	ldr	r3, [pc, #168]	; (408aec <prvDetermineSocketSize+0xdc>)
  408a44:	689b      	ldr	r3, [r3, #8]
  408a46:	f1b3 3fff 	cmp.w	r3, #4294967295
  408a4a:	d004      	beq.n	408a56 <prvDetermineSocketSize+0x46>
  408a4c:	22e5      	movs	r2, #229	; 0xe5
  408a4e:	4924      	ldr	r1, [pc, #144]	; (408ae0 <prvDetermineSocketSize+0xd0>)
  408a50:	4824      	ldr	r0, [pc, #144]	; (408ae4 <prvDetermineSocketSize+0xd4>)
  408a52:	4b25      	ldr	r3, [pc, #148]	; (408ae8 <prvDetermineSocketSize+0xd8>)
  408a54:	4798      	blx	r3
		#if( ipconfigUSE_TCP == 1 )
		{
			/* Check if the TCP socket-list has been initialised. */
			configASSERT( listLIST_IS_INITIALISED( &xBoundTCPSocketsList ) );
  408a56:	4b26      	ldr	r3, [pc, #152]	; (408af0 <prvDetermineSocketSize+0xe0>)
  408a58:	689b      	ldr	r3, [r3, #8]
  408a5a:	f1b3 3fff 	cmp.w	r3, #4294967295
  408a5e:	d004      	beq.n	408a6a <prvDetermineSocketSize+0x5a>
  408a60:	22e9      	movs	r2, #233	; 0xe9
  408a62:	491f      	ldr	r1, [pc, #124]	; (408ae0 <prvDetermineSocketSize+0xd0>)
  408a64:	481f      	ldr	r0, [pc, #124]	; (408ae4 <prvDetermineSocketSize+0xd4>)
  408a66:	4b20      	ldr	r3, [pc, #128]	; (408ae8 <prvDetermineSocketSize+0xd8>)
  408a68:	4798      	blx	r3
		}
		#endif  /* ipconfigUSE_TCP == 1 */

		if( xProtocol == FREERTOS_IPPROTO_UDP )
  408a6a:	687b      	ldr	r3, [r7, #4]
  408a6c:	2b11      	cmp	r3, #17
  408a6e:	d110      	bne.n	408a92 <prvDetermineSocketSize+0x82>
		{
			if( xType != FREERTOS_SOCK_DGRAM )
  408a70:	68bb      	ldr	r3, [r7, #8]
  408a72:	2b02      	cmp	r3, #2
  408a74:	d009      	beq.n	408a8a <prvDetermineSocketSize+0x7a>
			{
				xReturn = pdFAIL;
  408a76:	2300      	movs	r3, #0
  408a78:	617b      	str	r3, [r7, #20]
				configASSERT( xReturn );
  408a7a:	697b      	ldr	r3, [r7, #20]
  408a7c:	2b00      	cmp	r3, #0
  408a7e:	d104      	bne.n	408a8a <prvDetermineSocketSize+0x7a>
  408a80:	22f2      	movs	r2, #242	; 0xf2
  408a82:	4917      	ldr	r1, [pc, #92]	; (408ae0 <prvDetermineSocketSize+0xd0>)
  408a84:	4817      	ldr	r0, [pc, #92]	; (408ae4 <prvDetermineSocketSize+0xd4>)
  408a86:	4b18      	ldr	r3, [pc, #96]	; (408ae8 <prvDetermineSocketSize+0xd8>)
  408a88:	4798      	blx	r3
			}
			/* In case a UDP socket is created, do not allocate space for TCP data. */
			*pxSocketSize = ( sizeof( *pxSocket ) - sizeof( pxSocket->u ) ) + sizeof( pxSocket->u.xUDP );
  408a8a:	683b      	ldr	r3, [r7, #0]
  408a8c:	224c      	movs	r2, #76	; 0x4c
  408a8e:	601a      	str	r2, [r3, #0]
  408a90:	e01f      	b.n	408ad2 <prvDetermineSocketSize+0xc2>
		}
#if( ipconfigUSE_TCP == 1 )
		else if( xProtocol == FREERTOS_IPPROTO_TCP )
  408a92:	687b      	ldr	r3, [r7, #4]
  408a94:	2b06      	cmp	r3, #6
  408a96:	d111      	bne.n	408abc <prvDetermineSocketSize+0xac>
		{
			if( xType != FREERTOS_SOCK_STREAM )
  408a98:	68bb      	ldr	r3, [r7, #8]
  408a9a:	2b01      	cmp	r3, #1
  408a9c:	d009      	beq.n	408ab2 <prvDetermineSocketSize+0xa2>
			{
				xReturn = pdFAIL;
  408a9e:	2300      	movs	r3, #0
  408aa0:	617b      	str	r3, [r7, #20]
				configASSERT( xReturn );
  408aa2:	697b      	ldr	r3, [r7, #20]
  408aa4:	2b00      	cmp	r3, #0
  408aa6:	d104      	bne.n	408ab2 <prvDetermineSocketSize+0xa2>
  408aa8:	22fd      	movs	r2, #253	; 0xfd
  408aaa:	490d      	ldr	r1, [pc, #52]	; (408ae0 <prvDetermineSocketSize+0xd0>)
  408aac:	480d      	ldr	r0, [pc, #52]	; (408ae4 <prvDetermineSocketSize+0xd4>)
  408aae:	4b0e      	ldr	r3, [pc, #56]	; (408ae8 <prvDetermineSocketSize+0xd8>)
  408ab0:	4798      	blx	r3
			}

			*pxSocketSize = ( sizeof( *pxSocket ) - sizeof( pxSocket->u ) ) + sizeof( pxSocket->u.xTCP );
  408ab2:	683b      	ldr	r3, [r7, #0]
  408ab4:	f44f 72c8 	mov.w	r2, #400	; 0x190
  408ab8:	601a      	str	r2, [r3, #0]
  408aba:	e00a      	b.n	408ad2 <prvDetermineSocketSize+0xc2>
		}
#endif  /* ipconfigUSE_TCP == 1 */
		else
		{
			xReturn = pdFAIL;
  408abc:	2300      	movs	r3, #0
  408abe:	617b      	str	r3, [r7, #20]
			configASSERT( xReturn );
  408ac0:	697b      	ldr	r3, [r7, #20]
  408ac2:	2b00      	cmp	r3, #0
  408ac4:	d105      	bne.n	408ad2 <prvDetermineSocketSize+0xc2>
  408ac6:	f44f 7283 	mov.w	r2, #262	; 0x106
  408aca:	4905      	ldr	r1, [pc, #20]	; (408ae0 <prvDetermineSocketSize+0xd0>)
  408acc:	4805      	ldr	r0, [pc, #20]	; (408ae4 <prvDetermineSocketSize+0xd4>)
  408ace:	4b06      	ldr	r3, [pc, #24]	; (408ae8 <prvDetermineSocketSize+0xd8>)
  408ad0:	4798      	blx	r3
		}
	}
	/* In case configASSERT() is not used */
	( void )xDomain;
	return xReturn;
  408ad2:	697b      	ldr	r3, [r7, #20]
}
  408ad4:	4618      	mov	r0, r3
  408ad6:	3718      	adds	r7, #24
  408ad8:	46bd      	mov	sp, r7
  408ada:	bd80      	pop	{r7, pc}
  408adc:	004087b5 	.word	0x004087b5
  408ae0:	0041cc08 	.word	0x0041cc08
  408ae4:	0041cc64 	.word	0x0041cc64
  408ae8:	00416c7d 	.word	0x00416c7d
  408aec:	2000b5c4 	.word	0x2000b5c4
  408af0:	2000b5b0 	.word	0x2000b5b0

00408af4 <FreeRTOS_socket>:
/*-----------------------------------------------------------*/

/* FreeRTOS_socket() allocates and initiates a socket */
Socket_t FreeRTOS_socket( BaseType_t xDomain, BaseType_t xType, BaseType_t xProtocol )
{
  408af4:	b590      	push	{r4, r7, lr}
  408af6:	b089      	sub	sp, #36	; 0x24
  408af8:	af00      	add	r7, sp, #0
  408afa:	60f8      	str	r0, [r7, #12]
  408afc:	60b9      	str	r1, [r7, #8]
  408afe:	607a      	str	r2, [r7, #4]
FreeRTOS_Socket_t *pxSocket;
size_t uxSocketSize;
EventGroupHandle_t xEventGroup;
Socket_t xReturn;

	if( prvDetermineSocketSize( xDomain, xType, xProtocol, &uxSocketSize ) == pdFAIL )
  408b00:	f107 0310 	add.w	r3, r7, #16
  408b04:	687a      	ldr	r2, [r7, #4]
  408b06:	68b9      	ldr	r1, [r7, #8]
  408b08:	68f8      	ldr	r0, [r7, #12]
  408b0a:	4c45      	ldr	r4, [pc, #276]	; (408c20 <FreeRTOS_socket+0x12c>)
  408b0c:	47a0      	blx	r4
  408b0e:	4603      	mov	r3, r0
  408b10:	2b00      	cmp	r3, #0
  408b12:	d103      	bne.n	408b1c <FreeRTOS_socket+0x28>
	{
		xReturn = FREERTOS_INVALID_SOCKET;
  408b14:	f04f 33ff 	mov.w	r3, #4294967295
  408b18:	61bb      	str	r3, [r7, #24]
  408b1a:	e07b      	b.n	408c14 <FreeRTOS_socket+0x120>
	{
		/* Allocate the structure that will hold the socket information.  The
		size depends on the type of socket: UDP sockets need less space.  A
		define 'pvPortMallocSocket' will used to allocate the necessary space.
		By default it points to the FreeRTOS function 'pvPortMalloc()'. */
		pxSocket = ( FreeRTOS_Socket_t * ) pvPortMallocSocket( uxSocketSize );
  408b1c:	693b      	ldr	r3, [r7, #16]
  408b1e:	4618      	mov	r0, r3
  408b20:	4b40      	ldr	r3, [pc, #256]	; (408c24 <FreeRTOS_socket+0x130>)
  408b22:	4798      	blx	r3
  408b24:	61f8      	str	r0, [r7, #28]

		if( pxSocket == NULL )
  408b26:	69fb      	ldr	r3, [r7, #28]
  408b28:	2b00      	cmp	r3, #0
  408b2a:	d103      	bne.n	408b34 <FreeRTOS_socket+0x40>
		{
			pxSocket = ( FreeRTOS_Socket_t * ) FREERTOS_INVALID_SOCKET;
  408b2c:	f04f 33ff 	mov.w	r3, #4294967295
  408b30:	61fb      	str	r3, [r7, #28]
  408b32:	e06d      	b.n	408c10 <FreeRTOS_socket+0x11c>
			iptraceFAILED_TO_CREATE_SOCKET();
		}
		else if( ( xEventGroup = xEventGroupCreate() ) == NULL )
  408b34:	4b3c      	ldr	r3, [pc, #240]	; (408c28 <FreeRTOS_socket+0x134>)
  408b36:	4798      	blx	r3
  408b38:	6178      	str	r0, [r7, #20]
  408b3a:	697b      	ldr	r3, [r7, #20]
  408b3c:	2b00      	cmp	r3, #0
  408b3e:	d106      	bne.n	408b4e <FreeRTOS_socket+0x5a>
		{
			vPortFreeSocket( pxSocket );
  408b40:	69f8      	ldr	r0, [r7, #28]
  408b42:	4b3a      	ldr	r3, [pc, #232]	; (408c2c <FreeRTOS_socket+0x138>)
  408b44:	4798      	blx	r3
			pxSocket = ( FreeRTOS_Socket_t * ) FREERTOS_INVALID_SOCKET;
  408b46:	f04f 33ff 	mov.w	r3, #4294967295
  408b4a:	61fb      	str	r3, [r7, #28]
  408b4c:	e060      	b.n	408c10 <FreeRTOS_socket+0x11c>
			iptraceFAILED_TO_CREATE_EVENT_GROUP();
		}
		else
		{
			/* Clear the entire space to avoid nulling individual entries */
			memset( pxSocket, '\0', uxSocketSize );
  408b4e:	693b      	ldr	r3, [r7, #16]
  408b50:	461a      	mov	r2, r3
  408b52:	2100      	movs	r1, #0
  408b54:	69f8      	ldr	r0, [r7, #28]
  408b56:	4b36      	ldr	r3, [pc, #216]	; (408c30 <FreeRTOS_socket+0x13c>)
  408b58:	4798      	blx	r3

			pxSocket->xEventGroup = xEventGroup;
  408b5a:	69fb      	ldr	r3, [r7, #28]
  408b5c:	697a      	ldr	r2, [r7, #20]
  408b5e:	605a      	str	r2, [r3, #4]

			/* Initialise the socket's members.  The semaphore will be created
			if the socket is bound to an address, for now the pointer to the
			semaphore is just set to NULL to show it has not been created. */
			if( xProtocol == FREERTOS_IPPROTO_UDP )
  408b60:	687b      	ldr	r3, [r7, #4]
  408b62:	2b11      	cmp	r3, #17
  408b64:	d104      	bne.n	408b70 <FreeRTOS_socket+0x7c>
			{
				vListInitialise( &( pxSocket->u.xUDP.xWaitingPacketsList ) );
  408b66:	69fb      	ldr	r3, [r7, #28]
  408b68:	3338      	adds	r3, #56	; 0x38
  408b6a:	4618      	mov	r0, r3
  408b6c:	4b31      	ldr	r3, [pc, #196]	; (408c34 <FreeRTOS_socket+0x140>)
  408b6e:	4798      	blx	r3
					pxSocket->u.xUDP.uxMaxPackets = ( UBaseType_t ) ipconfigUDP_MAX_RX_PACKETS;
				}
				#endif /* ipconfigUDP_MAX_RX_PACKETS > 0 */
			}

			vListInitialiseItem( &( pxSocket->xBoundSocketListItem ) );
  408b70:	69fb      	ldr	r3, [r7, #28]
  408b72:	3308      	adds	r3, #8
  408b74:	4618      	mov	r0, r3
  408b76:	4b30      	ldr	r3, [pc, #192]	; (408c38 <FreeRTOS_socket+0x144>)
  408b78:	4798      	blx	r3
			listSET_LIST_ITEM_OWNER( &( pxSocket->xBoundSocketListItem ), ( void * ) pxSocket );
  408b7a:	69fb      	ldr	r3, [r7, #28]
  408b7c:	69fa      	ldr	r2, [r7, #28]
  408b7e:	615a      	str	r2, [r3, #20]

			pxSocket->xReceiveBlockTime = ipconfigSOCK_DEFAULT_RECEIVE_BLOCK_TIME;
  408b80:	69fb      	ldr	r3, [r7, #28]
  408b82:	f241 3288 	movw	r2, #5000	; 0x1388
  408b86:	61da      	str	r2, [r3, #28]
			pxSocket->xSendBlockTime	= ipconfigSOCK_DEFAULT_SEND_BLOCK_TIME;
  408b88:	69fb      	ldr	r3, [r7, #28]
  408b8a:	f241 3288 	movw	r2, #5000	; 0x1388
  408b8e:	621a      	str	r2, [r3, #32]
			pxSocket->ucSocketOptions   = ( uint8_t ) FREERTOS_SO_UDPCKSUM_OUT;
  408b90:	69fb      	ldr	r3, [r7, #28]
  408b92:	2202      	movs	r2, #2
  408b94:	f883 2026 	strb.w	r2, [r3, #38]	; 0x26
			pxSocket->ucProtocol		= ( uint8_t ) xProtocol; /* protocol: UDP or TCP */
  408b98:	687b      	ldr	r3, [r7, #4]
  408b9a:	b2da      	uxtb	r2, r3
  408b9c:	69fb      	ldr	r3, [r7, #28]
  408b9e:	f883 2027 	strb.w	r2, [r3, #39]	; 0x27

			#if( ipconfigUSE_TCP == 1 )
			{
				if( xProtocol == FREERTOS_IPPROTO_TCP )
  408ba2:	687b      	ldr	r3, [r7, #4]
  408ba4:	2b06      	cmp	r3, #6
  408ba6:	d133      	bne.n	408c10 <FreeRTOS_socket+0x11c>
				{
					/* StreamSize is expressed in number of bytes */
					/* Round up buffer sizes to nearest multiple of MSS */
					pxSocket->u.xTCP.usInitMSS	= pxSocket->u.xTCP.usCurMSS = ipconfigTCP_MSS;
  408ba8:	69fb      	ldr	r3, [r7, #28]
  408baa:	f44f 62aa 	mov.w	r2, #1360	; 0x550
  408bae:	f8a3 204a 	strh.w	r2, [r3, #74]	; 0x4a
  408bb2:	69fb      	ldr	r3, [r7, #28]
  408bb4:	f8b3 204a 	ldrh.w	r2, [r3, #74]	; 0x4a
  408bb8:	69fb      	ldr	r3, [r7, #28]
  408bba:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
					pxSocket->u.xTCP.uxRxStreamSize = ( size_t ) ipconfigTCP_RX_BUFFER_LENGTH;
  408bbe:	69fb      	ldr	r3, [r7, #28]
  408bc0:	f44f 52aa 	mov.w	r2, #5440	; 0x1540
  408bc4:	665a      	str	r2, [r3, #100]	; 0x64
					pxSocket->u.xTCP.uxTxStreamSize = ( size_t ) FreeRTOS_round_up( ipconfigTCP_TX_BUFFER_LENGTH, ipconfigTCP_MSS );
  408bc6:	f44f 61aa 	mov.w	r1, #1360	; 0x550
  408bca:	f44f 50aa 	mov.w	r0, #5440	; 0x1540
  408bce:	4b1b      	ldr	r3, [pc, #108]	; (408c3c <FreeRTOS_socket+0x148>)
  408bd0:	4798      	blx	r3
  408bd2:	4602      	mov	r2, r0
  408bd4:	69fb      	ldr	r3, [r7, #28]
  408bd6:	669a      	str	r2, [r3, #104]	; 0x68
					/* Use half of the buffer size of the TCP windows */
					#if ( ipconfigUSE_TCP_WIN == 1 )
					{
						pxSocket->u.xTCP.uxRxWinSize  = FreeRTOS_max_uint32( 1UL, ( uint32_t ) ( pxSocket->u.xTCP.uxRxStreamSize / 2 ) / ipconfigTCP_MSS );
  408bd8:	69fb      	ldr	r3, [r7, #28]
  408bda:	6e5b      	ldr	r3, [r3, #100]	; 0x64
  408bdc:	4a18      	ldr	r2, [pc, #96]	; (408c40 <FreeRTOS_socket+0x14c>)
  408bde:	fba2 2303 	umull	r2, r3, r2, r3
  408be2:	0adb      	lsrs	r3, r3, #11
  408be4:	4619      	mov	r1, r3
  408be6:	2001      	movs	r0, #1
  408be8:	4b16      	ldr	r3, [pc, #88]	; (408c44 <FreeRTOS_socket+0x150>)
  408bea:	4798      	blx	r3
  408bec:	4602      	mov	r2, r0
  408bee:	69fb      	ldr	r3, [r7, #28]
  408bf0:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
						pxSocket->u.xTCP.uxTxWinSize  = FreeRTOS_max_uint32( 1UL, ( uint32_t ) ( pxSocket->u.xTCP.uxTxStreamSize / 2 ) / ipconfigTCP_MSS );
  408bf4:	69fb      	ldr	r3, [r7, #28]
  408bf6:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  408bf8:	4a11      	ldr	r2, [pc, #68]	; (408c40 <FreeRTOS_socket+0x14c>)
  408bfa:	fba2 2303 	umull	r2, r3, r2, r3
  408bfe:	0adb      	lsrs	r3, r3, #11
  408c00:	4619      	mov	r1, r3
  408c02:	2001      	movs	r0, #1
  408c04:	4b0f      	ldr	r3, [pc, #60]	; (408c44 <FreeRTOS_socket+0x150>)
  408c06:	4798      	blx	r3
  408c08:	4602      	mov	r2, r0
  408c0a:	69fb      	ldr	r3, [r7, #28]
  408c0c:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc
				}
			}
			#endif  /* ipconfigUSE_TCP == 1 */
		}

		xReturn = ( Socket_t ) pxSocket;
  408c10:	69fb      	ldr	r3, [r7, #28]
  408c12:	61bb      	str	r3, [r7, #24]
	}

	/* Remove compiler warnings in the case the configASSERT() is not defined. */
	( void ) xDomain;

	return xReturn;
  408c14:	69bb      	ldr	r3, [r7, #24]
}
  408c16:	4618      	mov	r0, r3
  408c18:	3724      	adds	r7, #36	; 0x24
  408c1a:	46bd      	mov	sp, r7
  408c1c:	bd90      	pop	{r4, r7, pc}
  408c1e:	bf00      	nop
  408c20:	00408a11 	.word	0x00408a11
  408c24:	004111e5 	.word	0x004111e5
  408c28:	004108ed 	.word	0x004108ed
  408c2c:	004113a1 	.word	0x004113a1
  408c30:	00416f01 	.word	0x00416f01
  408c34:	00410ce1 	.word	0x00410ce1
  408c38:	00410d21 	.word	0x00410d21
  408c3c:	00408825 	.word	0x00408825
  408c40:	c0c0c0c1 	.word	0xc0c0c0c1
  408c44:	004087e5 	.word	0x004087e5

00408c48 <FreeRTOS_recvfrom>:
 * FreeRTOS_recvfrom: receive data from a bound socket
 * In this library, the function can only be used with connectionsless sockets
 * (UDP)
 */
int32_t FreeRTOS_recvfrom( Socket_t xSocket, void *pvBuffer, size_t xBufferLength, BaseType_t xFlags, struct freertos_sockaddr *pxSourceAddress, socklen_t *pxSourceAddressLength )
{
  408c48:	b590      	push	{r4, r7, lr}
  408c4a:	b091      	sub	sp, #68	; 0x44
  408c4c:	af02      	add	r7, sp, #8
  408c4e:	60f8      	str	r0, [r7, #12]
  408c50:	60b9      	str	r1, [r7, #8]
  408c52:	607a      	str	r2, [r7, #4]
  408c54:	603b      	str	r3, [r7, #0]
BaseType_t lPacketCount = 0;
  408c56:	2300      	movs	r3, #0
  408c58:	637b      	str	r3, [r7, #52]	; 0x34
NetworkBufferDescriptor_t *pxNetworkBuffer;
FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) xSocket;
  408c5a:	68fb      	ldr	r3, [r7, #12]
  408c5c:	62bb      	str	r3, [r7, #40]	; 0x28
TickType_t xRemainingTime = ( TickType_t ) 0; /* Obsolete assignment, but some compilers output a warning if its not done. */
  408c5e:	2300      	movs	r3, #0
  408c60:	61fb      	str	r3, [r7, #28]
BaseType_t xTimed = pdFALSE;
  408c62:	2300      	movs	r3, #0
  408c64:	633b      	str	r3, [r7, #48]	; 0x30
TimeOut_t xTimeOut;
int32_t lReturn;
EventBits_t xEventBits = ( EventBits_t ) 0;
  408c66:	2300      	movs	r3, #0
  408c68:	627b      	str	r3, [r7, #36]	; 0x24

	if( prvValidSocket( pxSocket, FREERTOS_IPPROTO_UDP, pdTRUE ) == pdFALSE )
  408c6a:	2201      	movs	r2, #1
  408c6c:	2111      	movs	r1, #17
  408c6e:	6ab8      	ldr	r0, [r7, #40]	; 0x28
  408c70:	4b4a      	ldr	r3, [pc, #296]	; (408d9c <FreeRTOS_recvfrom+0x154>)
  408c72:	4798      	blx	r3
  408c74:	4603      	mov	r3, r0
  408c76:	2b00      	cmp	r3, #0
  408c78:	d102      	bne.n	408c80 <FreeRTOS_recvfrom+0x38>
	{
		return -pdFREERTOS_ERRNO_EINVAL;
  408c7a:	f06f 0315 	mvn.w	r3, #21
  408c7e:	e088      	b.n	408d92 <FreeRTOS_recvfrom+0x14a>
	}

	lPacketCount = ( BaseType_t ) listCURRENT_LIST_LENGTH( &( pxSocket->u.xUDP.xWaitingPacketsList ) );
  408c80:	6abb      	ldr	r3, [r7, #40]	; 0x28
  408c82:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  408c84:	637b      	str	r3, [r7, #52]	; 0x34

	/* The function prototype is designed to maintain the expected Berkeley
	sockets standard, but this implementation does not use all the parameters. */
	( void ) pxSourceAddressLength;

	while( lPacketCount == 0 )
  408c86:	e02f      	b.n	408ce8 <FreeRTOS_recvfrom+0xa0>
	{
		if( xTimed == pdFALSE )
  408c88:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  408c8a:	2b00      	cmp	r3, #0
  408c8c:	d111      	bne.n	408cb2 <FreeRTOS_recvfrom+0x6a>
		{
			/* Check to see if the socket is non blocking on the first
			iteration.  */
			xRemainingTime = pxSocket->xReceiveBlockTime;
  408c8e:	6abb      	ldr	r3, [r7, #40]	; 0x28
  408c90:	69db      	ldr	r3, [r3, #28]
  408c92:	61fb      	str	r3, [r7, #28]

			if( xRemainingTime == ( TickType_t ) 0 )
  408c94:	69fb      	ldr	r3, [r7, #28]
  408c96:	2b00      	cmp	r3, #0
  408c98:	d02a      	beq.n	408cf0 <FreeRTOS_recvfrom+0xa8>
				}
				#endif /* ipconfigSUPPORT_SIGNALS */
				break;
			}

			if( ( xFlags & FREERTOS_MSG_DONTWAIT ) != 0 )
  408c9a:	683b      	ldr	r3, [r7, #0]
  408c9c:	f003 0310 	and.w	r3, r3, #16
  408ca0:	2b00      	cmp	r3, #0
  408ca2:	d127      	bne.n	408cf4 <FreeRTOS_recvfrom+0xac>
			{
				break;
			}

			/* To ensure this part only executes once. */
			xTimed = pdTRUE;
  408ca4:	2301      	movs	r3, #1
  408ca6:	633b      	str	r3, [r7, #48]	; 0x30

			/* Fetch the current time. */
			vTaskSetTimeOutState( &xTimeOut );
  408ca8:	f107 0314 	add.w	r3, r7, #20
  408cac:	4618      	mov	r0, r3
  408cae:	4b3c      	ldr	r3, [pc, #240]	; (408da0 <FreeRTOS_recvfrom+0x158>)
  408cb0:	4798      	blx	r3
		}

		/* Wait for arrival of data.  While waiting, the IP-task may set the
		'eSOCKET_RECEIVE' bit in 'xEventGroup', if it receives data for this
		socket, thus unblocking this API call. */
		xEventBits = xEventGroupWaitBits( pxSocket->xEventGroup, eSOCKET_RECEIVE | eSOCKET_INTR,
  408cb2:	6abb      	ldr	r3, [r7, #40]	; 0x28
  408cb4:	6858      	ldr	r0, [r3, #4]
  408cb6:	69fb      	ldr	r3, [r7, #28]
  408cb8:	9300      	str	r3, [sp, #0]
  408cba:	2300      	movs	r3, #0
  408cbc:	2201      	movs	r2, #1
  408cbe:	2141      	movs	r1, #65	; 0x41
  408cc0:	4c38      	ldr	r4, [pc, #224]	; (408da4 <FreeRTOS_recvfrom+0x15c>)
  408cc2:	47a0      	blx	r4
  408cc4:	6278      	str	r0, [r7, #36]	; 0x24
		{
			( void ) xEventBits;
		}
		#endif /* ipconfigSUPPORT_SIGNALS */

		lPacketCount = ( BaseType_t ) listCURRENT_LIST_LENGTH( &( pxSocket->u.xUDP.xWaitingPacketsList ) );
  408cc6:	6abb      	ldr	r3, [r7, #40]	; 0x28
  408cc8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  408cca:	637b      	str	r3, [r7, #52]	; 0x34

		if( lPacketCount != 0 )
  408ccc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  408cce:	2b00      	cmp	r3, #0
  408cd0:	d112      	bne.n	408cf8 <FreeRTOS_recvfrom+0xb0>
		{
			break;
		}

		/* Has the timeout been reached ? */
		if( xTaskCheckForTimeOut( &xTimeOut, &xRemainingTime ) )
  408cd2:	f107 021c 	add.w	r2, r7, #28
  408cd6:	f107 0314 	add.w	r3, r7, #20
  408cda:	4611      	mov	r1, r2
  408cdc:	4618      	mov	r0, r3
  408cde:	4b32      	ldr	r3, [pc, #200]	; (408da8 <FreeRTOS_recvfrom+0x160>)
  408ce0:	4798      	blx	r3
  408ce2:	4603      	mov	r3, r0
  408ce4:	2b00      	cmp	r3, #0
  408ce6:	d109      	bne.n	408cfc <FreeRTOS_recvfrom+0xb4>
	while( lPacketCount == 0 )
  408ce8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  408cea:	2b00      	cmp	r3, #0
  408cec:	d0cc      	beq.n	408c88 <FreeRTOS_recvfrom+0x40>
  408cee:	e006      	b.n	408cfe <FreeRTOS_recvfrom+0xb6>
				break;
  408cf0:	bf00      	nop
  408cf2:	e004      	b.n	408cfe <FreeRTOS_recvfrom+0xb6>
				break;
  408cf4:	bf00      	nop
  408cf6:	e002      	b.n	408cfe <FreeRTOS_recvfrom+0xb6>
			break;
  408cf8:	bf00      	nop
  408cfa:	e000      	b.n	408cfe <FreeRTOS_recvfrom+0xb6>
		{
			break;
  408cfc:	bf00      	nop
		}
	} /* while( lPacketCount == 0 ) */

	if( lPacketCount != 0 )
  408cfe:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  408d00:	2b00      	cmp	r3, #0
  408d02:	d042      	beq.n	408d8a <FreeRTOS_recvfrom+0x142>
	{
		taskENTER_CRITICAL();
  408d04:	4b29      	ldr	r3, [pc, #164]	; (408dac <FreeRTOS_recvfrom+0x164>)
  408d06:	4798      	blx	r3
		{
			/* The owner of the list item is the network buffer. */
			pxNetworkBuffer = ( NetworkBufferDescriptor_t * ) listGET_OWNER_OF_HEAD_ENTRY( &( pxSocket->u.xUDP.xWaitingPacketsList ) );
  408d08:	6abb      	ldr	r3, [r7, #40]	; 0x28
  408d0a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  408d0c:	68db      	ldr	r3, [r3, #12]
  408d0e:	623b      	str	r3, [r7, #32]

			if( ( xFlags & FREERTOS_MSG_PEEK ) == 0 )
  408d10:	683b      	ldr	r3, [r7, #0]
  408d12:	f003 0304 	and.w	r3, r3, #4
  408d16:	2b00      	cmp	r3, #0
  408d18:	d103      	bne.n	408d22 <FreeRTOS_recvfrom+0xda>
			{
				/* Remove the network buffer from the list of buffers waiting to
				be processed by the socket. */
				uxListRemove( &( pxNetworkBuffer->xBufferListItem ) );
  408d1a:	6a3b      	ldr	r3, [r7, #32]
  408d1c:	4618      	mov	r0, r3
  408d1e:	4b24      	ldr	r3, [pc, #144]	; (408db0 <FreeRTOS_recvfrom+0x168>)
  408d20:	4798      	blx	r3
			}
		}
		taskEXIT_CRITICAL();
  408d22:	4b24      	ldr	r3, [pc, #144]	; (408db4 <FreeRTOS_recvfrom+0x16c>)
  408d24:	4798      	blx	r3

		/* The returned value is the length of the payload data, which is
		calculated at the total packet size minus the headers.
		The validity of `xDataLength` prvProcessIPPacket has been confirmed
		in 'prvProcessIPPacket()'. */
		lReturn = ( int32_t ) ( pxNetworkBuffer->xDataLength - sizeof( UDPPacket_t ) );
  408d26:	6a3b      	ldr	r3, [r7, #32]
  408d28:	69db      	ldr	r3, [r3, #28]
  408d2a:	3b2a      	subs	r3, #42	; 0x2a
  408d2c:	62fb      	str	r3, [r7, #44]	; 0x2c

		if( pxSourceAddress != NULL )
  408d2e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  408d30:	2b00      	cmp	r3, #0
  408d32:	d007      	beq.n	408d44 <FreeRTOS_recvfrom+0xfc>
		{
			pxSourceAddress->sin_port = pxNetworkBuffer->usPort;
  408d34:	6a3b      	ldr	r3, [r7, #32]
  408d36:	8c1a      	ldrh	r2, [r3, #32]
  408d38:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  408d3a:	805a      	strh	r2, [r3, #2]
			pxSourceAddress->sin_addr = pxNetworkBuffer->ulIPAddress;
  408d3c:	6a3b      	ldr	r3, [r7, #32]
  408d3e:	695a      	ldr	r2, [r3, #20]
  408d40:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  408d42:	605a      	str	r2, [r3, #4]
		}

		if( ( xFlags & FREERTOS_ZERO_COPY ) == 0 )
  408d44:	683b      	ldr	r3, [r7, #0]
  408d46:	f003 0301 	and.w	r3, r3, #1
  408d4a:	2b00      	cmp	r3, #0
  408d4c:	d116      	bne.n	408d7c <FreeRTOS_recvfrom+0x134>
		{
			/* The zero copy flag is not set.  Truncate the length if it won't
			fit in the provided buffer. */
			if( lReturn > ( int32_t ) xBufferLength )
  408d4e:	687b      	ldr	r3, [r7, #4]
  408d50:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  408d52:	429a      	cmp	r2, r3
  408d54:	dd01      	ble.n	408d5a <FreeRTOS_recvfrom+0x112>
			{
				iptraceRECVFROM_DISCARDING_BYTES( ( xBufferLength - lReturn ) );
				lReturn = ( int32_t )xBufferLength;
  408d56:	687b      	ldr	r3, [r7, #4]
  408d58:	62fb      	str	r3, [r7, #44]	; 0x2c
			}

			/* Copy the received data into the provided buffer, then release the
			network buffer. */
			memcpy( pvBuffer, ( void * ) &( pxNetworkBuffer->pucEthernetBuffer[ ipUDP_PAYLOAD_OFFSET_IPv4 ] ), ( size_t )lReturn );
  408d5a:	6a3b      	ldr	r3, [r7, #32]
  408d5c:	699b      	ldr	r3, [r3, #24]
  408d5e:	332a      	adds	r3, #42	; 0x2a
  408d60:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  408d62:	4619      	mov	r1, r3
  408d64:	68b8      	ldr	r0, [r7, #8]
  408d66:	4b14      	ldr	r3, [pc, #80]	; (408db8 <FreeRTOS_recvfrom+0x170>)
  408d68:	4798      	blx	r3

			if( ( xFlags & FREERTOS_MSG_PEEK ) == 0 )
  408d6a:	683b      	ldr	r3, [r7, #0]
  408d6c:	f003 0304 	and.w	r3, r3, #4
  408d70:	2b00      	cmp	r3, #0
  408d72:	d10d      	bne.n	408d90 <FreeRTOS_recvfrom+0x148>
			{
				vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
  408d74:	6a38      	ldr	r0, [r7, #32]
  408d76:	4b11      	ldr	r3, [pc, #68]	; (408dbc <FreeRTOS_recvfrom+0x174>)
  408d78:	4798      	blx	r3
  408d7a:	e009      	b.n	408d90 <FreeRTOS_recvfrom+0x148>
		{
			/* The zero copy flag was set.  pvBuffer is not a buffer into which
			the received data can be copied, but a pointer that must be set to
			point to the buffer in which the received data has already been
			placed. */
			*( ( void** ) pvBuffer ) = ( void * ) ( &( pxNetworkBuffer->pucEthernetBuffer[ ipUDP_PAYLOAD_OFFSET_IPv4 ] ) );
  408d7c:	6a3b      	ldr	r3, [r7, #32]
  408d7e:	699b      	ldr	r3, [r3, #24]
  408d80:	f103 022a 	add.w	r2, r3, #42	; 0x2a
  408d84:	68bb      	ldr	r3, [r7, #8]
  408d86:	601a      	str	r2, [r3, #0]
  408d88:	e002      	b.n	408d90 <FreeRTOS_recvfrom+0x148>
		iptraceRECVFROM_INTERRUPTED();
	}
#endif /* ipconfigSUPPORT_SIGNALS */
	else
	{
		lReturn = -pdFREERTOS_ERRNO_EWOULDBLOCK;
  408d8a:	f06f 030a 	mvn.w	r3, #10
  408d8e:	62fb      	str	r3, [r7, #44]	; 0x2c
		iptraceRECVFROM_TIMEOUT();
	}

	return lReturn;
  408d90:	6afb      	ldr	r3, [r7, #44]	; 0x2c
}
  408d92:	4618      	mov	r0, r3
  408d94:	373c      	adds	r7, #60	; 0x3c
  408d96:	46bd      	mov	sp, r7
  408d98:	bd90      	pop	{r4, r7, pc}
  408d9a:	bf00      	nop
  408d9c:	00408995 	.word	0x00408995
  408da0:	00412c89 	.word	0x00412c89
  408da4:	00410925 	.word	0x00410925
  408da8:	00412d0d 	.word	0x00412d0d
  408dac:	0041103d 	.word	0x0041103d
  408db0:	00410df5 	.word	0x00410df5
  408db4:	00411099 	.word	0x00411099
  408db8:	00416d05 	.word	0x00416d05
  408dbc:	0040f2ed 	.word	0x0040f2ed

00408dc0 <FreeRTOS_sendto>:
/*-----------------------------------------------------------*/

int32_t FreeRTOS_sendto( Socket_t xSocket, const void *pvBuffer, size_t xTotalDataLength, BaseType_t xFlags, const struct freertos_sockaddr *pxDestinationAddress, socklen_t xDestinationAddressLength )
{
  408dc0:	b580      	push	{r7, lr}
  408dc2:	b08c      	sub	sp, #48	; 0x30
  408dc4:	af00      	add	r7, sp, #0
  408dc6:	60f8      	str	r0, [r7, #12]
  408dc8:	60b9      	str	r1, [r7, #8]
  408dca:	607a      	str	r2, [r7, #4]
  408dcc:	603b      	str	r3, [r7, #0]
NetworkBufferDescriptor_t *pxNetworkBuffer;
IPStackEvent_t xStackTxEvent = { eStackTxEvent, NULL };
  408dce:	2304      	movs	r3, #4
  408dd0:	773b      	strb	r3, [r7, #28]
  408dd2:	2300      	movs	r3, #0
  408dd4:	623b      	str	r3, [r7, #32]
TimeOut_t xTimeOut;
TickType_t xTicksToWait;
int32_t lReturn = 0;
  408dd6:	2300      	movs	r3, #0
  408dd8:	62bb      	str	r3, [r7, #40]	; 0x28
FreeRTOS_Socket_t *pxSocket;

	pxSocket = ( FreeRTOS_Socket_t * ) xSocket;
  408dda:	68fb      	ldr	r3, [r7, #12]
  408ddc:	627b      	str	r3, [r7, #36]	; 0x24

	/* The function prototype is designed to maintain the expected Berkeley
	sockets standard, but this implementation does not use all the
	parameters. */
	( void ) xDestinationAddressLength;
	configASSERT( pvBuffer );
  408dde:	68bb      	ldr	r3, [r7, #8]
  408de0:	2b00      	cmp	r3, #0
  408de2:	d105      	bne.n	408df0 <FreeRTOS_sendto+0x30>
  408de4:	f44f 7243 	mov.w	r2, #780	; 0x30c
  408de8:	4942      	ldr	r1, [pc, #264]	; (408ef4 <FreeRTOS_sendto+0x134>)
  408dea:	4843      	ldr	r0, [pc, #268]	; (408ef8 <FreeRTOS_sendto+0x138>)
  408dec:	4b43      	ldr	r3, [pc, #268]	; (408efc <FreeRTOS_sendto+0x13c>)
  408dee:	4798      	blx	r3

	if( xTotalDataLength <= ( size_t ) ipMAX_UDP_PAYLOAD_LENGTH )
  408df0:	687b      	ldr	r3, [r7, #4]
  408df2:	f240 525c 	movw	r2, #1372	; 0x55c
  408df6:	4293      	cmp	r3, r2
  408df8:	d877      	bhi.n	408eea <FreeRTOS_sendto+0x12a>
	{
		/* If the socket is not already bound to an address, bind it now.
		Passing NULL as the address parameter tells FreeRTOS_bind() to select
		the address to bind to. */
		if( ( socketSOCKET_IS_BOUND( pxSocket ) != pdFALSE ) ||
  408dfa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  408dfc:	699b      	ldr	r3, [r3, #24]
  408dfe:	2b00      	cmp	r3, #0
  408e00:	d107      	bne.n	408e12 <FreeRTOS_sendto+0x52>
			( FreeRTOS_bind( xSocket, NULL, 0u ) == 0 ) )
  408e02:	2200      	movs	r2, #0
  408e04:	2100      	movs	r1, #0
  408e06:	68f8      	ldr	r0, [r7, #12]
  408e08:	4b3d      	ldr	r3, [pc, #244]	; (408f00 <FreeRTOS_sendto+0x140>)
  408e0a:	4798      	blx	r3
  408e0c:	4603      	mov	r3, r0
		if( ( socketSOCKET_IS_BOUND( pxSocket ) != pdFALSE ) ||
  408e0e:	2b00      	cmp	r3, #0
  408e10:	d16b      	bne.n	408eea <FreeRTOS_sendto+0x12a>
		{
			xTicksToWait = pxSocket->xSendBlockTime;
  408e12:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  408e14:	6a1b      	ldr	r3, [r3, #32]
  408e16:	613b      	str	r3, [r7, #16]
					xTicksToWait = ( TickType_t )0;
				}
			}
			#endif /* ipconfigUSE_CALLBACKS */

			if( ( xFlags & FREERTOS_MSG_DONTWAIT ) != 0 )
  408e18:	683b      	ldr	r3, [r7, #0]
  408e1a:	f003 0310 	and.w	r3, r3, #16
  408e1e:	2b00      	cmp	r3, #0
  408e20:	d001      	beq.n	408e26 <FreeRTOS_sendto+0x66>
			{
				xTicksToWait = ( TickType_t ) 0;
  408e22:	2300      	movs	r3, #0
  408e24:	613b      	str	r3, [r7, #16]
			}

			if( ( xFlags & FREERTOS_ZERO_COPY ) == 0 )
  408e26:	683b      	ldr	r3, [r7, #0]
  408e28:	f003 0301 	and.w	r3, r3, #1
  408e2c:	2b00      	cmp	r3, #0
  408e2e:	d125      	bne.n	408e7c <FreeRTOS_sendto+0xbc>
			{
				/* Zero copy is not set, so obtain a network buffer into
				which the payload will be copied. */
				vTaskSetTimeOutState( &xTimeOut );
  408e30:	f107 0314 	add.w	r3, r7, #20
  408e34:	4618      	mov	r0, r3
  408e36:	4b33      	ldr	r3, [pc, #204]	; (408f04 <FreeRTOS_sendto+0x144>)
  408e38:	4798      	blx	r3

				/* Block until a buffer becomes available, or until a
				timeout has been reached */
				pxNetworkBuffer = pxGetNetworkBufferWithDescriptor( xTotalDataLength + sizeof( UDPPacket_t ), xTicksToWait );
  408e3a:	687b      	ldr	r3, [r7, #4]
  408e3c:	332a      	adds	r3, #42	; 0x2a
  408e3e:	693a      	ldr	r2, [r7, #16]
  408e40:	4611      	mov	r1, r2
  408e42:	4618      	mov	r0, r3
  408e44:	4b30      	ldr	r3, [pc, #192]	; (408f08 <FreeRTOS_sendto+0x148>)
  408e46:	4798      	blx	r3
  408e48:	62f8      	str	r0, [r7, #44]	; 0x2c

				if( pxNetworkBuffer != NULL )
  408e4a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  408e4c:	2b00      	cmp	r3, #0
  408e4e:	d019      	beq.n	408e84 <FreeRTOS_sendto+0xc4>
				{
					memcpy( ( void * ) &( pxNetworkBuffer->pucEthernetBuffer[ ipUDP_PAYLOAD_OFFSET_IPv4 ] ), ( void * ) pvBuffer, xTotalDataLength );
  408e50:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  408e52:	699b      	ldr	r3, [r3, #24]
  408e54:	332a      	adds	r3, #42	; 0x2a
  408e56:	687a      	ldr	r2, [r7, #4]
  408e58:	68b9      	ldr	r1, [r7, #8]
  408e5a:	4618      	mov	r0, r3
  408e5c:	4b2b      	ldr	r3, [pc, #172]	; (408f0c <FreeRTOS_sendto+0x14c>)
  408e5e:	4798      	blx	r3

					if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdTRUE )
  408e60:	f107 0210 	add.w	r2, r7, #16
  408e64:	f107 0314 	add.w	r3, r7, #20
  408e68:	4611      	mov	r1, r2
  408e6a:	4618      	mov	r0, r3
  408e6c:	4b28      	ldr	r3, [pc, #160]	; (408f10 <FreeRTOS_sendto+0x150>)
  408e6e:	4798      	blx	r3
  408e70:	4603      	mov	r3, r0
  408e72:	2b01      	cmp	r3, #1
  408e74:	d106      	bne.n	408e84 <FreeRTOS_sendto+0xc4>
					{
						/* The entire block time has been used up. */
						xTicksToWait = ( TickType_t ) 0;
  408e76:	2300      	movs	r3, #0
  408e78:	613b      	str	r3, [r7, #16]
  408e7a:	e003      	b.n	408e84 <FreeRTOS_sendto+0xc4>
			else
			{
				/* When zero copy is used, pvBuffer is a pointer to the
				payload of a buffer that has already been obtained from the
				stack.  Obtain the network buffer pointer from the buffer. */
				pxNetworkBuffer = pxUDPPayloadBuffer_to_NetworkBuffer( (void*)pvBuffer );
  408e7c:	68b8      	ldr	r0, [r7, #8]
  408e7e:	4b25      	ldr	r3, [pc, #148]	; (408f14 <FreeRTOS_sendto+0x154>)
  408e80:	4798      	blx	r3
  408e82:	62f8      	str	r0, [r7, #44]	; 0x2c
			}

			if( pxNetworkBuffer != NULL )
  408e84:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  408e86:	2b00      	cmp	r3, #0
  408e88:	d02f      	beq.n	408eea <FreeRTOS_sendto+0x12a>
			{
				/* xDataLength is the size of the total packet, including the Ethernet header. */
				pxNetworkBuffer->xDataLength = xTotalDataLength + sizeof( UDPPacket_t );
  408e8a:	687b      	ldr	r3, [r7, #4]
  408e8c:	f103 022a 	add.w	r2, r3, #42	; 0x2a
  408e90:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  408e92:	61da      	str	r2, [r3, #28]
				pxNetworkBuffer->usPort = pxDestinationAddress->sin_port;
  408e94:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  408e96:	885a      	ldrh	r2, [r3, #2]
  408e98:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  408e9a:	841a      	strh	r2, [r3, #32]
				pxNetworkBuffer->usBoundPort = ( uint16_t ) socketGET_SOCKET_PORT( pxSocket );
  408e9c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  408e9e:	689b      	ldr	r3, [r3, #8]
  408ea0:	b29a      	uxth	r2, r3
  408ea2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  408ea4:	845a      	strh	r2, [r3, #34]	; 0x22
				pxNetworkBuffer->ulIPAddress = pxDestinationAddress->sin_addr;
  408ea6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  408ea8:	685a      	ldr	r2, [r3, #4]
  408eaa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  408eac:	615a      	str	r2, [r3, #20]

				/* The socket options are passed to the IP layer in the
				space that will eventually get used by the Ethernet header. */
				pxNetworkBuffer->pucEthernetBuffer[ ipSOCKET_OPTIONS_OFFSET ] = pxSocket->ucSocketOptions;
  408eae:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  408eb0:	699b      	ldr	r3, [r3, #24]
  408eb2:	3306      	adds	r3, #6
  408eb4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  408eb6:	f892 2026 	ldrb.w	r2, [r2, #38]	; 0x26
  408eba:	701a      	strb	r2, [r3, #0]

				/* Tell the networking task that the packet needs sending. */
				xStackTxEvent.pvData = pxNetworkBuffer;
  408ebc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  408ebe:	623b      	str	r3, [r7, #32]

				/* Ask the IP-task to send this packet */
				if( xSendEventStructToIPTask( &xStackTxEvent, xTicksToWait ) == pdPASS )
  408ec0:	693a      	ldr	r2, [r7, #16]
  408ec2:	f107 031c 	add.w	r3, r7, #28
  408ec6:	4611      	mov	r1, r2
  408ec8:	4618      	mov	r0, r3
  408eca:	4b13      	ldr	r3, [pc, #76]	; (408f18 <FreeRTOS_sendto+0x158>)
  408ecc:	4798      	blx	r3
  408ece:	4603      	mov	r3, r0
  408ed0:	2b01      	cmp	r3, #1
  408ed2:	d102      	bne.n	408eda <FreeRTOS_sendto+0x11a>
				{
					/* The packet was successfully sent to the IP task. */
					lReturn = ( int32_t ) xTotalDataLength;
  408ed4:	687b      	ldr	r3, [r7, #4]
  408ed6:	62bb      	str	r3, [r7, #40]	; 0x28
  408ed8:	e007      	b.n	408eea <FreeRTOS_sendto+0x12a>
				}
				else
				{
					/* If the buffer was allocated in this function, release
					it. */
					if( ( xFlags & FREERTOS_ZERO_COPY ) == 0 )
  408eda:	683b      	ldr	r3, [r7, #0]
  408edc:	f003 0301 	and.w	r3, r3, #1
  408ee0:	2b00      	cmp	r3, #0
  408ee2:	d102      	bne.n	408eea <FreeRTOS_sendto+0x12a>
					{
						vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
  408ee4:	6af8      	ldr	r0, [r7, #44]	; 0x2c
  408ee6:	4b0d      	ldr	r3, [pc, #52]	; (408f1c <FreeRTOS_sendto+0x15c>)
  408ee8:	4798      	blx	r3
	{
		/* The data is longer than the available buffer space. */
		iptraceSENDTO_DATA_TOO_LONG();
	}

	return lReturn;
  408eea:	6abb      	ldr	r3, [r7, #40]	; 0x28
} /* Tested */
  408eec:	4618      	mov	r0, r3
  408eee:	3730      	adds	r7, #48	; 0x30
  408ef0:	46bd      	mov	sp, r7
  408ef2:	bd80      	pop	{r7, pc}
  408ef4:	0041cc08 	.word	0x0041cc08
  408ef8:	0041cc64 	.word	0x0041cc64
  408efc:	00416c7d 	.word	0x00416c7d
  408f00:	00408f21 	.word	0x00408f21
  408f04:	00412c89 	.word	0x00412c89
  408f08:	0040f1d5 	.word	0x0040f1d5
  408f0c:	00416d05 	.word	0x00416d05
  408f10:	00412d0d 	.word	0x00412d0d
  408f14:	00407b61 	.word	0x00407b61
  408f18:	00407e49 	.word	0x00407e49
  408f1c:	0040f2ed 	.word	0x0040f2ed

00408f20 <FreeRTOS_bind>:
 * be used for both UDP and TCP sockets.  The actual binding will be performed
 * by the IP-task to avoid mutual access to the bound-socket-lists
 * (xBoundUDPSocketsList or xBoundTCPSocketsList).
 */
BaseType_t FreeRTOS_bind( Socket_t xSocket, struct freertos_sockaddr * pxAddress, socklen_t xAddressLength )
{
  408f20:	b590      	push	{r4, r7, lr}
  408f22:	b08b      	sub	sp, #44	; 0x2c
  408f24:	af02      	add	r7, sp, #8
  408f26:	60f8      	str	r0, [r7, #12]
  408f28:	60b9      	str	r1, [r7, #8]
  408f2a:	607a      	str	r2, [r7, #4]
IPStackEvent_t xBindEvent;
FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) xSocket;
  408f2c:	68fb      	ldr	r3, [r7, #12]
  408f2e:	61bb      	str	r3, [r7, #24]
BaseType_t xReturn = 0;
  408f30:	2300      	movs	r3, #0
  408f32:	61fb      	str	r3, [r7, #28]

	( void ) xAddressLength;

	if( ( pxSocket == NULL ) || ( pxSocket == FREERTOS_INVALID_SOCKET ) )
  408f34:	69bb      	ldr	r3, [r7, #24]
  408f36:	2b00      	cmp	r3, #0
  408f38:	d003      	beq.n	408f42 <FreeRTOS_bind+0x22>
  408f3a:	69bb      	ldr	r3, [r7, #24]
  408f3c:	f1b3 3fff 	cmp.w	r3, #4294967295
  408f40:	d103      	bne.n	408f4a <FreeRTOS_bind+0x2a>
	{
		xReturn = -pdFREERTOS_ERRNO_EINVAL;
  408f42:	f06f 0315 	mvn.w	r3, #21
  408f46:	61fb      	str	r3, [r7, #28]
  408f48:	e04d      	b.n	408fe6 <FreeRTOS_bind+0xc6>
	}
	/* Once a socket is bound to a port, it can not be bound to a different
	port number */
	else if( socketSOCKET_IS_BOUND( pxSocket) != pdFALSE )
  408f4a:	69bb      	ldr	r3, [r7, #24]
  408f4c:	699b      	ldr	r3, [r3, #24]
  408f4e:	2b00      	cmp	r3, #0
  408f50:	d001      	beq.n	408f56 <FreeRTOS_bind+0x36>
  408f52:	2301      	movs	r3, #1
  408f54:	e000      	b.n	408f58 <FreeRTOS_bind+0x38>
  408f56:	2300      	movs	r3, #0
  408f58:	2b00      	cmp	r3, #0
  408f5a:	d009      	beq.n	408f70 <FreeRTOS_bind+0x50>
	{
		/* The socket is already bound. */
		FreeRTOS_debug_printf( ( "vSocketBind: Socket already bound to %d\n", pxSocket->usLocalPort ) );
  408f5c:	69bb      	ldr	r3, [r7, #24]
  408f5e:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
  408f60:	4619      	mov	r1, r3
  408f62:	4823      	ldr	r0, [pc, #140]	; (408ff0 <FreeRTOS_bind+0xd0>)
  408f64:	4b23      	ldr	r3, [pc, #140]	; (408ff4 <FreeRTOS_bind+0xd4>)
  408f66:	4798      	blx	r3
		xReturn = -pdFREERTOS_ERRNO_EINVAL;
  408f68:	f06f 0315 	mvn.w	r3, #21
  408f6c:	61fb      	str	r3, [r7, #28]
  408f6e:	e03a      	b.n	408fe6 <FreeRTOS_bind+0xc6>
	}
	else
	{
		/* Prepare a messages to the IP-task in order to perform the binding.
		The desired port number will be passed in usLocalPort. */
		xBindEvent.eEventType = eSocketBindEvent;
  408f70:	2309      	movs	r3, #9
  408f72:	743b      	strb	r3, [r7, #16]
		xBindEvent.pvData = ( void * ) xSocket;
  408f74:	68fb      	ldr	r3, [r7, #12]
  408f76:	617b      	str	r3, [r7, #20]
		if( pxAddress != NULL )
  408f78:	68bb      	ldr	r3, [r7, #8]
  408f7a:	2b00      	cmp	r3, #0
  408f7c:	d00e      	beq.n	408f9c <FreeRTOS_bind+0x7c>
		{
			pxSocket->usLocalPort = FreeRTOS_ntohs( pxAddress->sin_port );
  408f7e:	68bb      	ldr	r3, [r7, #8]
  408f80:	885b      	ldrh	r3, [r3, #2]
  408f82:	021b      	lsls	r3, r3, #8
  408f84:	b21a      	sxth	r2, r3
  408f86:	68bb      	ldr	r3, [r7, #8]
  408f88:	885b      	ldrh	r3, [r3, #2]
  408f8a:	0a1b      	lsrs	r3, r3, #8
  408f8c:	b29b      	uxth	r3, r3
  408f8e:	b21b      	sxth	r3, r3
  408f90:	4313      	orrs	r3, r2
  408f92:	b21b      	sxth	r3, r3
  408f94:	b29a      	uxth	r2, r3
  408f96:	69bb      	ldr	r3, [r7, #24]
  408f98:	849a      	strh	r2, [r3, #36]	; 0x24
  408f9a:	e002      	b.n	408fa2 <FreeRTOS_bind+0x82>
		}
		else
		{
			/* Caller wants to bind to a random port number. */
			pxSocket->usLocalPort = 0u;
  408f9c:	69bb      	ldr	r3, [r7, #24]
  408f9e:	2200      	movs	r2, #0
  408fa0:	849a      	strh	r2, [r3, #36]	; 0x24
		}

		/* portMAX_DELAY is used as a the time-out parameter, as binding *must*
		succeed before the socket can be used.  _RB_ The use of an infinite
		block time needs be changed as it could result in the task hanging. */
		if( xSendEventStructToIPTask( &xBindEvent, ( TickType_t ) portMAX_DELAY ) == pdFAIL )
  408fa2:	f107 0310 	add.w	r3, r7, #16
  408fa6:	f04f 31ff 	mov.w	r1, #4294967295
  408faa:	4618      	mov	r0, r3
  408fac:	4b12      	ldr	r3, [pc, #72]	; (408ff8 <FreeRTOS_bind+0xd8>)
  408fae:	4798      	blx	r3
  408fb0:	4603      	mov	r3, r0
  408fb2:	2b00      	cmp	r3, #0
  408fb4:	d106      	bne.n	408fc4 <FreeRTOS_bind+0xa4>
		{
			/* Failed to wake-up the IP-task, no use to wait for it */
			FreeRTOS_debug_printf( ( "FreeRTOS_bind: send event failed\n" ) );
  408fb6:	4811      	ldr	r0, [pc, #68]	; (408ffc <FreeRTOS_bind+0xdc>)
  408fb8:	4b0e      	ldr	r3, [pc, #56]	; (408ff4 <FreeRTOS_bind+0xd4>)
  408fba:	4798      	blx	r3
			xReturn = -pdFREERTOS_ERRNO_ECANCELED;
  408fbc:	f06f 038b 	mvn.w	r3, #139	; 0x8b
  408fc0:	61fb      	str	r3, [r7, #28]
  408fc2:	e010      	b.n	408fe6 <FreeRTOS_bind+0xc6>
		}
		else
		{
			/* The IP-task will set the 'eSOCKET_BOUND' bit when it has done its
			job. */
			xEventGroupWaitBits( pxSocket->xEventGroup, eSOCKET_BOUND, pdTRUE /*xClearOnExit*/, pdFALSE /*xWaitAllBits*/, portMAX_DELAY );
  408fc4:	69bb      	ldr	r3, [r7, #24]
  408fc6:	6858      	ldr	r0, [r3, #4]
  408fc8:	f04f 33ff 	mov.w	r3, #4294967295
  408fcc:	9300      	str	r3, [sp, #0]
  408fce:	2300      	movs	r3, #0
  408fd0:	2201      	movs	r2, #1
  408fd2:	2110      	movs	r1, #16
  408fd4:	4c0a      	ldr	r4, [pc, #40]	; (409000 <FreeRTOS_bind+0xe0>)
  408fd6:	47a0      	blx	r4
			if( socketSOCKET_IS_BOUND( pxSocket ) == pdFALSE )
  408fd8:	69bb      	ldr	r3, [r7, #24]
  408fda:	699b      	ldr	r3, [r3, #24]
  408fdc:	2b00      	cmp	r3, #0
  408fde:	d102      	bne.n	408fe6 <FreeRTOS_bind+0xc6>
			{
				xReturn = -pdFREERTOS_ERRNO_EINVAL;
  408fe0:	f06f 0315 	mvn.w	r3, #21
  408fe4:	61fb      	str	r3, [r7, #28]
			}
		}
	}

	return xReturn;
  408fe6:	69fb      	ldr	r3, [r7, #28]
}
  408fe8:	4618      	mov	r0, r3
  408fea:	3724      	adds	r7, #36	; 0x24
  408fec:	46bd      	mov	sp, r7
  408fee:	bd90      	pop	{r4, r7, pc}
  408ff0:	0041cc94 	.word	0x0041cc94
  408ff4:	00416c7d 	.word	0x00416c7d
  408ff8:	00407e49 	.word	0x00407e49
  408ffc:	0041ccc0 	.word	0x0041ccc0
  409000:	00410925 	.word	0x00410925

00409004 <vSocketBind>:
 * vSocketBind(): internal version of bind() that should not be called directly.
 * 'xInternal' is used for TCP sockets only: it allows to have several
 * (connected) child sockets bound to the same server port.
 */
BaseType_t vSocketBind( FreeRTOS_Socket_t *pxSocket, struct freertos_sockaddr * pxAddress, size_t uxAddressLength, BaseType_t xInternal )
{
  409004:	b580      	push	{r7, lr}
  409006:	b088      	sub	sp, #32
  409008:	af00      	add	r7, sp, #0
  40900a:	60f8      	str	r0, [r7, #12]
  40900c:	60b9      	str	r1, [r7, #8]
  40900e:	607a      	str	r2, [r7, #4]
  409010:	603b      	str	r3, [r7, #0]
BaseType_t xReturn = 0; /* In Berkeley sockets, 0 means pass for bind(). */
  409012:	2300      	movs	r3, #0
  409014:	61fb      	str	r3, [r7, #28]
#if( ipconfigALLOW_SOCKET_SEND_WITHOUT_BIND == 1 )
	struct freertos_sockaddr xAddress;
#endif /* ipconfigALLOW_SOCKET_SEND_WITHOUT_BIND */

#if( ipconfigUSE_TCP == 1 )
	if( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_TCP )
  409016:	68fb      	ldr	r3, [r7, #12]
  409018:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
  40901c:	2b06      	cmp	r3, #6
  40901e:	d102      	bne.n	409026 <vSocketBind+0x22>
	{
		pxSocketList = &xBoundTCPSocketsList;
  409020:	4b4b      	ldr	r3, [pc, #300]	; (409150 <vSocketBind+0x14c>)
  409022:	61bb      	str	r3, [r7, #24]
  409024:	e001      	b.n	40902a <vSocketBind+0x26>
	}
	else
#endif  /* ipconfigUSE_TCP == 1 */
	{
		pxSocketList = &xBoundUDPSocketsList;
  409026:	4b4b      	ldr	r3, [pc, #300]	; (409154 <vSocketBind+0x150>)
  409028:	61bb      	str	r3, [r7, #24]

	/* The function prototype is designed to maintain the expected Berkeley
	sockets standard, but this implementation does not use all the parameters. */
	( void ) uxAddressLength;

	configASSERT( pxSocket );
  40902a:	68fb      	ldr	r3, [r7, #12]
  40902c:	2b00      	cmp	r3, #0
  40902e:	d105      	bne.n	40903c <vSocketBind+0x38>
  409030:	f240 32e5 	movw	r2, #997	; 0x3e5
  409034:	4948      	ldr	r1, [pc, #288]	; (409158 <vSocketBind+0x154>)
  409036:	4849      	ldr	r0, [pc, #292]	; (40915c <vSocketBind+0x158>)
  409038:	4b49      	ldr	r3, [pc, #292]	; (409160 <vSocketBind+0x15c>)
  40903a:	4798      	blx	r3
	configASSERT( pxSocket != FREERTOS_INVALID_SOCKET );
  40903c:	68fb      	ldr	r3, [r7, #12]
  40903e:	f1b3 3fff 	cmp.w	r3, #4294967295
  409042:	d105      	bne.n	409050 <vSocketBind+0x4c>
  409044:	f240 32e6 	movw	r2, #998	; 0x3e6
  409048:	4943      	ldr	r1, [pc, #268]	; (409158 <vSocketBind+0x154>)
  40904a:	4844      	ldr	r0, [pc, #272]	; (40915c <vSocketBind+0x158>)
  40904c:	4b44      	ldr	r3, [pc, #272]	; (409160 <vSocketBind+0x15c>)
  40904e:	4798      	blx	r3
	#if( ipconfigALLOW_SOCKET_SEND_WITHOUT_BIND == 1 )
	{
		/* pxAddress will be NULL if sendto() was called on a socket without the
		socket being bound to an address. In this case, automatically allocate
		an address and port to the socket. */
		if( pxAddress == NULL )
  409050:	68bb      	ldr	r3, [r7, #8]
  409052:	2b00      	cmp	r3, #0
  409054:	d105      	bne.n	409062 <vSocketBind+0x5e>
		{
			pxAddress = &xAddress;
  409056:	f107 0310 	add.w	r3, r7, #16
  40905a:	60bb      	str	r3, [r7, #8]
			/* Put the port to zero to be assigned later. */
			pxAddress->sin_port = 0u;
  40905c:	68bb      	ldr	r3, [r7, #8]
  40905e:	2200      	movs	r2, #0
  409060:	805a      	strh	r2, [r3, #2]
	}
	#endif /* ipconfigALLOW_SOCKET_SEND_WITHOUT_BIND == 1 */

	/* Sockets must be bound before calling FreeRTOS_sendto() if
	ipconfigALLOW_SOCKET_SEND_WITHOUT_BIND is not set to 1. */
	configASSERT( pxAddress );
  409062:	68bb      	ldr	r3, [r7, #8]
  409064:	2b00      	cmp	r3, #0
  409066:	d105      	bne.n	409074 <vSocketBind+0x70>
  409068:	f44f 727e 	mov.w	r2, #1016	; 0x3f8
  40906c:	493a      	ldr	r1, [pc, #232]	; (409158 <vSocketBind+0x154>)
  40906e:	483b      	ldr	r0, [pc, #236]	; (40915c <vSocketBind+0x158>)
  409070:	4b3b      	ldr	r3, [pc, #236]	; (409160 <vSocketBind+0x15c>)
  409072:	4798      	blx	r3

	if( pxAddress != NULL )
  409074:	68bb      	ldr	r3, [r7, #8]
  409076:	2b00      	cmp	r3, #0
  409078:	d05f      	beq.n	40913a <vSocketBind+0x136>
	{
		if( pxAddress->sin_port == 0u )
  40907a:	68bb      	ldr	r3, [r7, #8]
  40907c:	885b      	ldrh	r3, [r3, #2]
  40907e:	2b00      	cmp	r3, #0
  409080:	d110      	bne.n	4090a4 <vSocketBind+0xa0>
		{
			pxAddress->sin_port = prvGetPrivatePortNumber( ( BaseType_t )pxSocket->ucProtocol );
  409082:	68fb      	ldr	r3, [r7, #12]
  409084:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
  409088:	4618      	mov	r0, r3
  40908a:	4b36      	ldr	r3, [pc, #216]	; (409164 <vSocketBind+0x160>)
  40908c:	4798      	blx	r3
  40908e:	4603      	mov	r3, r0
  409090:	461a      	mov	r2, r3
  409092:	68bb      	ldr	r3, [r7, #8]
  409094:	805a      	strh	r2, [r3, #2]
			if( 0 == pxAddress->sin_port )
  409096:	68bb      	ldr	r3, [r7, #8]
  409098:	885b      	ldrh	r3, [r3, #2]
  40909a:	2b00      	cmp	r3, #0
  40909c:	d102      	bne.n	4090a4 <vSocketBind+0xa0>
			{
				return -pdFREERTOS_ERRNO_EADDRNOTAVAIL;
  40909e:	f06f 037c 	mvn.w	r3, #124	; 0x7c
  4090a2:	e051      	b.n	409148 <vSocketBind+0x144>
		confirmed that the socket was not yet bound to a port.  If it is called
		from the IP-task, no such check is necessary. */

		/* Check to ensure the port is not already in use.  If the bind is
		called internally, a port MAY be used by more than one socket. */
		if( ( ( xInternal == pdFALSE ) || ( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP ) ) &&
  4090a4:	683b      	ldr	r3, [r7, #0]
  4090a6:	2b00      	cmp	r3, #0
  4090a8:	d004      	beq.n	4090b4 <vSocketBind+0xb0>
  4090aa:	68fb      	ldr	r3, [r7, #12]
  4090ac:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
  4090b0:	2b06      	cmp	r3, #6
  4090b2:	d024      	beq.n	4090fe <vSocketBind+0xfa>
			( pxListFindListItemWithValue( pxSocketList, ( TickType_t ) pxAddress->sin_port ) != NULL ) )
  4090b4:	68bb      	ldr	r3, [r7, #8]
  4090b6:	885b      	ldrh	r3, [r3, #2]
  4090b8:	4619      	mov	r1, r3
  4090ba:	69b8      	ldr	r0, [r7, #24]
  4090bc:	4b2a      	ldr	r3, [pc, #168]	; (409168 <vSocketBind+0x164>)
  4090be:	4798      	blx	r3
  4090c0:	4603      	mov	r3, r0
		if( ( ( xInternal == pdFALSE ) || ( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP ) ) &&
  4090c2:	2b00      	cmp	r3, #0
  4090c4:	d01b      	beq.n	4090fe <vSocketBind+0xfa>
		{
			FreeRTOS_debug_printf( ( "vSocketBind: %sP port %d in use\n",
  4090c6:	68fb      	ldr	r3, [r7, #12]
  4090c8:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
  4090cc:	2b06      	cmp	r3, #6
  4090ce:	d101      	bne.n	4090d4 <vSocketBind+0xd0>
  4090d0:	4926      	ldr	r1, [pc, #152]	; (40916c <vSocketBind+0x168>)
  4090d2:	e000      	b.n	4090d6 <vSocketBind+0xd2>
  4090d4:	4926      	ldr	r1, [pc, #152]	; (409170 <vSocketBind+0x16c>)
  4090d6:	68bb      	ldr	r3, [r7, #8]
  4090d8:	885b      	ldrh	r3, [r3, #2]
  4090da:	021b      	lsls	r3, r3, #8
  4090dc:	b21a      	sxth	r2, r3
  4090de:	68bb      	ldr	r3, [r7, #8]
  4090e0:	885b      	ldrh	r3, [r3, #2]
  4090e2:	0a1b      	lsrs	r3, r3, #8
  4090e4:	b29b      	uxth	r3, r3
  4090e6:	b21b      	sxth	r3, r3
  4090e8:	4313      	orrs	r3, r2
  4090ea:	b21b      	sxth	r3, r3
  4090ec:	b29b      	uxth	r3, r3
  4090ee:	461a      	mov	r2, r3
  4090f0:	4820      	ldr	r0, [pc, #128]	; (409174 <vSocketBind+0x170>)
  4090f2:	4b1b      	ldr	r3, [pc, #108]	; (409160 <vSocketBind+0x15c>)
  4090f4:	4798      	blx	r3
				pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_TCP ? "TC" : "UD",
				FreeRTOS_ntohs( pxAddress->sin_port ) ) );
			xReturn = -pdFREERTOS_ERRNO_EADDRINUSE;
  4090f6:	f06f 036f 	mvn.w	r3, #111	; 0x6f
  4090fa:	61fb      	str	r3, [r7, #28]
  4090fc:	e023      	b.n	409146 <vSocketBind+0x142>
		}
		else
		{
			/* Allocate the port number to the socket.
			This macro will set 'xBoundSocketListItem->xItemValue' */
			socketSET_SOCKET_PORT( pxSocket, pxAddress->sin_port );
  4090fe:	68bb      	ldr	r3, [r7, #8]
  409100:	885b      	ldrh	r3, [r3, #2]
  409102:	461a      	mov	r2, r3
  409104:	68fb      	ldr	r3, [r7, #12]
  409106:	609a      	str	r2, [r3, #8]

			/* And also store it in a socket field 'usLocalPort' in host-byte-order,
			mostly used for logging and debugging purposes */
			pxSocket->usLocalPort = FreeRTOS_ntohs( pxAddress->sin_port );
  409108:	68bb      	ldr	r3, [r7, #8]
  40910a:	885b      	ldrh	r3, [r3, #2]
  40910c:	021b      	lsls	r3, r3, #8
  40910e:	b21a      	sxth	r2, r3
  409110:	68bb      	ldr	r3, [r7, #8]
  409112:	885b      	ldrh	r3, [r3, #2]
  409114:	0a1b      	lsrs	r3, r3, #8
  409116:	b29b      	uxth	r3, r3
  409118:	b21b      	sxth	r3, r3
  40911a:	4313      	orrs	r3, r2
  40911c:	b21b      	sxth	r3, r3
  40911e:	b29a      	uxth	r2, r3
  409120:	68fb      	ldr	r3, [r7, #12]
  409122:	849a      	strh	r2, [r3, #36]	; 0x24
				/* If the network driver can iterate through 'xBoundUDPSocketsList',
				by calling xPortHasUDPSocket() then the IP-task must temporarily
				suspend the scheduler to keep the list in a consistent state. */
				#if( ipconfigETHERNET_DRIVER_FILTERS_PACKETS == 1 )
				{
					vTaskSuspendAll();
  409124:	4b14      	ldr	r3, [pc, #80]	; (409178 <vSocketBind+0x174>)
  409126:	4798      	blx	r3
				}
				#endif /* ipconfigETHERNET_DRIVER_FILTERS_PACKETS */

				/* Add the socket to 'xBoundUDPSocketsList' or 'xBoundTCPSocketsList' */
				vListInsertEnd( pxSocketList, &( pxSocket->xBoundSocketListItem ) );
  409128:	68fb      	ldr	r3, [r7, #12]
  40912a:	3308      	adds	r3, #8
  40912c:	4619      	mov	r1, r3
  40912e:	69b8      	ldr	r0, [r7, #24]
  409130:	4b12      	ldr	r3, [pc, #72]	; (40917c <vSocketBind+0x178>)
  409132:	4798      	blx	r3

				#if( ipconfigETHERNET_DRIVER_FILTERS_PACKETS == 1 )
				{
					xTaskResumeAll();
  409134:	4b12      	ldr	r3, [pc, #72]	; (409180 <vSocketBind+0x17c>)
  409136:	4798      	blx	r3
  409138:	e005      	b.n	409146 <vSocketBind+0x142>
			}
		}
	}
	else
	{
		xReturn = -pdFREERTOS_ERRNO_EADDRNOTAVAIL;
  40913a:	f06f 037c 	mvn.w	r3, #124	; 0x7c
  40913e:	61fb      	str	r3, [r7, #28]
		FreeRTOS_debug_printf( ( "vSocketBind: Socket no addr\n" ) );
  409140:	4810      	ldr	r0, [pc, #64]	; (409184 <vSocketBind+0x180>)
  409142:	4b07      	ldr	r3, [pc, #28]	; (409160 <vSocketBind+0x15c>)
  409144:	4798      	blx	r3
	if( xReturn != 0 )
	{
		iptraceBIND_FAILED( xSocket, ( FreeRTOS_ntohs( pxAddress->sin_port ) ) );
	}

	return xReturn;
  409146:	69fb      	ldr	r3, [r7, #28]
} /* Tested */
  409148:	4618      	mov	r0, r3
  40914a:	3720      	adds	r7, #32
  40914c:	46bd      	mov	sp, r7
  40914e:	bd80      	pop	{r7, pc}
  409150:	2000b5b0 	.word	0x2000b5b0
  409154:	2000b5c4 	.word	0x2000b5c4
  409158:	0041cc08 	.word	0x0041cc08
  40915c:	0041cc64 	.word	0x0041cc64
  409160:	00416c7d 	.word	0x00416c7d
  409164:	004093c1 	.word	0x004093c1
  409168:	00409479 	.word	0x00409479
  40916c:	0041cce4 	.word	0x0041cce4
  409170:	0041cce8 	.word	0x0041cce8
  409174:	0041ccec 	.word	0x0041ccec
  409178:	0041267d 	.word	0x0041267d
  40917c:	00410d3b 	.word	0x00410d3b
  409180:	00412699 	.word	0x00412699
  409184:	0041cd10 	.word	0x0041cd10

00409188 <FreeRTOS_closesocket>:
 * In case of a TCP socket: the connection will not be closed automatically
 * Subsequent messages for the closed socket will be responded to with a RST
 * The IP-task will actually close the socket, after receiving a 'eSocketCloseEvent' message
 */
BaseType_t FreeRTOS_closesocket( Socket_t xSocket )
{
  409188:	b580      	push	{r7, lr}
  40918a:	b086      	sub	sp, #24
  40918c:	af00      	add	r7, sp, #0
  40918e:	6078      	str	r0, [r7, #4]
BaseType_t xResult;
#if( ipconfigUSE_TCP == 1 ) && ( ipconfigUSE_CALLBACKS == 1 )
	FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * )xSocket;
#endif
IPStackEvent_t xCloseEvent;
xCloseEvent.eEventType = eSocketCloseEvent;
  409190:	230a      	movs	r3, #10
  409192:	733b      	strb	r3, [r7, #12]
xCloseEvent.pvData = ( void * ) xSocket;
  409194:	687b      	ldr	r3, [r7, #4]
  409196:	613b      	str	r3, [r7, #16]

	if( ( xSocket == NULL ) || ( xSocket == FREERTOS_INVALID_SOCKET ) )
  409198:	687b      	ldr	r3, [r7, #4]
  40919a:	2b00      	cmp	r3, #0
  40919c:	d003      	beq.n	4091a6 <FreeRTOS_closesocket+0x1e>
  40919e:	687b      	ldr	r3, [r7, #4]
  4091a0:	f1b3 3fff 	cmp.w	r3, #4294967295
  4091a4:	d102      	bne.n	4091ac <FreeRTOS_closesocket+0x24>
	{
		xResult = 0;
  4091a6:	2300      	movs	r3, #0
  4091a8:	617b      	str	r3, [r7, #20]
  4091aa:	e011      	b.n	4091d0 <FreeRTOS_closesocket+0x48>
		packet handling. */

		/* Note when changing the time-out value below, it must be checked who is calling
		this function. If it is called by the IP-task, a deadlock could occur.
		The IP-task would only call it in case of a user call-back */
		if( xSendEventStructToIPTask( &xCloseEvent, ( TickType_t ) 0 ) == pdFAIL )
  4091ac:	f107 030c 	add.w	r3, r7, #12
  4091b0:	2100      	movs	r1, #0
  4091b2:	4618      	mov	r0, r3
  4091b4:	4b09      	ldr	r3, [pc, #36]	; (4091dc <FreeRTOS_closesocket+0x54>)
  4091b6:	4798      	blx	r3
  4091b8:	4603      	mov	r3, r0
  4091ba:	2b00      	cmp	r3, #0
  4091bc:	d106      	bne.n	4091cc <FreeRTOS_closesocket+0x44>
		{
			FreeRTOS_debug_printf( ( "FreeRTOS_closesocket: failed\n" ) );
  4091be:	4808      	ldr	r0, [pc, #32]	; (4091e0 <FreeRTOS_closesocket+0x58>)
  4091c0:	4b08      	ldr	r3, [pc, #32]	; (4091e4 <FreeRTOS_closesocket+0x5c>)
  4091c2:	4798      	blx	r3
			xResult = -1;
  4091c4:	f04f 33ff 	mov.w	r3, #4294967295
  4091c8:	617b      	str	r3, [r7, #20]
  4091ca:	e001      	b.n	4091d0 <FreeRTOS_closesocket+0x48>
		}
		else
		{
			xResult = 1;
  4091cc:	2301      	movs	r3, #1
  4091ce:	617b      	str	r3, [r7, #20]
		}
	}

	return xResult;
  4091d0:	697b      	ldr	r3, [r7, #20]
}
  4091d2:	4618      	mov	r0, r3
  4091d4:	3718      	adds	r7, #24
  4091d6:	46bd      	mov	sp, r7
  4091d8:	bd80      	pop	{r7, pc}
  4091da:	bf00      	nop
  4091dc:	00407e49 	.word	0x00407e49
  4091e0:	0041cd30 	.word	0x0041cd30
  4091e4:	00416c7d 	.word	0x00416c7d

004091e8 <vSocketClose>:

/* This is the internal version of FreeRTOS_closesocket()
 * It will be called by the IPtask only to avoid problems with synchronicity
 */
void *vSocketClose( FreeRTOS_Socket_t *pxSocket )
{
  4091e8:	b5f0      	push	{r4, r5, r6, r7, lr}
  4091ea:	b087      	sub	sp, #28
  4091ec:	af02      	add	r7, sp, #8
  4091ee:	6078      	str	r0, [r7, #4]
NetworkBufferDescriptor_t *pxNetworkBuffer;

	#if( ipconfigUSE_TCP == 1 )
	{
		/* For TCP: clean up a little more. */
		if( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_TCP )
  4091f0:	687b      	ldr	r3, [r7, #4]
  4091f2:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
  4091f6:	2b06      	cmp	r3, #6
  4091f8:	d122      	bne.n	409240 <vSocketClose+0x58>
		{
			#if( ipconfigUSE_TCP_WIN == 1 )
			{
				if( pxSocket->u.xTCP.pxAckMessage != NULL )
  4091fa:	687b      	ldr	r3, [r7, #4]
  4091fc:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  4091fe:	2b00      	cmp	r3, #0
  409200:	d004      	beq.n	40920c <vSocketClose+0x24>
				{
					vReleaseNetworkBufferAndDescriptor( pxSocket->u.xTCP.pxAckMessage );
  409202:	687b      	ldr	r3, [r7, #4]
  409204:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  409206:	4618      	mov	r0, r3
  409208:	4b36      	ldr	r3, [pc, #216]	; (4092e4 <vSocketClose+0xfc>)
  40920a:	4798      	blx	r3
				}
				/* Free the resources which were claimed by the tcpWin member */
				vTCPWindowDestroy( &pxSocket->u.xTCP.xTCPWindow );
  40920c:	687b      	ldr	r3, [r7, #4]
  40920e:	33d0      	adds	r3, #208	; 0xd0
  409210:	4618      	mov	r0, r3
  409212:	4b35      	ldr	r3, [pc, #212]	; (4092e8 <vSocketClose+0x100>)
  409214:	4798      	blx	r3
			}
			#endif /* ipconfigUSE_TCP_WIN */

			/* Free the input and output streams */
			if( pxSocket->u.xTCP.rxStream != NULL )
  409216:	687b      	ldr	r3, [r7, #4]
  409218:	6edb      	ldr	r3, [r3, #108]	; 0x6c
  40921a:	2b00      	cmp	r3, #0
  40921c:	d004      	beq.n	409228 <vSocketClose+0x40>
			{
				vPortFreeLarge( pxSocket->u.xTCP.rxStream );
  40921e:	687b      	ldr	r3, [r7, #4]
  409220:	6edb      	ldr	r3, [r3, #108]	; 0x6c
  409222:	4618      	mov	r0, r3
  409224:	4b31      	ldr	r3, [pc, #196]	; (4092ec <vSocketClose+0x104>)
  409226:	4798      	blx	r3
			}

			if( pxSocket->u.xTCP.txStream != NULL )
  409228:	687b      	ldr	r3, [r7, #4]
  40922a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  40922c:	2b00      	cmp	r3, #0
  40922e:	d004      	beq.n	40923a <vSocketClose+0x52>
			{
				vPortFreeLarge( pxSocket->u.xTCP.txStream );
  409230:	687b      	ldr	r3, [r7, #4]
  409232:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  409234:	4618      	mov	r0, r3
  409236:	4b2d      	ldr	r3, [pc, #180]	; (4092ec <vSocketClose+0x104>)
  409238:	4798      	blx	r3
			}

			/* In case this is a child socket, make sure the child-count of the
			parent socket is decreased. */
			prvTCPSetSocketCount( pxSocket );
  40923a:	6878      	ldr	r0, [r7, #4]
  40923c:	4b2c      	ldr	r3, [pc, #176]	; (4092f0 <vSocketClose+0x108>)
  40923e:	4798      	blx	r3
	}
	#endif  /* ipconfigUSE_TCP == 1 */

	/* Socket must be unbound first, to ensure no more packets are queued on
	it. */
	if( socketSOCKET_IS_BOUND( pxSocket ) != pdFALSE )
  409240:	687b      	ldr	r3, [r7, #4]
  409242:	699b      	ldr	r3, [r3, #24]
  409244:	2b00      	cmp	r3, #0
  409246:	d001      	beq.n	40924c <vSocketClose+0x64>
  409248:	2301      	movs	r3, #1
  40924a:	e000      	b.n	40924e <vSocketClose+0x66>
  40924c:	2300      	movs	r3, #0
  40924e:	2b00      	cmp	r3, #0
  409250:	d008      	beq.n	409264 <vSocketClose+0x7c>
		/* If the network driver can iterate through 'xBoundUDPSocketsList',
		by calling xPortHasUDPSocket(), then the IP-task must temporarily
		suspend the scheduler to keep the list in a consistent state. */
		#if( ipconfigETHERNET_DRIVER_FILTERS_PACKETS == 1 )
		{
			vTaskSuspendAll();
  409252:	4b28      	ldr	r3, [pc, #160]	; (4092f4 <vSocketClose+0x10c>)
  409254:	4798      	blx	r3
		}
		#endif /* ipconfigETHERNET_DRIVER_FILTERS_PACKETS */

		uxListRemove( &( pxSocket->xBoundSocketListItem ) );
  409256:	687b      	ldr	r3, [r7, #4]
  409258:	3308      	adds	r3, #8
  40925a:	4618      	mov	r0, r3
  40925c:	4b26      	ldr	r3, [pc, #152]	; (4092f8 <vSocketClose+0x110>)
  40925e:	4798      	blx	r3

		#if( ipconfigETHERNET_DRIVER_FILTERS_PACKETS == 1 )
		{
			xTaskResumeAll();
  409260:	4b26      	ldr	r3, [pc, #152]	; (4092fc <vSocketClose+0x114>)
  409262:	4798      	blx	r3
		#endif /* ipconfigETHERNET_DRIVER_FILTERS_PACKETS */
	}

	/* Now the socket is not bound the list of waiting packets can be
	drained. */
	if( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_UDP )
  409264:	687b      	ldr	r3, [r7, #4]
  409266:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
  40926a:	2b11      	cmp	r3, #17
  40926c:	d10f      	bne.n	40928e <vSocketClose+0xa6>
	{
		while( listCURRENT_LIST_LENGTH( &( pxSocket->u.xUDP.xWaitingPacketsList ) ) > 0U )
  40926e:	e00a      	b.n	409286 <vSocketClose+0x9e>
		{
			pxNetworkBuffer = ( NetworkBufferDescriptor_t * ) listGET_OWNER_OF_HEAD_ENTRY( &( pxSocket->u.xUDP.xWaitingPacketsList ) );
  409270:	687b      	ldr	r3, [r7, #4]
  409272:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  409274:	68db      	ldr	r3, [r3, #12]
  409276:	60fb      	str	r3, [r7, #12]
			uxListRemove( &( pxNetworkBuffer->xBufferListItem ) );
  409278:	68fb      	ldr	r3, [r7, #12]
  40927a:	4618      	mov	r0, r3
  40927c:	4b1e      	ldr	r3, [pc, #120]	; (4092f8 <vSocketClose+0x110>)
  40927e:	4798      	blx	r3
			vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
  409280:	68f8      	ldr	r0, [r7, #12]
  409282:	4b18      	ldr	r3, [pc, #96]	; (4092e4 <vSocketClose+0xfc>)
  409284:	4798      	blx	r3
		while( listCURRENT_LIST_LENGTH( &( pxSocket->u.xUDP.xWaitingPacketsList ) ) > 0U )
  409286:	687b      	ldr	r3, [r7, #4]
  409288:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  40928a:	2b00      	cmp	r3, #0
  40928c:	d1f0      	bne.n	409270 <vSocketClose+0x88>
		}
	}

	if( pxSocket->xEventGroup )
  40928e:	687b      	ldr	r3, [r7, #4]
  409290:	685b      	ldr	r3, [r3, #4]
  409292:	2b00      	cmp	r3, #0
  409294:	d004      	beq.n	4092a0 <vSocketClose+0xb8>
	{
		vEventGroupDelete( pxSocket->xEventGroup );
  409296:	687b      	ldr	r3, [r7, #4]
  409298:	685b      	ldr	r3, [r3, #4]
  40929a:	4618      	mov	r0, r3
  40929c:	4b18      	ldr	r3, [pc, #96]	; (409300 <vSocketClose+0x118>)
  40929e:	4798      	blx	r3
	}

	#if( ipconfigUSE_TCP == 1 ) && ( ipconfigHAS_DEBUG_PRINTF != 0 )
	{
		if( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_TCP )
  4092a0:	687b      	ldr	r3, [r7, #4]
  4092a2:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
  4092a6:	2b06      	cmp	r3, #6
  4092a8:	d114      	bne.n	4092d4 <vSocketClose+0xec>
		{
			FreeRTOS_debug_printf( ( "FreeRTOS_closesocket[%u to %lxip:%u]: buffers %lu socks %lu\n",
  4092aa:	687b      	ldr	r3, [r7, #4]
  4092ac:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
  4092ae:	461d      	mov	r5, r3
  4092b0:	687b      	ldr	r3, [r7, #4]
  4092b2:	6b9c      	ldr	r4, [r3, #56]	; 0x38
  4092b4:	687b      	ldr	r3, [r7, #4]
  4092b6:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
  4092b8:	461e      	mov	r6, r3
  4092ba:	4b12      	ldr	r3, [pc, #72]	; (409304 <vSocketClose+0x11c>)
  4092bc:	4798      	blx	r3
  4092be:	4602      	mov	r2, r0
  4092c0:	4b11      	ldr	r3, [pc, #68]	; (409308 <vSocketClose+0x120>)
  4092c2:	681b      	ldr	r3, [r3, #0]
  4092c4:	9301      	str	r3, [sp, #4]
  4092c6:	9200      	str	r2, [sp, #0]
  4092c8:	4633      	mov	r3, r6
  4092ca:	4622      	mov	r2, r4
  4092cc:	4629      	mov	r1, r5
  4092ce:	480f      	ldr	r0, [pc, #60]	; (40930c <vSocketClose+0x124>)
  4092d0:	4c0f      	ldr	r4, [pc, #60]	; (409310 <vSocketClose+0x128>)
  4092d2:	47a0      	blx	r4
		}
	}
	#endif /* ( ipconfigUSE_TCP == 1 ) && ( ipconfigHAS_DEBUG_PRINTF != 0 ) */

	/* Anf finally, after all resources have been freed, free the socket space */
	vPortFreeSocket( pxSocket );
  4092d4:	6878      	ldr	r0, [r7, #4]
  4092d6:	4b05      	ldr	r3, [pc, #20]	; (4092ec <vSocketClose+0x104>)
  4092d8:	4798      	blx	r3

	return 0;
  4092da:	2300      	movs	r3, #0
} /* Tested */
  4092dc:	4618      	mov	r0, r3
  4092de:	3714      	adds	r7, #20
  4092e0:	46bd      	mov	sp, r7
  4092e2:	bdf0      	pop	{r4, r5, r6, r7, pc}
  4092e4:	0040f2ed 	.word	0x0040f2ed
  4092e8:	0040de31 	.word	0x0040de31
  4092ec:	004113a1 	.word	0x004113a1
  4092f0:	00409315 	.word	0x00409315
  4092f4:	0041267d 	.word	0x0041267d
  4092f8:	00410df5 	.word	0x00410df5
  4092fc:	00412699 	.word	0x00412699
  409300:	00410c29 	.word	0x00410c29
  409304:	0040f369 	.word	0x0040f369
  409308:	2000b5b0 	.word	0x2000b5b0
  40930c:	0041cd50 	.word	0x0041cd50
  409310:	00416c7d 	.word	0x00416c7d

00409314 <prvTCPSetSocketCount>:
	 * When a child socket gets closed, make sure to update the child-count of the
	 * parent.  When a listening parent socket is closed, make sure no child-sockets
	 * keep a pointer to it.
	 */
	static void prvTCPSetSocketCount( FreeRTOS_Socket_t *pxSocketToDelete )
	{
  409314:	b590      	push	{r4, r7, lr}
  409316:	b089      	sub	sp, #36	; 0x24
  409318:	af02      	add	r7, sp, #8
  40931a:	6078      	str	r0, [r7, #4]
	const ListItem_t *pxIterator;
	const MiniListItem_t *pxEnd = ( const MiniListItem_t* )listGET_END_MARKER( &xBoundTCPSocketsList );
  40931c:	4b23      	ldr	r3, [pc, #140]	; (4093ac <prvTCPSetSocketCount+0x98>)
  40931e:	613b      	str	r3, [r7, #16]
	FreeRTOS_Socket_t *pxOtherSocket;
	uint16_t usLocalPort = pxSocketToDelete->usLocalPort;
  409320:	687b      	ldr	r3, [r7, #4]
  409322:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
  409324:	81fb      	strh	r3, [r7, #14]

		for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
  409326:	693b      	ldr	r3, [r7, #16]
  409328:	685b      	ldr	r3, [r3, #4]
  40932a:	617b      	str	r3, [r7, #20]
  40932c:	e035      	b.n	40939a <prvTCPSetSocketCount+0x86>
			 pxIterator != ( const ListItem_t * ) pxEnd;
			 pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxIterator ) )
		{
			pxOtherSocket = ( FreeRTOS_Socket_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
  40932e:	697b      	ldr	r3, [r7, #20]
  409330:	68db      	ldr	r3, [r3, #12]
  409332:	60bb      	str	r3, [r7, #8]
			if( ( pxOtherSocket->u.xTCP.ucTCPState == eTCP_LISTEN ) &&
  409334:	68bb      	ldr	r3, [r7, #8]
  409336:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
  40933a:	2b01      	cmp	r3, #1
  40933c:	d12a      	bne.n	409394 <prvTCPSetSocketCount+0x80>
				( pxOtherSocket->usLocalPort == usLocalPort ) &&
  40933e:	68bb      	ldr	r3, [r7, #8]
  409340:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
			if( ( pxOtherSocket->u.xTCP.ucTCPState == eTCP_LISTEN ) &&
  409342:	89fa      	ldrh	r2, [r7, #14]
  409344:	429a      	cmp	r2, r3
  409346:	d125      	bne.n	409394 <prvTCPSetSocketCount+0x80>
				( pxOtherSocket->u.xTCP.usChildCount ) )
  409348:	68bb      	ldr	r3, [r7, #8]
  40934a:	f8b3 304e 	ldrh.w	r3, [r3, #78]	; 0x4e
				( pxOtherSocket->usLocalPort == usLocalPort ) &&
  40934e:	2b00      	cmp	r3, #0
  409350:	d020      	beq.n	409394 <prvTCPSetSocketCount+0x80>
			{
				pxOtherSocket->u.xTCP.usChildCount--;
  409352:	68bb      	ldr	r3, [r7, #8]
  409354:	f8b3 304e 	ldrh.w	r3, [r3, #78]	; 0x4e
  409358:	3b01      	subs	r3, #1
  40935a:	b29a      	uxth	r2, r3
  40935c:	68bb      	ldr	r3, [r7, #8]
  40935e:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
				FreeRTOS_debug_printf( ( "Lost: Socket %u now has %u / %u child%s\n",
  409362:	68bb      	ldr	r3, [r7, #8]
  409364:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
  409366:	4619      	mov	r1, r3
  409368:	68bb      	ldr	r3, [r7, #8]
  40936a:	f8b3 304e 	ldrh.w	r3, [r3, #78]	; 0x4e
  40936e:	461a      	mov	r2, r3
  409370:	68bb      	ldr	r3, [r7, #8]
  409372:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
  409376:	4618      	mov	r0, r3
  409378:	68bb      	ldr	r3, [r7, #8]
  40937a:	f8b3 304e 	ldrh.w	r3, [r3, #78]	; 0x4e
  40937e:	2b01      	cmp	r3, #1
  409380:	d101      	bne.n	409386 <prvTCPSetSocketCount+0x72>
  409382:	4b0b      	ldr	r3, [pc, #44]	; (4093b0 <prvTCPSetSocketCount+0x9c>)
  409384:	e000      	b.n	409388 <prvTCPSetSocketCount+0x74>
  409386:	4b0b      	ldr	r3, [pc, #44]	; (4093b4 <prvTCPSetSocketCount+0xa0>)
  409388:	9300      	str	r3, [sp, #0]
  40938a:	4603      	mov	r3, r0
  40938c:	480a      	ldr	r0, [pc, #40]	; (4093b8 <prvTCPSetSocketCount+0xa4>)
  40938e:	4c0b      	ldr	r4, [pc, #44]	; (4093bc <prvTCPSetSocketCount+0xa8>)
  409390:	47a0      	blx	r4
					pxOtherSocket->usLocalPort,
					pxOtherSocket->u.xTCP.usChildCount,
					pxOtherSocket->u.xTCP.usBacklog,
					pxOtherSocket->u.xTCP.usChildCount == 1u ? "" : "ren" ) );
				break;
  409392:	e006      	b.n	4093a2 <prvTCPSetSocketCount+0x8e>
			 pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxIterator ) )
  409394:	697b      	ldr	r3, [r7, #20]
  409396:	685b      	ldr	r3, [r3, #4]
  409398:	617b      	str	r3, [r7, #20]
		for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
  40939a:	697a      	ldr	r2, [r7, #20]
  40939c:	693b      	ldr	r3, [r7, #16]
  40939e:	429a      	cmp	r2, r3
  4093a0:	d1c5      	bne.n	40932e <prvTCPSetSocketCount+0x1a>
			}
		}
	}
  4093a2:	bf00      	nop
  4093a4:	371c      	adds	r7, #28
  4093a6:	46bd      	mov	sp, r7
  4093a8:	bd90      	pop	{r4, r7, pc}
  4093aa:	bf00      	nop
  4093ac:	2000b5b8 	.word	0x2000b5b8
  4093b0:	0041cd90 	.word	0x0041cd90
  4093b4:	0041cd94 	.word	0x0041cd94
  4093b8:	0041cd98 	.word	0x0041cd98
  4093bc:	00416c7d 	.word	0x00416c7d

004093c0 <prvGetPrivatePortNumber>:

/*-----------------------------------------------------------*/

/* Find an available port number per https://tools.ietf.org/html/rfc6056. */
static uint16_t prvGetPrivatePortNumber( BaseType_t xProtocol )
{
  4093c0:	b580      	push	{r7, lr}
  4093c2:	b086      	sub	sp, #24
  4093c4:	af00      	add	r7, sp, #0
  4093c6:	6078      	str	r0, [r7, #4]
const uint16_t usEphemeralPortCount =
  4093c8:	f44f 437c 	mov.w	r3, #64512	; 0xfc00
  4093cc:	81fb      	strh	r3, [r7, #14]
	socketAUTO_PORT_ALLOCATION_MAX_NUMBER - socketAUTO_PORT_ALLOCATION_START_NUMBER + 1;
uint16_t usIterations = usEphemeralPortCount;
  4093ce:	89fb      	ldrh	r3, [r7, #14]
  4093d0:	82fb      	strh	r3, [r7, #22]
uint32_t ulRandomSeed = 0;
  4093d2:	2300      	movs	r3, #0
  4093d4:	60bb      	str	r3, [r7, #8]
uint16_t usResult = 0;
  4093d6:	2300      	movs	r3, #0
  4093d8:	82bb      	strh	r3, [r7, #20]
const List_t *pxList;

#if ipconfigUSE_TCP == 1
	if( xProtocol == ( BaseType_t ) FREERTOS_IPPROTO_TCP )
  4093da:	687b      	ldr	r3, [r7, #4]
  4093dc:	2b06      	cmp	r3, #6
  4093de:	d102      	bne.n	4093e6 <prvGetPrivatePortNumber+0x26>
	{
		pxList = &xBoundTCPSocketsList;
  4093e0:	4b21      	ldr	r3, [pc, #132]	; (409468 <prvGetPrivatePortNumber+0xa8>)
  4093e2:	613b      	str	r3, [r7, #16]
  4093e4:	e001      	b.n	4093ea <prvGetPrivatePortNumber+0x2a>
	}
	else
#endif
	{
		pxList = &xBoundUDPSocketsList;
  4093e6:	4b21      	ldr	r3, [pc, #132]	; (40946c <prvGetPrivatePortNumber+0xac>)
  4093e8:	613b      	str	r3, [r7, #16]
	/* Find the next available port using the random seed as a starting
	point. */
	do
	{
		/* Only proceed if the random number generator succeeded. */
		if( xApplicationGetRandomNumber( &( ulRandomSeed ) ) == pdFALSE )
  4093ea:	f107 0308 	add.w	r3, r7, #8
  4093ee:	4618      	mov	r0, r3
  4093f0:	4b1f      	ldr	r3, [pc, #124]	; (409470 <prvGetPrivatePortNumber+0xb0>)
  4093f2:	4798      	blx	r3
  4093f4:	4603      	mov	r3, r0
  4093f6:	2b00      	cmp	r3, #0
  4093f8:	d030      	beq.n	40945c <prvGetPrivatePortNumber+0x9c>
		}

		/* Map the random to a candidate port. */
		usResult =
			socketAUTO_PORT_ALLOCATION_START_NUMBER +
			( ( ( uint16_t )ulRandomSeed ) % usEphemeralPortCount );
  4093fa:	68bb      	ldr	r3, [r7, #8]
  4093fc:	b29b      	uxth	r3, r3
			socketAUTO_PORT_ALLOCATION_START_NUMBER +
  4093fe:	89fa      	ldrh	r2, [r7, #14]
  409400:	fbb3 f1f2 	udiv	r1, r3, r2
  409404:	fb02 f201 	mul.w	r2, r2, r1
  409408:	1a9b      	subs	r3, r3, r2
  40940a:	b29b      	uxth	r3, r3
		usResult =
  40940c:	f503 6380 	add.w	r3, r3, #1024	; 0x400
  409410:	82bb      	strh	r3, [r7, #20]

		/* Check if there's already an open socket with the same protocol
		and port. */
		if( NULL == pxListFindListItemWithValue(
			pxList,
			( TickType_t )FreeRTOS_htons( usResult ) ) )
  409412:	8abb      	ldrh	r3, [r7, #20]
  409414:	021b      	lsls	r3, r3, #8
  409416:	b21a      	sxth	r2, r3
  409418:	8abb      	ldrh	r3, [r7, #20]
  40941a:	0a1b      	lsrs	r3, r3, #8
  40941c:	b29b      	uxth	r3, r3
  40941e:	b21b      	sxth	r3, r3
  409420:	4313      	orrs	r3, r2
  409422:	b21b      	sxth	r3, r3
  409424:	b29b      	uxth	r3, r3
		if( NULL == pxListFindListItemWithValue(
  409426:	4619      	mov	r1, r3
  409428:	6938      	ldr	r0, [r7, #16]
  40942a:	4b12      	ldr	r3, [pc, #72]	; (409474 <prvGetPrivatePortNumber+0xb4>)
  40942c:	4798      	blx	r3
  40942e:	4603      	mov	r3, r0
  409430:	2b00      	cmp	r3, #0
  409432:	d10a      	bne.n	40944a <prvGetPrivatePortNumber+0x8a>
		{
			usResult = FreeRTOS_htons( usResult );
  409434:	8abb      	ldrh	r3, [r7, #20]
  409436:	021b      	lsls	r3, r3, #8
  409438:	b21a      	sxth	r2, r3
  40943a:	8abb      	ldrh	r3, [r7, #20]
  40943c:	0a1b      	lsrs	r3, r3, #8
  40943e:	b29b      	uxth	r3, r3
  409440:	b21b      	sxth	r3, r3
  409442:	4313      	orrs	r3, r2
  409444:	b21b      	sxth	r3, r3
  409446:	82bb      	strh	r3, [r7, #20]
			break;
  409448:	e009      	b.n	40945e <prvGetPrivatePortNumber+0x9e>
		}
		else
		{
			usResult = 0;
  40944a:	2300      	movs	r3, #0
  40944c:	82bb      	strh	r3, [r7, #20]
		}

		usIterations--;
  40944e:	8afb      	ldrh	r3, [r7, #22]
  409450:	3b01      	subs	r3, #1
  409452:	82fb      	strh	r3, [r7, #22]
	}
	while( usIterations > 0 );
  409454:	8afb      	ldrh	r3, [r7, #22]
  409456:	2b00      	cmp	r3, #0
  409458:	d1c7      	bne.n	4093ea <prvGetPrivatePortNumber+0x2a>
  40945a:	e000      	b.n	40945e <prvGetPrivatePortNumber+0x9e>
			break;
  40945c:	bf00      	nop

	return usResult;
  40945e:	8abb      	ldrh	r3, [r7, #20]
}
  409460:	4618      	mov	r0, r3
  409462:	3718      	adds	r7, #24
  409464:	46bd      	mov	sp, r7
  409466:	bd80      	pop	{r7, pc}
  409468:	2000b5b0 	.word	0x2000b5b0
  40946c:	2000b5c4 	.word	0x2000b5c4
  409470:	00415e7d 	.word	0x00415e7d
  409474:	00409479 	.word	0x00409479

00409478 <pxListFindListItemWithValue>:
/*-----------------------------------------------------------*/

/* pxListFindListItemWithValue: find a list item in a bound socket list
'xWantedItemValue' refers to a port number */
static const ListItem_t * pxListFindListItemWithValue( const List_t *pxList, TickType_t xWantedItemValue )
{
  409478:	b580      	push	{r7, lr}
  40947a:	b086      	sub	sp, #24
  40947c:	af00      	add	r7, sp, #0
  40947e:	6078      	str	r0, [r7, #4]
  409480:	6039      	str	r1, [r7, #0]
const ListItem_t * pxResult = NULL;
  409482:	2300      	movs	r3, #0
  409484:	617b      	str	r3, [r7, #20]

	if( ( xIPIsNetworkTaskReady() != pdFALSE ) && ( pxList != NULL ) )
  409486:	4b11      	ldr	r3, [pc, #68]	; (4094cc <pxListFindListItemWithValue+0x54>)
  409488:	4798      	blx	r3
  40948a:	4603      	mov	r3, r0
  40948c:	2b00      	cmp	r3, #0
  40948e:	d018      	beq.n	4094c2 <pxListFindListItemWithValue+0x4a>
  409490:	687b      	ldr	r3, [r7, #4]
  409492:	2b00      	cmp	r3, #0
  409494:	d015      	beq.n	4094c2 <pxListFindListItemWithValue+0x4a>
	{
		const ListItem_t *pxIterator;
		const MiniListItem_t *pxEnd = ( const MiniListItem_t* )listGET_END_MARKER( pxList );
  409496:	687b      	ldr	r3, [r7, #4]
  409498:	3308      	adds	r3, #8
  40949a:	60fb      	str	r3, [r7, #12]
		for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
  40949c:	68fb      	ldr	r3, [r7, #12]
  40949e:	685b      	ldr	r3, [r3, #4]
  4094a0:	613b      	str	r3, [r7, #16]
  4094a2:	e00a      	b.n	4094ba <pxListFindListItemWithValue+0x42>
			 pxIterator != ( const ListItem_t * ) pxEnd;
			 pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxIterator ) )
		{
			if( listGET_LIST_ITEM_VALUE( pxIterator ) == xWantedItemValue )
  4094a4:	693b      	ldr	r3, [r7, #16]
  4094a6:	681a      	ldr	r2, [r3, #0]
  4094a8:	683b      	ldr	r3, [r7, #0]
  4094aa:	429a      	cmp	r2, r3
  4094ac:	d102      	bne.n	4094b4 <pxListFindListItemWithValue+0x3c>
			{
				pxResult = pxIterator;
  4094ae:	693b      	ldr	r3, [r7, #16]
  4094b0:	617b      	str	r3, [r7, #20]
				break;
  4094b2:	e006      	b.n	4094c2 <pxListFindListItemWithValue+0x4a>
			 pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxIterator ) )
  4094b4:	693b      	ldr	r3, [r7, #16]
  4094b6:	685b      	ldr	r3, [r3, #4]
  4094b8:	613b      	str	r3, [r7, #16]
		for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
  4094ba:	693a      	ldr	r2, [r7, #16]
  4094bc:	68fb      	ldr	r3, [r7, #12]
  4094be:	429a      	cmp	r2, r3
  4094c0:	d1f0      	bne.n	4094a4 <pxListFindListItemWithValue+0x2c>
			}
		}
	}

	return pxResult;
  4094c2:	697b      	ldr	r3, [r7, #20]
} /* Tested */
  4094c4:	4618      	mov	r0, r3
  4094c6:	3718      	adds	r7, #24
  4094c8:	46bd      	mov	sp, r7
  4094ca:	bd80      	pop	{r7, pc}
  4094cc:	004087b5 	.word	0x004087b5

004094d0 <pxUDPSocketLookup>:

/*-----------------------------------------------------------*/

FreeRTOS_Socket_t *pxUDPSocketLookup( UBaseType_t uxLocalPort )
{
  4094d0:	b580      	push	{r7, lr}
  4094d2:	b084      	sub	sp, #16
  4094d4:	af00      	add	r7, sp, #0
  4094d6:	6078      	str	r0, [r7, #4]
const ListItem_t *pxListItem;
FreeRTOS_Socket_t *pxSocket = NULL;
  4094d8:	2300      	movs	r3, #0
  4094da:	60fb      	str	r3, [r7, #12]

	/* Looking up a socket is quite simple, find a match with the local port.

	See if there is a list item associated with the port number on the
	list of bound sockets. */
	pxListItem = pxListFindListItemWithValue( &xBoundUDPSocketsList, ( TickType_t ) uxLocalPort );
  4094dc:	6879      	ldr	r1, [r7, #4]
  4094de:	480c      	ldr	r0, [pc, #48]	; (409510 <pxUDPSocketLookup+0x40>)
  4094e0:	4b0c      	ldr	r3, [pc, #48]	; (409514 <pxUDPSocketLookup+0x44>)
  4094e2:	4798      	blx	r3
  4094e4:	60b8      	str	r0, [r7, #8]

	if( pxListItem != NULL )
  4094e6:	68bb      	ldr	r3, [r7, #8]
  4094e8:	2b00      	cmp	r3, #0
  4094ea:	d00b      	beq.n	409504 <pxUDPSocketLookup+0x34>
	{
		/* The owner of the list item is the socket itself. */
		pxSocket = ( FreeRTOS_Socket_t * ) listGET_LIST_ITEM_OWNER( pxListItem );
  4094ec:	68bb      	ldr	r3, [r7, #8]
  4094ee:	68db      	ldr	r3, [r3, #12]
  4094f0:	60fb      	str	r3, [r7, #12]
		configASSERT( pxSocket != NULL );
  4094f2:	68fb      	ldr	r3, [r7, #12]
  4094f4:	2b00      	cmp	r3, #0
  4094f6:	d105      	bne.n	409504 <pxUDPSocketLookup+0x34>
  4094f8:	f240 62dd 	movw	r2, #1757	; 0x6dd
  4094fc:	4906      	ldr	r1, [pc, #24]	; (409518 <pxUDPSocketLookup+0x48>)
  4094fe:	4807      	ldr	r0, [pc, #28]	; (40951c <pxUDPSocketLookup+0x4c>)
  409500:	4b07      	ldr	r3, [pc, #28]	; (409520 <pxUDPSocketLookup+0x50>)
  409502:	4798      	blx	r3
	}
	return pxSocket;
  409504:	68fb      	ldr	r3, [r7, #12]
}
  409506:	4618      	mov	r0, r3
  409508:	3710      	adds	r7, #16
  40950a:	46bd      	mov	sp, r7
  40950c:	bd80      	pop	{r7, pc}
  40950e:	bf00      	nop
  409510:	2000b5c4 	.word	0x2000b5c4
  409514:	00409479 	.word	0x00409479
  409518:	0041cc08 	.word	0x0041cc08
  40951c:	0041cc64 	.word	0x0041cc64
  409520:	00416c7d 	.word	0x00416c7d

00409524 <FreeRTOS_inet_addr>:
/*-----------------------------------------------------------*/

#if ipconfigINCLUDE_FULL_INET_ADDR == 1

	uint32_t FreeRTOS_inet_addr( const char * pcIPAddress )
	{
  409524:	b480      	push	{r7}
  409526:	b08b      	sub	sp, #44	; 0x2c
  409528:	af00      	add	r7, sp, #0
  40952a:	6078      	str	r0, [r7, #4]
	const uint32_t ulDecimalBase = 10u;
  40952c:	230a      	movs	r3, #10
  40952e:	617b      	str	r3, [r7, #20]
	uint8_t ucOctet[ socketMAX_IP_ADDRESS_OCTETS ];
	const char *pcPointerOnEntering;
	uint32_t ulReturn = 0UL, ulValue;
  409530:	2300      	movs	r3, #0
  409532:	627b      	str	r3, [r7, #36]	; 0x24
	UBaseType_t uxOctetNumber;
	BaseType_t xResult = pdPASS;
  409534:	2301      	movs	r3, #1
  409536:	61bb      	str	r3, [r7, #24]

		for( uxOctetNumber = 0u; uxOctetNumber < socketMAX_IP_ADDRESS_OCTETS; uxOctetNumber++ )
  409538:	2300      	movs	r3, #0
  40953a:	61fb      	str	r3, [r7, #28]
  40953c:	e042      	b.n	4095c4 <FreeRTOS_inet_addr+0xa0>
		{
			ulValue = 0ul;
  40953e:	2300      	movs	r3, #0
  409540:	623b      	str	r3, [r7, #32]
			pcPointerOnEntering = pcIPAddress;
  409542:	687b      	ldr	r3, [r7, #4]
  409544:	613b      	str	r3, [r7, #16]

			while( ( *pcIPAddress >= '0' ) && ( *pcIPAddress <= '9' ) )
  409546:	e00e      	b.n	409566 <FreeRTOS_inet_addr+0x42>
			{
				/* Move previous read characters into the next decimal
				position. */
				ulValue *= ulDecimalBase;
  409548:	6a3b      	ldr	r3, [r7, #32]
  40954a:	697a      	ldr	r2, [r7, #20]
  40954c:	fb02 f303 	mul.w	r3, r2, r3
  409550:	623b      	str	r3, [r7, #32]

				/* Add the binary value of the ascii character. */
				ulValue += ( ( uint32_t ) ( *pcIPAddress ) - ( uint32_t ) '0' );
  409552:	687b      	ldr	r3, [r7, #4]
  409554:	781b      	ldrb	r3, [r3, #0]
  409556:	461a      	mov	r2, r3
  409558:	6a3b      	ldr	r3, [r7, #32]
  40955a:	4413      	add	r3, r2
  40955c:	3b30      	subs	r3, #48	; 0x30
  40955e:	623b      	str	r3, [r7, #32]

				/* Move to next character in the string. */
				pcIPAddress++;
  409560:	687b      	ldr	r3, [r7, #4]
  409562:	3301      	adds	r3, #1
  409564:	607b      	str	r3, [r7, #4]
			while( ( *pcIPAddress >= '0' ) && ( *pcIPAddress <= '9' ) )
  409566:	687b      	ldr	r3, [r7, #4]
  409568:	781b      	ldrb	r3, [r3, #0]
  40956a:	2b2f      	cmp	r3, #47	; 0x2f
  40956c:	d903      	bls.n	409576 <FreeRTOS_inet_addr+0x52>
  40956e:	687b      	ldr	r3, [r7, #4]
  409570:	781b      	ldrb	r3, [r3, #0]
  409572:	2b39      	cmp	r3, #57	; 0x39
  409574:	d9e8      	bls.n	409548 <FreeRTOS_inet_addr+0x24>
			}

			/* Check characters were read. */
			if( pcIPAddress == pcPointerOnEntering )
  409576:	687a      	ldr	r2, [r7, #4]
  409578:	693b      	ldr	r3, [r7, #16]
  40957a:	429a      	cmp	r2, r3
  40957c:	d101      	bne.n	409582 <FreeRTOS_inet_addr+0x5e>
			{
				xResult = pdFAIL;
  40957e:	2300      	movs	r3, #0
  409580:	61bb      	str	r3, [r7, #24]
			}

			/* Check the value fits in an 8-bit number. */
			if( ulValue > 0xffUL )
  409582:	6a3b      	ldr	r3, [r7, #32]
  409584:	2bff      	cmp	r3, #255	; 0xff
  409586:	d902      	bls.n	40958e <FreeRTOS_inet_addr+0x6a>
			{
				xResult = pdFAIL;
  409588:	2300      	movs	r3, #0
  40958a:	61bb      	str	r3, [r7, #24]
  40958c:	e014      	b.n	4095b8 <FreeRTOS_inet_addr+0x94>
			}
			else
			{
				ucOctet[ uxOctetNumber ] = ( uint8_t ) ulValue;
  40958e:	6a3b      	ldr	r3, [r7, #32]
  409590:	b2d9      	uxtb	r1, r3
  409592:	f107 020c 	add.w	r2, r7, #12
  409596:	69fb      	ldr	r3, [r7, #28]
  409598:	4413      	add	r3, r2
  40959a:	460a      	mov	r2, r1
  40959c:	701a      	strb	r2, [r3, #0]

				/* Check the next character is as expected. */
				if( uxOctetNumber < ( socketMAX_IP_ADDRESS_OCTETS - 1u ) )
  40959e:	69fb      	ldr	r3, [r7, #28]
  4095a0:	2b02      	cmp	r3, #2
  4095a2:	d809      	bhi.n	4095b8 <FreeRTOS_inet_addr+0x94>
				{
					if( *pcIPAddress != '.' )
  4095a4:	687b      	ldr	r3, [r7, #4]
  4095a6:	781b      	ldrb	r3, [r3, #0]
  4095a8:	2b2e      	cmp	r3, #46	; 0x2e
  4095aa:	d002      	beq.n	4095b2 <FreeRTOS_inet_addr+0x8e>
					{
						xResult = pdFAIL;
  4095ac:	2300      	movs	r3, #0
  4095ae:	61bb      	str	r3, [r7, #24]
  4095b0:	e002      	b.n	4095b8 <FreeRTOS_inet_addr+0x94>
					}
					else
					{
						/* Move past the dot. */
						pcIPAddress++;
  4095b2:	687b      	ldr	r3, [r7, #4]
  4095b4:	3301      	adds	r3, #1
  4095b6:	607b      	str	r3, [r7, #4]
					}
				}
			}

			if( xResult == pdFAIL )
  4095b8:	69bb      	ldr	r3, [r7, #24]
  4095ba:	2b00      	cmp	r3, #0
  4095bc:	d006      	beq.n	4095cc <FreeRTOS_inet_addr+0xa8>
		for( uxOctetNumber = 0u; uxOctetNumber < socketMAX_IP_ADDRESS_OCTETS; uxOctetNumber++ )
  4095be:	69fb      	ldr	r3, [r7, #28]
  4095c0:	3301      	adds	r3, #1
  4095c2:	61fb      	str	r3, [r7, #28]
  4095c4:	69fb      	ldr	r3, [r7, #28]
  4095c6:	2b03      	cmp	r3, #3
  4095c8:	d9b9      	bls.n	40953e <FreeRTOS_inet_addr+0x1a>
  4095ca:	e000      	b.n	4095ce <FreeRTOS_inet_addr+0xaa>
			{
				/* No point going on. */
				break;
  4095cc:	bf00      	nop
			}
		}

		if( *pcIPAddress != ( char ) 0 )
  4095ce:	687b      	ldr	r3, [r7, #4]
  4095d0:	781b      	ldrb	r3, [r3, #0]
  4095d2:	2b00      	cmp	r3, #0
  4095d4:	d001      	beq.n	4095da <FreeRTOS_inet_addr+0xb6>
		{
			/* Expected the end of the string. */
			xResult = pdFAIL;
  4095d6:	2300      	movs	r3, #0
  4095d8:	61bb      	str	r3, [r7, #24]
		}

		if( uxOctetNumber != socketMAX_IP_ADDRESS_OCTETS )
  4095da:	69fb      	ldr	r3, [r7, #28]
  4095dc:	2b04      	cmp	r3, #4
  4095de:	d001      	beq.n	4095e4 <FreeRTOS_inet_addr+0xc0>
		{
			/* Didn't read enough octets. */
			xResult = pdFAIL;
  4095e0:	2300      	movs	r3, #0
  4095e2:	61bb      	str	r3, [r7, #24]
		}

		if( xResult == pdPASS )
  4095e4:	69bb      	ldr	r3, [r7, #24]
  4095e6:	2b01      	cmp	r3, #1
  4095e8:	d10a      	bne.n	409600 <FreeRTOS_inet_addr+0xdc>
		{
			ulReturn = FreeRTOS_inet_addr_quick( ucOctet[ 0 ], ucOctet[ 1 ], ucOctet[ 2 ], ucOctet[ 3 ] );
  4095ea:	7bfb      	ldrb	r3, [r7, #15]
  4095ec:	061a      	lsls	r2, r3, #24
  4095ee:	7bbb      	ldrb	r3, [r7, #14]
  4095f0:	041b      	lsls	r3, r3, #16
  4095f2:	431a      	orrs	r2, r3
  4095f4:	7b7b      	ldrb	r3, [r7, #13]
  4095f6:	021b      	lsls	r3, r3, #8
  4095f8:	4313      	orrs	r3, r2
  4095fa:	7b3a      	ldrb	r2, [r7, #12]
  4095fc:	4313      	orrs	r3, r2
  4095fe:	627b      	str	r3, [r7, #36]	; 0x24
		}

		return ulReturn;
  409600:	6a7b      	ldr	r3, [r7, #36]	; 0x24
	}
  409602:	4618      	mov	r0, r3
  409604:	372c      	adds	r7, #44	; 0x2c
  409606:	46bd      	mov	sp, r7
  409608:	f85d 7b04 	ldr.w	r7, [sp], #4
  40960c:	4770      	bx	lr
	...

00409610 <vSocketWakeUpUser>:
}

/*-----------------------------------------------------------*/

void vSocketWakeUpUser( FreeRTOS_Socket_t *pxSocket )
{
  409610:	b580      	push	{r7, lr}
  409612:	b084      	sub	sp, #16
  409614:	af00      	add	r7, sp, #0
  409616:	6078      	str	r0, [r7, #4]
	}
	#endif /* ipconfigSOCKET_HAS_USER_SEMAPHORE */

	#if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
	{
		if( pxSocket->pxSocketSet != NULL )
  409618:	687b      	ldr	r3, [r7, #4]
  40961a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  40961c:	2b00      	cmp	r3, #0
  40961e:	d015      	beq.n	40964c <vSocketWakeUpUser+0x3c>
		{
			EventBits_t xSelectBits = ( pxSocket->xEventBits >> SOCKET_EVENT_BIT_COUNT ) & eSELECT_ALL;
  409620:	687b      	ldr	r3, [r7, #4]
  409622:	681b      	ldr	r3, [r3, #0]
  409624:	0a1b      	lsrs	r3, r3, #8
  409626:	f003 030f 	and.w	r3, r3, #15
  40962a:	60fb      	str	r3, [r7, #12]
			if( xSelectBits != 0ul )
  40962c:	68fb      	ldr	r3, [r7, #12]
  40962e:	2b00      	cmp	r3, #0
  409630:	d00c      	beq.n	40964c <vSocketWakeUpUser+0x3c>
			{
				pxSocket->xSocketBits |= xSelectBits;
  409632:	687b      	ldr	r3, [r7, #4]
  409634:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  409636:	68fb      	ldr	r3, [r7, #12]
  409638:	431a      	orrs	r2, r3
  40963a:	687b      	ldr	r3, [r7, #4]
  40963c:	631a      	str	r2, [r3, #48]	; 0x30
				xEventGroupSetBits( pxSocket->pxSocketSet->xSelectGroup, xSelectBits );
  40963e:	687b      	ldr	r3, [r7, #4]
  409640:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  409642:	681b      	ldr	r3, [r3, #0]
  409644:	68f9      	ldr	r1, [r7, #12]
  409646:	4618      	mov	r0, r3
  409648:	4b0f      	ldr	r3, [pc, #60]	; (409688 <vSocketWakeUpUser+0x78>)
  40964a:	4798      	blx	r3
			}
		}

		pxSocket->xEventBits &= eSOCKET_ALL;
  40964c:	687b      	ldr	r3, [r7, #4]
  40964e:	681b      	ldr	r3, [r3, #0]
  409650:	f003 027f 	and.w	r2, r3, #127	; 0x7f
  409654:	687b      	ldr	r3, [r7, #4]
  409656:	601a      	str	r2, [r3, #0]
	}
	#endif /* ipconfigSUPPORT_SELECT_FUNCTION */

	if( ( pxSocket->xEventGroup != NULL ) && ( pxSocket->xEventBits != 0u ) )
  409658:	687b      	ldr	r3, [r7, #4]
  40965a:	685b      	ldr	r3, [r3, #4]
  40965c:	2b00      	cmp	r3, #0
  40965e:	d00b      	beq.n	409678 <vSocketWakeUpUser+0x68>
  409660:	687b      	ldr	r3, [r7, #4]
  409662:	681b      	ldr	r3, [r3, #0]
  409664:	2b00      	cmp	r3, #0
  409666:	d007      	beq.n	409678 <vSocketWakeUpUser+0x68>
	{
		xEventGroupSetBits( pxSocket->xEventGroup, pxSocket->xEventBits );
  409668:	687b      	ldr	r3, [r7, #4]
  40966a:	685a      	ldr	r2, [r3, #4]
  40966c:	687b      	ldr	r3, [r7, #4]
  40966e:	681b      	ldr	r3, [r3, #0]
  409670:	4619      	mov	r1, r3
  409672:	4610      	mov	r0, r2
  409674:	4b04      	ldr	r3, [pc, #16]	; (409688 <vSocketWakeUpUser+0x78>)
  409676:	4798      	blx	r3
	}

	pxSocket->xEventBits = 0ul;
  409678:	687b      	ldr	r3, [r7, #4]
  40967a:	2200      	movs	r2, #0
  40967c:	601a      	str	r2, [r3, #0]
}
  40967e:	bf00      	nop
  409680:	3710      	adds	r7, #16
  409682:	46bd      	mov	sp, r7
  409684:	bd80      	pop	{r7, pc}
  409686:	bf00      	nop
  409688:	00410b0d 	.word	0x00410b0d

0040968c <bMayConnect>:

#if( ipconfigUSE_TCP == 1 )

	static BaseType_t bMayConnect( FreeRTOS_Socket_t *pxSocket );
	static BaseType_t bMayConnect( FreeRTOS_Socket_t *pxSocket )
	{
  40968c:	b480      	push	{r7}
  40968e:	b083      	sub	sp, #12
  409690:	af00      	add	r7, sp, #0
  409692:	6078      	str	r0, [r7, #4]
		switch( pxSocket->u.xTCP.ucTCPState )
  409694:	687b      	ldr	r3, [r7, #4]
  409696:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
  40969a:	2b02      	cmp	r3, #2
  40969c:	d005      	beq.n	4096aa <bMayConnect+0x1e>
  40969e:	2b08      	cmp	r3, #8
  4096a0:	d001      	beq.n	4096a6 <bMayConnect+0x1a>
  4096a2:	2b00      	cmp	r3, #0
  4096a4:	d104      	bne.n	4096b0 <bMayConnect+0x24>
		{
			case eCLOSED:
			case eCLOSE_WAIT:	return 0;
  4096a6:	2300      	movs	r3, #0
  4096a8:	e004      	b.n	4096b4 <bMayConnect+0x28>
			case eCONNECT_SYN:	return -pdFREERTOS_ERRNO_EINPROGRESS;
  4096aa:	f06f 0376 	mvn.w	r3, #118	; 0x76
  4096ae:	e001      	b.n	4096b4 <bMayConnect+0x28>
			default:			return -pdFREERTOS_ERRNO_EAGAIN;
  4096b0:	f06f 030a 	mvn.w	r3, #10
		}
	}
  4096b4:	4618      	mov	r0, r3
  4096b6:	370c      	adds	r7, #12
  4096b8:	46bd      	mov	sp, r7
  4096ba:	f85d 7b04 	ldr.w	r7, [sp], #4
  4096be:	4770      	bx	lr

004096c0 <prvTCPConnectStart>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP == 1 )

	static BaseType_t prvTCPConnectStart( FreeRTOS_Socket_t *pxSocket, struct freertos_sockaddr *pxAddress )
	{
  4096c0:	b590      	push	{r4, r7, lr}
  4096c2:	b085      	sub	sp, #20
  4096c4:	af00      	add	r7, sp, #0
  4096c6:	6078      	str	r0, [r7, #4]
  4096c8:	6039      	str	r1, [r7, #0]
	BaseType_t xResult = 0;
  4096ca:	2300      	movs	r3, #0
  4096cc:	60fb      	str	r3, [r7, #12]

		if( prvValidSocket( pxSocket, FREERTOS_IPPROTO_TCP, pdFALSE ) == pdFALSE )
  4096ce:	2200      	movs	r2, #0
  4096d0:	2106      	movs	r1, #6
  4096d2:	6878      	ldr	r0, [r7, #4]
  4096d4:	4b49      	ldr	r3, [pc, #292]	; (4097fc <prvTCPConnectStart+0x13c>)
  4096d6:	4798      	blx	r3
  4096d8:	4603      	mov	r3, r0
  4096da:	2b00      	cmp	r3, #0
  4096dc:	d103      	bne.n	4096e6 <prvTCPConnectStart+0x26>
		{
			/* Not a valid socket or wrong type */
			xResult = -pdFREERTOS_ERRNO_EBADF;
  4096de:	f06f 0308 	mvn.w	r3, #8
  4096e2:	60fb      	str	r3, [r7, #12]
  4096e4:	e013      	b.n	40970e <prvTCPConnectStart+0x4e>
		}
		else if( FreeRTOS_issocketconnected( pxSocket ) > 0 )
  4096e6:	6878      	ldr	r0, [r7, #4]
  4096e8:	4b45      	ldr	r3, [pc, #276]	; (409800 <prvTCPConnectStart+0x140>)
  4096ea:	4798      	blx	r3
  4096ec:	4603      	mov	r3, r0
  4096ee:	2b00      	cmp	r3, #0
  4096f0:	dd03      	ble.n	4096fa <prvTCPConnectStart+0x3a>
		{
			/* The socket is already connected. */
			xResult = -pdFREERTOS_ERRNO_EISCONN;
  4096f2:	f06f 037e 	mvn.w	r3, #126	; 0x7e
  4096f6:	60fb      	str	r3, [r7, #12]
  4096f8:	e009      	b.n	40970e <prvTCPConnectStart+0x4e>
		}
		else if( socketSOCKET_IS_BOUND( pxSocket ) == pdFALSE )
  4096fa:	687b      	ldr	r3, [r7, #4]
  4096fc:	699b      	ldr	r3, [r3, #24]
  4096fe:	2b00      	cmp	r3, #0
  409700:	d105      	bne.n	40970e <prvTCPConnectStart+0x4e>
		{
			/* Bind the socket to the port that the client task will send from.
			Non-standard, so the error returned is that returned by bind(). */
			xResult = FreeRTOS_bind( ( Socket_t ) pxSocket, NULL, 0u );
  409702:	2200      	movs	r2, #0
  409704:	2100      	movs	r1, #0
  409706:	6878      	ldr	r0, [r7, #4]
  409708:	4b3e      	ldr	r3, [pc, #248]	; (409804 <prvTCPConnectStart+0x144>)
  40970a:	4798      	blx	r3
  40970c:	60f8      	str	r0, [r7, #12]
		}

		if( xResult == 0 )
  40970e:	68fb      	ldr	r3, [r7, #12]
  409710:	2b00      	cmp	r3, #0
  409712:	d16d      	bne.n	4097f0 <prvTCPConnectStart+0x130>
		{
			/* Check if it makes any sense to wait for a connect event, this condition
			might change while sleeping, so it must be checked within each loop */
			xResult = bMayConnect( pxSocket ); /* -EINPROGRESS, -EAGAIN, or 0 for OK */
  409714:	6878      	ldr	r0, [r7, #4]
  409716:	4b3c      	ldr	r3, [pc, #240]	; (409808 <prvTCPConnectStart+0x148>)
  409718:	4798      	blx	r3
  40971a:	60f8      	str	r0, [r7, #12]

			/* Start the connect procedure, kernel will start working on it */
			if( xResult == 0 )
  40971c:	68fb      	ldr	r3, [r7, #12]
  40971e:	2b00      	cmp	r3, #0
  409720:	d166      	bne.n	4097f0 <prvTCPConnectStart+0x130>
			{
				pxSocket->u.xTCP.bits.bConnPrepared = pdFALSE_UNSIGNED;
  409722:	687a      	ldr	r2, [r7, #4]
  409724:	f892 3041 	ldrb.w	r3, [r2, #65]	; 0x41
  409728:	f36f 03c3 	bfc	r3, #3, #1
  40972c:	f882 3041 	strb.w	r3, [r2, #65]	; 0x41
				pxSocket->u.xTCP.ucRepCount = 0u;
  409730:	687b      	ldr	r3, [r7, #4]
  409732:	2200      	movs	r2, #0
  409734:	f883 2052 	strb.w	r2, [r3, #82]	; 0x52

				FreeRTOS_debug_printf( ( "FreeRTOS_connect: %u to %lxip:%u\n",
  409738:	687b      	ldr	r3, [r7, #4]
  40973a:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
  40973c:	4618      	mov	r0, r3
  40973e:	683b      	ldr	r3, [r7, #0]
  409740:	685b      	ldr	r3, [r3, #4]
  409742:	061a      	lsls	r2, r3, #24
  409744:	683b      	ldr	r3, [r7, #0]
  409746:	685b      	ldr	r3, [r3, #4]
  409748:	021b      	lsls	r3, r3, #8
  40974a:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
  40974e:	431a      	orrs	r2, r3
  409750:	683b      	ldr	r3, [r7, #0]
  409752:	685b      	ldr	r3, [r3, #4]
  409754:	0a1b      	lsrs	r3, r3, #8
  409756:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
  40975a:	431a      	orrs	r2, r3
  40975c:	683b      	ldr	r3, [r7, #0]
  40975e:	685b      	ldr	r3, [r3, #4]
  409760:	0e1b      	lsrs	r3, r3, #24
  409762:	ea42 0103 	orr.w	r1, r2, r3
  409766:	683b      	ldr	r3, [r7, #0]
  409768:	885b      	ldrh	r3, [r3, #2]
  40976a:	021b      	lsls	r3, r3, #8
  40976c:	b21a      	sxth	r2, r3
  40976e:	683b      	ldr	r3, [r7, #0]
  409770:	885b      	ldrh	r3, [r3, #2]
  409772:	0a1b      	lsrs	r3, r3, #8
  409774:	b29b      	uxth	r3, r3
  409776:	b21b      	sxth	r3, r3
  409778:	4313      	orrs	r3, r2
  40977a:	b21b      	sxth	r3, r3
  40977c:	b29b      	uxth	r3, r3
  40977e:	460a      	mov	r2, r1
  409780:	4601      	mov	r1, r0
  409782:	4822      	ldr	r0, [pc, #136]	; (40980c <prvTCPConnectStart+0x14c>)
  409784:	4c22      	ldr	r4, [pc, #136]	; (409810 <prvTCPConnectStart+0x150>)
  409786:	47a0      	blx	r4
					pxSocket->usLocalPort, FreeRTOS_ntohl( pxAddress->sin_addr ), FreeRTOS_ntohs( pxAddress->sin_port ) ) );

				/* Port on remote machine. */
				pxSocket->u.xTCP.usRemotePort = FreeRTOS_ntohs( pxAddress->sin_port );
  409788:	683b      	ldr	r3, [r7, #0]
  40978a:	885b      	ldrh	r3, [r3, #2]
  40978c:	021b      	lsls	r3, r3, #8
  40978e:	b21a      	sxth	r2, r3
  409790:	683b      	ldr	r3, [r7, #0]
  409792:	885b      	ldrh	r3, [r3, #2]
  409794:	0a1b      	lsrs	r3, r3, #8
  409796:	b29b      	uxth	r3, r3
  409798:	b21b      	sxth	r3, r3
  40979a:	4313      	orrs	r3, r2
  40979c:	b21b      	sxth	r3, r3
  40979e:	b29a      	uxth	r2, r3
  4097a0:	687b      	ldr	r3, [r7, #4]
  4097a2:	879a      	strh	r2, [r3, #60]	; 0x3c

				/* IP address of remote machine. */
				pxSocket->u.xTCP.ulRemoteIP = FreeRTOS_ntohl( pxAddress->sin_addr );
  4097a4:	683b      	ldr	r3, [r7, #0]
  4097a6:	685b      	ldr	r3, [r3, #4]
  4097a8:	061a      	lsls	r2, r3, #24
  4097aa:	683b      	ldr	r3, [r7, #0]
  4097ac:	685b      	ldr	r3, [r3, #4]
  4097ae:	021b      	lsls	r3, r3, #8
  4097b0:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
  4097b4:	431a      	orrs	r2, r3
  4097b6:	683b      	ldr	r3, [r7, #0]
  4097b8:	685b      	ldr	r3, [r3, #4]
  4097ba:	0a1b      	lsrs	r3, r3, #8
  4097bc:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
  4097c0:	431a      	orrs	r2, r3
  4097c2:	683b      	ldr	r3, [r7, #0]
  4097c4:	685b      	ldr	r3, [r3, #4]
  4097c6:	0e1b      	lsrs	r3, r3, #24
  4097c8:	431a      	orrs	r2, r3
  4097ca:	687b      	ldr	r3, [r7, #4]
  4097cc:	639a      	str	r2, [r3, #56]	; 0x38

				/* (client) internal state: socket wants to send a connect. */
				vTCPStateChange( pxSocket, eCONNECT_SYN );
  4097ce:	2102      	movs	r1, #2
  4097d0:	6878      	ldr	r0, [r7, #4]
  4097d2:	4b10      	ldr	r3, [pc, #64]	; (409814 <prvTCPConnectStart+0x154>)
  4097d4:	4798      	blx	r3

				/* To start an active connect. */
				pxSocket->u.xTCP.usTimeout = 1u;
  4097d6:	687b      	ldr	r3, [r7, #4]
  4097d8:	2201      	movs	r2, #1
  4097da:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48

				if( xSendEventToIPTask( eTCPTimerEvent ) != pdPASS )
  4097de:	2006      	movs	r0, #6
  4097e0:	4b0d      	ldr	r3, [pc, #52]	; (409818 <prvTCPConnectStart+0x158>)
  4097e2:	4798      	blx	r3
  4097e4:	4603      	mov	r3, r0
  4097e6:	2b01      	cmp	r3, #1
  4097e8:	d002      	beq.n	4097f0 <prvTCPConnectStart+0x130>
				{
					xResult = -pdFREERTOS_ERRNO_ECANCELED;
  4097ea:	f06f 038b 	mvn.w	r3, #139	; 0x8b
  4097ee:	60fb      	str	r3, [r7, #12]
				}
			}
		}

		return xResult;
  4097f0:	68fb      	ldr	r3, [r7, #12]
	}
  4097f2:	4618      	mov	r0, r3
  4097f4:	3714      	adds	r7, #20
  4097f6:	46bd      	mov	sp, r7
  4097f8:	bd90      	pop	{r4, r7, pc}
  4097fa:	bf00      	nop
  4097fc:	00408995 	.word	0x00408995
  409800:	0040a189 	.word	0x0040a189
  409804:	00408f21 	.word	0x00408f21
  409808:	0040968d 	.word	0x0040968d
  40980c:	0041cec8 	.word	0x0041cec8
  409810:	00416c7d 	.word	0x00416c7d
  409814:	0040bbc1 	.word	0x0040bbc1
  409818:	00407e19 	.word	0x00407e19

0040981c <FreeRTOS_connect>:

	/*
	 * FreeRTOS_connect: socket wants to connect to a remote port
	 */
	BaseType_t FreeRTOS_connect( Socket_t xClientSocket, struct freertos_sockaddr *pxAddress, socklen_t xAddressLength )
	{
  40981c:	b590      	push	{r4, r7, lr}
  40981e:	b08d      	sub	sp, #52	; 0x34
  409820:	af02      	add	r7, sp, #8
  409822:	60f8      	str	r0, [r7, #12]
  409824:	60b9      	str	r1, [r7, #8]
  409826:	607a      	str	r2, [r7, #4]
	FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t* ) xClientSocket;
  409828:	68fb      	ldr	r3, [r7, #12]
  40982a:	61fb      	str	r3, [r7, #28]
	TickType_t xRemainingTime;
	BaseType_t xTimed = pdFALSE;
  40982c:	2300      	movs	r3, #0
  40982e:	627b      	str	r3, [r7, #36]	; 0x24
	BaseType_t xResult;
	TimeOut_t xTimeOut;

		( void ) xAddressLength;

		xResult = prvTCPConnectStart( pxSocket, pxAddress );
  409830:	68b9      	ldr	r1, [r7, #8]
  409832:	69f8      	ldr	r0, [r7, #28]
  409834:	4b22      	ldr	r3, [pc, #136]	; (4098c0 <FreeRTOS_connect+0xa4>)
  409836:	4798      	blx	r3
  409838:	6238      	str	r0, [r7, #32]

		if( xResult == 0 )
  40983a:	6a3b      	ldr	r3, [r7, #32]
  40983c:	2b00      	cmp	r3, #0
  40983e:	d13a      	bne.n	4098b6 <FreeRTOS_connect+0x9a>
		{
			/* And wait for the result */
			for( ;; )
			{
				if( xTimed == pdFALSE )
  409840:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  409842:	2b00      	cmp	r3, #0
  409844:	d110      	bne.n	409868 <FreeRTOS_connect+0x4c>
				{
					/* Only in the first round, check for non-blocking */
					xRemainingTime = pxSocket->xReceiveBlockTime;
  409846:	69fb      	ldr	r3, [r7, #28]
  409848:	69db      	ldr	r3, [r3, #28]
  40984a:	61bb      	str	r3, [r7, #24]
					if( xRemainingTime == ( TickType_t )0 )
  40984c:	69bb      	ldr	r3, [r7, #24]
  40984e:	2b00      	cmp	r3, #0
  409850:	d103      	bne.n	40985a <FreeRTOS_connect+0x3e>
					{
						/* Not yet connected, correct state, non-blocking. */
						xResult = -pdFREERTOS_ERRNO_EWOULDBLOCK;
  409852:	f06f 030a 	mvn.w	r3, #10
  409856:	623b      	str	r3, [r7, #32]
						break;
  409858:	e02d      	b.n	4098b6 <FreeRTOS_connect+0x9a>
					}

					/* Don't get here a second time. */
					xTimed = pdTRUE;
  40985a:	2301      	movs	r3, #1
  40985c:	627b      	str	r3, [r7, #36]	; 0x24

					/* Fetch the current time */
					vTaskSetTimeOutState( &xTimeOut );
  40985e:	f107 0310 	add.w	r3, r7, #16
  409862:	4618      	mov	r0, r3
  409864:	4b17      	ldr	r3, [pc, #92]	; (4098c4 <FreeRTOS_connect+0xa8>)
  409866:	4798      	blx	r3
				}

				/* Did it get connected while sleeping ? */
				xResult = FreeRTOS_issocketconnected( pxSocket );
  409868:	69f8      	ldr	r0, [r7, #28]
  40986a:	4b17      	ldr	r3, [pc, #92]	; (4098c8 <FreeRTOS_connect+0xac>)
  40986c:	4798      	blx	r3
  40986e:	6238      	str	r0, [r7, #32]

				/* Returns positive when connected, negative means an error */
				if( xResult < 0 )
  409870:	6a3b      	ldr	r3, [r7, #32]
  409872:	2b00      	cmp	r3, #0
  409874:	db1e      	blt.n	4098b4 <FreeRTOS_connect+0x98>
				{
					/* Return the error */
					break;
				}

				if( xResult > 0 )
  409876:	6a3b      	ldr	r3, [r7, #32]
  409878:	2b00      	cmp	r3, #0
  40987a:	dd02      	ble.n	409882 <FreeRTOS_connect+0x66>
				{
					/* Socket now connected, return a zero */
					xResult = 0;
  40987c:	2300      	movs	r3, #0
  40987e:	623b      	str	r3, [r7, #32]
					break;
  409880:	e019      	b.n	4098b6 <FreeRTOS_connect+0x9a>
				}

				/* Is it allowed to sleep more? */
				if( xTaskCheckForTimeOut( &xTimeOut, &xRemainingTime ) )
  409882:	f107 0218 	add.w	r2, r7, #24
  409886:	f107 0310 	add.w	r3, r7, #16
  40988a:	4611      	mov	r1, r2
  40988c:	4618      	mov	r0, r3
  40988e:	4b0f      	ldr	r3, [pc, #60]	; (4098cc <FreeRTOS_connect+0xb0>)
  409890:	4798      	blx	r3
  409892:	4603      	mov	r3, r0
  409894:	2b00      	cmp	r3, #0
  409896:	d003      	beq.n	4098a0 <FreeRTOS_connect+0x84>
				{
					xResult = -pdFREERTOS_ERRNO_ETIMEDOUT;
  409898:	f06f 0373 	mvn.w	r3, #115	; 0x73
  40989c:	623b      	str	r3, [r7, #32]
					break;
  40989e:	e00a      	b.n	4098b6 <FreeRTOS_connect+0x9a>
				}

				/* Go sleeping until we get any down-stream event */
				xEventGroupWaitBits( pxSocket->xEventGroup, eSOCKET_CONNECT, pdTRUE /*xClearOnExit*/, pdFALSE /*xWaitAllBits*/, xRemainingTime );
  4098a0:	69fb      	ldr	r3, [r7, #28]
  4098a2:	6858      	ldr	r0, [r3, #4]
  4098a4:	69bb      	ldr	r3, [r7, #24]
  4098a6:	9300      	str	r3, [sp, #0]
  4098a8:	2300      	movs	r3, #0
  4098aa:	2201      	movs	r2, #1
  4098ac:	2108      	movs	r1, #8
  4098ae:	4c08      	ldr	r4, [pc, #32]	; (4098d0 <FreeRTOS_connect+0xb4>)
  4098b0:	47a0      	blx	r4
				if( xTimed == pdFALSE )
  4098b2:	e7c5      	b.n	409840 <FreeRTOS_connect+0x24>
					break;
  4098b4:	bf00      	nop
			}
		}

		return xResult;
  4098b6:	6a3b      	ldr	r3, [r7, #32]
	}
  4098b8:	4618      	mov	r0, r3
  4098ba:	372c      	adds	r7, #44	; 0x2c
  4098bc:	46bd      	mov	sp, r7
  4098be:	bd90      	pop	{r4, r7, pc}
  4098c0:	004096c1 	.word	0x004096c1
  4098c4:	00412c89 	.word	0x00412c89
  4098c8:	0040a189 	.word	0x0040a189
  4098cc:	00412d0d 	.word	0x00412d0d
  4098d0:	00410925 	.word	0x00410925

004098d4 <FreeRTOS_recv>:
	/*
	 * Read incoming data from a TCP socket
	 * Only after the last byte has been read, a close error might be returned
	 */
	BaseType_t FreeRTOS_recv( Socket_t xSocket, void *pvBuffer, size_t xBufferLength, BaseType_t xFlags )
	{
  4098d4:	b590      	push	{r4, r7, lr}
  4098d6:	b08f      	sub	sp, #60	; 0x3c
  4098d8:	af02      	add	r7, sp, #8
  4098da:	60f8      	str	r0, [r7, #12]
  4098dc:	60b9      	str	r1, [r7, #8]
  4098de:	607a      	str	r2, [r7, #4]
  4098e0:	603b      	str	r3, [r7, #0]
	BaseType_t xByteCount;
	FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) xSocket;
  4098e2:	68fb      	ldr	r3, [r7, #12]
  4098e4:	627b      	str	r3, [r7, #36]	; 0x24
	TickType_t xRemainingTime;
	BaseType_t xTimed = pdFALSE;
  4098e6:	2300      	movs	r3, #0
  4098e8:	62bb      	str	r3, [r7, #40]	; 0x28
	TimeOut_t xTimeOut;
	EventBits_t xEventBits = ( EventBits_t ) 0;
  4098ea:	2300      	movs	r3, #0
  4098ec:	623b      	str	r3, [r7, #32]

		/* Check if the socket is valid, has type TCP and if it is bound to a
		port. */
		if( prvValidSocket( pxSocket, FREERTOS_IPPROTO_TCP, pdTRUE ) == pdFALSE )
  4098ee:	2201      	movs	r2, #1
  4098f0:	2106      	movs	r1, #6
  4098f2:	6a78      	ldr	r0, [r7, #36]	; 0x24
  4098f4:	4b61      	ldr	r3, [pc, #388]	; (409a7c <FreeRTOS_recv+0x1a8>)
  4098f6:	4798      	blx	r3
  4098f8:	4603      	mov	r3, r0
  4098fa:	2b00      	cmp	r3, #0
  4098fc:	d103      	bne.n	409906 <FreeRTOS_recv+0x32>
		{
			xByteCount = -pdFREERTOS_ERRNO_EINVAL;
  4098fe:	f06f 0315 	mvn.w	r3, #21
  409902:	62fb      	str	r3, [r7, #44]	; 0x2c
  409904:	e0b5      	b.n	409a72 <FreeRTOS_recv+0x19e>
		}
		else
		{
			if( pxSocket->u.xTCP.rxStream != NULL )
  409906:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  409908:	6edb      	ldr	r3, [r3, #108]	; 0x6c
  40990a:	2b00      	cmp	r3, #0
  40990c:	d007      	beq.n	40991e <FreeRTOS_recv+0x4a>
			{
				xByteCount = ( BaseType_t )uxStreamBufferGetSize ( pxSocket->u.xTCP.rxStream );
  40990e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  409910:	6edb      	ldr	r3, [r3, #108]	; 0x6c
  409912:	4618      	mov	r0, r3
  409914:	4b5a      	ldr	r3, [pc, #360]	; (409a80 <FreeRTOS_recv+0x1ac>)
  409916:	4798      	blx	r3
  409918:	4603      	mov	r3, r0
  40991a:	62fb      	str	r3, [r7, #44]	; 0x2c
  40991c:	e055      	b.n	4099ca <FreeRTOS_recv+0xf6>
			}
			else
			{
				xByteCount = 0;
  40991e:	2300      	movs	r3, #0
  409920:	62fb      	str	r3, [r7, #44]	; 0x2c
			}

			while( xByteCount == 0 )
  409922:	e052      	b.n	4099ca <FreeRTOS_recv+0xf6>
			{
				switch( pxSocket->u.xTCP.ucTCPState )
  409924:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  409926:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
  40992a:	2b00      	cmp	r3, #0
  40992c:	d004      	beq.n	409938 <FreeRTOS_recv+0x64>
  40992e:	2b00      	cmp	r3, #0
  409930:	db12      	blt.n	409958 <FreeRTOS_recv+0x84>
  409932:	3b08      	subs	r3, #8
  409934:	2b01      	cmp	r3, #1
  409936:	d80f      	bhi.n	409958 <FreeRTOS_recv+0x84>
				{
				case eCLOSED:
				case eCLOSE_WAIT:	/* (server + client) waiting for a connection termination request from the local user. */
				case eCLOSING:		/* (server + client) waiting for a connection termination request acknowledgement from the remote TCP. */
					if( pxSocket->u.xTCP.bits.bMallocError != pdFALSE_UNSIGNED )
  409938:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40993a:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
  40993e:	f003 0308 	and.w	r3, r3, #8
  409942:	b2db      	uxtb	r3, r3
  409944:	2b00      	cmp	r3, #0
  409946:	d003      	beq.n	409950 <FreeRTOS_recv+0x7c>
					{
						/* The no-memory error has priority above the non-connected error.
						Both are fatal and will elad to closing the socket. */
						xByteCount = -pdFREERTOS_ERRNO_ENOMEM;
  409948:	f06f 030b 	mvn.w	r3, #11
  40994c:	62fb      	str	r3, [r7, #44]	; 0x2c
  40994e:	e03c      	b.n	4099ca <FreeRTOS_recv+0xf6>
					}
					else
					{
						xByteCount = -pdFREERTOS_ERRNO_ENOTCONN;
  409950:	f06f 037f 	mvn.w	r3, #127	; 0x7f
  409954:	62fb      	str	r3, [r7, #44]	; 0x2c
					}
					/* Call continue to break out of the switch and also the while
					loop. */
					continue;
  409956:	e038      	b.n	4099ca <FreeRTOS_recv+0xf6>
				default:
					break;
  409958:	bf00      	nop
				}

				if( xTimed == pdFALSE )
  40995a:	6abb      	ldr	r3, [r7, #40]	; 0x28
  40995c:	2b00      	cmp	r3, #0
  40995e:	d111      	bne.n	409984 <FreeRTOS_recv+0xb0>
				{
					/* Only in the first round, check for non-blocking. */
					xRemainingTime = pxSocket->xReceiveBlockTime;
  409960:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  409962:	69db      	ldr	r3, [r3, #28]
  409964:	61bb      	str	r3, [r7, #24]

					if( xRemainingTime == ( TickType_t ) 0 )
  409966:	69bb      	ldr	r3, [r7, #24]
  409968:	2b00      	cmp	r3, #0
  40996a:	d032      	beq.n	4099d2 <FreeRTOS_recv+0xfe>
						}
						#endif /* ipconfigSUPPORT_SIGNALS */
						break;
					}

					if( ( xFlags & FREERTOS_MSG_DONTWAIT ) != 0 )
  40996c:	683b      	ldr	r3, [r7, #0]
  40996e:	f003 0310 	and.w	r3, r3, #16
  409972:	2b00      	cmp	r3, #0
  409974:	d12f      	bne.n	4099d6 <FreeRTOS_recv+0x102>
					{
						break;
					}

					/* Don't get here a second time. */
					xTimed = pdTRUE;
  409976:	2301      	movs	r3, #1
  409978:	62bb      	str	r3, [r7, #40]	; 0x28

					/* Fetch the current time. */
					vTaskSetTimeOutState( &xTimeOut );
  40997a:	f107 0310 	add.w	r3, r7, #16
  40997e:	4618      	mov	r0, r3
  409980:	4b40      	ldr	r3, [pc, #256]	; (409a84 <FreeRTOS_recv+0x1b0>)
  409982:	4798      	blx	r3
				}

				/* Has the timeout been reached? */
				if( xTaskCheckForTimeOut( &xTimeOut, &xRemainingTime ) != pdFALSE )
  409984:	f107 0218 	add.w	r2, r7, #24
  409988:	f107 0310 	add.w	r3, r7, #16
  40998c:	4611      	mov	r1, r2
  40998e:	4618      	mov	r0, r3
  409990:	4b3d      	ldr	r3, [pc, #244]	; (409a88 <FreeRTOS_recv+0x1b4>)
  409992:	4798      	blx	r3
  409994:	4603      	mov	r3, r0
  409996:	2b00      	cmp	r3, #0
  409998:	d11f      	bne.n	4099da <FreeRTOS_recv+0x106>
				{
					break;
				}

				/* Block until there is a down-stream event. */
				xEventBits = xEventGroupWaitBits( pxSocket->xEventGroup,
  40999a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40999c:	6858      	ldr	r0, [r3, #4]
  40999e:	69bb      	ldr	r3, [r7, #24]
  4099a0:	9300      	str	r3, [sp, #0]
  4099a2:	2300      	movs	r3, #0
  4099a4:	2201      	movs	r2, #1
  4099a6:	2161      	movs	r1, #97	; 0x61
  4099a8:	4c38      	ldr	r4, [pc, #224]	; (409a8c <FreeRTOS_recv+0x1b8>)
  4099aa:	47a0      	blx	r4
  4099ac:	6238      	str	r0, [r7, #32]
				{
					( void ) xEventBits;
				}
				#endif /* ipconfigSUPPORT_SIGNALS */

				if( pxSocket->u.xTCP.rxStream != NULL )
  4099ae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4099b0:	6edb      	ldr	r3, [r3, #108]	; 0x6c
  4099b2:	2b00      	cmp	r3, #0
  4099b4:	d007      	beq.n	4099c6 <FreeRTOS_recv+0xf2>
				{
					xByteCount = ( BaseType_t ) uxStreamBufferGetSize ( pxSocket->u.xTCP.rxStream );
  4099b6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4099b8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
  4099ba:	4618      	mov	r0, r3
  4099bc:	4b30      	ldr	r3, [pc, #192]	; (409a80 <FreeRTOS_recv+0x1ac>)
  4099be:	4798      	blx	r3
  4099c0:	4603      	mov	r3, r0
  4099c2:	62fb      	str	r3, [r7, #44]	; 0x2c
  4099c4:	e001      	b.n	4099ca <FreeRTOS_recv+0xf6>
				}
				else
				{
					xByteCount = 0;
  4099c6:	2300      	movs	r3, #0
  4099c8:	62fb      	str	r3, [r7, #44]	; 0x2c
			while( xByteCount == 0 )
  4099ca:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  4099cc:	2b00      	cmp	r3, #0
  4099ce:	d0a9      	beq.n	409924 <FreeRTOS_recv+0x50>
  4099d0:	e004      	b.n	4099dc <FreeRTOS_recv+0x108>
						break;
  4099d2:	bf00      	nop
  4099d4:	e002      	b.n	4099dc <FreeRTOS_recv+0x108>
						break;
  4099d6:	bf00      	nop
  4099d8:	e000      	b.n	4099dc <FreeRTOS_recv+0x108>
					break;
  4099da:	bf00      	nop
				}
				xByteCount = -pdFREERTOS_ERRNO_EINTR;
			}
			else
		#endif /* ipconfigSUPPORT_SIGNALS */
			if( xByteCount > 0 )
  4099dc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  4099de:	2b00      	cmp	r3, #0
  4099e0:	dd47      	ble.n	409a72 <FreeRTOS_recv+0x19e>
			{
				if( ( xFlags & FREERTOS_ZERO_COPY ) == 0 )
  4099e2:	683b      	ldr	r3, [r7, #0]
  4099e4:	f003 0301 	and.w	r3, r3, #1
  4099e8:	2b00      	cmp	r3, #0
  4099ea:	d13a      	bne.n	409a62 <FreeRTOS_recv+0x18e>
				{
					xByteCount = ( BaseType_t ) uxStreamBufferGet( pxSocket->u.xTCP.rxStream, 0ul, ( uint8_t * ) pvBuffer, ( size_t ) xBufferLength, ( xFlags & FREERTOS_MSG_PEEK ) != 0 );
  4099ec:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4099ee:	6ed8      	ldr	r0, [r3, #108]	; 0x6c
  4099f0:	683b      	ldr	r3, [r7, #0]
  4099f2:	f003 0304 	and.w	r3, r3, #4
  4099f6:	2b00      	cmp	r3, #0
  4099f8:	bf14      	ite	ne
  4099fa:	2301      	movne	r3, #1
  4099fc:	2300      	moveq	r3, #0
  4099fe:	b2db      	uxtb	r3, r3
  409a00:	9300      	str	r3, [sp, #0]
  409a02:	687b      	ldr	r3, [r7, #4]
  409a04:	68ba      	ldr	r2, [r7, #8]
  409a06:	2100      	movs	r1, #0
  409a08:	4c21      	ldr	r4, [pc, #132]	; (409a90 <FreeRTOS_recv+0x1bc>)
  409a0a:	47a0      	blx	r4
  409a0c:	4603      	mov	r3, r0
  409a0e:	62fb      	str	r3, [r7, #44]	; 0x2c
					if( pxSocket->u.xTCP.bits.bLowWater != pdFALSE_UNSIGNED )
  409a10:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  409a12:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
  409a16:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
  409a1a:	b2db      	uxtb	r3, r3
  409a1c:	2b00      	cmp	r3, #0
  409a1e:	d028      	beq.n	409a72 <FreeRTOS_recv+0x19e>
					{
						/* We had reached the low-water mark, now see if the flag
						can be cleared */
						size_t uxFrontSpace = uxStreamBufferFrontSpace( pxSocket->u.xTCP.rxStream );
  409a20:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  409a22:	6edb      	ldr	r3, [r3, #108]	; 0x6c
  409a24:	4618      	mov	r0, r3
  409a26:	4b1b      	ldr	r3, [pc, #108]	; (409a94 <FreeRTOS_recv+0x1c0>)
  409a28:	4798      	blx	r3
  409a2a:	61f8      	str	r0, [r7, #28]

						if( uxFrontSpace >= pxSocket->u.xTCP.uxEnoughSpace )
  409a2c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  409a2e:	6e1a      	ldr	r2, [r3, #96]	; 0x60
  409a30:	69fb      	ldr	r3, [r7, #28]
  409a32:	429a      	cmp	r2, r3
  409a34:	d81d      	bhi.n	409a72 <FreeRTOS_recv+0x19e>
						{
							pxSocket->u.xTCP.bits.bLowWater = pdFALSE_UNSIGNED;
  409a36:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  409a38:	f892 3040 	ldrb.w	r3, [r2, #64]	; 0x40
  409a3c:	f36f 13c7 	bfc	r3, #7, #1
  409a40:	f882 3040 	strb.w	r3, [r2, #64]	; 0x40
							pxSocket->u.xTCP.bits.bWinChange = pdTRUE_UNSIGNED;
  409a44:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  409a46:	f892 3041 	ldrb.w	r3, [r2, #65]	; 0x41
  409a4a:	f043 0301 	orr.w	r3, r3, #1
  409a4e:	f882 3041 	strb.w	r3, [r2, #65]	; 0x41
							pxSocket->u.xTCP.usTimeout = 1u; /* because bLowWater is cleared. */
  409a52:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  409a54:	2201      	movs	r2, #1
  409a56:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48
							xSendEventToIPTask( eTCPTimerEvent );
  409a5a:	2006      	movs	r0, #6
  409a5c:	4b0e      	ldr	r3, [pc, #56]	; (409a98 <FreeRTOS_recv+0x1c4>)
  409a5e:	4798      	blx	r3
  409a60:	e007      	b.n	409a72 <FreeRTOS_recv+0x19e>
					}
				}
				else
				{
					/* Zero-copy reception of data: pvBuffer is a pointer to a pointer. */
					xByteCount = ( BaseType_t ) uxStreamBufferGetPtr( pxSocket->u.xTCP.rxStream, (uint8_t **)pvBuffer );
  409a62:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  409a64:	6edb      	ldr	r3, [r3, #108]	; 0x6c
  409a66:	68b9      	ldr	r1, [r7, #8]
  409a68:	4618      	mov	r0, r3
  409a6a:	4b0c      	ldr	r3, [pc, #48]	; (409a9c <FreeRTOS_recv+0x1c8>)
  409a6c:	4798      	blx	r3
  409a6e:	4603      	mov	r3, r0
  409a70:	62fb      	str	r3, [r7, #44]	; 0x2c
				}
			}
		} /* prvValidSocket() */

		return xByteCount;
  409a72:	6afb      	ldr	r3, [r7, #44]	; 0x2c
	}
  409a74:	4618      	mov	r0, r3
  409a76:	3734      	adds	r7, #52	; 0x34
  409a78:	46bd      	mov	sp, r7
  409a7a:	bd90      	pop	{r4, r7, pc}
  409a7c:	00408995 	.word	0x00408995
  409a80:	00408921 	.word	0x00408921
  409a84:	00412c89 	.word	0x00412c89
  409a88:	00412d0d 	.word	0x00412d0d
  409a8c:	00410925 	.word	0x00410925
  409a90:	0040a88d 	.word	0x0040a88d
  409a94:	004088f5 	.word	0x004088f5
  409a98:	00407e19 	.word	0x00407e19
  409a9c:	0040894d 	.word	0x0040894d

00409aa0 <prvTCPSendCheck>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP == 1 )

	static int32_t prvTCPSendCheck( FreeRTOS_Socket_t *pxSocket, size_t xDataLength )
	{
  409aa0:	b580      	push	{r7, lr}
  409aa2:	b084      	sub	sp, #16
  409aa4:	af00      	add	r7, sp, #0
  409aa6:	6078      	str	r0, [r7, #4]
  409aa8:	6039      	str	r1, [r7, #0]
	int32_t xResult = 1;
  409aaa:	2301      	movs	r3, #1
  409aac:	60fb      	str	r3, [r7, #12]

		/* Is this a socket of type TCP and is it already bound to a port number ? */
		if( prvValidSocket( pxSocket, FREERTOS_IPPROTO_TCP, pdTRUE ) == pdFALSE )
  409aae:	2201      	movs	r2, #1
  409ab0:	2106      	movs	r1, #6
  409ab2:	6878      	ldr	r0, [r7, #4]
  409ab4:	4b26      	ldr	r3, [pc, #152]	; (409b50 <prvTCPSendCheck+0xb0>)
  409ab6:	4798      	blx	r3
  409ab8:	4603      	mov	r3, r0
  409aba:	2b00      	cmp	r3, #0
  409abc:	d103      	bne.n	409ac6 <prvTCPSendCheck+0x26>
		{
			xResult = -pdFREERTOS_ERRNO_EINVAL;
  409abe:	f06f 0315 	mvn.w	r3, #21
  409ac2:	60fb      	str	r3, [r7, #12]
  409ac4:	e03e      	b.n	409b44 <prvTCPSendCheck+0xa4>
		}
		else if( pxSocket->u.xTCP.bits.bMallocError != pdFALSE_UNSIGNED )
  409ac6:	687b      	ldr	r3, [r7, #4]
  409ac8:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
  409acc:	f003 0308 	and.w	r3, r3, #8
  409ad0:	b2db      	uxtb	r3, r3
  409ad2:	2b00      	cmp	r3, #0
  409ad4:	d003      	beq.n	409ade <prvTCPSendCheck+0x3e>
		{
			xResult = -pdFREERTOS_ERRNO_ENOMEM;
  409ad6:	f06f 030b 	mvn.w	r3, #11
  409ada:	60fb      	str	r3, [r7, #12]
  409adc:	e032      	b.n	409b44 <prvTCPSendCheck+0xa4>
		}
		else if( pxSocket->u.xTCP.ucTCPState == eCLOSED ||
  409ade:	687b      	ldr	r3, [r7, #4]
  409ae0:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
  409ae4:	2b00      	cmp	r3, #0
  409ae6:	d009      	beq.n	409afc <prvTCPSendCheck+0x5c>
                 pxSocket->u.xTCP.ucTCPState == eCLOSE_WAIT ||
  409ae8:	687b      	ldr	r3, [r7, #4]
  409aea:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
		else if( pxSocket->u.xTCP.ucTCPState == eCLOSED ||
  409aee:	2b08      	cmp	r3, #8
  409af0:	d004      	beq.n	409afc <prvTCPSendCheck+0x5c>
                 pxSocket->u.xTCP.ucTCPState == eCLOSING )
  409af2:	687b      	ldr	r3, [r7, #4]
  409af4:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
                 pxSocket->u.xTCP.ucTCPState == eCLOSE_WAIT ||
  409af8:	2b09      	cmp	r3, #9
  409afa:	d103      	bne.n	409b04 <prvTCPSendCheck+0x64>
		{
			xResult = -pdFREERTOS_ERRNO_ENOTCONN;
  409afc:	f06f 037f 	mvn.w	r3, #127	; 0x7f
  409b00:	60fb      	str	r3, [r7, #12]
  409b02:	e01f      	b.n	409b44 <prvTCPSendCheck+0xa4>
		}
		else if( pxSocket->u.xTCP.bits.bFinSent != pdFALSE_UNSIGNED )
  409b04:	687b      	ldr	r3, [r7, #4]
  409b06:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
  409b0a:	f003 0340 	and.w	r3, r3, #64	; 0x40
  409b0e:	b2db      	uxtb	r3, r3
  409b10:	2b00      	cmp	r3, #0
  409b12:	d002      	beq.n	409b1a <prvTCPSendCheck+0x7a>
		{
			/* This TCP connection is closing already, the FIN flag has been sent.
			Maybe it is still delivering or receiving data.
			Return OK in order not to get closed/deleted too quickly */
			xResult = 0;
  409b14:	2300      	movs	r3, #0
  409b16:	60fb      	str	r3, [r7, #12]
  409b18:	e014      	b.n	409b44 <prvTCPSendCheck+0xa4>
		}
		else if( xDataLength == 0ul )
  409b1a:	683b      	ldr	r3, [r7, #0]
  409b1c:	2b00      	cmp	r3, #0
  409b1e:	d102      	bne.n	409b26 <prvTCPSendCheck+0x86>
		{
			/* send() is being called to send zero bytes */
			xResult = 0;
  409b20:	2300      	movs	r3, #0
  409b22:	60fb      	str	r3, [r7, #12]
  409b24:	e00e      	b.n	409b44 <prvTCPSendCheck+0xa4>
		}
		else if( pxSocket->u.xTCP.txStream == NULL )
  409b26:	687b      	ldr	r3, [r7, #4]
  409b28:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  409b2a:	2b00      	cmp	r3, #0
  409b2c:	d10a      	bne.n	409b44 <prvTCPSendCheck+0xa4>
		{
			/* Create the outgoing stream only when it is needed */
			prvTCPCreateStream( pxSocket, pdFALSE );
  409b2e:	2100      	movs	r1, #0
  409b30:	6878      	ldr	r0, [r7, #4]
  409b32:	4b08      	ldr	r3, [pc, #32]	; (409b54 <prvTCPSendCheck+0xb4>)
  409b34:	4798      	blx	r3

			if( pxSocket->u.xTCP.txStream == NULL )
  409b36:	687b      	ldr	r3, [r7, #4]
  409b38:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  409b3a:	2b00      	cmp	r3, #0
  409b3c:	d102      	bne.n	409b44 <prvTCPSendCheck+0xa4>
			{
				xResult = -pdFREERTOS_ERRNO_ENOMEM;
  409b3e:	f06f 030b 	mvn.w	r3, #11
  409b42:	60fb      	str	r3, [r7, #12]
			}
		}

		return xResult;
  409b44:	68fb      	ldr	r3, [r7, #12]
	}
  409b46:	4618      	mov	r0, r3
  409b48:	3710      	adds	r7, #16
  409b4a:	46bd      	mov	sp, r7
  409b4c:	bd80      	pop	{r7, pc}
  409b4e:	bf00      	nop
  409b50:	00408995 	.word	0x00408995
  409b54:	00409f21 	.word	0x00409f21

00409b58 <FreeRTOS_send>:
	 * Send data using a TCP socket.  It is not necessary to have the socket
	 * connected already.  Outgoing data will be stored and delivered as soon as
	 * the socket gets connected.
	 */
	BaseType_t FreeRTOS_send( Socket_t xSocket, const void *pvBuffer, size_t uxDataLength, BaseType_t xFlags )
	{
  409b58:	b590      	push	{r4, r7, lr}
  409b5a:	b08f      	sub	sp, #60	; 0x3c
  409b5c:	af02      	add	r7, sp, #8
  409b5e:	60f8      	str	r0, [r7, #12]
  409b60:	60b9      	str	r1, [r7, #8]
  409b62:	607a      	str	r2, [r7, #4]
  409b64:	603b      	str	r3, [r7, #0]
	BaseType_t xByteCount;
	BaseType_t xBytesLeft;
	FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) xSocket;
  409b66:	68fb      	ldr	r3, [r7, #12]
  409b68:	61fb      	str	r3, [r7, #28]
	TickType_t xRemainingTime;
	BaseType_t xTimed = pdFALSE;
  409b6a:	2300      	movs	r3, #0
  409b6c:	627b      	str	r3, [r7, #36]	; 0x24

		/* Prevent compiler warnings about unused parameters.  The parameter
		may be used in future versions. */
		( void ) xFlags;

		xByteCount = ( BaseType_t ) prvTCPSendCheck( pxSocket, uxDataLength );
  409b6e:	6879      	ldr	r1, [r7, #4]
  409b70:	69f8      	ldr	r0, [r7, #28]
  409b72:	4b63      	ldr	r3, [pc, #396]	; (409d00 <FreeRTOS_send+0x1a8>)
  409b74:	4798      	blx	r3
  409b76:	62f8      	str	r0, [r7, #44]	; 0x2c

		if( xByteCount > 0 )
  409b78:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  409b7a:	2b00      	cmp	r3, #0
  409b7c:	f340 80ba 	ble.w	409cf4 <FreeRTOS_send+0x19c>
		{
			/* xBytesLeft is number of bytes to send, will count to zero. */
			xBytesLeft = ( BaseType_t ) uxDataLength;
  409b80:	687b      	ldr	r3, [r7, #4]
  409b82:	62bb      	str	r3, [r7, #40]	; 0x28

			/* xByteCount is number of bytes that can be sent now. */
			xByteCount = ( BaseType_t ) uxStreamBufferGetSpace( pxSocket->u.xTCP.txStream );
  409b84:	69fb      	ldr	r3, [r7, #28]
  409b86:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  409b88:	4618      	mov	r0, r3
  409b8a:	4b5e      	ldr	r3, [pc, #376]	; (409d04 <FreeRTOS_send+0x1ac>)
  409b8c:	4798      	blx	r3
  409b8e:	4603      	mov	r3, r0
  409b90:	62fb      	str	r3, [r7, #44]	; 0x2c

			/* While there are still bytes to be sent. */
			while( xBytesLeft > 0 )
  409b92:	e07b      	b.n	409c8c <FreeRTOS_send+0x134>
			{
				/* If txStream has space. */
				if( xByteCount > 0 )
  409b94:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  409b96:	2b00      	cmp	r3, #0
  409b98:	dd47      	ble.n	409c2a <FreeRTOS_send+0xd2>
				{
					/* Don't send more than necessary. */
					if( xByteCount > xBytesLeft )
  409b9a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  409b9c:	6abb      	ldr	r3, [r7, #40]	; 0x28
  409b9e:	429a      	cmp	r2, r3
  409ba0:	dd01      	ble.n	409ba6 <FreeRTOS_send+0x4e>
					{
						xByteCount = xBytesLeft;
  409ba2:	6abb      	ldr	r3, [r7, #40]	; 0x28
  409ba4:	62fb      	str	r3, [r7, #44]	; 0x2c
					}

					/* Is the close-after-send flag set and is this really the
					last transmission? */
					if( ( pxSocket->u.xTCP.bits.bCloseAfterSend != pdFALSE_UNSIGNED ) && ( xByteCount == xBytesLeft ) )
  409ba6:	69fb      	ldr	r3, [r7, #28]
  409ba8:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
  409bac:	f003 0310 	and.w	r3, r3, #16
  409bb0:	b2db      	uxtb	r3, r3
  409bb2:	2b00      	cmp	r3, #0
  409bb4:	d006      	beq.n	409bc4 <FreeRTOS_send+0x6c>
  409bb6:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  409bb8:	6abb      	ldr	r3, [r7, #40]	; 0x28
  409bba:	429a      	cmp	r2, r3
  409bbc:	d102      	bne.n	409bc4 <FreeRTOS_send+0x6c>
					{
						xCloseAfterSend = pdTRUE;
  409bbe:	2301      	movs	r3, #1
  409bc0:	623b      	str	r3, [r7, #32]
  409bc2:	e001      	b.n	409bc8 <FreeRTOS_send+0x70>
					}
					else
					{
						xCloseAfterSend = pdFALSE;
  409bc4:	2300      	movs	r3, #0
  409bc6:	623b      	str	r3, [r7, #32]
					When the last data packet is being sent out, a FIN flag will
					be included to let the peer know that no more data is to be
					expected.  The use of 'bCloseAfterSend' is not mandatory, it
					is just a faster way of transferring files (e.g. when using
					FTP). */
					if( xCloseAfterSend != pdFALSE )
  409bc8:	6a3b      	ldr	r3, [r7, #32]
  409bca:	2b00      	cmp	r3, #0
  409bcc:	d008      	beq.n	409be0 <FreeRTOS_send+0x88>
					{
						/* Now suspend the scheduler: sending the last data	and
						setting bCloseRequested must be done together */
						vTaskSuspendAll();
  409bce:	4b4e      	ldr	r3, [pc, #312]	; (409d08 <FreeRTOS_send+0x1b0>)
  409bd0:	4798      	blx	r3
						pxSocket->u.xTCP.bits.bCloseRequested = pdTRUE_UNSIGNED;
  409bd2:	69fa      	ldr	r2, [r7, #28]
  409bd4:	f892 3040 	ldrb.w	r3, [r2, #64]	; 0x40
  409bd8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  409bdc:	f882 3040 	strb.w	r3, [r2, #64]	; 0x40
					}

					xByteCount = ( BaseType_t ) uxStreamBufferAdd( pxSocket->u.xTCP.txStream, 0ul, ( const uint8_t * ) pvBuffer, ( size_t ) xByteCount );
  409be0:	69fb      	ldr	r3, [r7, #28]
  409be2:	6f18      	ldr	r0, [r3, #112]	; 0x70
  409be4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  409be6:	68ba      	ldr	r2, [r7, #8]
  409be8:	2100      	movs	r1, #0
  409bea:	4c48      	ldr	r4, [pc, #288]	; (409d0c <FreeRTOS_send+0x1b4>)
  409bec:	47a0      	blx	r4
  409bee:	4603      	mov	r3, r0
  409bf0:	62fb      	str	r3, [r7, #44]	; 0x2c

					if( xCloseAfterSend != pdFALSE )
  409bf2:	6a3b      	ldr	r3, [r7, #32]
  409bf4:	2b00      	cmp	r3, #0
  409bf6:	d001      	beq.n	409bfc <FreeRTOS_send+0xa4>
					{
						/* Now when the IP-task transmits the data, it will also
						see	that bCloseRequested is true and include the FIN
						flag to start closure of the connection. */
						xTaskResumeAll();
  409bf8:	4b45      	ldr	r3, [pc, #276]	; (409d10 <FreeRTOS_send+0x1b8>)
  409bfa:	4798      	blx	r3
					}

					/* Send a message to the IP-task so it can work on this
					socket.  Data is sent, let the IP-task work on it. */
					pxSocket->u.xTCP.usTimeout = 1u;
  409bfc:	69fb      	ldr	r3, [r7, #28]
  409bfe:	2201      	movs	r2, #1
  409c00:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48

					if( xIsCallingFromIPTask() == pdFALSE )
  409c04:	4b43      	ldr	r3, [pc, #268]	; (409d14 <FreeRTOS_send+0x1bc>)
  409c06:	4798      	blx	r3
  409c08:	4603      	mov	r3, r0
  409c0a:	2b00      	cmp	r3, #0
  409c0c:	d102      	bne.n	409c14 <FreeRTOS_send+0xbc>
					{
						/* Only send a TCP timer event when not called from the
						IP-task. */
						xSendEventToIPTask( eTCPTimerEvent );
  409c0e:	2006      	movs	r0, #6
  409c10:	4b41      	ldr	r3, [pc, #260]	; (409d18 <FreeRTOS_send+0x1c0>)
  409c12:	4798      	blx	r3
					}

					xBytesLeft -= xByteCount;
  409c14:	6aba      	ldr	r2, [r7, #40]	; 0x28
  409c16:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  409c18:	1ad3      	subs	r3, r2, r3
  409c1a:	62bb      	str	r3, [r7, #40]	; 0x28

					if( xBytesLeft == 0 )
  409c1c:	6abb      	ldr	r3, [r7, #40]	; 0x28
  409c1e:	2b00      	cmp	r3, #0
  409c20:	d038      	beq.n	409c94 <FreeRTOS_send+0x13c>
						break;
					}

					/* As there are still bytes left to be sent, increase the
					data pointer. */
					pvBuffer = ( void * ) ( ( ( const uint8_t * ) pvBuffer) + xByteCount );
  409c22:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  409c24:	68ba      	ldr	r2, [r7, #8]
  409c26:	4413      	add	r3, r2
  409c28:	60bb      	str	r3, [r7, #8]
				}

				/* Not all bytes have been sent. In case the socket is marked as
				blocking sleep for a while. */
				if( xTimed == pdFALSE )
  409c2a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  409c2c:	2b00      	cmp	r3, #0
  409c2e:	d112      	bne.n	409c56 <FreeRTOS_send+0xfe>
				{
					/* Only in the first round, check for non-blocking. */
					xRemainingTime = pxSocket->xSendBlockTime;
  409c30:	69fb      	ldr	r3, [r7, #28]
  409c32:	6a1b      	ldr	r3, [r3, #32]
  409c34:	61bb      	str	r3, [r7, #24]
							xRemainingTime = ( TickType_t ) 0;
						}
					}
					#endif /* ipconfigUSE_CALLBACKS */

					if( xRemainingTime == ( TickType_t ) 0 )
  409c36:	69bb      	ldr	r3, [r7, #24]
  409c38:	2b00      	cmp	r3, #0
  409c3a:	d02d      	beq.n	409c98 <FreeRTOS_send+0x140>
					{
						break;
					}

					if( ( xFlags & FREERTOS_MSG_DONTWAIT ) != 0 )
  409c3c:	683b      	ldr	r3, [r7, #0]
  409c3e:	f003 0310 	and.w	r3, r3, #16
  409c42:	2b00      	cmp	r3, #0
  409c44:	d12a      	bne.n	409c9c <FreeRTOS_send+0x144>
					{
						break;
					}

					/* Don't get here a second time. */
					xTimed = pdTRUE;
  409c46:	2301      	movs	r3, #1
  409c48:	627b      	str	r3, [r7, #36]	; 0x24

					/* Fetch the current time. */
					vTaskSetTimeOutState( &xTimeOut );
  409c4a:	f107 0310 	add.w	r3, r7, #16
  409c4e:	4618      	mov	r0, r3
  409c50:	4b32      	ldr	r3, [pc, #200]	; (409d1c <FreeRTOS_send+0x1c4>)
  409c52:	4798      	blx	r3
  409c54:	e00a      	b.n	409c6c <FreeRTOS_send+0x114>
				}
				else
				{
					/* Has the timeout been reached? */
					if( xTaskCheckForTimeOut( &xTimeOut, &xRemainingTime ) != pdFALSE )
  409c56:	f107 0218 	add.w	r2, r7, #24
  409c5a:	f107 0310 	add.w	r3, r7, #16
  409c5e:	4611      	mov	r1, r2
  409c60:	4618      	mov	r0, r3
  409c62:	4b2f      	ldr	r3, [pc, #188]	; (409d20 <FreeRTOS_send+0x1c8>)
  409c64:	4798      	blx	r3
  409c66:	4603      	mov	r3, r0
  409c68:	2b00      	cmp	r3, #0
  409c6a:	d119      	bne.n	409ca0 <FreeRTOS_send+0x148>
						break;
					}
				}

				/* Go sleeping until down-stream events are received. */
				xEventGroupWaitBits( pxSocket->xEventGroup, eSOCKET_SEND | eSOCKET_CLOSED,
  409c6c:	69fb      	ldr	r3, [r7, #28]
  409c6e:	6858      	ldr	r0, [r3, #4]
  409c70:	69bb      	ldr	r3, [r7, #24]
  409c72:	9300      	str	r3, [sp, #0]
  409c74:	2300      	movs	r3, #0
  409c76:	2201      	movs	r2, #1
  409c78:	2122      	movs	r1, #34	; 0x22
  409c7a:	4c2a      	ldr	r4, [pc, #168]	; (409d24 <FreeRTOS_send+0x1cc>)
  409c7c:	47a0      	blx	r4
					pdTRUE /*xClearOnExit*/, pdFALSE /*xWaitAllBits*/, xRemainingTime );

				xByteCount = ( BaseType_t ) uxStreamBufferGetSpace( pxSocket->u.xTCP.txStream );
  409c7e:	69fb      	ldr	r3, [r7, #28]
  409c80:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  409c82:	4618      	mov	r0, r3
  409c84:	4b1f      	ldr	r3, [pc, #124]	; (409d04 <FreeRTOS_send+0x1ac>)
  409c86:	4798      	blx	r3
  409c88:	4603      	mov	r3, r0
  409c8a:	62fb      	str	r3, [r7, #44]	; 0x2c
			while( xBytesLeft > 0 )
  409c8c:	6abb      	ldr	r3, [r7, #40]	; 0x28
  409c8e:	2b00      	cmp	r3, #0
  409c90:	dc80      	bgt.n	409b94 <FreeRTOS_send+0x3c>
  409c92:	e006      	b.n	409ca2 <FreeRTOS_send+0x14a>
						break;
  409c94:	bf00      	nop
  409c96:	e004      	b.n	409ca2 <FreeRTOS_send+0x14a>
						break;
  409c98:	bf00      	nop
  409c9a:	e002      	b.n	409ca2 <FreeRTOS_send+0x14a>
						break;
  409c9c:	bf00      	nop
  409c9e:	e000      	b.n	409ca2 <FreeRTOS_send+0x14a>
						break;
  409ca0:	bf00      	nop
			}

			/* How much was actually sent? */
			xByteCount = ( ( BaseType_t ) uxDataLength ) - xBytesLeft;
  409ca2:	687a      	ldr	r2, [r7, #4]
  409ca4:	6abb      	ldr	r3, [r7, #40]	; 0x28
  409ca6:	1ad3      	subs	r3, r2, r3
  409ca8:	62fb      	str	r3, [r7, #44]	; 0x2c

			if( xByteCount == 0 )
  409caa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  409cac:	2b00      	cmp	r3, #0
  409cae:	d121      	bne.n	409cf4 <FreeRTOS_send+0x19c>
			{
				if( pxSocket->u.xTCP.ucTCPState > eESTABLISHED )
  409cb0:	69fb      	ldr	r3, [r7, #28]
  409cb2:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
  409cb6:	2b05      	cmp	r3, #5
  409cb8:	d903      	bls.n	409cc2 <FreeRTOS_send+0x16a>
				{
					xByteCount = ( BaseType_t ) -pdFREERTOS_ERRNO_ENOTCONN;
  409cba:	f06f 037f 	mvn.w	r3, #127	; 0x7f
  409cbe:	62fb      	str	r3, [r7, #44]	; 0x2c
  409cc0:	e018      	b.n	409cf4 <FreeRTOS_send+0x19c>
				}
				else
				{
					if( ipconfigTCP_MAY_LOG_PORT( pxSocket->usLocalPort ) != pdFALSE )
  409cc2:	69fb      	ldr	r3, [r7, #28]
  409cc4:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
  409cc6:	2b17      	cmp	r3, #23
  409cc8:	d001      	beq.n	409cce <FreeRTOS_send+0x176>
  409cca:	2301      	movs	r3, #1
  409ccc:	e000      	b.n	409cd0 <FreeRTOS_send+0x178>
  409cce:	2300      	movs	r3, #0
  409cd0:	2b00      	cmp	r3, #0
  409cd2:	d00c      	beq.n	409cee <FreeRTOS_send+0x196>
					{
						FreeRTOS_debug_printf( ( "FreeRTOS_send: %u -> %lxip:%d: no space\n",
  409cd4:	69fb      	ldr	r3, [r7, #28]
  409cd6:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
  409cd8:	4619      	mov	r1, r3
  409cda:	69fb      	ldr	r3, [r7, #28]
  409cdc:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  409cde:	69fb      	ldr	r3, [r7, #28]
  409ce0:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
  409ce2:	4811      	ldr	r0, [pc, #68]	; (409d28 <FreeRTOS_send+0x1d0>)
  409ce4:	4c11      	ldr	r4, [pc, #68]	; (409d2c <FreeRTOS_send+0x1d4>)
  409ce6:	47a0      	blx	r4
							pxSocket->usLocalPort,
							pxSocket->u.xTCP.ulRemoteIP,
							pxSocket->u.xTCP.usRemotePort ) );
							
							// HICS debug error and reset
							WDT_Debug_printf_state(1); // Print status e reset por watchdog
  409ce8:	2001      	movs	r0, #1
  409cea:	4b11      	ldr	r3, [pc, #68]	; (409d30 <FreeRTOS_send+0x1d8>)
  409cec:	4798      	blx	r3
							
					}

					xByteCount = ( BaseType_t ) -pdFREERTOS_ERRNO_ENOSPC;
  409cee:	f06f 031b 	mvn.w	r3, #27
  409cf2:	62fb      	str	r3, [r7, #44]	; 0x2c
				}
			}
		}

		return xByteCount;
  409cf4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
	}
  409cf6:	4618      	mov	r0, r3
  409cf8:	3734      	adds	r7, #52	; 0x34
  409cfa:	46bd      	mov	sp, r7
  409cfc:	bd90      	pop	{r4, r7, pc}
  409cfe:	bf00      	nop
  409d00:	00409aa1 	.word	0x00409aa1
  409d04:	004088c9 	.word	0x004088c9
  409d08:	0041267d 	.word	0x0041267d
  409d0c:	0040a781 	.word	0x0040a781
  409d10:	00412699 	.word	0x00412699
  409d14:	00407909 	.word	0x00407909
  409d18:	00407e19 	.word	0x00407e19
  409d1c:	00412c89 	.word	0x00412c89
  409d20:	00412d0d 	.word	0x00412d0d
  409d24:	00410925 	.word	0x00410925
  409d28:	0041ceec 	.word	0x0041ceec
  409d2c:	00416c7d 	.word	0x00416c7d
  409d30:	004158d9 	.word	0x004158d9

00409d34 <FreeRTOS_shutdown>:

#if( ipconfigUSE_TCP == 1 )

	/* shutdown - shut down part of a full-duplex connection */
	BaseType_t FreeRTOS_shutdown( Socket_t xSocket, BaseType_t xHow )
	{
  409d34:	b580      	push	{r7, lr}
  409d36:	b084      	sub	sp, #16
  409d38:	af00      	add	r7, sp, #0
  409d3a:	6078      	str	r0, [r7, #4]
  409d3c:	6039      	str	r1, [r7, #0]
	FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) xSocket;
  409d3e:	687b      	ldr	r3, [r7, #4]
  409d40:	60bb      	str	r3, [r7, #8]
	BaseType_t xResult;

		if( prvValidSocket( pxSocket, FREERTOS_IPPROTO_TCP, pdTRUE ) == pdFALSE )
  409d42:	2201      	movs	r2, #1
  409d44:	2106      	movs	r1, #6
  409d46:	68b8      	ldr	r0, [r7, #8]
  409d48:	4b13      	ldr	r3, [pc, #76]	; (409d98 <FreeRTOS_shutdown+0x64>)
  409d4a:	4798      	blx	r3
  409d4c:	4603      	mov	r3, r0
  409d4e:	2b00      	cmp	r3, #0
  409d50:	d103      	bne.n	409d5a <FreeRTOS_shutdown+0x26>
		{
			/*_RB_ Is this comment correct?  The socket is not of a type that
			supports the listen() operation. */
			xResult = -pdFREERTOS_ERRNO_EOPNOTSUPP;
  409d52:	f06f 035e 	mvn.w	r3, #94	; 0x5e
  409d56:	60fb      	str	r3, [r7, #12]
  409d58:	e018      	b.n	409d8c <FreeRTOS_shutdown+0x58>
		}
		else if ( pxSocket->u.xTCP.ucTCPState != eESTABLISHED )
  409d5a:	68bb      	ldr	r3, [r7, #8]
  409d5c:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
  409d60:	2b05      	cmp	r3, #5
  409d62:	d003      	beq.n	409d6c <FreeRTOS_shutdown+0x38>
		{
			/*_RB_ Is this comment correct?  The socket is not of a type that
			supports the listen() operation. */
			xResult = -pdFREERTOS_ERRNO_EOPNOTSUPP;
  409d64:	f06f 035e 	mvn.w	r3, #94	; 0x5e
  409d68:	60fb      	str	r3, [r7, #12]
  409d6a:	e00f      	b.n	409d8c <FreeRTOS_shutdown+0x58>
		}
		else
		{
			pxSocket->u.xTCP.bits.bUserShutdown = pdTRUE_UNSIGNED;
  409d6c:	68ba      	ldr	r2, [r7, #8]
  409d6e:	f892 3040 	ldrb.w	r3, [r2, #64]	; 0x40
  409d72:	f043 0320 	orr.w	r3, r3, #32
  409d76:	f882 3040 	strb.w	r3, [r2, #64]	; 0x40

			/* Let the IP-task perform the shutdown of the connection. */
			pxSocket->u.xTCP.usTimeout = 1u;
  409d7a:	68bb      	ldr	r3, [r7, #8]
  409d7c:	2201      	movs	r2, #1
  409d7e:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48
			xSendEventToIPTask( eTCPTimerEvent );
  409d82:	2006      	movs	r0, #6
  409d84:	4b05      	ldr	r3, [pc, #20]	; (409d9c <FreeRTOS_shutdown+0x68>)
  409d86:	4798      	blx	r3
			xResult = 0;
  409d88:	2300      	movs	r3, #0
  409d8a:	60fb      	str	r3, [r7, #12]
		}
		(void) xHow;

		return xResult;
  409d8c:	68fb      	ldr	r3, [r7, #12]
	}
  409d8e:	4618      	mov	r0, r3
  409d90:	3710      	adds	r7, #16
  409d92:	46bd      	mov	sp, r7
  409d94:	bd80      	pop	{r7, pc}
  409d96:	bf00      	nop
  409d98:	00408995 	.word	0x00408995
  409d9c:	00407e19 	.word	0x00407e19

00409da0 <xTCPTimerCheck>:
	 * - Send new data
	 * - Send a keep-alive packet
	 * - Check for timeout (in non-connected states only)
	 */
	TickType_t xTCPTimerCheck( BaseType_t xWillSleep )
	{
  409da0:	b580      	push	{r7, lr}
  409da2:	b08a      	sub	sp, #40	; 0x28
  409da4:	af00      	add	r7, sp, #0
  409da6:	6078      	str	r0, [r7, #4]
	FreeRTOS_Socket_t *pxSocket;
	TickType_t xShortest = pdMS_TO_TICKS( ( TickType_t ) ipTCP_TIMER_PERIOD_MS );
  409da8:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
  409dac:	627b      	str	r3, [r7, #36]	; 0x24
	TickType_t xNow = xTaskGetTickCount();
  409dae:	4b33      	ldr	r3, [pc, #204]	; (409e7c <xTCPTimerCheck+0xdc>)
  409db0:	4798      	blx	r3
  409db2:	61b8      	str	r0, [r7, #24]
	static TickType_t xLastTime = 0u;
	TickType_t xDelta = xNow - xLastTime;
  409db4:	4b32      	ldr	r3, [pc, #200]	; (409e80 <xTCPTimerCheck+0xe0>)
  409db6:	681b      	ldr	r3, [r3, #0]
  409db8:	69ba      	ldr	r2, [r7, #24]
  409dba:	1ad3      	subs	r3, r2, r3
  409dbc:	623b      	str	r3, [r7, #32]
	ListItem_t* pxEnd = ( ListItem_t * ) listGET_END_MARKER( &xBoundTCPSocketsList );
  409dbe:	4b31      	ldr	r3, [pc, #196]	; (409e84 <xTCPTimerCheck+0xe4>)
  409dc0:	617b      	str	r3, [r7, #20]
	ListItem_t *pxIterator = ( ListItem_t * ) listGET_HEAD_ENTRY( &xBoundTCPSocketsList );
  409dc2:	4b31      	ldr	r3, [pc, #196]	; (409e88 <xTCPTimerCheck+0xe8>)
  409dc4:	68db      	ldr	r3, [r3, #12]
  409dc6:	61fb      	str	r3, [r7, #28]

		xLastTime = xNow;
  409dc8:	4a2d      	ldr	r2, [pc, #180]	; (409e80 <xTCPTimerCheck+0xe0>)
  409dca:	69bb      	ldr	r3, [r7, #24]
  409dcc:	6013      	str	r3, [r2, #0]

		if( xDelta == 0u )
  409dce:	6a3b      	ldr	r3, [r7, #32]
  409dd0:	2b00      	cmp	r3, #0
  409dd2:	d149      	bne.n	409e68 <xTCPTimerCheck+0xc8>
		{
			xDelta = 1u;
  409dd4:	2301      	movs	r3, #1
  409dd6:	623b      	str	r3, [r7, #32]
		}

		while( pxIterator != pxEnd )
  409dd8:	e046      	b.n	409e68 <xTCPTimerCheck+0xc8>
		{
			pxSocket = ( FreeRTOS_Socket_t * )listGET_LIST_ITEM_OWNER( pxIterator );
  409dda:	69fb      	ldr	r3, [r7, #28]
  409ddc:	68db      	ldr	r3, [r3, #12]
  409dde:	613b      	str	r3, [r7, #16]
			pxIterator = ( ListItem_t * ) listGET_NEXT( pxIterator );
  409de0:	69fb      	ldr	r3, [r7, #28]
  409de2:	685b      	ldr	r3, [r3, #4]
  409de4:	61fb      	str	r3, [r7, #28]

			/* Sockets with 'tmout == 0' do not need any regular attention. */
			if( pxSocket->u.xTCP.usTimeout == 0u )
  409de6:	693b      	ldr	r3, [r7, #16]
  409de8:	f8b3 3048 	ldrh.w	r3, [r3, #72]	; 0x48
  409dec:	2b00      	cmp	r3, #0
  409dee:	d100      	bne.n	409df2 <xTCPTimerCheck+0x52>
			{
				continue;
  409df0:	e03a      	b.n	409e68 <xTCPTimerCheck+0xc8>
			}

			if( xDelta < ( TickType_t ) pxSocket->u.xTCP.usTimeout )
  409df2:	693b      	ldr	r3, [r7, #16]
  409df4:	f8b3 3048 	ldrh.w	r3, [r3, #72]	; 0x48
  409df8:	461a      	mov	r2, r3
  409dfa:	6a3b      	ldr	r3, [r7, #32]
  409dfc:	429a      	cmp	r2, r3
  409dfe:	d90a      	bls.n	409e16 <xTCPTimerCheck+0x76>
			{
				pxSocket->u.xTCP.usTimeout = ( uint16_t ) ( ( ( TickType_t ) pxSocket->u.xTCP.usTimeout ) - xDelta );
  409e00:	693b      	ldr	r3, [r7, #16]
  409e02:	f8b3 2048 	ldrh.w	r2, [r3, #72]	; 0x48
  409e06:	6a3b      	ldr	r3, [r7, #32]
  409e08:	b29b      	uxth	r3, r3
  409e0a:	1ad3      	subs	r3, r2, r3
  409e0c:	b29a      	uxth	r2, r3
  409e0e:	693b      	ldr	r3, [r7, #16]
  409e10:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48
  409e14:	e00b      	b.n	409e2e <xTCPTimerCheck+0x8e>
			}
			else
			{
			int rc ;
				pxSocket->u.xTCP.usTimeout = 0u;
  409e16:	693b      	ldr	r3, [r7, #16]
  409e18:	2200      	movs	r2, #0
  409e1a:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48
				rc = xTCPSocketCheck( pxSocket );
  409e1e:	6938      	ldr	r0, [r7, #16]
  409e20:	4b1a      	ldr	r3, [pc, #104]	; (409e8c <xTCPTimerCheck+0xec>)
  409e22:	4798      	blx	r3
  409e24:	60f8      	str	r0, [r7, #12]

				/* Within this function, the socket might want to send a delayed
				ack or send out data or whatever it needs to do. */
				if( rc < 0 )
  409e26:	68fb      	ldr	r3, [r7, #12]
  409e28:	2b00      	cmp	r3, #0
  409e2a:	da00      	bge.n	409e2e <xTCPTimerCheck+0x8e>
				{
					/* Continue because the socket was deleted. */
					continue;
  409e2c:	e01c      	b.n	409e68 <xTCPTimerCheck+0xc8>
			}

			/* In xEventBits the driver may indicate that the socket has
			important events for the user.  These are only done just before the
			IP-task goes to sleep. */
			if( pxSocket->xEventBits != 0u )
  409e2e:	693b      	ldr	r3, [r7, #16]
  409e30:	681b      	ldr	r3, [r3, #0]
  409e32:	2b00      	cmp	r3, #0
  409e34:	d008      	beq.n	409e48 <xTCPTimerCheck+0xa8>
			{
				if( xWillSleep != pdFALSE )
  409e36:	687b      	ldr	r3, [r7, #4]
  409e38:	2b00      	cmp	r3, #0
  409e3a:	d003      	beq.n	409e44 <xTCPTimerCheck+0xa4>
				{
					/* The IP-task is about to go to sleep, so messages can be
					sent to the socket owners. */
					vSocketWakeUpUser( pxSocket );
  409e3c:	6938      	ldr	r0, [r7, #16]
  409e3e:	4b14      	ldr	r3, [pc, #80]	; (409e90 <xTCPTimerCheck+0xf0>)
  409e40:	4798      	blx	r3
  409e42:	e001      	b.n	409e48 <xTCPTimerCheck+0xa8>
				}
				else
				{
					/* Or else make sure this will be called again to wake-up
					the sockets' owner. */
					xShortest = ( TickType_t ) 0;
  409e44:	2300      	movs	r3, #0
  409e46:	627b      	str	r3, [r7, #36]	; 0x24
				}
			}

			if( ( pxSocket->u.xTCP.usTimeout != 0u ) && ( xShortest > ( TickType_t ) pxSocket->u.xTCP.usTimeout ) )
  409e48:	693b      	ldr	r3, [r7, #16]
  409e4a:	f8b3 3048 	ldrh.w	r3, [r3, #72]	; 0x48
  409e4e:	2b00      	cmp	r3, #0
  409e50:	d00a      	beq.n	409e68 <xTCPTimerCheck+0xc8>
  409e52:	693b      	ldr	r3, [r7, #16]
  409e54:	f8b3 3048 	ldrh.w	r3, [r3, #72]	; 0x48
  409e58:	461a      	mov	r2, r3
  409e5a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  409e5c:	429a      	cmp	r2, r3
  409e5e:	d203      	bcs.n	409e68 <xTCPTimerCheck+0xc8>
			{
				xShortest = ( TickType_t ) pxSocket->u.xTCP.usTimeout;
  409e60:	693b      	ldr	r3, [r7, #16]
  409e62:	f8b3 3048 	ldrh.w	r3, [r3, #72]	; 0x48
  409e66:	627b      	str	r3, [r7, #36]	; 0x24
		while( pxIterator != pxEnd )
  409e68:	69fa      	ldr	r2, [r7, #28]
  409e6a:	697b      	ldr	r3, [r7, #20]
  409e6c:	429a      	cmp	r2, r3
  409e6e:	d1b4      	bne.n	409dda <xTCPTimerCheck+0x3a>
			}
		}

		return xShortest;
  409e70:	6a7b      	ldr	r3, [r7, #36]	; 0x24
	}
  409e72:	4618      	mov	r0, r3
  409e74:	3728      	adds	r7, #40	; 0x28
  409e76:	46bd      	mov	sp, r7
  409e78:	bd80      	pop	{r7, pc}
  409e7a:	bf00      	nop
  409e7c:	004127d1 	.word	0x004127d1
  409e80:	20006d38 	.word	0x20006d38
  409e84:	2000b5b8 	.word	0x2000b5b8
  409e88:	2000b5b0 	.word	0x2000b5b0
  409e8c:	0040ad01 	.word	0x0040ad01
  409e90:	00409611 	.word	0x00409611

00409e94 <pxTCPSocketLookup>:
	 * looking up a socket is a little more complex:
	 * Both a local port, and a remote port and IP address are being used
	 * For a socket in listening mode, the remote port and IP address are both 0
	 */
	FreeRTOS_Socket_t *pxTCPSocketLookup( uint32_t ulLocalIP, UBaseType_t uxLocalPort, uint32_t ulRemoteIP, UBaseType_t uxRemotePort )
	{
  409e94:	b480      	push	{r7}
  409e96:	b08b      	sub	sp, #44	; 0x2c
  409e98:	af00      	add	r7, sp, #0
  409e9a:	60f8      	str	r0, [r7, #12]
  409e9c:	60b9      	str	r1, [r7, #8]
  409e9e:	607a      	str	r2, [r7, #4]
  409ea0:	603b      	str	r3, [r7, #0]
	ListItem_t *pxIterator;
	FreeRTOS_Socket_t *pxResult = NULL, *pxListenSocket = NULL;
  409ea2:	2300      	movs	r3, #0
  409ea4:	623b      	str	r3, [r7, #32]
  409ea6:	2300      	movs	r3, #0
  409ea8:	61fb      	str	r3, [r7, #28]
	MiniListItem_t *pxEnd = ( MiniListItem_t* )listGET_END_MARKER( &xBoundTCPSocketsList );
  409eaa:	4b1c      	ldr	r3, [pc, #112]	; (409f1c <pxTCPSocketLookup+0x88>)
  409eac:	61bb      	str	r3, [r7, #24]

		/* Parameter not yet supported. */
		( void ) ulLocalIP;

		for( pxIterator  = ( ListItem_t * ) listGET_NEXT( pxEnd );
  409eae:	69bb      	ldr	r3, [r7, #24]
  409eb0:	685b      	ldr	r3, [r3, #4]
  409eb2:	627b      	str	r3, [r7, #36]	; 0x24
  409eb4:	e021      	b.n	409efa <pxTCPSocketLookup+0x66>
			 pxIterator != ( ListItem_t * ) pxEnd;
			 pxIterator  = ( ListItem_t * ) listGET_NEXT( pxIterator ) )
		{
			FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
  409eb6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  409eb8:	68db      	ldr	r3, [r3, #12]
  409eba:	617b      	str	r3, [r7, #20]

			if( pxSocket->usLocalPort == ( uint16_t ) uxLocalPort )
  409ebc:	697b      	ldr	r3, [r7, #20]
  409ebe:	8c9a      	ldrh	r2, [r3, #36]	; 0x24
  409ec0:	68bb      	ldr	r3, [r7, #8]
  409ec2:	b29b      	uxth	r3, r3
  409ec4:	429a      	cmp	r2, r3
  409ec6:	d115      	bne.n	409ef4 <pxTCPSocketLookup+0x60>
			{
				if( pxSocket->u.xTCP.ucTCPState == eTCP_LISTEN )
  409ec8:	697b      	ldr	r3, [r7, #20]
  409eca:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
  409ece:	2b01      	cmp	r3, #1
  409ed0:	d102      	bne.n	409ed8 <pxTCPSocketLookup+0x44>
				{
					/* If this is a socket listening to uxLocalPort, remember it
					in case there is no perfect match. */
					pxListenSocket = pxSocket;
  409ed2:	697b      	ldr	r3, [r7, #20]
  409ed4:	61fb      	str	r3, [r7, #28]
  409ed6:	e00d      	b.n	409ef4 <pxTCPSocketLookup+0x60>
				}
				else if( ( pxSocket->u.xTCP.usRemotePort == ( uint16_t ) uxRemotePort ) && ( pxSocket->u.xTCP.ulRemoteIP == ulRemoteIP ) )
  409ed8:	697b      	ldr	r3, [r7, #20]
  409eda:	8f9a      	ldrh	r2, [r3, #60]	; 0x3c
  409edc:	683b      	ldr	r3, [r7, #0]
  409ede:	b29b      	uxth	r3, r3
  409ee0:	429a      	cmp	r2, r3
  409ee2:	d107      	bne.n	409ef4 <pxTCPSocketLookup+0x60>
  409ee4:	697b      	ldr	r3, [r7, #20]
  409ee6:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  409ee8:	687b      	ldr	r3, [r7, #4]
  409eea:	429a      	cmp	r2, r3
  409eec:	d102      	bne.n	409ef4 <pxTCPSocketLookup+0x60>
				{
					/* For sockets not in listening mode, find a match with
					xLocalPort, ulRemoteIP AND xRemotePort. */
					pxResult = pxSocket;
  409eee:	697b      	ldr	r3, [r7, #20]
  409ef0:	623b      	str	r3, [r7, #32]
					break;
  409ef2:	e006      	b.n	409f02 <pxTCPSocketLookup+0x6e>
			 pxIterator  = ( ListItem_t * ) listGET_NEXT( pxIterator ) )
  409ef4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  409ef6:	685b      	ldr	r3, [r3, #4]
  409ef8:	627b      	str	r3, [r7, #36]	; 0x24
		for( pxIterator  = ( ListItem_t * ) listGET_NEXT( pxEnd );
  409efa:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  409efc:	69bb      	ldr	r3, [r7, #24]
  409efe:	429a      	cmp	r2, r3
  409f00:	d1d9      	bne.n	409eb6 <pxTCPSocketLookup+0x22>
				}
			}
		}
		if( pxResult == NULL )
  409f02:	6a3b      	ldr	r3, [r7, #32]
  409f04:	2b00      	cmp	r3, #0
  409f06:	d101      	bne.n	409f0c <pxTCPSocketLookup+0x78>
		{
			/* An exact match was not found, maybe a listening socket was
			found. */
			pxResult = pxListenSocket;
  409f08:	69fb      	ldr	r3, [r7, #28]
  409f0a:	623b      	str	r3, [r7, #32]
		}

		return pxResult;
  409f0c:	6a3b      	ldr	r3, [r7, #32]
	}
  409f0e:	4618      	mov	r0, r3
  409f10:	372c      	adds	r7, #44	; 0x2c
  409f12:	46bd      	mov	sp, r7
  409f14:	f85d 7b04 	ldr.w	r7, [sp], #4
  409f18:	4770      	bx	lr
  409f1a:	bf00      	nop
  409f1c:	2000b5b8 	.word	0x2000b5b8

00409f20 <prvTCPCreateStream>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP == 1 )

	static StreamBuffer_t *prvTCPCreateStream ( FreeRTOS_Socket_t *pxSocket, BaseType_t xIsInputStream )
	{
  409f20:	b590      	push	{r4, r7, lr}
  409f22:	b087      	sub	sp, #28
  409f24:	af00      	add	r7, sp, #0
  409f26:	6078      	str	r0, [r7, #4]
  409f28:	6039      	str	r1, [r7, #0]
	size_t uxLength;
	size_t uxSize;

		/* Now that a stream is created, the maximum size is fixed before
		creation, it could still be changed with setsockopt(). */
		if( xIsInputStream != pdFALSE )
  409f2a:	683b      	ldr	r3, [r7, #0]
  409f2c:	2b00      	cmp	r3, #0
  409f2e:	d025      	beq.n	409f7c <prvTCPCreateStream+0x5c>
		{
			uxLength = pxSocket->u.xTCP.uxRxStreamSize;
  409f30:	687b      	ldr	r3, [r7, #4]
  409f32:	6e5b      	ldr	r3, [r3, #100]	; 0x64
  409f34:	617b      	str	r3, [r7, #20]

			if( pxSocket->u.xTCP.uxLittleSpace == 0ul )
  409f36:	687b      	ldr	r3, [r7, #4]
  409f38:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
  409f3a:	2b00      	cmp	r3, #0
  409f3c:	d10c      	bne.n	409f58 <prvTCPCreateStream+0x38>
			{
				pxSocket->u.xTCP.uxLittleSpace  = ( sock20_PERCENT * pxSocket->u.xTCP.uxRxStreamSize ) / sock100_PERCENT;
  409f3e:	687b      	ldr	r3, [r7, #4]
  409f40:	6e5a      	ldr	r2, [r3, #100]	; 0x64
  409f42:	4613      	mov	r3, r2
  409f44:	009b      	lsls	r3, r3, #2
  409f46:	4413      	add	r3, r2
  409f48:	009b      	lsls	r3, r3, #2
  409f4a:	461a      	mov	r2, r3
  409f4c:	4b30      	ldr	r3, [pc, #192]	; (40a010 <prvTCPCreateStream+0xf0>)
  409f4e:	fba3 2302 	umull	r2, r3, r3, r2
  409f52:	095a      	lsrs	r2, r3, #5
  409f54:	687b      	ldr	r3, [r7, #4]
  409f56:	65da      	str	r2, [r3, #92]	; 0x5c
			}

			if( pxSocket->u.xTCP.uxEnoughSpace == 0ul )
  409f58:	687b      	ldr	r3, [r7, #4]
  409f5a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
  409f5c:	2b00      	cmp	r3, #0
  409f5e:	d110      	bne.n	409f82 <prvTCPCreateStream+0x62>
			{
				pxSocket->u.xTCP.uxEnoughSpace = ( sock80_PERCENT * pxSocket->u.xTCP.uxRxStreamSize ) / sock100_PERCENT;
  409f60:	687b      	ldr	r3, [r7, #4]
  409f62:	6e5a      	ldr	r2, [r3, #100]	; 0x64
  409f64:	4613      	mov	r3, r2
  409f66:	009b      	lsls	r3, r3, #2
  409f68:	4413      	add	r3, r2
  409f6a:	011b      	lsls	r3, r3, #4
  409f6c:	461a      	mov	r2, r3
  409f6e:	4b28      	ldr	r3, [pc, #160]	; (40a010 <prvTCPCreateStream+0xf0>)
  409f70:	fba3 2302 	umull	r2, r3, r3, r2
  409f74:	095a      	lsrs	r2, r3, #5
  409f76:	687b      	ldr	r3, [r7, #4]
  409f78:	661a      	str	r2, [r3, #96]	; 0x60
  409f7a:	e002      	b.n	409f82 <prvTCPCreateStream+0x62>
			}
		}
		else
		{
			uxLength = pxSocket->u.xTCP.uxTxStreamSize;
  409f7c:	687b      	ldr	r3, [r7, #4]
  409f7e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  409f80:	617b      	str	r3, [r7, #20]
		}

		/* Add an extra 4 (or 8) bytes. */
		uxLength += sizeof( size_t );
  409f82:	697b      	ldr	r3, [r7, #20]
  409f84:	3304      	adds	r3, #4
  409f86:	617b      	str	r3, [r7, #20]

		/* And make the length a multiple of sizeof( size_t ). */
		uxLength &= ~( sizeof( size_t ) - 1u );
  409f88:	697b      	ldr	r3, [r7, #20]
  409f8a:	f023 0303 	bic.w	r3, r3, #3
  409f8e:	617b      	str	r3, [r7, #20]

		uxSize = sizeof( *pxBuffer ) - sizeof( pxBuffer->ucArray ) + uxLength;
  409f90:	697b      	ldr	r3, [r7, #20]
  409f92:	3314      	adds	r3, #20
  409f94:	613b      	str	r3, [r7, #16]

		pxBuffer = ( StreamBuffer_t * )pvPortMallocLarge( uxSize );
  409f96:	6938      	ldr	r0, [r7, #16]
  409f98:	4b1e      	ldr	r3, [pc, #120]	; (40a014 <prvTCPCreateStream+0xf4>)
  409f9a:	4798      	blx	r3
  409f9c:	60f8      	str	r0, [r7, #12]

		if( pxBuffer == NULL )
  409f9e:	68fb      	ldr	r3, [r7, #12]
  409fa0:	2b00      	cmp	r3, #0
  409fa2:	d10e      	bne.n	409fc2 <prvTCPCreateStream+0xa2>
		{
			FreeRTOS_debug_printf( ( "prvTCPCreateStream: malloc failed\n" ) );
  409fa4:	481c      	ldr	r0, [pc, #112]	; (40a018 <prvTCPCreateStream+0xf8>)
  409fa6:	4b1d      	ldr	r3, [pc, #116]	; (40a01c <prvTCPCreateStream+0xfc>)
  409fa8:	4798      	blx	r3
			pxSocket->u.xTCP.bits.bMallocError = pdTRUE_UNSIGNED;
  409faa:	687a      	ldr	r2, [r7, #4]
  409fac:	f892 3042 	ldrb.w	r3, [r2, #66]	; 0x42
  409fb0:	f043 0308 	orr.w	r3, r3, #8
  409fb4:	f882 3042 	strb.w	r3, [r2, #66]	; 0x42
			vTCPStateChange( pxSocket, eCLOSE_WAIT );
  409fb8:	2108      	movs	r1, #8
  409fba:	6878      	ldr	r0, [r7, #4]
  409fbc:	4b18      	ldr	r3, [pc, #96]	; (40a020 <prvTCPCreateStream+0x100>)
  409fbe:	4798      	blx	r3
  409fc0:	e020      	b.n	40a004 <prvTCPCreateStream+0xe4>
		}
		else
		{
			/* Clear the markers of the stream */
			memset( pxBuffer, '\0', sizeof( *pxBuffer ) - sizeof( pxBuffer->ucArray ) );
  409fc2:	2214      	movs	r2, #20
  409fc4:	2100      	movs	r1, #0
  409fc6:	68f8      	ldr	r0, [r7, #12]
  409fc8:	4b16      	ldr	r3, [pc, #88]	; (40a024 <prvTCPCreateStream+0x104>)
  409fca:	4798      	blx	r3
			pxBuffer->LENGTH = ( size_t ) uxLength ;
  409fcc:	68fb      	ldr	r3, [r7, #12]
  409fce:	697a      	ldr	r2, [r7, #20]
  409fd0:	611a      	str	r2, [r3, #16]

			if( xTCPWindowLoggingLevel != 0 )
  409fd2:	4b15      	ldr	r3, [pc, #84]	; (40a028 <prvTCPCreateStream+0x108>)
  409fd4:	681b      	ldr	r3, [r3, #0]
  409fd6:	2b00      	cmp	r3, #0
  409fd8:	d00a      	beq.n	409ff0 <prvTCPCreateStream+0xd0>
			{
				FreeRTOS_debug_printf( ( "prvTCPCreateStream: %cxStream created %lu bytes (total %lu)\n", xIsInputStream ? 'R' : 'T', uxLength, uxSize ) );
  409fda:	683b      	ldr	r3, [r7, #0]
  409fdc:	2b00      	cmp	r3, #0
  409fde:	d001      	beq.n	409fe4 <prvTCPCreateStream+0xc4>
  409fe0:	2152      	movs	r1, #82	; 0x52
  409fe2:	e000      	b.n	409fe6 <prvTCPCreateStream+0xc6>
  409fe4:	2154      	movs	r1, #84	; 0x54
  409fe6:	693b      	ldr	r3, [r7, #16]
  409fe8:	697a      	ldr	r2, [r7, #20]
  409fea:	4810      	ldr	r0, [pc, #64]	; (40a02c <prvTCPCreateStream+0x10c>)
  409fec:	4c0b      	ldr	r4, [pc, #44]	; (40a01c <prvTCPCreateStream+0xfc>)
  409fee:	47a0      	blx	r4
			}

			if( xIsInputStream != 0 )
  409ff0:	683b      	ldr	r3, [r7, #0]
  409ff2:	2b00      	cmp	r3, #0
  409ff4:	d003      	beq.n	409ffe <prvTCPCreateStream+0xde>
			{
				pxSocket->u.xTCP.rxStream = pxBuffer;
  409ff6:	687b      	ldr	r3, [r7, #4]
  409ff8:	68fa      	ldr	r2, [r7, #12]
  409ffa:	66da      	str	r2, [r3, #108]	; 0x6c
  409ffc:	e002      	b.n	40a004 <prvTCPCreateStream+0xe4>
			}
			else
			{
				pxSocket->u.xTCP.txStream = pxBuffer;
  409ffe:	687b      	ldr	r3, [r7, #4]
  40a000:	68fa      	ldr	r2, [r7, #12]
  40a002:	671a      	str	r2, [r3, #112]	; 0x70
			}
		}

		return pxBuffer;
  40a004:	68fb      	ldr	r3, [r7, #12]
	}
  40a006:	4618      	mov	r0, r3
  40a008:	371c      	adds	r7, #28
  40a00a:	46bd      	mov	sp, r7
  40a00c:	bd90      	pop	{r4, r7, pc}
  40a00e:	bf00      	nop
  40a010:	51eb851f 	.word	0x51eb851f
  40a014:	004111e5 	.word	0x004111e5
  40a018:	0041cf18 	.word	0x0041cf18
  40a01c:	00416c7d 	.word	0x00416c7d
  40a020:	0040bbc1 	.word	0x0040bbc1
  40a024:	00416f01 	.word	0x00416f01
  40a028:	20006d60 	.word	0x20006d60
  40a02c:	0041cf3c 	.word	0x0041cf3c

0040a030 <lTCPAddRxdata>:
	/*
	 * Add data to the RxStream.  When uxOffset > 0, data has come in out-of-order
	 * and will be put in front of the head so it can not be popped by the user.
	 */
	int32_t lTCPAddRxdata( FreeRTOS_Socket_t *pxSocket, size_t uxOffset, const uint8_t *pcData, uint32_t ulByteCount )
	{
  40a030:	b5b0      	push	{r4, r5, r7, lr}
  40a032:	b08c      	sub	sp, #48	; 0x30
  40a034:	af04      	add	r7, sp, #16
  40a036:	60f8      	str	r0, [r7, #12]
  40a038:	60b9      	str	r1, [r7, #8]
  40a03a:	607a      	str	r2, [r7, #4]
  40a03c:	603b      	str	r3, [r7, #0]
	StreamBuffer_t *pxStream = pxSocket->u.xTCP.rxStream;
  40a03e:	68fb      	ldr	r3, [r7, #12]
  40a040:	6edb      	ldr	r3, [r3, #108]	; 0x6c
  40a042:	61fb      	str	r3, [r7, #28]
		/* int32_t uxStreamBufferAdd( pxBuffer, uxOffset, pucData, aCount )
		if( pucData != NULL ) copy data the the buffer
		if( pucData == NULL ) no copying, just advance rxHead
		if( uxOffset != 0 ) Just store data which has come out-of-order
		if( uxOffset == 0 ) Also advance rxHead */
		if( pxStream == NULL )
  40a044:	69fb      	ldr	r3, [r7, #28]
  40a046:	2b00      	cmp	r3, #0
  40a048:	d10a      	bne.n	40a060 <lTCPAddRxdata+0x30>
		{
			pxStream = prvTCPCreateStream( pxSocket, pdTRUE );
  40a04a:	2101      	movs	r1, #1
  40a04c:	68f8      	ldr	r0, [r7, #12]
  40a04e:	4b35      	ldr	r3, [pc, #212]	; (40a124 <lTCPAddRxdata+0xf4>)
  40a050:	4798      	blx	r3
  40a052:	61f8      	str	r0, [r7, #28]
			if( pxStream == NULL )
  40a054:	69fb      	ldr	r3, [r7, #28]
  40a056:	2b00      	cmp	r3, #0
  40a058:	d102      	bne.n	40a060 <lTCPAddRxdata+0x30>
			{
				return -1;
  40a05a:	f04f 33ff 	mov.w	r3, #4294967295
  40a05e:	e05d      	b.n	40a11c <lTCPAddRxdata+0xec>
				pcData = NULL;
			}
		}
		#endif /* ipconfigUSE_CALLBACKS */

		xResult = ( int32_t ) uxStreamBufferAdd( pxStream, uxOffset, pcData, ( size_t ) ulByteCount );
  40a060:	683b      	ldr	r3, [r7, #0]
  40a062:	687a      	ldr	r2, [r7, #4]
  40a064:	68b9      	ldr	r1, [r7, #8]
  40a066:	69f8      	ldr	r0, [r7, #28]
  40a068:	4c2f      	ldr	r4, [pc, #188]	; (40a128 <lTCPAddRxdata+0xf8>)
  40a06a:	47a0      	blx	r4
  40a06c:	4603      	mov	r3, r0
  40a06e:	61bb      	str	r3, [r7, #24]

		#if( ipconfigHAS_DEBUG_PRINTF != 0 )
		{
			if( xResult != ( int32_t ) ulByteCount )
  40a070:	683b      	ldr	r3, [r7, #0]
  40a072:	69ba      	ldr	r2, [r7, #24]
  40a074:	429a      	cmp	r2, r3
  40a076:	d013      	beq.n	40a0a0 <lTCPAddRxdata+0x70>
			{
				FreeRTOS_debug_printf( ( "lTCPAddRxdata: at %ld: %ld/%lu bytes (tail %lu head %lu space %lu front %lu)\n",
  40a078:	69fb      	ldr	r3, [r7, #28]
  40a07a:	681c      	ldr	r4, [r3, #0]
  40a07c:	69fb      	ldr	r3, [r7, #28]
  40a07e:	689d      	ldr	r5, [r3, #8]
  40a080:	69f8      	ldr	r0, [r7, #28]
  40a082:	4b2a      	ldr	r3, [pc, #168]	; (40a12c <lTCPAddRxdata+0xfc>)
  40a084:	4798      	blx	r3
  40a086:	4602      	mov	r2, r0
  40a088:	69fb      	ldr	r3, [r7, #28]
  40a08a:	68db      	ldr	r3, [r3, #12]
  40a08c:	9303      	str	r3, [sp, #12]
  40a08e:	9202      	str	r2, [sp, #8]
  40a090:	9501      	str	r5, [sp, #4]
  40a092:	9400      	str	r4, [sp, #0]
  40a094:	683b      	ldr	r3, [r7, #0]
  40a096:	69ba      	ldr	r2, [r7, #24]
  40a098:	68b9      	ldr	r1, [r7, #8]
  40a09a:	4825      	ldr	r0, [pc, #148]	; (40a130 <lTCPAddRxdata+0x100>)
  40a09c:	4c25      	ldr	r4, [pc, #148]	; (40a134 <lTCPAddRxdata+0x104>)
  40a09e:	47a0      	blx	r4
					pxStream->uxFront ) );
			}
		}
		#endif /* ipconfigHAS_DEBUG_PRINTF */

		if( uxOffset == 0u )
  40a0a0:	68bb      	ldr	r3, [r7, #8]
  40a0a2:	2b00      	cmp	r3, #0
  40a0a4:	d139      	bne.n	40a11a <lTCPAddRxdata+0xea>
					}
				} else
			#endif /* ipconfigUSE_CALLBACKS */
			{
				/* See if running out of space. */
				if( pxSocket->u.xTCP.bits.bLowWater == pdFALSE_UNSIGNED )
  40a0a6:	68fb      	ldr	r3, [r7, #12]
  40a0a8:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
  40a0ac:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
  40a0b0:	b2db      	uxtb	r3, r3
  40a0b2:	2b00      	cmp	r3, #0
  40a0b4:	d11f      	bne.n	40a0f6 <lTCPAddRxdata+0xc6>
				{
					size_t uxFrontSpace = uxStreamBufferFrontSpace( pxSocket->u.xTCP.rxStream );
  40a0b6:	68fb      	ldr	r3, [r7, #12]
  40a0b8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
  40a0ba:	4618      	mov	r0, r3
  40a0bc:	4b1b      	ldr	r3, [pc, #108]	; (40a12c <lTCPAddRxdata+0xfc>)
  40a0be:	4798      	blx	r3
  40a0c0:	6178      	str	r0, [r7, #20]
					if( uxFrontSpace <= pxSocket->u.xTCP.uxLittleSpace  )
  40a0c2:	68fb      	ldr	r3, [r7, #12]
  40a0c4:	6dda      	ldr	r2, [r3, #92]	; 0x5c
  40a0c6:	697b      	ldr	r3, [r7, #20]
  40a0c8:	429a      	cmp	r2, r3
  40a0ca:	d314      	bcc.n	40a0f6 <lTCPAddRxdata+0xc6>
					{
						pxSocket->u.xTCP.bits.bLowWater = pdTRUE_UNSIGNED;
  40a0cc:	68fa      	ldr	r2, [r7, #12]
  40a0ce:	f892 3040 	ldrb.w	r3, [r2, #64]	; 0x40
  40a0d2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  40a0d6:	f882 3040 	strb.w	r3, [r2, #64]	; 0x40
						pxSocket->u.xTCP.bits.bWinChange = pdTRUE_UNSIGNED;
  40a0da:	68fa      	ldr	r2, [r7, #12]
  40a0dc:	f892 3041 	ldrb.w	r3, [r2, #65]	; 0x41
  40a0e0:	f043 0301 	orr.w	r3, r3, #1
  40a0e4:	f882 3041 	strb.w	r3, [r2, #65]	; 0x41

						/* bLowWater was reached, send the changed window size. */
						pxSocket->u.xTCP.usTimeout = 1u;
  40a0e8:	68fb      	ldr	r3, [r7, #12]
  40a0ea:	2201      	movs	r2, #1
  40a0ec:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48
						xSendEventToIPTask( eTCPTimerEvent );
  40a0f0:	2006      	movs	r0, #6
  40a0f2:	4b11      	ldr	r3, [pc, #68]	; (40a138 <lTCPAddRxdata+0x108>)
  40a0f4:	4798      	blx	r3
					}
				}

				/* New incoming data is available, wake up the user.   User's
				semaphores will be set just before the IP-task goes asleep. */
				pxSocket->xEventBits |= eSOCKET_RECEIVE;
  40a0f6:	68fb      	ldr	r3, [r7, #12]
  40a0f8:	681b      	ldr	r3, [r3, #0]
  40a0fa:	f043 0201 	orr.w	r2, r3, #1
  40a0fe:	68fb      	ldr	r3, [r7, #12]
  40a100:	601a      	str	r2, [r3, #0]

				#if ipconfigSUPPORT_SELECT_FUNCTION == 1
				{
					if( ( pxSocket->xSelectBits & eSELECT_READ ) != 0 )
  40a102:	68fb      	ldr	r3, [r7, #12]
  40a104:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  40a106:	f003 0301 	and.w	r3, r3, #1
  40a10a:	2b00      	cmp	r3, #0
  40a10c:	d005      	beq.n	40a11a <lTCPAddRxdata+0xea>
					{
						pxSocket->xEventBits |= ( eSELECT_READ << SOCKET_EVENT_BIT_COUNT );
  40a10e:	68fb      	ldr	r3, [r7, #12]
  40a110:	681b      	ldr	r3, [r3, #0]
  40a112:	f443 7280 	orr.w	r2, r3, #256	; 0x100
  40a116:	68fb      	ldr	r3, [r7, #12]
  40a118:	601a      	str	r2, [r3, #0]
				}
				#endif
			}
		}

		return xResult;
  40a11a:	69bb      	ldr	r3, [r7, #24]
	}
  40a11c:	4618      	mov	r0, r3
  40a11e:	3720      	adds	r7, #32
  40a120:	46bd      	mov	sp, r7
  40a122:	bdb0      	pop	{r4, r5, r7, pc}
  40a124:	00409f21 	.word	0x00409f21
  40a128:	0040a781 	.word	0x0040a781
  40a12c:	004088f5 	.word	0x004088f5
  40a130:	0041cf7c 	.word	0x0041cf7c
  40a134:	00416c7d 	.word	0x00416c7d
  40a138:	00407e19 	.word	0x00407e19

0040a13c <FreeRTOS_tx_space>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP ==1 )

	BaseType_t FreeRTOS_tx_space( Socket_t xSocket )
	{
  40a13c:	b580      	push	{r7, lr}
  40a13e:	b084      	sub	sp, #16
  40a140:	af00      	add	r7, sp, #0
  40a142:	6078      	str	r0, [r7, #4]
	FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) xSocket;
  40a144:	687b      	ldr	r3, [r7, #4]
  40a146:	60bb      	str	r3, [r7, #8]
	BaseType_t xReturn;

		if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
  40a148:	68bb      	ldr	r3, [r7, #8]
  40a14a:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
  40a14e:	2b06      	cmp	r3, #6
  40a150:	d003      	beq.n	40a15a <FreeRTOS_tx_space+0x1e>
		{
			xReturn = -pdFREERTOS_ERRNO_EINVAL;
  40a152:	f06f 0315 	mvn.w	r3, #21
  40a156:	60fb      	str	r3, [r7, #12]
  40a158:	e00e      	b.n	40a178 <FreeRTOS_tx_space+0x3c>
		}
		else
		{
			if( pxSocket->u.xTCP.txStream != NULL )
  40a15a:	68bb      	ldr	r3, [r7, #8]
  40a15c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  40a15e:	2b00      	cmp	r3, #0
  40a160:	d007      	beq.n	40a172 <FreeRTOS_tx_space+0x36>
			{
				xReturn = ( BaseType_t ) uxStreamBufferGetSpace ( pxSocket->u.xTCP.txStream );
  40a162:	68bb      	ldr	r3, [r7, #8]
  40a164:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  40a166:	4618      	mov	r0, r3
  40a168:	4b06      	ldr	r3, [pc, #24]	; (40a184 <FreeRTOS_tx_space+0x48>)
  40a16a:	4798      	blx	r3
  40a16c:	4603      	mov	r3, r0
  40a16e:	60fb      	str	r3, [r7, #12]
  40a170:	e002      	b.n	40a178 <FreeRTOS_tx_space+0x3c>
			}
			else
			{
				xReturn = ( BaseType_t ) pxSocket->u.xTCP.uxTxStreamSize;
  40a172:	68bb      	ldr	r3, [r7, #8]
  40a174:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  40a176:	60fb      	str	r3, [r7, #12]
			}
		}

		return xReturn;
  40a178:	68fb      	ldr	r3, [r7, #12]
	}
  40a17a:	4618      	mov	r0, r3
  40a17c:	3710      	adds	r7, #16
  40a17e:	46bd      	mov	sp, r7
  40a180:	bd80      	pop	{r7, pc}
  40a182:	bf00      	nop
  40a184:	004088c9 	.word	0x004088c9

0040a188 <FreeRTOS_issocketconnected>:

#if( ipconfigUSE_TCP == 1 )

	/* Returns pdTRUE if TCP socket is connected. */
	BaseType_t FreeRTOS_issocketconnected( Socket_t xSocket )
	{
  40a188:	b480      	push	{r7}
  40a18a:	b085      	sub	sp, #20
  40a18c:	af00      	add	r7, sp, #0
  40a18e:	6078      	str	r0, [r7, #4]
	FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) xSocket;
  40a190:	687b      	ldr	r3, [r7, #4]
  40a192:	60bb      	str	r3, [r7, #8]
	BaseType_t xReturn = pdFALSE;
  40a194:	2300      	movs	r3, #0
  40a196:	60fb      	str	r3, [r7, #12]

		if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
  40a198:	68bb      	ldr	r3, [r7, #8]
  40a19a:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
  40a19e:	2b06      	cmp	r3, #6
  40a1a0:	d003      	beq.n	40a1aa <FreeRTOS_issocketconnected+0x22>
		{
			xReturn = -pdFREERTOS_ERRNO_EINVAL;
  40a1a2:	f06f 0315 	mvn.w	r3, #21
  40a1a6:	60fb      	str	r3, [r7, #12]
  40a1a8:	e00b      	b.n	40a1c2 <FreeRTOS_issocketconnected+0x3a>
		}
		else
		{
			if( pxSocket->u.xTCP.ucTCPState >= eESTABLISHED )
  40a1aa:	68bb      	ldr	r3, [r7, #8]
  40a1ac:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
  40a1b0:	2b04      	cmp	r3, #4
  40a1b2:	d906      	bls.n	40a1c2 <FreeRTOS_issocketconnected+0x3a>
			{
				if( pxSocket->u.xTCP.ucTCPState < eCLOSE_WAIT )
  40a1b4:	68bb      	ldr	r3, [r7, #8]
  40a1b6:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
  40a1ba:	2b07      	cmp	r3, #7
  40a1bc:	d801      	bhi.n	40a1c2 <FreeRTOS_issocketconnected+0x3a>
				{
					xReturn = pdTRUE;
  40a1be:	2301      	movs	r3, #1
  40a1c0:	60fb      	str	r3, [r7, #12]
				}
			}
		}

		return xReturn;
  40a1c2:	68fb      	ldr	r3, [r7, #12]
	}
  40a1c4:	4618      	mov	r0, r3
  40a1c6:	3714      	adds	r7, #20
  40a1c8:	46bd      	mov	sp, r7
  40a1ca:	f85d 7b04 	ldr.w	r7, [sp], #4
  40a1ce:	4770      	bx	lr

0040a1d0 <FreeRTOS_rx_size>:

	/*
	 * Returns the number of bytes which can be read.
	 */
	BaseType_t FreeRTOS_rx_size( Socket_t xSocket )
	{
  40a1d0:	b580      	push	{r7, lr}
  40a1d2:	b084      	sub	sp, #16
  40a1d4:	af00      	add	r7, sp, #0
  40a1d6:	6078      	str	r0, [r7, #4]
	FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) xSocket;
  40a1d8:	687b      	ldr	r3, [r7, #4]
  40a1da:	60bb      	str	r3, [r7, #8]
	BaseType_t xReturn;

		if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
  40a1dc:	68bb      	ldr	r3, [r7, #8]
  40a1de:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
  40a1e2:	2b06      	cmp	r3, #6
  40a1e4:	d003      	beq.n	40a1ee <FreeRTOS_rx_size+0x1e>
		{
			xReturn = -pdFREERTOS_ERRNO_EINVAL;
  40a1e6:	f06f 0315 	mvn.w	r3, #21
  40a1ea:	60fb      	str	r3, [r7, #12]
  40a1ec:	e00d      	b.n	40a20a <FreeRTOS_rx_size+0x3a>
		}
		else if( pxSocket->u.xTCP.rxStream != NULL )
  40a1ee:	68bb      	ldr	r3, [r7, #8]
  40a1f0:	6edb      	ldr	r3, [r3, #108]	; 0x6c
  40a1f2:	2b00      	cmp	r3, #0
  40a1f4:	d007      	beq.n	40a206 <FreeRTOS_rx_size+0x36>
		{
			xReturn = ( BaseType_t ) uxStreamBufferGetSize( pxSocket->u.xTCP.rxStream );
  40a1f6:	68bb      	ldr	r3, [r7, #8]
  40a1f8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
  40a1fa:	4618      	mov	r0, r3
  40a1fc:	4b05      	ldr	r3, [pc, #20]	; (40a214 <FreeRTOS_rx_size+0x44>)
  40a1fe:	4798      	blx	r3
  40a200:	4603      	mov	r3, r0
  40a202:	60fb      	str	r3, [r7, #12]
  40a204:	e001      	b.n	40a20a <FreeRTOS_rx_size+0x3a>
		}
		else
		{
			xReturn = 0;
  40a206:	2300      	movs	r3, #0
  40a208:	60fb      	str	r3, [r7, #12]
		}

		return xReturn;
  40a20a:	68fb      	ldr	r3, [r7, #12]
	}
  40a20c:	4618      	mov	r0, r3
  40a20e:	3710      	adds	r7, #16
  40a210:	46bd      	mov	sp, r7
  40a212:	bd80      	pop	{r7, pc}
  40a214:	00408921 	.word	0x00408921

0040a218 <vTCPNetStat>:
/*-----------------------------------------------------------*/

#if( ( ipconfigHAS_PRINTF != 0 ) && ( ipconfigUSE_TCP == 1 ) )

	void vTCPNetStat( void )
	{
  40a218:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  40a21c:	b091      	sub	sp, #68	; 0x44
  40a21e:	af06      	add	r7, sp, #24
	/* Show a simple listing of all created sockets and their connections */
	ListItem_t *pxIterator;
	BaseType_t count = 0;
  40a220:	2300      	movs	r3, #0
  40a222:	623b      	str	r3, [r7, #32]

		if( listLIST_IS_INITIALISED( &xBoundTCPSocketsList ) == pdFALSE )
  40a224:	4b59      	ldr	r3, [pc, #356]	; (40a38c <vTCPNetStat+0x174>)
  40a226:	689b      	ldr	r3, [r3, #8]
  40a228:	f1b3 3fff 	cmp.w	r3, #4294967295
  40a22c:	d003      	beq.n	40a236 <vTCPNetStat+0x1e>
		{
			FreeRTOS_printf( ( "PLUS-TCP not initialized\n" ) );
  40a22e:	4858      	ldr	r0, [pc, #352]	; (40a390 <vTCPNetStat+0x178>)
  40a230:	4b58      	ldr	r3, [pc, #352]	; (40a394 <vTCPNetStat+0x17c>)
  40a232:	4798      	blx	r3
				count,
				uxGetMinimumFreeNetworkBuffers( ),
				uxGetNumberOfFreeNetworkBuffers( ),
				ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS ) );
		}
	}
  40a234:	e0a4      	b.n	40a380 <vTCPNetStat+0x168>
			FreeRTOS_printf( ( "Prot Port IP-Remote	   : Port  R/T Status	   Alive  tmout Child\n" ) );
  40a236:	4858      	ldr	r0, [pc, #352]	; (40a398 <vTCPNetStat+0x180>)
  40a238:	4b56      	ldr	r3, [pc, #344]	; (40a394 <vTCPNetStat+0x17c>)
  40a23a:	4798      	blx	r3
			for( pxIterator  = ( ListItem_t * ) listGET_HEAD_ENTRY( &xBoundTCPSocketsList );
  40a23c:	4b53      	ldr	r3, [pc, #332]	; (40a38c <vTCPNetStat+0x174>)
  40a23e:	68db      	ldr	r3, [r3, #12]
  40a240:	627b      	str	r3, [r7, #36]	; 0x24
  40a242:	e06e      	b.n	40a322 <vTCPNetStat+0x10a>
				FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
  40a244:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40a246:	68db      	ldr	r3, [r3, #12]
  40a248:	61fb      	str	r3, [r7, #28]
					TickType_t age = 0u;
  40a24a:	2300      	movs	r3, #0
  40a24c:	61bb      	str	r3, [r7, #24]
					void *pxHandleReceive = (void*)NULL;
  40a24e:	2300      	movs	r3, #0
  40a250:	617b      	str	r3, [r7, #20]
				char ucChildText[16] = "";
  40a252:	2300      	movs	r3, #0
  40a254:	603b      	str	r3, [r7, #0]
  40a256:	1d3b      	adds	r3, r7, #4
  40a258:	2200      	movs	r2, #0
  40a25a:	601a      	str	r2, [r3, #0]
  40a25c:	605a      	str	r2, [r3, #4]
  40a25e:	609a      	str	r2, [r3, #8]
				if (pxSocket->u.xTCP.ucTCPState == eTCP_LISTEN)
  40a260:	69fb      	ldr	r3, [r7, #28]
  40a262:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
  40a266:	2b01      	cmp	r3, #1
  40a268:	d120      	bne.n	40a2ac <vTCPNetStat+0x94>
						( int ) pxSocket->u.xTCP.usChildCount,
  40a26a:	69fb      	ldr	r3, [r7, #28]
  40a26c:	f8b3 304e 	ldrh.w	r3, [r3, #78]	; 0x4e
					const int32_t copied_len = snprintf( ucChildText, sizeof( ucChildText ), " %d/%d",
  40a270:	461a      	mov	r2, r3
						( int ) pxSocket->u.xTCP.usBacklog);
  40a272:	69fb      	ldr	r3, [r7, #28]
  40a274:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
					const int32_t copied_len = snprintf( ucChildText, sizeof( ucChildText ), " %d/%d",
  40a278:	4638      	mov	r0, r7
  40a27a:	9300      	str	r3, [sp, #0]
  40a27c:	4613      	mov	r3, r2
  40a27e:	4a47      	ldr	r2, [pc, #284]	; (40a39c <vTCPNetStat+0x184>)
  40a280:	2110      	movs	r1, #16
  40a282:	4c47      	ldr	r4, [pc, #284]	; (40a3a0 <vTCPNetStat+0x188>)
  40a284:	47a0      	blx	r4
  40a286:	6138      	str	r0, [r7, #16]
					configASSERT( copied_len >= 0 );
  40a288:	693b      	ldr	r3, [r7, #16]
  40a28a:	2b00      	cmp	r3, #0
  40a28c:	da05      	bge.n	40a29a <vTCPNetStat+0x82>
  40a28e:	f640 5256 	movw	r2, #3414	; 0xd56
  40a292:	4944      	ldr	r1, [pc, #272]	; (40a3a4 <vTCPNetStat+0x18c>)
  40a294:	4844      	ldr	r0, [pc, #272]	; (40a3a8 <vTCPNetStat+0x190>)
  40a296:	4b3f      	ldr	r3, [pc, #252]	; (40a394 <vTCPNetStat+0x17c>)
  40a298:	4798      	blx	r3
					configASSERT( copied_len < sizeof( ucChildText ) );
  40a29a:	693b      	ldr	r3, [r7, #16]
  40a29c:	2b0f      	cmp	r3, #15
  40a29e:	d905      	bls.n	40a2ac <vTCPNetStat+0x94>
  40a2a0:	f640 5257 	movw	r2, #3415	; 0xd57
  40a2a4:	493f      	ldr	r1, [pc, #252]	; (40a3a4 <vTCPNetStat+0x18c>)
  40a2a6:	4840      	ldr	r0, [pc, #256]	; (40a3a8 <vTCPNetStat+0x190>)
  40a2a8:	4b3a      	ldr	r3, [pc, #232]	; (40a394 <vTCPNetStat+0x17c>)
  40a2aa:	4798      	blx	r3
				FreeRTOS_printf( ( "TCP %5d %-16lxip:%5d %d/%d %-13.13s %6lu %6u%s\n",
  40a2ac:	69fb      	ldr	r3, [r7, #28]
  40a2ae:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
  40a2b0:	4698      	mov	r8, r3
  40a2b2:	69fb      	ldr	r3, [r7, #28]
  40a2b4:	6b9c      	ldr	r4, [r3, #56]	; 0x38
  40a2b6:	69fb      	ldr	r3, [r7, #28]
  40a2b8:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
  40a2ba:	4699      	mov	r9, r3
  40a2bc:	69fb      	ldr	r3, [r7, #28]
  40a2be:	6edb      	ldr	r3, [r3, #108]	; 0x6c
  40a2c0:	2b00      	cmp	r3, #0
  40a2c2:	bf14      	ite	ne
  40a2c4:	2301      	movne	r3, #1
  40a2c6:	2300      	moveq	r3, #0
  40a2c8:	b2db      	uxtb	r3, r3
  40a2ca:	461d      	mov	r5, r3
  40a2cc:	69fb      	ldr	r3, [r7, #28]
  40a2ce:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  40a2d0:	2b00      	cmp	r3, #0
  40a2d2:	bf14      	ite	ne
  40a2d4:	2301      	movne	r3, #1
  40a2d6:	2300      	moveq	r3, #0
  40a2d8:	b2db      	uxtb	r3, r3
  40a2da:	461e      	mov	r6, r3
  40a2dc:	69fb      	ldr	r3, [r7, #28]
  40a2de:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
  40a2e2:	4618      	mov	r0, r3
  40a2e4:	4b31      	ldr	r3, [pc, #196]	; (40a3ac <vTCPNetStat+0x194>)
  40a2e6:	4798      	blx	r3
  40a2e8:	4601      	mov	r1, r0
  40a2ea:	69bb      	ldr	r3, [r7, #24]
  40a2ec:	4a30      	ldr	r2, [pc, #192]	; (40a3b0 <vTCPNetStat+0x198>)
  40a2ee:	4293      	cmp	r3, r2
  40a2f0:	bf28      	it	cs
  40a2f2:	4613      	movcs	r3, r2
  40a2f4:	69fa      	ldr	r2, [r7, #28]
  40a2f6:	f8b2 2048 	ldrh.w	r2, [r2, #72]	; 0x48
  40a2fa:	4610      	mov	r0, r2
  40a2fc:	463a      	mov	r2, r7
  40a2fe:	9205      	str	r2, [sp, #20]
  40a300:	9004      	str	r0, [sp, #16]
  40a302:	9303      	str	r3, [sp, #12]
  40a304:	9102      	str	r1, [sp, #8]
  40a306:	9601      	str	r6, [sp, #4]
  40a308:	9500      	str	r5, [sp, #0]
  40a30a:	464b      	mov	r3, r9
  40a30c:	4622      	mov	r2, r4
  40a30e:	4641      	mov	r1, r8
  40a310:	4828      	ldr	r0, [pc, #160]	; (40a3b4 <vTCPNetStat+0x19c>)
  40a312:	4c20      	ldr	r4, [pc, #128]	; (40a394 <vTCPNetStat+0x17c>)
  40a314:	47a0      	blx	r4
				count++;
  40a316:	6a3b      	ldr	r3, [r7, #32]
  40a318:	3301      	adds	r3, #1
  40a31a:	623b      	str	r3, [r7, #32]
				 pxIterator  = ( ListItem_t * ) listGET_NEXT( pxIterator ) )
  40a31c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40a31e:	685b      	ldr	r3, [r3, #4]
  40a320:	627b      	str	r3, [r7, #36]	; 0x24
			for( pxIterator  = ( ListItem_t * ) listGET_HEAD_ENTRY( &xBoundTCPSocketsList );
  40a322:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40a324:	4a24      	ldr	r2, [pc, #144]	; (40a3b8 <vTCPNetStat+0x1a0>)
  40a326:	4293      	cmp	r3, r2
  40a328:	d18c      	bne.n	40a244 <vTCPNetStat+0x2c>
			for( pxIterator  = ( ListItem_t * ) listGET_HEAD_ENTRY( &xBoundUDPSocketsList );
  40a32a:	4b24      	ldr	r3, [pc, #144]	; (40a3bc <vTCPNetStat+0x1a4>)
  40a32c:	68db      	ldr	r3, [r3, #12]
  40a32e:	627b      	str	r3, [r7, #36]	; 0x24
  40a330:	e014      	b.n	40a35c <vTCPNetStat+0x144>
				FreeRTOS_printf( ( "UDP Port %5u\n",
  40a332:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40a334:	681b      	ldr	r3, [r3, #0]
  40a336:	b29b      	uxth	r3, r3
  40a338:	021b      	lsls	r3, r3, #8
  40a33a:	b29a      	uxth	r2, r3
  40a33c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40a33e:	681b      	ldr	r3, [r3, #0]
  40a340:	0a1b      	lsrs	r3, r3, #8
  40a342:	b29b      	uxth	r3, r3
  40a344:	4313      	orrs	r3, r2
  40a346:	b29b      	uxth	r3, r3
  40a348:	4619      	mov	r1, r3
  40a34a:	481d      	ldr	r0, [pc, #116]	; (40a3c0 <vTCPNetStat+0x1a8>)
  40a34c:	4b11      	ldr	r3, [pc, #68]	; (40a394 <vTCPNetStat+0x17c>)
  40a34e:	4798      	blx	r3
				count++;
  40a350:	6a3b      	ldr	r3, [r7, #32]
  40a352:	3301      	adds	r3, #1
  40a354:	623b      	str	r3, [r7, #32]
				 pxIterator  = ( ListItem_t * ) listGET_NEXT( pxIterator ) )
  40a356:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40a358:	685b      	ldr	r3, [r3, #4]
  40a35a:	627b      	str	r3, [r7, #36]	; 0x24
			for( pxIterator  = ( ListItem_t * ) listGET_HEAD_ENTRY( &xBoundUDPSocketsList );
  40a35c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40a35e:	4a19      	ldr	r2, [pc, #100]	; (40a3c4 <vTCPNetStat+0x1ac>)
  40a360:	4293      	cmp	r3, r2
  40a362:	d1e6      	bne.n	40a332 <vTCPNetStat+0x11a>
			FreeRTOS_printf( ( "FreeRTOS_netstat: %lu sockets %lu < %lu < %d buffers free\n",
  40a364:	4b18      	ldr	r3, [pc, #96]	; (40a3c8 <vTCPNetStat+0x1b0>)
  40a366:	4798      	blx	r3
  40a368:	4604      	mov	r4, r0
  40a36a:	4b18      	ldr	r3, [pc, #96]	; (40a3cc <vTCPNetStat+0x1b4>)
  40a36c:	4798      	blx	r3
  40a36e:	4602      	mov	r2, r0
  40a370:	233c      	movs	r3, #60	; 0x3c
  40a372:	9300      	str	r3, [sp, #0]
  40a374:	4613      	mov	r3, r2
  40a376:	4622      	mov	r2, r4
  40a378:	6a39      	ldr	r1, [r7, #32]
  40a37a:	4815      	ldr	r0, [pc, #84]	; (40a3d0 <vTCPNetStat+0x1b8>)
  40a37c:	4c05      	ldr	r4, [pc, #20]	; (40a394 <vTCPNetStat+0x17c>)
  40a37e:	47a0      	blx	r4
	}
  40a380:	bf00      	nop
  40a382:	372c      	adds	r7, #44	; 0x2c
  40a384:	46bd      	mov	sp, r7
  40a386:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  40a38a:	bf00      	nop
  40a38c:	2000b5b0 	.word	0x2000b5b0
  40a390:	0041cfcc 	.word	0x0041cfcc
  40a394:	00416c7d 	.word	0x00416c7d
  40a398:	0041cfe8 	.word	0x0041cfe8
  40a39c:	0041d02c 	.word	0x0041d02c
  40a3a0:	0041713d 	.word	0x0041713d
  40a3a4:	0041cc08 	.word	0x0041cc08
  40a3a8:	0041cc64 	.word	0x0041cc64
  40a3ac:	0040d8b5 	.word	0x0040d8b5
  40a3b0:	000f423f 	.word	0x000f423f
  40a3b4:	0041d034 	.word	0x0041d034
  40a3b8:	2000b5b8 	.word	0x2000b5b8
  40a3bc:	2000b5c4 	.word	0x2000b5c4
  40a3c0:	0041d064 	.word	0x0041d064
  40a3c4:	2000b5cc 	.word	0x2000b5cc
  40a3c8:	0040f381 	.word	0x0040f381
  40a3cc:	0040f369 	.word	0x0040f369
  40a3d0:	0041d074 	.word	0x0041d074

0040a3d4 <vSocketSelect>:
/*-----------------------------------------------------------*/

#if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )

	void vSocketSelect( SocketSelect_t *pxSocketSet )
	{
  40a3d4:	b580      	push	{r7, lr}
  40a3d6:	b08c      	sub	sp, #48	; 0x30
  40a3d8:	af00      	add	r7, sp, #0
  40a3da:	6078      	str	r0, [r7, #4]
	BaseType_t xRound;
	EventBits_t xSocketBits, xBitsToClear;
	#if ipconfigUSE_TCP == 1
		BaseType_t xLastRound = 1;
  40a3dc:	2301      	movs	r3, #1
  40a3de:	613b      	str	r3, [r7, #16]
	#else
		BaseType_t xLastRound = 0;
	#endif

		/* These flags will be switched on after checking the socket status. */
		EventBits_t xGroupBits = 0;
  40a3e0:	2300      	movs	r3, #0
  40a3e2:	627b      	str	r3, [r7, #36]	; 0x24
		pxSocketSet->pxSocket = NULL;
  40a3e4:	687b      	ldr	r3, [r7, #4]
  40a3e6:	2200      	movs	r2, #0
  40a3e8:	609a      	str	r2, [r3, #8]

		for( xRound = 0; xRound <= xLastRound; xRound++ )
  40a3ea:	2300      	movs	r3, #0
  40a3ec:	62fb      	str	r3, [r7, #44]	; 0x2c
  40a3ee:	e0e1      	b.n	40a5b4 <vSocketSelect+0x1e0>
		{
			const ListItem_t *pxIterator;
			const MiniListItem_t *pxEnd;
			if( xRound == 0 )
  40a3f0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40a3f2:	2b00      	cmp	r3, #0
  40a3f4:	d102      	bne.n	40a3fc <vSocketSelect+0x28>
			{
				pxEnd = ( const MiniListItem_t* )listGET_END_MARKER( &xBoundUDPSocketsList );
  40a3f6:	4b84      	ldr	r3, [pc, #528]	; (40a608 <vSocketSelect+0x234>)
  40a3f8:	61fb      	str	r3, [r7, #28]
  40a3fa:	e001      	b.n	40a400 <vSocketSelect+0x2c>
			}
		#if ipconfigUSE_TCP == 1
			else
			{
				pxEnd = ( const MiniListItem_t* )listGET_END_MARKER( &xBoundTCPSocketsList );
  40a3fc:	4b83      	ldr	r3, [pc, #524]	; (40a60c <vSocketSelect+0x238>)
  40a3fe:	61fb      	str	r3, [r7, #28]
			}
		#endif /* ipconfigUSE_TCP == 1 */
			for( pxIterator = ( const ListItem_t * ) ( listGET_NEXT( pxEnd ) );
  40a400:	69fb      	ldr	r3, [r7, #28]
  40a402:	685b      	ldr	r3, [r3, #4]
  40a404:	623b      	str	r3, [r7, #32]
  40a406:	e0cd      	b.n	40a5a4 <vSocketSelect+0x1d0>
				 pxIterator != ( const ListItem_t * ) pxEnd;
				 pxIterator = ( const ListItem_t * ) listGET_NEXT( pxIterator ) )
			{
				FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
  40a408:	6a3b      	ldr	r3, [r7, #32]
  40a40a:	68db      	ldr	r3, [r3, #12]
  40a40c:	60fb      	str	r3, [r7, #12]
				if( pxSocket->pxSocketSet != pxSocketSet )
  40a40e:	68fb      	ldr	r3, [r7, #12]
  40a410:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  40a412:	687b      	ldr	r3, [r7, #4]
  40a414:	429a      	cmp	r2, r3
  40a416:	f040 80c1 	bne.w	40a59c <vSocketSelect+0x1c8>
				{
					/* Socket does not belong to this select group. */
					continue;
				}
				xSocketBits = 0;
  40a41a:	2300      	movs	r3, #0
  40a41c:	62bb      	str	r3, [r7, #40]	; 0x28

				#if( ipconfigUSE_TCP == 1 )
					if( pxSocket->ucProtocol == FREERTOS_IPPROTO_TCP )
  40a41e:	68fb      	ldr	r3, [r7, #12]
  40a420:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
  40a424:	2b06      	cmp	r3, #6
  40a426:	f040 80a3 	bne.w	40a570 <vSocketSelect+0x19c>
					{
						/* Check if the socket has already been accepted by the
						owner.  If not, it is useless to return it from a
						select(). */
						BaseType_t bAccepted = pdFALSE;
  40a42a:	2300      	movs	r3, #0
  40a42c:	61bb      	str	r3, [r7, #24]

						if( pxSocket->u.xTCP.bits.bPassQueued == pdFALSE_UNSIGNED )
  40a42e:	68fb      	ldr	r3, [r7, #12]
  40a430:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
  40a434:	f003 0304 	and.w	r3, r3, #4
  40a438:	b2db      	uxtb	r3, r3
  40a43a:	2b00      	cmp	r3, #0
  40a43c:	d109      	bne.n	40a452 <vSocketSelect+0x7e>
						{
							if( pxSocket->u.xTCP.bits.bPassAccept == pdFALSE_UNSIGNED )
  40a43e:	68fb      	ldr	r3, [r7, #12]
  40a440:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
  40a444:	f003 0302 	and.w	r3, r3, #2
  40a448:	b2db      	uxtb	r3, r3
  40a44a:	2b00      	cmp	r3, #0
  40a44c:	d101      	bne.n	40a452 <vSocketSelect+0x7e>
							{
								bAccepted = pdTRUE;
  40a44e:	2301      	movs	r3, #1
  40a450:	61bb      	str	r3, [r7, #24]
							}
						}

						/* Is the set owner interested in READ events? */
						if( ( pxSocket->xSelectBits & eSELECT_READ ) != 0 )
  40a452:	68fb      	ldr	r3, [r7, #12]
  40a454:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  40a456:	f003 0301 	and.w	r3, r3, #1
  40a45a:	2b00      	cmp	r3, #0
  40a45c:	d038      	beq.n	40a4d0 <vSocketSelect+0xfc>
						{
							if( pxSocket->u.xTCP.ucTCPState == eTCP_LISTEN )
  40a45e:	68fb      	ldr	r3, [r7, #12]
  40a460:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
  40a464:	2b01      	cmp	r3, #1
  40a466:	d111      	bne.n	40a48c <vSocketSelect+0xb8>
							{
								if( ( pxSocket->u.xTCP.pxPeerSocket != NULL ) && ( pxSocket->u.xTCP.pxPeerSocket->u.xTCP.bits.bPassAccept != 0 ) )
  40a468:	68fb      	ldr	r3, [r7, #12]
  40a46a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
  40a46c:	2b00      	cmp	r3, #0
  40a46e:	d02f      	beq.n	40a4d0 <vSocketSelect+0xfc>
  40a470:	68fb      	ldr	r3, [r7, #12]
  40a472:	6d5b      	ldr	r3, [r3, #84]	; 0x54
  40a474:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
  40a478:	f003 0302 	and.w	r3, r3, #2
  40a47c:	b2db      	uxtb	r3, r3
  40a47e:	2b00      	cmp	r3, #0
  40a480:	d026      	beq.n	40a4d0 <vSocketSelect+0xfc>
								{
									xSocketBits |= eSELECT_READ;
  40a482:	6abb      	ldr	r3, [r7, #40]	; 0x28
  40a484:	f043 0301 	orr.w	r3, r3, #1
  40a488:	62bb      	str	r3, [r7, #40]	; 0x28
  40a48a:	e021      	b.n	40a4d0 <vSocketSelect+0xfc>
								}
							}
							else if( ( pxSocket->u.xTCP.bits.bReuseSocket != pdFALSE_UNSIGNED ) && ( pxSocket->u.xTCP.bits.bPassAccept != pdFALSE_UNSIGNED ) )
  40a48c:	68fb      	ldr	r3, [r7, #12]
  40a48e:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
  40a492:	f003 0308 	and.w	r3, r3, #8
  40a496:	b2db      	uxtb	r3, r3
  40a498:	2b00      	cmp	r3, #0
  40a49a:	d00c      	beq.n	40a4b6 <vSocketSelect+0xe2>
  40a49c:	68fb      	ldr	r3, [r7, #12]
  40a49e:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
  40a4a2:	f003 0302 	and.w	r3, r3, #2
  40a4a6:	b2db      	uxtb	r3, r3
  40a4a8:	2b00      	cmp	r3, #0
  40a4aa:	d004      	beq.n	40a4b6 <vSocketSelect+0xe2>
							{
								/* This socket has the re-use flag. After connecting it turns into
								aconnected socket. Set the READ event, so that accept() will be called. */
								xSocketBits |= eSELECT_READ;
  40a4ac:	6abb      	ldr	r3, [r7, #40]	; 0x28
  40a4ae:	f043 0301 	orr.w	r3, r3, #1
  40a4b2:	62bb      	str	r3, [r7, #40]	; 0x28
  40a4b4:	e00c      	b.n	40a4d0 <vSocketSelect+0xfc>
							}
							else if( ( bAccepted != 0 ) && ( FreeRTOS_recvcount( pxSocket ) > 0 ) )
  40a4b6:	69bb      	ldr	r3, [r7, #24]
  40a4b8:	2b00      	cmp	r3, #0
  40a4ba:	d009      	beq.n	40a4d0 <vSocketSelect+0xfc>
  40a4bc:	68f8      	ldr	r0, [r7, #12]
  40a4be:	4b54      	ldr	r3, [pc, #336]	; (40a610 <vSocketSelect+0x23c>)
  40a4c0:	4798      	blx	r3
  40a4c2:	4603      	mov	r3, r0
  40a4c4:	2b00      	cmp	r3, #0
  40a4c6:	dd03      	ble.n	40a4d0 <vSocketSelect+0xfc>
							{
								xSocketBits |= eSELECT_READ;
  40a4c8:	6abb      	ldr	r3, [r7, #40]	; 0x28
  40a4ca:	f043 0301 	orr.w	r3, r3, #1
  40a4ce:	62bb      	str	r3, [r7, #40]	; 0x28
							}
						}
						/* Is the set owner interested in EXCEPTION events? */
						if( ( pxSocket->xSelectBits & eSELECT_EXCEPT ) != 0 )
  40a4d0:	68fb      	ldr	r3, [r7, #12]
  40a4d2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  40a4d4:	f003 0304 	and.w	r3, r3, #4
  40a4d8:	2b00      	cmp	r3, #0
  40a4da:	d00d      	beq.n	40a4f8 <vSocketSelect+0x124>
						{
							if( ( pxSocket->u.xTCP.ucTCPState == eCLOSE_WAIT ) || ( pxSocket->u.xTCP.ucTCPState == eCLOSED ) )
  40a4dc:	68fb      	ldr	r3, [r7, #12]
  40a4de:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
  40a4e2:	2b08      	cmp	r3, #8
  40a4e4:	d004      	beq.n	40a4f0 <vSocketSelect+0x11c>
  40a4e6:	68fb      	ldr	r3, [r7, #12]
  40a4e8:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
  40a4ec:	2b00      	cmp	r3, #0
  40a4ee:	d103      	bne.n	40a4f8 <vSocketSelect+0x124>
							{
								xSocketBits |= eSELECT_EXCEPT;
  40a4f0:	6abb      	ldr	r3, [r7, #40]	; 0x28
  40a4f2:	f043 0304 	orr.w	r3, r3, #4
  40a4f6:	62bb      	str	r3, [r7, #40]	; 0x28
							}
						}

						/* Is the set owner interested in WRITE events? */
						if( ( pxSocket->xSelectBits & eSELECT_WRITE ) != 0 )
  40a4f8:	68fb      	ldr	r3, [r7, #12]
  40a4fa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  40a4fc:	f003 0302 	and.w	r3, r3, #2
  40a500:	2b00      	cmp	r3, #0
  40a502:	d043      	beq.n	40a58c <vSocketSelect+0x1b8>
						{
							BaseType_t bMatch = pdFALSE;
  40a504:	2300      	movs	r3, #0
  40a506:	617b      	str	r3, [r7, #20]

							if( bAccepted != 0 )
  40a508:	69bb      	ldr	r3, [r7, #24]
  40a50a:	2b00      	cmp	r3, #0
  40a50c:	d007      	beq.n	40a51e <vSocketSelect+0x14a>
							{
								if( FreeRTOS_tx_space( pxSocket ) > 0 )
  40a50e:	68f8      	ldr	r0, [r7, #12]
  40a510:	4b40      	ldr	r3, [pc, #256]	; (40a614 <vSocketSelect+0x240>)
  40a512:	4798      	blx	r3
  40a514:	4603      	mov	r3, r0
  40a516:	2b00      	cmp	r3, #0
  40a518:	dd01      	ble.n	40a51e <vSocketSelect+0x14a>
								{
									bMatch = pdTRUE;
  40a51a:	2301      	movs	r3, #1
  40a51c:	617b      	str	r3, [r7, #20]
								}
							}

							if( bMatch == pdFALSE )
  40a51e:	697b      	ldr	r3, [r7, #20]
  40a520:	2b00      	cmp	r3, #0
  40a522:	d11d      	bne.n	40a560 <vSocketSelect+0x18c>
							{
								if( ( pxSocket->u.xTCP.bits.bConnPrepared != pdFALSE_UNSIGNED ) &&
  40a524:	68fb      	ldr	r3, [r7, #12]
  40a526:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
  40a52a:	f003 0308 	and.w	r3, r3, #8
  40a52e:	b2db      	uxtb	r3, r3
  40a530:	2b00      	cmp	r3, #0
  40a532:	d015      	beq.n	40a560 <vSocketSelect+0x18c>
									( pxSocket->u.xTCP.ucTCPState >= eESTABLISHED ) &&
  40a534:	68fb      	ldr	r3, [r7, #12]
  40a536:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
								if( ( pxSocket->u.xTCP.bits.bConnPrepared != pdFALSE_UNSIGNED ) &&
  40a53a:	2b04      	cmp	r3, #4
  40a53c:	d910      	bls.n	40a560 <vSocketSelect+0x18c>
									( pxSocket->u.xTCP.bits.bConnPassed == pdFALSE_UNSIGNED ) )
  40a53e:	68fb      	ldr	r3, [r7, #12]
  40a540:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
  40a544:	f003 0310 	and.w	r3, r3, #16
  40a548:	b2db      	uxtb	r3, r3
									( pxSocket->u.xTCP.ucTCPState >= eESTABLISHED ) &&
  40a54a:	2b00      	cmp	r3, #0
  40a54c:	d108      	bne.n	40a560 <vSocketSelect+0x18c>
								{
									pxSocket->u.xTCP.bits.bConnPassed = pdTRUE_UNSIGNED;
  40a54e:	68fa      	ldr	r2, [r7, #12]
  40a550:	f892 3041 	ldrb.w	r3, [r2, #65]	; 0x41
  40a554:	f043 0310 	orr.w	r3, r3, #16
  40a558:	f882 3041 	strb.w	r3, [r2, #65]	; 0x41
									bMatch = pdTRUE;
  40a55c:	2301      	movs	r3, #1
  40a55e:	617b      	str	r3, [r7, #20]
								}
							}

							if( bMatch != pdFALSE )
  40a560:	697b      	ldr	r3, [r7, #20]
  40a562:	2b00      	cmp	r3, #0
  40a564:	d012      	beq.n	40a58c <vSocketSelect+0x1b8>
							{
								xSocketBits |= eSELECT_WRITE;
  40a566:	6abb      	ldr	r3, [r7, #40]	; 0x28
  40a568:	f043 0302 	orr.w	r3, r3, #2
  40a56c:	62bb      	str	r3, [r7, #40]	; 0x28
  40a56e:	e00d      	b.n	40a58c <vSocketSelect+0x1b8>
					}
					else
				#endif /* ipconfigUSE_TCP == 1 */
				{
					/* Select events for UDP are simpler. */
					if( ( ( pxSocket->xSelectBits & eSELECT_READ ) != 0 ) &&
  40a570:	68fb      	ldr	r3, [r7, #12]
  40a572:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  40a574:	f003 0301 	and.w	r3, r3, #1
  40a578:	2b00      	cmp	r3, #0
  40a57a:	d007      	beq.n	40a58c <vSocketSelect+0x1b8>
						( listCURRENT_LIST_LENGTH( &( pxSocket->u.xUDP.xWaitingPacketsList ) ) > 0U ) )
  40a57c:	68fb      	ldr	r3, [r7, #12]
  40a57e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
					if( ( ( pxSocket->xSelectBits & eSELECT_READ ) != 0 ) &&
  40a580:	2b00      	cmp	r3, #0
  40a582:	d003      	beq.n	40a58c <vSocketSelect+0x1b8>
					{
						xSocketBits |= eSELECT_READ;
  40a584:	6abb      	ldr	r3, [r7, #40]	; 0x28
  40a586:	f043 0301 	orr.w	r3, r3, #1
  40a58a:	62bb      	str	r3, [r7, #40]	; 0x28
					/* The WRITE and EXCEPT bits are not used for UDP */
				}	/* if( pxSocket->ucProtocol == FREERTOS_IPPROTO_TCP ) */

				/* Each socket keeps its own event flags, which are looked-up
				by FreeRTOS_FD_ISSSET() */
				pxSocket->xSocketBits = xSocketBits;
  40a58c:	68fb      	ldr	r3, [r7, #12]
  40a58e:	6aba      	ldr	r2, [r7, #40]	; 0x28
  40a590:	631a      	str	r2, [r3, #48]	; 0x30

				/* The ORed value will be used to set the bits in the event
				group. */
				xGroupBits |= xSocketBits;
  40a592:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  40a594:	6abb      	ldr	r3, [r7, #40]	; 0x28
  40a596:	4313      	orrs	r3, r2
  40a598:	627b      	str	r3, [r7, #36]	; 0x24
  40a59a:	e000      	b.n	40a59e <vSocketSelect+0x1ca>
					continue;
  40a59c:	bf00      	nop
				 pxIterator = ( const ListItem_t * ) listGET_NEXT( pxIterator ) )
  40a59e:	6a3b      	ldr	r3, [r7, #32]
  40a5a0:	685b      	ldr	r3, [r3, #4]
  40a5a2:	623b      	str	r3, [r7, #32]
			for( pxIterator = ( const ListItem_t * ) ( listGET_NEXT( pxEnd ) );
  40a5a4:	6a3a      	ldr	r2, [r7, #32]
  40a5a6:	69fb      	ldr	r3, [r7, #28]
  40a5a8:	429a      	cmp	r2, r3
  40a5aa:	f47f af2d 	bne.w	40a408 <vSocketSelect+0x34>
		for( xRound = 0; xRound <= xLastRound; xRound++ )
  40a5ae:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40a5b0:	3301      	adds	r3, #1
  40a5b2:	62fb      	str	r3, [r7, #44]	; 0x2c
  40a5b4:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  40a5b6:	693b      	ldr	r3, [r7, #16]
  40a5b8:	429a      	cmp	r2, r3
  40a5ba:	f77f af19 	ble.w	40a3f0 <vSocketSelect+0x1c>

			}	/* for( pxIterator ... ) */
		}	/* for( xRound = 0; xRound <= xLastRound; xRound++ ) */

		xBitsToClear = xEventGroupGetBits( pxSocketSet->xSelectGroup );
  40a5be:	687b      	ldr	r3, [r7, #4]
  40a5c0:	681b      	ldr	r3, [r3, #0]
  40a5c2:	2100      	movs	r1, #0
  40a5c4:	4618      	mov	r0, r3
  40a5c6:	4b14      	ldr	r3, [pc, #80]	; (40a618 <vSocketSelect+0x244>)
  40a5c8:	4798      	blx	r3
  40a5ca:	60b8      	str	r0, [r7, #8]

		/* Now set the necessary bits. */
		xBitsToClear = ( xBitsToClear & ~xGroupBits ) & eSELECT_ALL;
  40a5cc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40a5ce:	43da      	mvns	r2, r3
  40a5d0:	68bb      	ldr	r3, [r7, #8]
  40a5d2:	4013      	ands	r3, r2
  40a5d4:	f003 030f 	and.w	r3, r3, #15
  40a5d8:	60bb      	str	r3, [r7, #8]
			and cleared in FreeRTOS_select(). */
			xBitsToClear &= ( EventBits_t ) ~eSELECT_INTR;
		}
		#endif /* ipconfigSUPPORT_SIGNALS */

		if( xBitsToClear != 0 )
  40a5da:	68bb      	ldr	r3, [r7, #8]
  40a5dc:	2b00      	cmp	r3, #0
  40a5de:	d005      	beq.n	40a5ec <vSocketSelect+0x218>
		{
			xEventGroupClearBits( pxSocketSet->xSelectGroup, xBitsToClear );
  40a5e0:	687b      	ldr	r3, [r7, #4]
  40a5e2:	681b      	ldr	r3, [r3, #0]
  40a5e4:	68b9      	ldr	r1, [r7, #8]
  40a5e6:	4618      	mov	r0, r3
  40a5e8:	4b0b      	ldr	r3, [pc, #44]	; (40a618 <vSocketSelect+0x244>)
  40a5ea:	4798      	blx	r3
		}

		/* Now include eSELECT_CALL_IP to wakeup the caller. */
		xEventGroupSetBits( pxSocketSet->xSelectGroup, xGroupBits | eSELECT_CALL_IP );
  40a5ec:	687b      	ldr	r3, [r7, #4]
  40a5ee:	681a      	ldr	r2, [r3, #0]
  40a5f0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40a5f2:	f043 0310 	orr.w	r3, r3, #16
  40a5f6:	4619      	mov	r1, r3
  40a5f8:	4610      	mov	r0, r2
  40a5fa:	4b08      	ldr	r3, [pc, #32]	; (40a61c <vSocketSelect+0x248>)
  40a5fc:	4798      	blx	r3
	}
  40a5fe:	bf00      	nop
  40a600:	3730      	adds	r7, #48	; 0x30
  40a602:	46bd      	mov	sp, r7
  40a604:	bd80      	pop	{r7, pc}
  40a606:	bf00      	nop
  40a608:	2000b5cc 	.word	0x2000b5cc
  40a60c:	2000b5b8 	.word	0x2000b5b8
  40a610:	0040a1d1 	.word	0x0040a1d1
  40a614:	0040a13d 	.word	0x0040a13d
  40a618:	00410a9d 	.word	0x00410a9d
  40a61c:	00410b0d 	.word	0x00410b0d

0040a620 <FreeRTOS_min_uint32>:
	static portINLINE uint32_t FreeRTOS_min_uint32 (uint32_t a, uint32_t b) { return a <= b ? a : b; }
  40a620:	b480      	push	{r7}
  40a622:	b083      	sub	sp, #12
  40a624:	af00      	add	r7, sp, #0
  40a626:	6078      	str	r0, [r7, #4]
  40a628:	6039      	str	r1, [r7, #0]
  40a62a:	687a      	ldr	r2, [r7, #4]
  40a62c:	683b      	ldr	r3, [r7, #0]
  40a62e:	4293      	cmp	r3, r2
  40a630:	bf28      	it	cs
  40a632:	4613      	movcs	r3, r2
  40a634:	4618      	mov	r0, r3
  40a636:	370c      	adds	r7, #12
  40a638:	46bd      	mov	sp, r7
  40a63a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40a63e:	4770      	bx	lr

0040a640 <uxStreamBufferSpace>:
{
  40a640:	b480      	push	{r7}
  40a642:	b087      	sub	sp, #28
  40a644:	af00      	add	r7, sp, #0
  40a646:	60f8      	str	r0, [r7, #12]
  40a648:	60b9      	str	r1, [r7, #8]
  40a64a:	607a      	str	r2, [r7, #4]
	uxCount = pxBuffer->LENGTH + uxUpper - uxLower - 1u;
  40a64c:	68fb      	ldr	r3, [r7, #12]
  40a64e:	691a      	ldr	r2, [r3, #16]
  40a650:	687b      	ldr	r3, [r7, #4]
  40a652:	441a      	add	r2, r3
  40a654:	68bb      	ldr	r3, [r7, #8]
  40a656:	1ad3      	subs	r3, r2, r3
  40a658:	3b01      	subs	r3, #1
  40a65a:	617b      	str	r3, [r7, #20]
	if( uxCount >= pxBuffer->LENGTH )
  40a65c:	68fb      	ldr	r3, [r7, #12]
  40a65e:	691a      	ldr	r2, [r3, #16]
  40a660:	697b      	ldr	r3, [r7, #20]
  40a662:	429a      	cmp	r2, r3
  40a664:	d804      	bhi.n	40a670 <uxStreamBufferSpace+0x30>
		uxCount -= pxBuffer->LENGTH;
  40a666:	68fb      	ldr	r3, [r7, #12]
  40a668:	691b      	ldr	r3, [r3, #16]
  40a66a:	697a      	ldr	r2, [r7, #20]
  40a66c:	1ad3      	subs	r3, r2, r3
  40a66e:	617b      	str	r3, [r7, #20]
	return uxCount;
  40a670:	697b      	ldr	r3, [r7, #20]
}
  40a672:	4618      	mov	r0, r3
  40a674:	371c      	adds	r7, #28
  40a676:	46bd      	mov	sp, r7
  40a678:	f85d 7b04 	ldr.w	r7, [sp], #4
  40a67c:	4770      	bx	lr

0040a67e <uxStreamBufferDistance>:
{
  40a67e:	b480      	push	{r7}
  40a680:	b087      	sub	sp, #28
  40a682:	af00      	add	r7, sp, #0
  40a684:	60f8      	str	r0, [r7, #12]
  40a686:	60b9      	str	r1, [r7, #8]
  40a688:	607a      	str	r2, [r7, #4]
	uxCount = pxBuffer->LENGTH + uxUpper - uxLower;
  40a68a:	68fb      	ldr	r3, [r7, #12]
  40a68c:	691a      	ldr	r2, [r3, #16]
  40a68e:	687b      	ldr	r3, [r7, #4]
  40a690:	441a      	add	r2, r3
  40a692:	68bb      	ldr	r3, [r7, #8]
  40a694:	1ad3      	subs	r3, r2, r3
  40a696:	617b      	str	r3, [r7, #20]
	if ( uxCount >= pxBuffer->LENGTH )
  40a698:	68fb      	ldr	r3, [r7, #12]
  40a69a:	691a      	ldr	r2, [r3, #16]
  40a69c:	697b      	ldr	r3, [r7, #20]
  40a69e:	429a      	cmp	r2, r3
  40a6a0:	d804      	bhi.n	40a6ac <uxStreamBufferDistance+0x2e>
		uxCount -= pxBuffer->LENGTH;
  40a6a2:	68fb      	ldr	r3, [r7, #12]
  40a6a4:	691b      	ldr	r3, [r3, #16]
  40a6a6:	697a      	ldr	r2, [r7, #20]
  40a6a8:	1ad3      	subs	r3, r2, r3
  40a6aa:	617b      	str	r3, [r7, #20]
	return uxCount;
  40a6ac:	697b      	ldr	r3, [r7, #20]
}
  40a6ae:	4618      	mov	r0, r3
  40a6b0:	371c      	adds	r7, #28
  40a6b2:	46bd      	mov	sp, r7
  40a6b4:	f85d 7b04 	ldr.w	r7, [sp], #4
  40a6b8:	4770      	bx	lr
	...

0040a6bc <uxStreamBufferGetSpace>:
{
  40a6bc:	b580      	push	{r7, lr}
  40a6be:	b084      	sub	sp, #16
  40a6c0:	af00      	add	r7, sp, #0
  40a6c2:	6078      	str	r0, [r7, #4]
size_t uxHead = pxBuffer->uxHead;
  40a6c4:	687b      	ldr	r3, [r7, #4]
  40a6c6:	689b      	ldr	r3, [r3, #8]
  40a6c8:	60fb      	str	r3, [r7, #12]
size_t uxTail = pxBuffer->uxTail;
  40a6ca:	687b      	ldr	r3, [r7, #4]
  40a6cc:	681b      	ldr	r3, [r3, #0]
  40a6ce:	60bb      	str	r3, [r7, #8]
	return uxStreamBufferSpace( pxBuffer, uxHead, uxTail );
  40a6d0:	68ba      	ldr	r2, [r7, #8]
  40a6d2:	68f9      	ldr	r1, [r7, #12]
  40a6d4:	6878      	ldr	r0, [r7, #4]
  40a6d6:	4b03      	ldr	r3, [pc, #12]	; (40a6e4 <uxStreamBufferGetSpace+0x28>)
  40a6d8:	4798      	blx	r3
  40a6da:	4603      	mov	r3, r0
}
  40a6dc:	4618      	mov	r0, r3
  40a6de:	3710      	adds	r7, #16
  40a6e0:	46bd      	mov	sp, r7
  40a6e2:	bd80      	pop	{r7, pc}
  40a6e4:	0040a641 	.word	0x0040a641

0040a6e8 <uxStreamBufferGetSize>:
{
  40a6e8:	b580      	push	{r7, lr}
  40a6ea:	b084      	sub	sp, #16
  40a6ec:	af00      	add	r7, sp, #0
  40a6ee:	6078      	str	r0, [r7, #4]
size_t uxHead = pxBuffer->uxHead;
  40a6f0:	687b      	ldr	r3, [r7, #4]
  40a6f2:	689b      	ldr	r3, [r3, #8]
  40a6f4:	60fb      	str	r3, [r7, #12]
size_t uxTail = pxBuffer->uxTail;
  40a6f6:	687b      	ldr	r3, [r7, #4]
  40a6f8:	681b      	ldr	r3, [r3, #0]
  40a6fa:	60bb      	str	r3, [r7, #8]
	return uxStreamBufferDistance( pxBuffer, uxTail, uxHead );
  40a6fc:	68fa      	ldr	r2, [r7, #12]
  40a6fe:	68b9      	ldr	r1, [r7, #8]
  40a700:	6878      	ldr	r0, [r7, #4]
  40a702:	4b03      	ldr	r3, [pc, #12]	; (40a710 <uxStreamBufferGetSize+0x28>)
  40a704:	4798      	blx	r3
  40a706:	4603      	mov	r3, r0
}
  40a708:	4618      	mov	r0, r3
  40a70a:	3710      	adds	r7, #16
  40a70c:	46bd      	mov	sp, r7
  40a70e:	bd80      	pop	{r7, pc}
  40a710:	0040a67f 	.word	0x0040a67f

0040a714 <xStreamBufferLessThenEqual>:
{
  40a714:	b480      	push	{r7}
  40a716:	b087      	sub	sp, #28
  40a718:	af00      	add	r7, sp, #0
  40a71a:	60f8      	str	r0, [r7, #12]
  40a71c:	60b9      	str	r1, [r7, #8]
  40a71e:	607a      	str	r2, [r7, #4]
size_t uxTail = pxBuffer->uxTail;
  40a720:	68fb      	ldr	r3, [r7, #12]
  40a722:	681b      	ldr	r3, [r3, #0]
  40a724:	613b      	str	r3, [r7, #16]
	if( ( uxLeft < uxTail ) ^ ( uxRight < uxTail ) )
  40a726:	68ba      	ldr	r2, [r7, #8]
  40a728:	693b      	ldr	r3, [r7, #16]
  40a72a:	429a      	cmp	r2, r3
  40a72c:	bf34      	ite	cc
  40a72e:	2301      	movcc	r3, #1
  40a730:	2300      	movcs	r3, #0
  40a732:	b2da      	uxtb	r2, r3
  40a734:	6879      	ldr	r1, [r7, #4]
  40a736:	693b      	ldr	r3, [r7, #16]
  40a738:	4299      	cmp	r1, r3
  40a73a:	bf34      	ite	cc
  40a73c:	2301      	movcc	r3, #1
  40a73e:	2300      	movcs	r3, #0
  40a740:	b2db      	uxtb	r3, r3
  40a742:	4053      	eors	r3, r2
  40a744:	b2db      	uxtb	r3, r3
  40a746:	2b00      	cmp	r3, #0
  40a748:	d009      	beq.n	40a75e <xStreamBufferLessThenEqual+0x4a>
		if( uxRight < uxTail )
  40a74a:	687a      	ldr	r2, [r7, #4]
  40a74c:	693b      	ldr	r3, [r7, #16]
  40a74e:	429a      	cmp	r2, r3
  40a750:	d202      	bcs.n	40a758 <xStreamBufferLessThenEqual+0x44>
			xReturn = pdTRUE;
  40a752:	2301      	movs	r3, #1
  40a754:	617b      	str	r3, [r7, #20]
  40a756:	e00b      	b.n	40a770 <xStreamBufferLessThenEqual+0x5c>
			xReturn = pdFALSE;
  40a758:	2300      	movs	r3, #0
  40a75a:	617b      	str	r3, [r7, #20]
  40a75c:	e008      	b.n	40a770 <xStreamBufferLessThenEqual+0x5c>
		if( uxLeft <= uxRight )
  40a75e:	68ba      	ldr	r2, [r7, #8]
  40a760:	687b      	ldr	r3, [r7, #4]
  40a762:	429a      	cmp	r2, r3
  40a764:	d802      	bhi.n	40a76c <xStreamBufferLessThenEqual+0x58>
			xReturn = pdTRUE;
  40a766:	2301      	movs	r3, #1
  40a768:	617b      	str	r3, [r7, #20]
  40a76a:	e001      	b.n	40a770 <xStreamBufferLessThenEqual+0x5c>
			xReturn = pdFALSE;
  40a76c:	2300      	movs	r3, #0
  40a76e:	617b      	str	r3, [r7, #20]
	return xReturn;
  40a770:	697b      	ldr	r3, [r7, #20]
}
  40a772:	4618      	mov	r0, r3
  40a774:	371c      	adds	r7, #28
  40a776:	46bd      	mov	sp, r7
  40a778:	f85d 7b04 	ldr.w	r7, [sp], #4
  40a77c:	4770      	bx	lr
	...

0040a780 <uxStreamBufferAdd>:
 * an offset from uxHead while uxHead will not be moved yet.  This possibility
 * will be used when TCP data is received while earlier data is still missing.
 * If 'pucData' equals NULL, the function is called to advance 'uxHead' only.
 */
size_t uxStreamBufferAdd( StreamBuffer_t *pxBuffer, size_t uxOffset, const uint8_t *pucData, size_t uxCount )
{
  40a780:	b580      	push	{r7, lr}
  40a782:	b088      	sub	sp, #32
  40a784:	af00      	add	r7, sp, #0
  40a786:	60f8      	str	r0, [r7, #12]
  40a788:	60b9      	str	r1, [r7, #8]
  40a78a:	607a      	str	r2, [r7, #4]
  40a78c:	603b      	str	r3, [r7, #0]
size_t uxSpace, uxNextHead, uxFirst;

	uxSpace = uxStreamBufferGetSpace( pxBuffer );
  40a78e:	68f8      	ldr	r0, [r7, #12]
  40a790:	4b3a      	ldr	r3, [pc, #232]	; (40a87c <uxStreamBufferAdd+0xfc>)
  40a792:	4798      	blx	r3
  40a794:	61f8      	str	r0, [r7, #28]

	/* If uxOffset > 0, items can be placed in front of uxHead */
	if( uxSpace > uxOffset )
  40a796:	69fa      	ldr	r2, [r7, #28]
  40a798:	68bb      	ldr	r3, [r7, #8]
  40a79a:	429a      	cmp	r2, r3
  40a79c:	d904      	bls.n	40a7a8 <uxStreamBufferAdd+0x28>
	{
		uxSpace -= uxOffset;
  40a79e:	69fa      	ldr	r2, [r7, #28]
  40a7a0:	68bb      	ldr	r3, [r7, #8]
  40a7a2:	1ad3      	subs	r3, r2, r3
  40a7a4:	61fb      	str	r3, [r7, #28]
  40a7a6:	e001      	b.n	40a7ac <uxStreamBufferAdd+0x2c>
	}
	else
	{
		uxSpace = 0u;
  40a7a8:	2300      	movs	r3, #0
  40a7aa:	61fb      	str	r3, [r7, #28]
	}

	/* The number of bytes that can be written is the minimum of the number of
	bytes requested and the number available. */
	uxCount = FreeRTOS_min_uint32( uxSpace, uxCount );
  40a7ac:	6839      	ldr	r1, [r7, #0]
  40a7ae:	69f8      	ldr	r0, [r7, #28]
  40a7b0:	4b33      	ldr	r3, [pc, #204]	; (40a880 <uxStreamBufferAdd+0x100>)
  40a7b2:	4798      	blx	r3
  40a7b4:	6038      	str	r0, [r7, #0]

	if( uxCount != 0u )
  40a7b6:	683b      	ldr	r3, [r7, #0]
  40a7b8:	2b00      	cmp	r3, #0
  40a7ba:	d05a      	beq.n	40a872 <uxStreamBufferAdd+0xf2>
	{
		uxNextHead = pxBuffer->uxHead;
  40a7bc:	68fb      	ldr	r3, [r7, #12]
  40a7be:	689b      	ldr	r3, [r3, #8]
  40a7c0:	61bb      	str	r3, [r7, #24]

		if( uxOffset != 0u )
  40a7c2:	68bb      	ldr	r3, [r7, #8]
  40a7c4:	2b00      	cmp	r3, #0
  40a7c6:	d00d      	beq.n	40a7e4 <uxStreamBufferAdd+0x64>
		{
			/* ( uxOffset > 0 ) means: write in front if the uxHead marker */
			uxNextHead += uxOffset;
  40a7c8:	69ba      	ldr	r2, [r7, #24]
  40a7ca:	68bb      	ldr	r3, [r7, #8]
  40a7cc:	4413      	add	r3, r2
  40a7ce:	61bb      	str	r3, [r7, #24]
			if( uxNextHead >= pxBuffer->LENGTH )
  40a7d0:	68fb      	ldr	r3, [r7, #12]
  40a7d2:	691a      	ldr	r2, [r3, #16]
  40a7d4:	69bb      	ldr	r3, [r7, #24]
  40a7d6:	429a      	cmp	r2, r3
  40a7d8:	d804      	bhi.n	40a7e4 <uxStreamBufferAdd+0x64>
			{
				uxNextHead -= pxBuffer->LENGTH;
  40a7da:	68fb      	ldr	r3, [r7, #12]
  40a7dc:	691b      	ldr	r3, [r3, #16]
  40a7de:	69ba      	ldr	r2, [r7, #24]
  40a7e0:	1ad3      	subs	r3, r2, r3
  40a7e2:	61bb      	str	r3, [r7, #24]
			}
		}

		if( pucData != NULL )
  40a7e4:	687b      	ldr	r3, [r7, #4]
  40a7e6:	2b00      	cmp	r3, #0
  40a7e8:	d022      	beq.n	40a830 <uxStreamBufferAdd+0xb0>
		{
			/* Calculate the number of bytes that can be added in the first
			write - which may be less than the total number of bytes that need
			to be added if the buffer will wrap back to the beginning. */
			uxFirst = FreeRTOS_min_uint32( pxBuffer->LENGTH - uxNextHead, uxCount );
  40a7ea:	68fb      	ldr	r3, [r7, #12]
  40a7ec:	691a      	ldr	r2, [r3, #16]
  40a7ee:	69bb      	ldr	r3, [r7, #24]
  40a7f0:	1ad3      	subs	r3, r2, r3
  40a7f2:	6839      	ldr	r1, [r7, #0]
  40a7f4:	4618      	mov	r0, r3
  40a7f6:	4b22      	ldr	r3, [pc, #136]	; (40a880 <uxStreamBufferAdd+0x100>)
  40a7f8:	4798      	blx	r3
  40a7fa:	6178      	str	r0, [r7, #20]

			/* Write as many bytes as can be written in the first write. */
			memcpy( ( void* ) ( pxBuffer->ucArray + uxNextHead ), pucData, uxFirst );
  40a7fc:	68fb      	ldr	r3, [r7, #12]
  40a7fe:	f103 0214 	add.w	r2, r3, #20
  40a802:	69bb      	ldr	r3, [r7, #24]
  40a804:	4413      	add	r3, r2
  40a806:	697a      	ldr	r2, [r7, #20]
  40a808:	6879      	ldr	r1, [r7, #4]
  40a80a:	4618      	mov	r0, r3
  40a80c:	4b1d      	ldr	r3, [pc, #116]	; (40a884 <uxStreamBufferAdd+0x104>)
  40a80e:	4798      	blx	r3

			/* If the number of bytes written was less than the number that
			could be written in the first write... */
			if( uxCount > uxFirst )
  40a810:	683a      	ldr	r2, [r7, #0]
  40a812:	697b      	ldr	r3, [r7, #20]
  40a814:	429a      	cmp	r2, r3
  40a816:	d90b      	bls.n	40a830 <uxStreamBufferAdd+0xb0>
			{
				/* ...then write the remaining bytes to the start of the
				buffer. */
				memcpy( ( void * )pxBuffer->ucArray, pucData + uxFirst, uxCount - uxFirst );
  40a818:	68fb      	ldr	r3, [r7, #12]
  40a81a:	f103 0014 	add.w	r0, r3, #20
  40a81e:	687a      	ldr	r2, [r7, #4]
  40a820:	697b      	ldr	r3, [r7, #20]
  40a822:	18d1      	adds	r1, r2, r3
  40a824:	683a      	ldr	r2, [r7, #0]
  40a826:	697b      	ldr	r3, [r7, #20]
  40a828:	1ad3      	subs	r3, r2, r3
  40a82a:	461a      	mov	r2, r3
  40a82c:	4b15      	ldr	r3, [pc, #84]	; (40a884 <uxStreamBufferAdd+0x104>)
  40a82e:	4798      	blx	r3
			}
		}

		if( uxOffset == 0u )
  40a830:	68bb      	ldr	r3, [r7, #8]
  40a832:	2b00      	cmp	r3, #0
  40a834:	d110      	bne.n	40a858 <uxStreamBufferAdd+0xd8>
		{
			/* ( uxOffset == 0 ) means: write at uxHead position */
			uxNextHead += uxCount;
  40a836:	69ba      	ldr	r2, [r7, #24]
  40a838:	683b      	ldr	r3, [r7, #0]
  40a83a:	4413      	add	r3, r2
  40a83c:	61bb      	str	r3, [r7, #24]
			if( uxNextHead >= pxBuffer->LENGTH )
  40a83e:	68fb      	ldr	r3, [r7, #12]
  40a840:	691a      	ldr	r2, [r3, #16]
  40a842:	69bb      	ldr	r3, [r7, #24]
  40a844:	429a      	cmp	r2, r3
  40a846:	d804      	bhi.n	40a852 <uxStreamBufferAdd+0xd2>
			{
				uxNextHead -= pxBuffer->LENGTH;
  40a848:	68fb      	ldr	r3, [r7, #12]
  40a84a:	691b      	ldr	r3, [r3, #16]
  40a84c:	69ba      	ldr	r2, [r7, #24]
  40a84e:	1ad3      	subs	r3, r2, r3
  40a850:	61bb      	str	r3, [r7, #24]
			}
			pxBuffer->uxHead = uxNextHead;
  40a852:	68fb      	ldr	r3, [r7, #12]
  40a854:	69ba      	ldr	r2, [r7, #24]
  40a856:	609a      	str	r2, [r3, #8]
		}

		if( xStreamBufferLessThenEqual( pxBuffer, pxBuffer->uxFront, uxNextHead ) != pdFALSE )
  40a858:	68fb      	ldr	r3, [r7, #12]
  40a85a:	68db      	ldr	r3, [r3, #12]
  40a85c:	69ba      	ldr	r2, [r7, #24]
  40a85e:	4619      	mov	r1, r3
  40a860:	68f8      	ldr	r0, [r7, #12]
  40a862:	4b09      	ldr	r3, [pc, #36]	; (40a888 <uxStreamBufferAdd+0x108>)
  40a864:	4798      	blx	r3
  40a866:	4603      	mov	r3, r0
  40a868:	2b00      	cmp	r3, #0
  40a86a:	d002      	beq.n	40a872 <uxStreamBufferAdd+0xf2>
		{
			/* Advance the front pointer */
			pxBuffer->uxFront = uxNextHead;
  40a86c:	68fb      	ldr	r3, [r7, #12]
  40a86e:	69ba      	ldr	r2, [r7, #24]
  40a870:	60da      	str	r2, [r3, #12]
		}
	}

	return uxCount;
  40a872:	683b      	ldr	r3, [r7, #0]
}
  40a874:	4618      	mov	r0, r3
  40a876:	3720      	adds	r7, #32
  40a878:	46bd      	mov	sp, r7
  40a87a:	bd80      	pop	{r7, pc}
  40a87c:	0040a6bd 	.word	0x0040a6bd
  40a880:	0040a621 	.word	0x0040a621
  40a884:	00416d05 	.word	0x00416d05
  40a888:	0040a715 	.word	0x0040a715

0040a88c <uxStreamBufferGet>:
 * If 'pucData' equals NULL, the function is called to advance 'lTail' only.
 * if 'xPeek' is pdTRUE, or if 'uxOffset' is non-zero, the 'lTail' pointer will
 * not be advanced.
 */
size_t uxStreamBufferGet( StreamBuffer_t *pxBuffer, size_t uxOffset, uint8_t *pucData, size_t uxMaxCount, BaseType_t xPeek )
{
  40a88c:	b580      	push	{r7, lr}
  40a88e:	b088      	sub	sp, #32
  40a890:	af00      	add	r7, sp, #0
  40a892:	60f8      	str	r0, [r7, #12]
  40a894:	60b9      	str	r1, [r7, #8]
  40a896:	607a      	str	r2, [r7, #4]
  40a898:	603b      	str	r3, [r7, #0]
size_t uxSize, uxCount, uxFirst, uxNextTail;

	/* How much data is available? */
	uxSize = uxStreamBufferGetSize( pxBuffer );
  40a89a:	68f8      	ldr	r0, [r7, #12]
  40a89c:	4b35      	ldr	r3, [pc, #212]	; (40a974 <uxStreamBufferGet+0xe8>)
  40a89e:	4798      	blx	r3
  40a8a0:	61f8      	str	r0, [r7, #28]

	if( uxSize > uxOffset )
  40a8a2:	69fa      	ldr	r2, [r7, #28]
  40a8a4:	68bb      	ldr	r3, [r7, #8]
  40a8a6:	429a      	cmp	r2, r3
  40a8a8:	d904      	bls.n	40a8b4 <uxStreamBufferGet+0x28>
	{
		uxSize -= uxOffset;
  40a8aa:	69fa      	ldr	r2, [r7, #28]
  40a8ac:	68bb      	ldr	r3, [r7, #8]
  40a8ae:	1ad3      	subs	r3, r2, r3
  40a8b0:	61fb      	str	r3, [r7, #28]
  40a8b2:	e001      	b.n	40a8b8 <uxStreamBufferGet+0x2c>
	}
	else
	{
		uxSize = 0u;
  40a8b4:	2300      	movs	r3, #0
  40a8b6:	61fb      	str	r3, [r7, #28]
	}

	/* Use the minimum of the wanted bytes and the available bytes. */
	uxCount = FreeRTOS_min_uint32( uxSize, uxMaxCount );
  40a8b8:	6839      	ldr	r1, [r7, #0]
  40a8ba:	69f8      	ldr	r0, [r7, #28]
  40a8bc:	4b2e      	ldr	r3, [pc, #184]	; (40a978 <uxStreamBufferGet+0xec>)
  40a8be:	4798      	blx	r3
  40a8c0:	6178      	str	r0, [r7, #20]

	if( uxCount > 0u )
  40a8c2:	697b      	ldr	r3, [r7, #20]
  40a8c4:	2b00      	cmp	r3, #0
  40a8c6:	d050      	beq.n	40a96a <uxStreamBufferGet+0xde>
	{
		uxNextTail = pxBuffer->uxTail;
  40a8c8:	68fb      	ldr	r3, [r7, #12]
  40a8ca:	681b      	ldr	r3, [r3, #0]
  40a8cc:	61bb      	str	r3, [r7, #24]

		if( uxOffset != 0u )
  40a8ce:	68bb      	ldr	r3, [r7, #8]
  40a8d0:	2b00      	cmp	r3, #0
  40a8d2:	d00d      	beq.n	40a8f0 <uxStreamBufferGet+0x64>
		{
			uxNextTail += uxOffset;
  40a8d4:	69ba      	ldr	r2, [r7, #24]
  40a8d6:	68bb      	ldr	r3, [r7, #8]
  40a8d8:	4413      	add	r3, r2
  40a8da:	61bb      	str	r3, [r7, #24]
			if( uxNextTail >= pxBuffer->LENGTH )
  40a8dc:	68fb      	ldr	r3, [r7, #12]
  40a8de:	691a      	ldr	r2, [r3, #16]
  40a8e0:	69bb      	ldr	r3, [r7, #24]
  40a8e2:	429a      	cmp	r2, r3
  40a8e4:	d804      	bhi.n	40a8f0 <uxStreamBufferGet+0x64>
			{
				uxNextTail -= pxBuffer->LENGTH;
  40a8e6:	68fb      	ldr	r3, [r7, #12]
  40a8e8:	691b      	ldr	r3, [r3, #16]
  40a8ea:	69ba      	ldr	r2, [r7, #24]
  40a8ec:	1ad3      	subs	r3, r2, r3
  40a8ee:	61bb      	str	r3, [r7, #24]
			}
		}

		if( pucData != NULL )
  40a8f0:	687b      	ldr	r3, [r7, #4]
  40a8f2:	2b00      	cmp	r3, #0
  40a8f4:	d022      	beq.n	40a93c <uxStreamBufferGet+0xb0>
		{
			/* Calculate the number of bytes that can be read - which may be
			less than the number wanted if the data wraps around to the start of
			the buffer. */
			uxFirst = FreeRTOS_min_uint32( pxBuffer->LENGTH - uxNextTail, uxCount );
  40a8f6:	68fb      	ldr	r3, [r7, #12]
  40a8f8:	691a      	ldr	r2, [r3, #16]
  40a8fa:	69bb      	ldr	r3, [r7, #24]
  40a8fc:	1ad3      	subs	r3, r2, r3
  40a8fe:	6979      	ldr	r1, [r7, #20]
  40a900:	4618      	mov	r0, r3
  40a902:	4b1d      	ldr	r3, [pc, #116]	; (40a978 <uxStreamBufferGet+0xec>)
  40a904:	4798      	blx	r3
  40a906:	6138      	str	r0, [r7, #16]

			/* Obtain the number of bytes it is possible to obtain in the first
			read. */
			memcpy( pucData, pxBuffer->ucArray + uxNextTail, uxFirst );
  40a908:	68fb      	ldr	r3, [r7, #12]
  40a90a:	f103 0214 	add.w	r2, r3, #20
  40a90e:	69bb      	ldr	r3, [r7, #24]
  40a910:	4413      	add	r3, r2
  40a912:	693a      	ldr	r2, [r7, #16]
  40a914:	4619      	mov	r1, r3
  40a916:	6878      	ldr	r0, [r7, #4]
  40a918:	4b18      	ldr	r3, [pc, #96]	; (40a97c <uxStreamBufferGet+0xf0>)
  40a91a:	4798      	blx	r3

			/* If the total number of wanted bytes is greater than the number
			that could be read in the first read... */
			if( uxCount > uxFirst )
  40a91c:	697a      	ldr	r2, [r7, #20]
  40a91e:	693b      	ldr	r3, [r7, #16]
  40a920:	429a      	cmp	r2, r3
  40a922:	d90b      	bls.n	40a93c <uxStreamBufferGet+0xb0>
			{
				/*...then read the remaining bytes from the start of the buffer. */
				memcpy( pucData + uxFirst, pxBuffer->ucArray, uxCount - uxFirst );
  40a924:	687a      	ldr	r2, [r7, #4]
  40a926:	693b      	ldr	r3, [r7, #16]
  40a928:	18d0      	adds	r0, r2, r3
  40a92a:	68fb      	ldr	r3, [r7, #12]
  40a92c:	f103 0114 	add.w	r1, r3, #20
  40a930:	697a      	ldr	r2, [r7, #20]
  40a932:	693b      	ldr	r3, [r7, #16]
  40a934:	1ad3      	subs	r3, r2, r3
  40a936:	461a      	mov	r2, r3
  40a938:	4b10      	ldr	r3, [pc, #64]	; (40a97c <uxStreamBufferGet+0xf0>)
  40a93a:	4798      	blx	r3
			}
		}

		if( ( xPeek == pdFALSE ) && ( uxOffset == 0UL ) )
  40a93c:	6abb      	ldr	r3, [r7, #40]	; 0x28
  40a93e:	2b00      	cmp	r3, #0
  40a940:	d113      	bne.n	40a96a <uxStreamBufferGet+0xde>
  40a942:	68bb      	ldr	r3, [r7, #8]
  40a944:	2b00      	cmp	r3, #0
  40a946:	d110      	bne.n	40a96a <uxStreamBufferGet+0xde>
		{
			/* Move the tail pointer to effecively remove the data read from
			the buffer. */
			uxNextTail += uxCount;
  40a948:	69ba      	ldr	r2, [r7, #24]
  40a94a:	697b      	ldr	r3, [r7, #20]
  40a94c:	4413      	add	r3, r2
  40a94e:	61bb      	str	r3, [r7, #24]

			if( uxNextTail >= pxBuffer->LENGTH )
  40a950:	68fb      	ldr	r3, [r7, #12]
  40a952:	691a      	ldr	r2, [r3, #16]
  40a954:	69bb      	ldr	r3, [r7, #24]
  40a956:	429a      	cmp	r2, r3
  40a958:	d804      	bhi.n	40a964 <uxStreamBufferGet+0xd8>
			{
				uxNextTail -= pxBuffer->LENGTH;
  40a95a:	68fb      	ldr	r3, [r7, #12]
  40a95c:	691b      	ldr	r3, [r3, #16]
  40a95e:	69ba      	ldr	r2, [r7, #24]
  40a960:	1ad3      	subs	r3, r2, r3
  40a962:	61bb      	str	r3, [r7, #24]
			}

			pxBuffer->uxTail = uxNextTail;
  40a964:	68fb      	ldr	r3, [r7, #12]
  40a966:	69ba      	ldr	r2, [r7, #24]
  40a968:	601a      	str	r2, [r3, #0]
		}
	}

	return uxCount;
  40a96a:	697b      	ldr	r3, [r7, #20]
}
  40a96c:	4618      	mov	r0, r3
  40a96e:	3720      	adds	r7, #32
  40a970:	46bd      	mov	sp, r7
  40a972:	bd80      	pop	{r7, pc}
  40a974:	0040a6e9 	.word	0x0040a6e9
  40a978:	0040a621 	.word	0x0040a621
  40a97c:	00416d05 	.word	0x00416d05

0040a980 <FreeRTOS_max_int32>:
	static portINLINE int32_t  FreeRTOS_max_int32  (int32_t  a, int32_t  b) { return a >= b ? a : b; }
  40a980:	b480      	push	{r7}
  40a982:	b083      	sub	sp, #12
  40a984:	af00      	add	r7, sp, #0
  40a986:	6078      	str	r0, [r7, #4]
  40a988:	6039      	str	r1, [r7, #0]
  40a98a:	687a      	ldr	r2, [r7, #4]
  40a98c:	683b      	ldr	r3, [r7, #0]
  40a98e:	4293      	cmp	r3, r2
  40a990:	bfb8      	it	lt
  40a992:	4613      	movlt	r3, r2
  40a994:	4618      	mov	r0, r3
  40a996:	370c      	adds	r7, #12
  40a998:	46bd      	mov	sp, r7
  40a99a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40a99e:	4770      	bx	lr

0040a9a0 <FreeRTOS_min_int32>:
	static portINLINE int32_t  FreeRTOS_min_int32  (int32_t  a, int32_t  b) { return a <= b ? a : b; }
  40a9a0:	b480      	push	{r7}
  40a9a2:	b083      	sub	sp, #12
  40a9a4:	af00      	add	r7, sp, #0
  40a9a6:	6078      	str	r0, [r7, #4]
  40a9a8:	6039      	str	r1, [r7, #0]
  40a9aa:	687a      	ldr	r2, [r7, #4]
  40a9ac:	683b      	ldr	r3, [r7, #0]
  40a9ae:	4293      	cmp	r3, r2
  40a9b0:	bfa8      	it	ge
  40a9b2:	4613      	movge	r3, r2
  40a9b4:	4618      	mov	r0, r3
  40a9b6:	370c      	adds	r7, #12
  40a9b8:	46bd      	mov	sp, r7
  40a9ba:	f85d 7b04 	ldr.w	r7, [sp], #4
  40a9be:	4770      	bx	lr

0040a9c0 <FreeRTOS_min_uint32>:
	static portINLINE uint32_t FreeRTOS_min_uint32 (uint32_t a, uint32_t b) { return a <= b ? a : b; }
  40a9c0:	b480      	push	{r7}
  40a9c2:	b083      	sub	sp, #12
  40a9c4:	af00      	add	r7, sp, #0
  40a9c6:	6078      	str	r0, [r7, #4]
  40a9c8:	6039      	str	r1, [r7, #0]
  40a9ca:	687a      	ldr	r2, [r7, #4]
  40a9cc:	683b      	ldr	r3, [r7, #0]
  40a9ce:	4293      	cmp	r3, r2
  40a9d0:	bf28      	it	cs
  40a9d2:	4613      	movcs	r3, r2
  40a9d4:	4618      	mov	r0, r3
  40a9d6:	370c      	adds	r7, #12
  40a9d8:	46bd      	mov	sp, r7
  40a9da:	f85d 7b04 	ldr.w	r7, [sp], #4
  40a9de:	4770      	bx	lr

0040a9e0 <uxStreamBufferSpace>:
{
  40a9e0:	b480      	push	{r7}
  40a9e2:	b087      	sub	sp, #28
  40a9e4:	af00      	add	r7, sp, #0
  40a9e6:	60f8      	str	r0, [r7, #12]
  40a9e8:	60b9      	str	r1, [r7, #8]
  40a9ea:	607a      	str	r2, [r7, #4]
	uxCount = pxBuffer->LENGTH + uxUpper - uxLower - 1u;
  40a9ec:	68fb      	ldr	r3, [r7, #12]
  40a9ee:	691a      	ldr	r2, [r3, #16]
  40a9f0:	687b      	ldr	r3, [r7, #4]
  40a9f2:	441a      	add	r2, r3
  40a9f4:	68bb      	ldr	r3, [r7, #8]
  40a9f6:	1ad3      	subs	r3, r2, r3
  40a9f8:	3b01      	subs	r3, #1
  40a9fa:	617b      	str	r3, [r7, #20]
	if( uxCount >= pxBuffer->LENGTH )
  40a9fc:	68fb      	ldr	r3, [r7, #12]
  40a9fe:	691a      	ldr	r2, [r3, #16]
  40aa00:	697b      	ldr	r3, [r7, #20]
  40aa02:	429a      	cmp	r2, r3
  40aa04:	d804      	bhi.n	40aa10 <uxStreamBufferSpace+0x30>
		uxCount -= pxBuffer->LENGTH;
  40aa06:	68fb      	ldr	r3, [r7, #12]
  40aa08:	691b      	ldr	r3, [r3, #16]
  40aa0a:	697a      	ldr	r2, [r7, #20]
  40aa0c:	1ad3      	subs	r3, r2, r3
  40aa0e:	617b      	str	r3, [r7, #20]
	return uxCount;
  40aa10:	697b      	ldr	r3, [r7, #20]
}
  40aa12:	4618      	mov	r0, r3
  40aa14:	371c      	adds	r7, #28
  40aa16:	46bd      	mov	sp, r7
  40aa18:	f85d 7b04 	ldr.w	r7, [sp], #4
  40aa1c:	4770      	bx	lr

0040aa1e <uxStreamBufferDistance>:
{
  40aa1e:	b480      	push	{r7}
  40aa20:	b087      	sub	sp, #28
  40aa22:	af00      	add	r7, sp, #0
  40aa24:	60f8      	str	r0, [r7, #12]
  40aa26:	60b9      	str	r1, [r7, #8]
  40aa28:	607a      	str	r2, [r7, #4]
	uxCount = pxBuffer->LENGTH + uxUpper - uxLower;
  40aa2a:	68fb      	ldr	r3, [r7, #12]
  40aa2c:	691a      	ldr	r2, [r3, #16]
  40aa2e:	687b      	ldr	r3, [r7, #4]
  40aa30:	441a      	add	r2, r3
  40aa32:	68bb      	ldr	r3, [r7, #8]
  40aa34:	1ad3      	subs	r3, r2, r3
  40aa36:	617b      	str	r3, [r7, #20]
	if ( uxCount >= pxBuffer->LENGTH )
  40aa38:	68fb      	ldr	r3, [r7, #12]
  40aa3a:	691a      	ldr	r2, [r3, #16]
  40aa3c:	697b      	ldr	r3, [r7, #20]
  40aa3e:	429a      	cmp	r2, r3
  40aa40:	d804      	bhi.n	40aa4c <uxStreamBufferDistance+0x2e>
		uxCount -= pxBuffer->LENGTH;
  40aa42:	68fb      	ldr	r3, [r7, #12]
  40aa44:	691b      	ldr	r3, [r3, #16]
  40aa46:	697a      	ldr	r2, [r7, #20]
  40aa48:	1ad3      	subs	r3, r2, r3
  40aa4a:	617b      	str	r3, [r7, #20]
	return uxCount;
  40aa4c:	697b      	ldr	r3, [r7, #20]
}
  40aa4e:	4618      	mov	r0, r3
  40aa50:	371c      	adds	r7, #28
  40aa52:	46bd      	mov	sp, r7
  40aa54:	f85d 7b04 	ldr.w	r7, [sp], #4
  40aa58:	4770      	bx	lr
	...

0040aa5c <uxStreamBufferGetSpace>:
{
  40aa5c:	b580      	push	{r7, lr}
  40aa5e:	b084      	sub	sp, #16
  40aa60:	af00      	add	r7, sp, #0
  40aa62:	6078      	str	r0, [r7, #4]
size_t uxHead = pxBuffer->uxHead;
  40aa64:	687b      	ldr	r3, [r7, #4]
  40aa66:	689b      	ldr	r3, [r3, #8]
  40aa68:	60fb      	str	r3, [r7, #12]
size_t uxTail = pxBuffer->uxTail;
  40aa6a:	687b      	ldr	r3, [r7, #4]
  40aa6c:	681b      	ldr	r3, [r3, #0]
  40aa6e:	60bb      	str	r3, [r7, #8]
	return uxStreamBufferSpace( pxBuffer, uxHead, uxTail );
  40aa70:	68ba      	ldr	r2, [r7, #8]
  40aa72:	68f9      	ldr	r1, [r7, #12]
  40aa74:	6878      	ldr	r0, [r7, #4]
  40aa76:	4b03      	ldr	r3, [pc, #12]	; (40aa84 <uxStreamBufferGetSpace+0x28>)
  40aa78:	4798      	blx	r3
  40aa7a:	4603      	mov	r3, r0
}
  40aa7c:	4618      	mov	r0, r3
  40aa7e:	3710      	adds	r7, #16
  40aa80:	46bd      	mov	sp, r7
  40aa82:	bd80      	pop	{r7, pc}
  40aa84:	0040a9e1 	.word	0x0040a9e1

0040aa88 <uxStreamBufferFrontSpace>:
{
  40aa88:	b580      	push	{r7, lr}
  40aa8a:	b084      	sub	sp, #16
  40aa8c:	af00      	add	r7, sp, #0
  40aa8e:	6078      	str	r0, [r7, #4]
size_t uxFront = pxBuffer->uxFront;
  40aa90:	687b      	ldr	r3, [r7, #4]
  40aa92:	68db      	ldr	r3, [r3, #12]
  40aa94:	60fb      	str	r3, [r7, #12]
size_t uxTail = pxBuffer->uxTail;
  40aa96:	687b      	ldr	r3, [r7, #4]
  40aa98:	681b      	ldr	r3, [r3, #0]
  40aa9a:	60bb      	str	r3, [r7, #8]
	return uxStreamBufferSpace( pxBuffer, uxFront, uxTail );
  40aa9c:	68ba      	ldr	r2, [r7, #8]
  40aa9e:	68f9      	ldr	r1, [r7, #12]
  40aaa0:	6878      	ldr	r0, [r7, #4]
  40aaa2:	4b03      	ldr	r3, [pc, #12]	; (40aab0 <uxStreamBufferFrontSpace+0x28>)
  40aaa4:	4798      	blx	r3
  40aaa6:	4603      	mov	r3, r0
}
  40aaa8:	4618      	mov	r0, r3
  40aaaa:	3710      	adds	r7, #16
  40aaac:	46bd      	mov	sp, r7
  40aaae:	bd80      	pop	{r7, pc}
  40aab0:	0040a9e1 	.word	0x0040a9e1

0040aab4 <uxStreamBufferMidSpace>:
{
  40aab4:	b580      	push	{r7, lr}
  40aab6:	b084      	sub	sp, #16
  40aab8:	af00      	add	r7, sp, #0
  40aaba:	6078      	str	r0, [r7, #4]
size_t uxHead = pxBuffer->uxHead;
  40aabc:	687b      	ldr	r3, [r7, #4]
  40aabe:	689b      	ldr	r3, [r3, #8]
  40aac0:	60fb      	str	r3, [r7, #12]
size_t uxMid = pxBuffer->uxMid;
  40aac2:	687b      	ldr	r3, [r7, #4]
  40aac4:	685b      	ldr	r3, [r3, #4]
  40aac6:	60bb      	str	r3, [r7, #8]
	return uxStreamBufferDistance( pxBuffer, uxMid, uxHead );
  40aac8:	68fa      	ldr	r2, [r7, #12]
  40aaca:	68b9      	ldr	r1, [r7, #8]
  40aacc:	6878      	ldr	r0, [r7, #4]
  40aace:	4b03      	ldr	r3, [pc, #12]	; (40aadc <uxStreamBufferMidSpace+0x28>)
  40aad0:	4798      	blx	r3
  40aad2:	4603      	mov	r3, r0
}
  40aad4:	4618      	mov	r0, r3
  40aad6:	3710      	adds	r7, #16
  40aad8:	46bd      	mov	sp, r7
  40aada:	bd80      	pop	{r7, pc}
  40aadc:	0040aa1f 	.word	0x0040aa1f

0040aae0 <vStreamBufferMoveMid>:
{
  40aae0:	b580      	push	{r7, lr}
  40aae2:	b084      	sub	sp, #16
  40aae4:	af00      	add	r7, sp, #0
  40aae6:	6078      	str	r0, [r7, #4]
  40aae8:	6039      	str	r1, [r7, #0]
size_t uxSize = uxStreamBufferMidSpace( pxBuffer );
  40aaea:	6878      	ldr	r0, [r7, #4]
  40aaec:	4b0f      	ldr	r3, [pc, #60]	; (40ab2c <vStreamBufferMoveMid+0x4c>)
  40aaee:	4798      	blx	r3
  40aaf0:	60f8      	str	r0, [r7, #12]
	if( uxCount > uxSize )
  40aaf2:	683a      	ldr	r2, [r7, #0]
  40aaf4:	68fb      	ldr	r3, [r7, #12]
  40aaf6:	429a      	cmp	r2, r3
  40aaf8:	d901      	bls.n	40aafe <vStreamBufferMoveMid+0x1e>
		uxCount = uxSize;
  40aafa:	68fb      	ldr	r3, [r7, #12]
  40aafc:	603b      	str	r3, [r7, #0]
	pxBuffer->uxMid += uxCount;
  40aafe:	687b      	ldr	r3, [r7, #4]
  40ab00:	685a      	ldr	r2, [r3, #4]
  40ab02:	683b      	ldr	r3, [r7, #0]
  40ab04:	441a      	add	r2, r3
  40ab06:	687b      	ldr	r3, [r7, #4]
  40ab08:	605a      	str	r2, [r3, #4]
	if( pxBuffer->uxMid >= pxBuffer->LENGTH )
  40ab0a:	687b      	ldr	r3, [r7, #4]
  40ab0c:	685a      	ldr	r2, [r3, #4]
  40ab0e:	687b      	ldr	r3, [r7, #4]
  40ab10:	691b      	ldr	r3, [r3, #16]
  40ab12:	429a      	cmp	r2, r3
  40ab14:	d306      	bcc.n	40ab24 <vStreamBufferMoveMid+0x44>
		pxBuffer->uxMid -= pxBuffer->LENGTH;
  40ab16:	687b      	ldr	r3, [r7, #4]
  40ab18:	685a      	ldr	r2, [r3, #4]
  40ab1a:	687b      	ldr	r3, [r7, #4]
  40ab1c:	691b      	ldr	r3, [r3, #16]
  40ab1e:	1ad2      	subs	r2, r2, r3
  40ab20:	687b      	ldr	r3, [r7, #4]
  40ab22:	605a      	str	r2, [r3, #4]
}
  40ab24:	bf00      	nop
  40ab26:	3710      	adds	r7, #16
  40ab28:	46bd      	mov	sp, r7
  40ab2a:	bd80      	pop	{r7, pc}
  40ab2c:	0040aab5 	.word	0x0040aab5

0040ab30 <ulChar2u32>:
/*
 * Some helping function, their meaning should be clear
 */
static portINLINE uint32_t ulChar2u32 (const uint8_t *apChr);
static portINLINE uint32_t ulChar2u32 (const uint8_t *apChr)
{
  40ab30:	b480      	push	{r7}
  40ab32:	b083      	sub	sp, #12
  40ab34:	af00      	add	r7, sp, #0
  40ab36:	6078      	str	r0, [r7, #4]
	return  ( ( ( uint32_t )apChr[0] ) << 24) |
  40ab38:	687b      	ldr	r3, [r7, #4]
  40ab3a:	781b      	ldrb	r3, [r3, #0]
  40ab3c:	061a      	lsls	r2, r3, #24
			( ( ( uint32_t )apChr[1] ) << 16) |
  40ab3e:	687b      	ldr	r3, [r7, #4]
  40ab40:	3301      	adds	r3, #1
  40ab42:	781b      	ldrb	r3, [r3, #0]
  40ab44:	041b      	lsls	r3, r3, #16
	return  ( ( ( uint32_t )apChr[0] ) << 24) |
  40ab46:	431a      	orrs	r2, r3
			( ( ( uint32_t )apChr[2] ) << 8) |
  40ab48:	687b      	ldr	r3, [r7, #4]
  40ab4a:	3302      	adds	r3, #2
  40ab4c:	781b      	ldrb	r3, [r3, #0]
  40ab4e:	021b      	lsls	r3, r3, #8
			( ( ( uint32_t )apChr[1] ) << 16) |
  40ab50:	4313      	orrs	r3, r2
			( ( ( uint32_t )apChr[3] ) );
  40ab52:	687a      	ldr	r2, [r7, #4]
  40ab54:	3203      	adds	r2, #3
  40ab56:	7812      	ldrb	r2, [r2, #0]
			( ( ( uint32_t )apChr[2] ) << 8) |
  40ab58:	4313      	orrs	r3, r2
}
  40ab5a:	4618      	mov	r0, r3
  40ab5c:	370c      	adds	r7, #12
  40ab5e:	46bd      	mov	sp, r7
  40ab60:	f85d 7b04 	ldr.w	r7, [sp], #4
  40ab64:	4770      	bx	lr

0040ab66 <usChar2u16>:

static portINLINE uint16_t usChar2u16 (const uint8_t *apChr);
static portINLINE uint16_t usChar2u16 (const uint8_t *apChr)
{
  40ab66:	b480      	push	{r7}
  40ab68:	b083      	sub	sp, #12
  40ab6a:	af00      	add	r7, sp, #0
  40ab6c:	6078      	str	r0, [r7, #4]
	return ( uint16_t )
			( ( ( ( uint32_t )apChr[0] ) << 8) |
  40ab6e:	687b      	ldr	r3, [r7, #4]
  40ab70:	781b      	ldrb	r3, [r3, #0]
  40ab72:	b29b      	uxth	r3, r3
  40ab74:	021b      	lsls	r3, r3, #8
  40ab76:	b29a      	uxth	r2, r3
			  ( ( ( uint32_t )apChr[1] ) ) );
  40ab78:	687b      	ldr	r3, [r7, #4]
  40ab7a:	3301      	adds	r3, #1
  40ab7c:	781b      	ldrb	r3, [r3, #0]
  40ab7e:	b29b      	uxth	r3, r3
	return ( uint16_t )
  40ab80:	4313      	orrs	r3, r2
  40ab82:	b29b      	uxth	r3, r3
}
  40ab84:	4618      	mov	r0, r3
  40ab86:	370c      	adds	r7, #12
  40ab88:	46bd      	mov	sp, r7
  40ab8a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40ab8e:	4770      	bx	lr

0040ab90 <ulApplicationGetNextSequenceNumber>:
uint32_t ulApplicationGetNextSequenceNumber( uint32_t
ulSourceAddress,
uint16_t usSourcePort,
uint32_t ulDestinationAddress,
uint16_t usDestinationPort )
{
  40ab90:	b580      	push	{r7, lr}
  40ab92:	b084      	sub	sp, #16
  40ab94:	af00      	add	r7, sp, #0
  40ab96:	60f8      	str	r0, [r7, #12]
  40ab98:	607a      	str	r2, [r7, #4]
  40ab9a:	461a      	mov	r2, r3
  40ab9c:	460b      	mov	r3, r1
  40ab9e:	817b      	strh	r3, [r7, #10]
  40aba0:	4613      	mov	r3, r2
  40aba2:	813b      	strh	r3, [r7, #8]
	( void ) ulSourceAddress;
	( void ) usSourcePort;
	( void ) ulDestinationAddress;
	( void ) usDestinationPort;

	return uxRand();
  40aba4:	4b03      	ldr	r3, [pc, #12]	; (40abb4 <ulApplicationGetNextSequenceNumber+0x24>)
  40aba6:	4798      	blx	r3
  40aba8:	4603      	mov	r3, r0
}
  40abaa:	4618      	mov	r0, r3
  40abac:	3710      	adds	r7, #16
  40abae:	46bd      	mov	sp, r7
  40abb0:	bd80      	pop	{r7, pc}
  40abb2:	bf00      	nop
  40abb4:	00415e3d 	.word	0x00415e3d

0040abb8 <prvTCPSocketIsActive>:

/* prvTCPSocketIsActive() returns true if the socket must be checked.
 * Non-active sockets are waiting for user action, either connect()
 * or close(). */
static BaseType_t prvTCPSocketIsActive( UBaseType_t uxStatus )
{
  40abb8:	b480      	push	{r7}
  40abba:	b083      	sub	sp, #12
  40abbc:	af00      	add	r7, sp, #0
  40abbe:	6078      	str	r0, [r7, #4]
	switch( uxStatus )
  40abc0:	687b      	ldr	r3, [r7, #4]
  40abc2:	2b0b      	cmp	r3, #11
  40abc4:	d81c      	bhi.n	40ac00 <prvTCPSocketIsActive+0x48>
  40abc6:	a201      	add	r2, pc, #4	; (adr r2, 40abcc <prvTCPSocketIsActive+0x14>)
  40abc8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40abcc:	0040abfd 	.word	0x0040abfd
  40abd0:	0040ac01 	.word	0x0040ac01
  40abd4:	0040ac01 	.word	0x0040ac01
  40abd8:	0040ac01 	.word	0x0040ac01
  40abdc:	0040ac01 	.word	0x0040ac01
  40abe0:	0040ac01 	.word	0x0040ac01
  40abe4:	0040ac01 	.word	0x0040ac01
  40abe8:	0040abfd 	.word	0x0040abfd
  40abec:	0040abfd 	.word	0x0040abfd
  40abf0:	0040abfd 	.word	0x0040abfd
  40abf4:	0040ac01 	.word	0x0040ac01
  40abf8:	0040abfd 	.word	0x0040abfd
	case eCLOSED:
	case eCLOSE_WAIT:
	case eFIN_WAIT_2:
	case eCLOSING:
	case eTIME_WAIT:
		return pdFALSE;
  40abfc:	2300      	movs	r3, #0
  40abfe:	e000      	b.n	40ac02 <prvTCPSocketIsActive+0x4a>
	default:
		return pdTRUE;
  40ac00:	2301      	movs	r3, #1
	}
}
  40ac02:	4618      	mov	r0, r3
  40ac04:	370c      	adds	r7, #12
  40ac06:	46bd      	mov	sp, r7
  40ac08:	f85d 7b04 	ldr.w	r7, [sp], #4
  40ac0c:	4770      	bx	lr
  40ac0e:	bf00      	nop

0040ac10 <prvTCPStatusAgeCheck>:
/*-----------------------------------------------------------*/

#if( ipconfigTCP_HANG_PROTECTION == 1 )

	static BaseType_t prvTCPStatusAgeCheck( FreeRTOS_Socket_t *pxSocket )
	{
  40ac10:	b5f0      	push	{r4, r5, r6, r7, lr}
  40ac12:	b087      	sub	sp, #28
  40ac14:	af02      	add	r7, sp, #8
  40ac16:	6078      	str	r0, [r7, #4]
	BaseType_t xResult;
		switch( pxSocket->u.xTCP.ucTCPState )
  40ac18:	687b      	ldr	r3, [r7, #4]
  40ac1a:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
  40ac1e:	2b08      	cmp	r3, #8
  40ac20:	d81a      	bhi.n	40ac58 <prvTCPStatusAgeCheck+0x48>
  40ac22:	a201      	add	r2, pc, #4	; (adr r2, 40ac28 <prvTCPStatusAgeCheck+0x18>)
  40ac24:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40ac28:	0040ac53 	.word	0x0040ac53
  40ac2c:	0040ac53 	.word	0x0040ac53
  40ac30:	0040ac59 	.word	0x0040ac59
  40ac34:	0040ac59 	.word	0x0040ac59
  40ac38:	0040ac59 	.word	0x0040ac59
  40ac3c:	0040ac4d 	.word	0x0040ac4d
  40ac40:	0040ac59 	.word	0x0040ac59
  40ac44:	0040ac59 	.word	0x0040ac59
  40ac48:	0040ac53 	.word	0x0040ac53
		{
		case eESTABLISHED:
			/* If the 'ipconfigTCP_KEEP_ALIVE' option is enabled, sockets in
			state ESTABLISHED can be protected using keep-alive messages. */
			xResult = pdFALSE;
  40ac4c:	2300      	movs	r3, #0
  40ac4e:	60fb      	str	r3, [r7, #12]
			break;
  40ac50:	e005      	b.n	40ac5e <prvTCPStatusAgeCheck+0x4e>
		case eCLOSED:
		case eTCP_LISTEN:
		case eCLOSE_WAIT:
			/* These 3 states may last for ever, up to the owner. */
			xResult = pdFALSE;
  40ac52:	2300      	movs	r3, #0
  40ac54:	60fb      	str	r3, [r7, #12]
			break;
  40ac56:	e002      	b.n	40ac5e <prvTCPStatusAgeCheck+0x4e>
		default:
			/* All other (non-connected) states will get anti-hanging
			protection. */
			xResult = pdTRUE;
  40ac58:	2301      	movs	r3, #1
  40ac5a:	60fb      	str	r3, [r7, #12]
			break;
  40ac5c:	bf00      	nop
		}
		if( xResult != pdFALSE )
  40ac5e:	68fb      	ldr	r3, [r7, #12]
  40ac60:	2b00      	cmp	r3, #0
  40ac62:	d03b      	beq.n	40acdc <prvTCPStatusAgeCheck+0xcc>
		{
			/* How much time has past since the last active moment which is
			defined as A) a state change or B) a packet has arrived. */
			TickType_t xAge = xTaskGetTickCount( ) - pxSocket->u.xTCP.xLastActTime;
  40ac64:	4b20      	ldr	r3, [pc, #128]	; (40ace8 <prvTCPStatusAgeCheck+0xd8>)
  40ac66:	4798      	blx	r3
  40ac68:	4602      	mov	r2, r0
  40ac6a:	687b      	ldr	r3, [r7, #4]
  40ac6c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
  40ac6e:	1ad3      	subs	r3, r2, r3
  40ac70:	60bb      	str	r3, [r7, #8]

			/* ipconfigTCP_HANG_PROTECTION_TIME is in units of seconds. */
			if( xAge > ( ipconfigTCP_HANG_PROTECTION_TIME * configTICK_RATE_HZ ) )
  40ac72:	68bb      	ldr	r3, [r7, #8]
  40ac74:	f247 5230 	movw	r2, #30000	; 0x7530
  40ac78:	4293      	cmp	r3, r2
  40ac7a:	d92f      	bls.n	40acdc <prvTCPStatusAgeCheck+0xcc>
			{
				#if( ipconfigHAS_DEBUG_PRINTF == 1 )
				{
					FreeRTOS_debug_printf( ( "Inactive socket closed: port %u rem %lxip:%u status %s\n",
  40ac7c:	687b      	ldr	r3, [r7, #4]
  40ac7e:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
  40ac80:	461d      	mov	r5, r3
  40ac82:	687b      	ldr	r3, [r7, #4]
  40ac84:	6b9c      	ldr	r4, [r3, #56]	; 0x38
  40ac86:	687b      	ldr	r3, [r7, #4]
  40ac88:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
  40ac8a:	461e      	mov	r6, r3
  40ac8c:	687b      	ldr	r3, [r7, #4]
  40ac8e:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
  40ac92:	4618      	mov	r0, r3
  40ac94:	4b15      	ldr	r3, [pc, #84]	; (40acec <prvTCPStatusAgeCheck+0xdc>)
  40ac96:	4798      	blx	r3
  40ac98:	4603      	mov	r3, r0
  40ac9a:	9300      	str	r3, [sp, #0]
  40ac9c:	4633      	mov	r3, r6
  40ac9e:	4622      	mov	r2, r4
  40aca0:	4629      	mov	r1, r5
  40aca2:	4813      	ldr	r0, [pc, #76]	; (40acf0 <prvTCPStatusAgeCheck+0xe0>)
  40aca4:	4c13      	ldr	r4, [pc, #76]	; (40acf4 <prvTCPStatusAgeCheck+0xe4>)
  40aca6:	47a0      	blx	r4
						FreeRTOS_GetTCPStateName( ( UBaseType_t ) pxSocket->u.xTCP.ucTCPState ) ) );
				}
				#endif /* ipconfigHAS_DEBUG_PRINTF */

				/* Move to eCLOSE_WAIT, user may close the socket. */
				vTCPStateChange( pxSocket, eCLOSE_WAIT );
  40aca8:	2108      	movs	r1, #8
  40acaa:	6878      	ldr	r0, [r7, #4]
  40acac:	4b12      	ldr	r3, [pc, #72]	; (40acf8 <prvTCPStatusAgeCheck+0xe8>)
  40acae:	4798      	blx	r3

				/* When 'bPassQueued' true, this socket is an orphan until it
				gets connected. */
				if( pxSocket->u.xTCP.bits.bPassQueued != pdFALSE_UNSIGNED )
  40acb0:	687b      	ldr	r3, [r7, #4]
  40acb2:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
  40acb6:	f003 0304 	and.w	r3, r3, #4
  40acba:	b2db      	uxtb	r3, r3
  40acbc:	2b00      	cmp	r3, #0
  40acbe:	d00d      	beq.n	40acdc <prvTCPStatusAgeCheck+0xcc>
				{
					if( pxSocket->u.xTCP.bits.bReuseSocket == pdFALSE_UNSIGNED )
  40acc0:	687b      	ldr	r3, [r7, #4]
  40acc2:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
  40acc6:	f003 0308 	and.w	r3, r3, #8
  40acca:	b2db      	uxtb	r3, r3
  40accc:	2b00      	cmp	r3, #0
  40acce:	d102      	bne.n	40acd6 <prvTCPStatusAgeCheck+0xc6>
					{
						/* As it did not get connected, and the user can never
						accept() it anymore, it will be deleted now.  Called from
						the IP-task, so it's safe to call the internal Close
						function: vSocketClose(). */
						vSocketClose( pxSocket );
  40acd0:	6878      	ldr	r0, [r7, #4]
  40acd2:	4b0a      	ldr	r3, [pc, #40]	; (40acfc <prvTCPStatusAgeCheck+0xec>)
  40acd4:	4798      	blx	r3
					}
					/* Return a negative value to tell to inform the caller
					xTCPTimerCheck()
					that the socket got closed and may not be accessed anymore. */
					xResult = -1;
  40acd6:	f04f 33ff 	mov.w	r3, #4294967295
  40acda:	60fb      	str	r3, [r7, #12]
				}
			}
		}
		return xResult;
  40acdc:	68fb      	ldr	r3, [r7, #12]
	}
  40acde:	4618      	mov	r0, r3
  40ace0:	3714      	adds	r7, #20
  40ace2:	46bd      	mov	sp, r7
  40ace4:	bdf0      	pop	{r4, r5, r6, r7, pc}
  40ace6:	bf00      	nop
  40ace8:	004127d1 	.word	0x004127d1
  40acec:	0040d8b5 	.word	0x0040d8b5
  40acf0:	0041d154 	.word	0x0041d154
  40acf4:	00416c7d 	.word	0x00416c7d
  40acf8:	0040bbc1 	.word	0x0040bbc1
  40acfc:	004091e9 	.word	0x004091e9

0040ad00 <xTCPSocketCheck>:
 *		prvTCPSendRepeated()			// Send at most 8 messages on a row
 *			prvTCPReturnPacket()		// Prepare for returning
 *			xNetworkInterfaceOutput()	// Sends data to the NIC ( declared in portable/NetworkInterface/xxx )
 */
BaseType_t xTCPSocketCheck( FreeRTOS_Socket_t *pxSocket )
{
  40ad00:	b590      	push	{r4, r7, lr}
  40ad02:	b087      	sub	sp, #28
  40ad04:	af02      	add	r7, sp, #8
  40ad06:	6078      	str	r0, [r7, #4]
BaseType_t xResult = 0;
  40ad08:	2300      	movs	r3, #0
  40ad0a:	60fb      	str	r3, [r7, #12]
BaseType_t xReady = pdFALSE;
  40ad0c:	2300      	movs	r3, #0
  40ad0e:	60bb      	str	r3, [r7, #8]

	if( ( pxSocket->u.xTCP.ucTCPState >= eESTABLISHED ) && ( pxSocket->u.xTCP.txStream != NULL ) )
  40ad10:	687b      	ldr	r3, [r7, #4]
  40ad12:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
  40ad16:	2b04      	cmp	r3, #4
  40ad18:	d906      	bls.n	40ad28 <xTCPSocketCheck+0x28>
  40ad1a:	687b      	ldr	r3, [r7, #4]
  40ad1c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  40ad1e:	2b00      	cmp	r3, #0
  40ad20:	d002      	beq.n	40ad28 <xTCPSocketCheck+0x28>
	{
		/* The API FreeRTOS_send() might have added data to the TX stream.  Add
		this data to the windowing system to it can be transmitted. */
		prvTCPAddTxData( pxSocket );
  40ad22:	6878      	ldr	r0, [r7, #4]
  40ad24:	4b37      	ldr	r3, [pc, #220]	; (40ae04 <xTCPSocketCheck+0x104>)
  40ad26:	4798      	blx	r3
	}

	#if ipconfigUSE_TCP_WIN == 1
	{
		if( pxSocket->u.xTCP.pxAckMessage != NULL )
  40ad28:	687b      	ldr	r3, [r7, #4]
  40ad2a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  40ad2c:	2b00      	cmp	r3, #0
  40ad2e:	d04c      	beq.n	40adca <xTCPSocketCheck+0xca>
		{
			/* The first task of this regular socket check is to send-out delayed
			ACK's. */
			if( pxSocket->u.xTCP.bits.bUserShutdown == pdFALSE_UNSIGNED )
  40ad30:	687b      	ldr	r3, [r7, #4]
  40ad32:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
  40ad36:	f003 0320 	and.w	r3, r3, #32
  40ad3a:	b2db      	uxtb	r3, r3
  40ad3c:	2b00      	cmp	r3, #0
  40ad3e:	d138      	bne.n	40adb2 <xTCPSocketCheck+0xb2>
			{
				/* Earlier data was received but not yet acknowledged.  This
				function is called when the TCP timer for the socket expires, the
				ACK may be sent now. */
				if( pxSocket->u.xTCP.ucTCPState != eCLOSED )
  40ad40:	687b      	ldr	r3, [r7, #4]
  40ad42:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
  40ad46:	2b00      	cmp	r3, #0
  40ad48:	d02b      	beq.n	40ada2 <xTCPSocketCheck+0xa2>
				{
					if( xTCPWindowLoggingLevel > 1 && ipconfigTCP_MAY_LOG_PORT( pxSocket->usLocalPort ) )
  40ad4a:	4b2f      	ldr	r3, [pc, #188]	; (40ae08 <xTCPSocketCheck+0x108>)
  40ad4c:	681b      	ldr	r3, [r3, #0]
  40ad4e:	2b01      	cmp	r3, #1
  40ad50:	dd20      	ble.n	40ad94 <xTCPSocketCheck+0x94>
  40ad52:	687b      	ldr	r3, [r7, #4]
  40ad54:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
  40ad56:	2b17      	cmp	r3, #23
  40ad58:	d01c      	beq.n	40ad94 <xTCPSocketCheck+0x94>
					{
						FreeRTOS_debug_printf( ( "Send[%u->%u] del ACK %lu SEQ %lu (len %u)\n",
  40ad5a:	687b      	ldr	r3, [r7, #4]
  40ad5c:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
  40ad5e:	4618      	mov	r0, r3
  40ad60:	687b      	ldr	r3, [r7, #4]
  40ad62:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
  40ad64:	461c      	mov	r4, r3
  40ad66:	687b      	ldr	r3, [r7, #4]
  40ad68:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
  40ad6c:	687b      	ldr	r3, [r7, #4]
  40ad6e:	f8d3 30dc 	ldr.w	r3, [r3, #220]	; 0xdc
  40ad72:	1ad1      	subs	r1, r2, r3
  40ad74:	687b      	ldr	r3, [r7, #4]
  40ad76:	f8d3 20fc 	ldr.w	r2, [r3, #252]	; 0xfc
  40ad7a:	687b      	ldr	r3, [r7, #4]
  40ad7c:	f8d3 30ec 	ldr.w	r3, [r3, #236]	; 0xec
  40ad80:	1ad3      	subs	r3, r2, r3
  40ad82:	2228      	movs	r2, #40	; 0x28
  40ad84:	9201      	str	r2, [sp, #4]
  40ad86:	9300      	str	r3, [sp, #0]
  40ad88:	460b      	mov	r3, r1
  40ad8a:	4622      	mov	r2, r4
  40ad8c:	4601      	mov	r1, r0
  40ad8e:	481f      	ldr	r0, [pc, #124]	; (40ae0c <xTCPSocketCheck+0x10c>)
  40ad90:	4c1f      	ldr	r4, [pc, #124]	; (40ae10 <xTCPSocketCheck+0x110>)
  40ad92:	47a0      	blx	r4
							pxSocket->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber - pxSocket->u.xTCP.xTCPWindow.rx.ulFirstSequenceNumber,
							pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber   - pxSocket->u.xTCP.xTCPWindow.tx.ulFirstSequenceNumber,
							ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER ) );
					}

					prvTCPReturnPacket( pxSocket, pxSocket->u.xTCP.pxAckMessage, ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER, ipconfigZERO_COPY_TX_DRIVER );
  40ad94:	687b      	ldr	r3, [r7, #4]
  40ad96:	6f59      	ldr	r1, [r3, #116]	; 0x74
  40ad98:	2300      	movs	r3, #0
  40ad9a:	2228      	movs	r2, #40	; 0x28
  40ad9c:	6878      	ldr	r0, [r7, #4]
  40ad9e:	4c1d      	ldr	r4, [pc, #116]	; (40ae14 <xTCPSocketCheck+0x114>)
  40ada0:	47a0      	blx	r4
						clear the pointer to it. */
						pxSocket->u.xTCP.pxAckMessage = NULL;
					}
					#endif /* ipconfigZERO_COPY_TX_DRIVER */
				}
				if( prvTCPNextTimeout( pxSocket ) > 1 )
  40ada2:	6878      	ldr	r0, [r7, #4]
  40ada4:	4b1c      	ldr	r3, [pc, #112]	; (40ae18 <xTCPSocketCheck+0x118>)
  40ada6:	4798      	blx	r3
  40ada8:	4603      	mov	r3, r0
  40adaa:	2b01      	cmp	r3, #1
  40adac:	d901      	bls.n	40adb2 <xTCPSocketCheck+0xb2>
				{
					/* Tell the code below that this function is ready. */
					xReady = pdTRUE;
  40adae:	2301      	movs	r3, #1
  40adb0:	60bb      	str	r3, [r7, #8]
				/* The user wants to perform an active shutdown(), skip sending
				the	delayed	ACK.  The function prvTCPSendPacket() will send the
				FIN	along with the ACK's. */
			}

			if( pxSocket->u.xTCP.pxAckMessage != NULL )
  40adb2:	687b      	ldr	r3, [r7, #4]
  40adb4:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  40adb6:	2b00      	cmp	r3, #0
  40adb8:	d007      	beq.n	40adca <xTCPSocketCheck+0xca>
			{
				vReleaseNetworkBufferAndDescriptor( pxSocket->u.xTCP.pxAckMessage );
  40adba:	687b      	ldr	r3, [r7, #4]
  40adbc:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  40adbe:	4618      	mov	r0, r3
  40adc0:	4b16      	ldr	r3, [pc, #88]	; (40ae1c <xTCPSocketCheck+0x11c>)
  40adc2:	4798      	blx	r3
				pxSocket->u.xTCP.pxAckMessage = NULL;
  40adc4:	687b      	ldr	r3, [r7, #4]
  40adc6:	2200      	movs	r2, #0
  40adc8:	675a      	str	r2, [r3, #116]	; 0x74
			}
		}
	}
	#endif /* ipconfigUSE_TCP_WIN */

	if( xReady == pdFALSE )
  40adca:	68bb      	ldr	r3, [r7, #8]
  40adcc:	2b00      	cmp	r3, #0
  40adce:	d113      	bne.n	40adf8 <xTCPSocketCheck+0xf8>
	{
		/* The second task of this regular socket check is sending out data. */
		if( ( pxSocket->u.xTCP.ucTCPState >= eESTABLISHED ) ||
  40add0:	687b      	ldr	r3, [r7, #4]
  40add2:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
  40add6:	2b04      	cmp	r3, #4
  40add8:	d804      	bhi.n	40ade4 <xTCPSocketCheck+0xe4>
			( pxSocket->u.xTCP.ucTCPState == eCONNECT_SYN ) )
  40adda:	687b      	ldr	r3, [r7, #4]
  40addc:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
		if( ( pxSocket->u.xTCP.ucTCPState >= eESTABLISHED ) ||
  40ade0:	2b02      	cmp	r3, #2
  40ade2:	d102      	bne.n	40adea <xTCPSocketCheck+0xea>
		{
			prvTCPSendPacket( pxSocket );
  40ade4:	6878      	ldr	r0, [r7, #4]
  40ade6:	4b0e      	ldr	r3, [pc, #56]	; (40ae20 <xTCPSocketCheck+0x120>)
  40ade8:	4798      	blx	r3
		}

		/* Set the time-out for the next wakeup for this socket. */
		prvTCPNextTimeout( pxSocket );
  40adea:	6878      	ldr	r0, [r7, #4]
  40adec:	4b0a      	ldr	r3, [pc, #40]	; (40ae18 <xTCPSocketCheck+0x118>)
  40adee:	4798      	blx	r3

		#if( ipconfigTCP_HANG_PROTECTION == 1 )
		{
			/* In all (non-connected) states in which keep-alive messages can not be sent
			the anti-hang protocol will close sockets that are 'hanging'. */
			xResult = prvTCPStatusAgeCheck( pxSocket );
  40adf0:	6878      	ldr	r0, [r7, #4]
  40adf2:	4b0c      	ldr	r3, [pc, #48]	; (40ae24 <xTCPSocketCheck+0x124>)
  40adf4:	4798      	blx	r3
  40adf6:	60f8      	str	r0, [r7, #12]
		}
		#endif
	}

	return xResult;
  40adf8:	68fb      	ldr	r3, [r7, #12]
}
  40adfa:	4618      	mov	r0, r3
  40adfc:	3714      	adds	r7, #20
  40adfe:	46bd      	mov	sp, r7
  40ae00:	bd90      	pop	{r4, r7, pc}
  40ae02:	bf00      	nop
  40ae04:	0040c2ad 	.word	0x0040c2ad
  40ae08:	20006d60 	.word	0x20006d60
  40ae0c:	0041d18c 	.word	0x0041d18c
  40ae10:	00416c7d 	.word	0x00416c7d
  40ae14:	0040af75 	.word	0x0040af75
  40ae18:	0040c185 	.word	0x0040c185
  40ae1c:	0040f2ed 	.word	0x0040f2ed
  40ae20:	0040ae29 	.word	0x0040ae29
  40ae24:	0040ac11 	.word	0x0040ac11

0040ae28 <prvTCPSendPacket>:
/*
 * prvTCPSendPacket() will be called when the socket time-out has been reached.
 * It is only called by xTCPSocketCheck().
 */
static int32_t prvTCPSendPacket( FreeRTOS_Socket_t *pxSocket )
{
  40ae28:	b590      	push	{r4, r7, lr}
  40ae2a:	b087      	sub	sp, #28
  40ae2c:	af00      	add	r7, sp, #0
  40ae2e:	6078      	str	r0, [r7, #4]
int32_t lResult = 0;
  40ae30:	2300      	movs	r3, #0
  40ae32:	617b      	str	r3, [r7, #20]
UBaseType_t uxOptionsLength;
TCPPacket_t *pxTCPPacket;
NetworkBufferDescriptor_t *pxNetworkBuffer;

	if( pxSocket->u.xTCP.ucTCPState != eCONNECT_SYN )
  40ae34:	687b      	ldr	r3, [r7, #4]
  40ae36:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
  40ae3a:	2b02      	cmp	r3, #2
  40ae3c:	d010      	beq.n	40ae60 <prvTCPSendPacket+0x38>
	{
		/* The connection is in s state other than SYN. */
		pxNetworkBuffer = NULL;
  40ae3e:	2300      	movs	r3, #0
  40ae40:	60bb      	str	r3, [r7, #8]

		/* prvTCPSendRepeated() will only create a network buffer if necessary,
		i.e. when data must be sent to the peer. */
		lResult = prvTCPSendRepeated( pxSocket, &pxNetworkBuffer );
  40ae42:	f107 0308 	add.w	r3, r7, #8
  40ae46:	4619      	mov	r1, r3
  40ae48:	6878      	ldr	r0, [r7, #4]
  40ae4a:	4b29      	ldr	r3, [pc, #164]	; (40aef0 <prvTCPSendPacket+0xc8>)
  40ae4c:	4798      	blx	r3
  40ae4e:	6178      	str	r0, [r7, #20]

		if( pxNetworkBuffer != NULL )
  40ae50:	68bb      	ldr	r3, [r7, #8]
  40ae52:	2b00      	cmp	r3, #0
  40ae54:	d046      	beq.n	40aee4 <prvTCPSendPacket+0xbc>
		{
			vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
  40ae56:	68bb      	ldr	r3, [r7, #8]
  40ae58:	4618      	mov	r0, r3
  40ae5a:	4b26      	ldr	r3, [pc, #152]	; (40aef4 <prvTCPSendPacket+0xcc>)
  40ae5c:	4798      	blx	r3
  40ae5e:	e041      	b.n	40aee4 <prvTCPSendPacket+0xbc>
		}
	}
	else
	{
		if( pxSocket->u.xTCP.ucRepCount >= 3u )
  40ae60:	687b      	ldr	r3, [r7, #4]
  40ae62:	f893 3052 	ldrb.w	r3, [r3, #82]	; 0x52
  40ae66:	2b02      	cmp	r3, #2
  40ae68:	d90c      	bls.n	40ae84 <prvTCPSendPacket+0x5c>
		{
			/* The connection is in the SYN status. The packet will be repeated
			to most 3 times.  When there is no response, the socket get the
			status 'eCLOSE_WAIT'. */
			FreeRTOS_debug_printf( ( "Connect: giving up %lxip:%u\n",
  40ae6a:	687b      	ldr	r3, [r7, #4]
  40ae6c:	6b99      	ldr	r1, [r3, #56]	; 0x38
  40ae6e:	687b      	ldr	r3, [r7, #4]
  40ae70:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
  40ae72:	461a      	mov	r2, r3
  40ae74:	4820      	ldr	r0, [pc, #128]	; (40aef8 <prvTCPSendPacket+0xd0>)
  40ae76:	4b21      	ldr	r3, [pc, #132]	; (40aefc <prvTCPSendPacket+0xd4>)
  40ae78:	4798      	blx	r3
				pxSocket->u.xTCP.ulRemoteIP,		/* IP address of remote machine. */
				pxSocket->u.xTCP.usRemotePort ) );	/* Port on remote machine. */
			vTCPStateChange( pxSocket, eCLOSE_WAIT );
  40ae7a:	2108      	movs	r1, #8
  40ae7c:	6878      	ldr	r0, [r7, #4]
  40ae7e:	4b20      	ldr	r3, [pc, #128]	; (40af00 <prvTCPSendPacket+0xd8>)
  40ae80:	4798      	blx	r3
  40ae82:	e02f      	b.n	40aee4 <prvTCPSendPacket+0xbc>
		}
		else if( ( pxSocket->u.xTCP.bits.bConnPrepared != pdFALSE_UNSIGNED ) || ( prvTCPPrepareConnect( pxSocket ) == pdTRUE ) )
  40ae84:	687b      	ldr	r3, [r7, #4]
  40ae86:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
  40ae8a:	f003 0308 	and.w	r3, r3, #8
  40ae8e:	b2db      	uxtb	r3, r3
  40ae90:	2b00      	cmp	r3, #0
  40ae92:	d105      	bne.n	40aea0 <prvTCPSendPacket+0x78>
  40ae94:	6878      	ldr	r0, [r7, #4]
  40ae96:	4b1b      	ldr	r3, [pc, #108]	; (40af04 <prvTCPSendPacket+0xdc>)
  40ae98:	4798      	blx	r3
  40ae9a:	4603      	mov	r3, r0
  40ae9c:	2b01      	cmp	r3, #1
  40ae9e:	d121      	bne.n	40aee4 <prvTCPSendPacket+0xbc>
		{
			/* Or else, if the connection has been prepared, or can be prepared
			now, proceed to send the packet with the SYN flag.
			prvTCPPrepareConnect() prepares 'xPacket' and returns pdTRUE if
			the Ethernet address of the peer or the gateway is found. */
			pxTCPPacket = ( TCPPacket_t * )pxSocket->u.xTCP.xPacket.u.ucLastPacket;
  40aea0:	687b      	ldr	r3, [r7, #4]
  40aea2:	337a      	adds	r3, #122	; 0x7a
  40aea4:	613b      	str	r3, [r7, #16]

			/* About to send a SYN packet.  Call prvSetSynAckOptions() to set
			the proper options: The size of MSS and whether SACK's are
			allowed. */
			uxOptionsLength = prvSetSynAckOptions( pxSocket, pxTCPPacket );
  40aea6:	6939      	ldr	r1, [r7, #16]
  40aea8:	6878      	ldr	r0, [r7, #4]
  40aeaa:	4b17      	ldr	r3, [pc, #92]	; (40af08 <prvTCPSendPacket+0xe0>)
  40aeac:	4798      	blx	r3
  40aeae:	60f8      	str	r0, [r7, #12]

			/* Return the number of bytes to be sent. */
			lResult = ( BaseType_t ) ( ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER + uxOptionsLength );
  40aeb0:	68fb      	ldr	r3, [r7, #12]
  40aeb2:	3328      	adds	r3, #40	; 0x28
  40aeb4:	617b      	str	r3, [r7, #20]

			/* Set the TCP offset field:  ipSIZE_OF_TCP_HEADER equals 20 and
			uxOptionsLength is always a multiple of 4.  The complete expression
			would be:
			ucTCPOffset = ( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) / 4 ) << 4 */
			pxTCPPacket->xTCPHeader.ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
  40aeb6:	68fb      	ldr	r3, [r7, #12]
  40aeb8:	b2db      	uxtb	r3, r3
  40aeba:	3314      	adds	r3, #20
  40aebc:	b2db      	uxtb	r3, r3
  40aebe:	009b      	lsls	r3, r3, #2
  40aec0:	b2da      	uxtb	r2, r3
  40aec2:	693b      	ldr	r3, [r7, #16]
  40aec4:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e

			/* Repeat Count is used for a connecting socket, to limit the number
			of tries. */
			pxSocket->u.xTCP.ucRepCount++;
  40aec8:	687b      	ldr	r3, [r7, #4]
  40aeca:	f893 3052 	ldrb.w	r3, [r3, #82]	; 0x52
  40aece:	3301      	adds	r3, #1
  40aed0:	b2da      	uxtb	r2, r3
  40aed2:	687b      	ldr	r3, [r7, #4]
  40aed4:	f883 2052 	strb.w	r2, [r3, #82]	; 0x52

			/* Send the SYN message to make a connection.  The messages is
			stored in the socket field 'xPacket'.  It will be wrapped in a
			pseudo network buffer descriptor before it will be sent. */
			prvTCPReturnPacket( pxSocket, NULL, ( uint32_t ) lResult, pdFALSE );
  40aed8:	697a      	ldr	r2, [r7, #20]
  40aeda:	2300      	movs	r3, #0
  40aedc:	2100      	movs	r1, #0
  40aede:	6878      	ldr	r0, [r7, #4]
  40aee0:	4c0a      	ldr	r4, [pc, #40]	; (40af0c <prvTCPSendPacket+0xe4>)
  40aee2:	47a0      	blx	r4
		}
	}

	/* Return the total number of bytes sent. */
	return lResult;
  40aee4:	697b      	ldr	r3, [r7, #20]
}
  40aee6:	4618      	mov	r0, r3
  40aee8:	371c      	adds	r7, #28
  40aeea:	46bd      	mov	sp, r7
  40aeec:	bd90      	pop	{r4, r7, pc}
  40aeee:	bf00      	nop
  40aef0:	0040af11 	.word	0x0040af11
  40aef4:	0040f2ed 	.word	0x0040f2ed
  40aef8:	0041d1b8 	.word	0x0041d1b8
  40aefc:	00416c7d 	.word	0x00416c7d
  40af00:	0040bbc1 	.word	0x0040bbc1
  40af04:	0040b445 	.word	0x0040b445
  40af08:	0040baf5 	.word	0x0040baf5
  40af0c:	0040af75 	.word	0x0040af75

0040af10 <prvTCPSendRepeated>:
/*
 * prvTCPSendRepeated will try to send a series of messages, as long as there is
 * data to be sent and as long as the transmit window isn't full.
 */
static int32_t prvTCPSendRepeated( FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t **ppxNetworkBuffer )
{
  40af10:	b590      	push	{r4, r7, lr}
  40af12:	b087      	sub	sp, #28
  40af14:	af00      	add	r7, sp, #0
  40af16:	6078      	str	r0, [r7, #4]
  40af18:	6039      	str	r1, [r7, #0]
UBaseType_t uxIndex;
int32_t lResult = 0;
  40af1a:	2300      	movs	r3, #0
  40af1c:	613b      	str	r3, [r7, #16]
UBaseType_t uxOptionsLength = 0u;
  40af1e:	2300      	movs	r3, #0
  40af20:	60fb      	str	r3, [r7, #12]
int32_t xSendLength;

	for( uxIndex = 0u; uxIndex < ( UBaseType_t ) SEND_REPEATED_COUNT; uxIndex++ )
  40af22:	2300      	movs	r3, #0
  40af24:	617b      	str	r3, [r7, #20]
  40af26:	e016      	b.n	40af56 <prvTCPSendRepeated+0x46>
	{
		/* prvTCPPrepareSend() might allocate a network buffer if there is data
		to be sent. */
		xSendLength = prvTCPPrepareSend( pxSocket, ppxNetworkBuffer, uxOptionsLength );
  40af28:	68fa      	ldr	r2, [r7, #12]
  40af2a:	6839      	ldr	r1, [r7, #0]
  40af2c:	6878      	ldr	r0, [r7, #4]
  40af2e:	4b0f      	ldr	r3, [pc, #60]	; (40af6c <prvTCPSendRepeated+0x5c>)
  40af30:	4798      	blx	r3
  40af32:	60b8      	str	r0, [r7, #8]
		if( xSendLength <= 0 )
  40af34:	68bb      	ldr	r3, [r7, #8]
  40af36:	2b00      	cmp	r3, #0
  40af38:	dd11      	ble.n	40af5e <prvTCPSendRepeated+0x4e>
		{
			break;
		}

		/* And return the packet to the peer. */
		prvTCPReturnPacket( pxSocket, *ppxNetworkBuffer, ( uint32_t ) xSendLength, ipconfigZERO_COPY_TX_DRIVER );
  40af3a:	683b      	ldr	r3, [r7, #0]
  40af3c:	6819      	ldr	r1, [r3, #0]
  40af3e:	68ba      	ldr	r2, [r7, #8]
  40af40:	2300      	movs	r3, #0
  40af42:	6878      	ldr	r0, [r7, #4]
  40af44:	4c0a      	ldr	r4, [pc, #40]	; (40af70 <prvTCPSendRepeated+0x60>)
  40af46:	47a0      	blx	r4
		{
			*ppxNetworkBuffer = NULL;
		}
		#endif /* ipconfigZERO_COPY_TX_DRIVER */

		lResult += xSendLength;
  40af48:	693a      	ldr	r2, [r7, #16]
  40af4a:	68bb      	ldr	r3, [r7, #8]
  40af4c:	4413      	add	r3, r2
  40af4e:	613b      	str	r3, [r7, #16]
	for( uxIndex = 0u; uxIndex < ( UBaseType_t ) SEND_REPEATED_COUNT; uxIndex++ )
  40af50:	697b      	ldr	r3, [r7, #20]
  40af52:	3301      	adds	r3, #1
  40af54:	617b      	str	r3, [r7, #20]
  40af56:	697b      	ldr	r3, [r7, #20]
  40af58:	2b07      	cmp	r3, #7
  40af5a:	d9e5      	bls.n	40af28 <prvTCPSendRepeated+0x18>
  40af5c:	e000      	b.n	40af60 <prvTCPSendRepeated+0x50>
			break;
  40af5e:	bf00      	nop
	}

	/* Return the total number of bytes sent. */
	return lResult;
  40af60:	693b      	ldr	r3, [r7, #16]
}
  40af62:	4618      	mov	r0, r3
  40af64:	371c      	adds	r7, #28
  40af66:	46bd      	mov	sp, r7
  40af68:	bd90      	pop	{r4, r7, pc}
  40af6a:	bf00      	nop
  40af6c:	0040bed5 	.word	0x0040bed5
  40af70:	0040af75 	.word	0x0040af75

0040af74 <prvTCPReturnPacket>:
 * which may either point to a real network buffer or to a TCP socket field
 * called 'xTCP.xPacket'.   A temporary xNetworkBuffer will be used to pass
 * the data to the NIC.
 */
static void prvTCPReturnPacket( FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t *pxNetworkBuffer, uint32_t ulLen, BaseType_t xReleaseAfterSend )
{
  40af74:	b5f0      	push	{r4, r5, r6, r7, lr}
  40af76:	b09f      	sub	sp, #124	; 0x7c
  40af78:	af04      	add	r7, sp, #16
  40af7a:	60f8      	str	r0, [r7, #12]
  40af7c:	60b9      	str	r1, [r7, #8]
  40af7e:	607a      	str	r2, [r7, #4]
  40af80:	603b      	str	r3, [r7, #0]
uint32_t ulFrontSpace, ulSpace, ulSourceAddress, ulWinSize;
TCPWindow_t *pxTCPWindow;
NetworkBufferDescriptor_t xTempBuffer;
/* For sending, a pseudo network buffer will be used, as explained above. */

	if( pxNetworkBuffer == NULL )
  40af82:	68bb      	ldr	r3, [r7, #8]
  40af84:	2b00      	cmp	r3, #0
  40af86:	d10b      	bne.n	40afa0 <prvTCPReturnPacket+0x2c>
	{
		pxNetworkBuffer = &xTempBuffer;
  40af88:	f107 0310 	add.w	r3, r7, #16
  40af8c:	60bb      	str	r3, [r7, #8]

		#if( ipconfigUSE_LINKED_RX_MESSAGES != 0 )
		{
			xTempBuffer.pxNextBuffer = NULL;
  40af8e:	2300      	movs	r3, #0
  40af90:	637b      	str	r3, [r7, #52]	; 0x34
		}
		#endif
		xTempBuffer.pucEthernetBuffer = pxSocket->u.xTCP.xPacket.u.ucLastPacket;
  40af92:	68fb      	ldr	r3, [r7, #12]
  40af94:	337a      	adds	r3, #122	; 0x7a
  40af96:	62bb      	str	r3, [r7, #40]	; 0x28
		xTempBuffer.xDataLength = sizeof( pxSocket->u.xTCP.xPacket.u.ucLastPacket );
  40af98:	2346      	movs	r3, #70	; 0x46
  40af9a:	62fb      	str	r3, [r7, #44]	; 0x2c
		xReleaseAfterSend = pdFALSE;
  40af9c:	2300      	movs	r3, #0
  40af9e:	603b      	str	r3, [r7, #0]
			xReleaseAfterSend = pdTRUE;
		}
	}
	#endif /* ipconfigZERO_COPY_TX_DRIVER */

	if( pxNetworkBuffer != NULL )
  40afa0:	68bb      	ldr	r3, [r7, #8]
  40afa2:	2b00      	cmp	r3, #0
  40afa4:	f000 81f7 	beq.w	40b396 <prvTCPReturnPacket+0x422>
	{
		pxTCPPacket = ( TCPPacket_t * ) ( pxNetworkBuffer->pucEthernetBuffer );
  40afa8:	68bb      	ldr	r3, [r7, #8]
  40afaa:	699b      	ldr	r3, [r3, #24]
  40afac:	653b      	str	r3, [r7, #80]	; 0x50
		pxIPHeader = &pxTCPPacket->xIPHeader;
  40afae:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  40afb0:	330e      	adds	r3, #14
  40afb2:	64fb      	str	r3, [r7, #76]	; 0x4c
		pxEthernetHeader = &pxTCPPacket->xEthernetHeader;
  40afb4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  40afb6:	64bb      	str	r3, [r7, #72]	; 0x48

		/* Fill the packet, using hton translations. */
		if( pxSocket != NULL )
  40afb8:	68fb      	ldr	r3, [r7, #12]
  40afba:	2b00      	cmp	r3, #0
  40afbc:	f000 810e 	beq.w	40b1dc <prvTCPReturnPacket+0x268>
		{
			/* Calculate the space in the RX buffer in order to advertise the
			size of this socket's reception window. */
			pxTCPWindow = &( pxSocket->u.xTCP.xTCPWindow );
  40afc0:	68fb      	ldr	r3, [r7, #12]
  40afc2:	33d0      	adds	r3, #208	; 0xd0
  40afc4:	647b      	str	r3, [r7, #68]	; 0x44

			if( pxSocket->u.xTCP.rxStream != NULL )
  40afc6:	68fb      	ldr	r3, [r7, #12]
  40afc8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
  40afca:	2b00      	cmp	r3, #0
  40afcc:	d006      	beq.n	40afdc <prvTCPReturnPacket+0x68>
			{
				/* An RX stream was created already, see how much space is
				available. */
				ulFrontSpace = ( uint32_t ) uxStreamBufferFrontSpace( pxSocket->u.xTCP.rxStream );
  40afce:	68fb      	ldr	r3, [r7, #12]
  40afd0:	6edb      	ldr	r3, [r3, #108]	; 0x6c
  40afd2:	4618      	mov	r0, r3
  40afd4:	4b95      	ldr	r3, [pc, #596]	; (40b22c <prvTCPReturnPacket+0x2b8>)
  40afd6:	4798      	blx	r3
  40afd8:	6678      	str	r0, [r7, #100]	; 0x64
  40afda:	e002      	b.n	40afe2 <prvTCPReturnPacket+0x6e>
			}
			else
			{
				/* No RX stream has been created, the full stream size is
				available. */
				ulFrontSpace = ( uint32_t ) pxSocket->u.xTCP.uxRxStreamSize;
  40afdc:	68fb      	ldr	r3, [r7, #12]
  40afde:	6e5b      	ldr	r3, [r3, #100]	; 0x64
  40afe0:	667b      	str	r3, [r7, #100]	; 0x64
			}

			/* Take the minimum of the RX buffer space and the RX window size. */
			ulSpace = FreeRTOS_min_uint32( pxTCPWindow->xSize.ulRxWindowLength, ulFrontSpace );
  40afe2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  40afe4:	685b      	ldr	r3, [r3, #4]
  40afe6:	6e79      	ldr	r1, [r7, #100]	; 0x64
  40afe8:	4618      	mov	r0, r3
  40afea:	4b91      	ldr	r3, [pc, #580]	; (40b230 <prvTCPReturnPacket+0x2bc>)
  40afec:	4798      	blx	r3
  40afee:	6638      	str	r0, [r7, #96]	; 0x60

			if( ( pxSocket->u.xTCP.bits.bLowWater != pdFALSE_UNSIGNED ) || ( pxSocket->u.xTCP.bits.bRxStopped != pdFALSE_UNSIGNED ) )
  40aff0:	68fb      	ldr	r3, [r7, #12]
  40aff2:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
  40aff6:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
  40affa:	b2db      	uxtb	r3, r3
  40affc:	2b00      	cmp	r3, #0
  40affe:	d107      	bne.n	40b010 <prvTCPReturnPacket+0x9c>
  40b000:	68fb      	ldr	r3, [r7, #12]
  40b002:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
  40b006:	f003 0304 	and.w	r3, r3, #4
  40b00a:	b2db      	uxtb	r3, r3
  40b00c:	2b00      	cmp	r3, #0
  40b00e:	d001      	beq.n	40b014 <prvTCPReturnPacket+0xa0>
			{
				/* The low-water mark was reached, meaning there was little
				space left.  The socket will wait until the application has read
				or flushed the incoming data, and 'zero-window' will be
				advertised. */
				ulSpace = 0u;
  40b010:	2300      	movs	r3, #0
  40b012:	663b      	str	r3, [r7, #96]	; 0x60
			}

			/* If possible, advertise an RX window size of at least 1 MSS, otherwise
			the peer might start 'zero window probing', i.e. sending small packets
			(1, 2, 4, 8... bytes). */
			if( ( ulSpace < pxSocket->u.xTCP.usCurMSS ) && ( ulFrontSpace >= pxSocket->u.xTCP.usCurMSS ) )
  40b014:	68fb      	ldr	r3, [r7, #12]
  40b016:	f8b3 304a 	ldrh.w	r3, [r3, #74]	; 0x4a
  40b01a:	461a      	mov	r2, r3
  40b01c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
  40b01e:	429a      	cmp	r2, r3
  40b020:	d90a      	bls.n	40b038 <prvTCPReturnPacket+0xc4>
  40b022:	68fb      	ldr	r3, [r7, #12]
  40b024:	f8b3 304a 	ldrh.w	r3, [r3, #74]	; 0x4a
  40b028:	461a      	mov	r2, r3
  40b02a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  40b02c:	429a      	cmp	r2, r3
  40b02e:	d803      	bhi.n	40b038 <prvTCPReturnPacket+0xc4>
			{
				ulSpace = pxSocket->u.xTCP.usCurMSS;
  40b030:	68fb      	ldr	r3, [r7, #12]
  40b032:	f8b3 304a 	ldrh.w	r3, [r3, #74]	; 0x4a
  40b036:	663b      	str	r3, [r7, #96]	; 0x60
			}

			/* Avoid overflow of the 16-bit win field. */
			#if( ipconfigUSE_TCP_WIN != 0 )
			{
				ulWinSize = ( ulSpace >> pxSocket->u.xTCP.ucMyWinScaleFactor );
  40b038:	68fb      	ldr	r3, [r7, #12]
  40b03a:	f893 30c1 	ldrb.w	r3, [r3, #193]	; 0xc1
  40b03e:	461a      	mov	r2, r3
  40b040:	6e3b      	ldr	r3, [r7, #96]	; 0x60
  40b042:	40d3      	lsrs	r3, r2
  40b044:	65bb      	str	r3, [r7, #88]	; 0x58
			#else
			{
				ulWinSize = ulSpace;
			}
			#endif
			if( ulWinSize > 0xfffcUL )
  40b046:	6dbb      	ldr	r3, [r7, #88]	; 0x58
  40b048:	f64f 72fc 	movw	r2, #65532	; 0xfffc
  40b04c:	4293      	cmp	r3, r2
  40b04e:	d902      	bls.n	40b056 <prvTCPReturnPacket+0xe2>
			{
				ulWinSize = 0xfffcUL;
  40b050:	f64f 73fc 	movw	r3, #65532	; 0xfffc
  40b054:	65bb      	str	r3, [r7, #88]	; 0x58
			}

			pxTCPPacket->xTCPHeader.usWindow = FreeRTOS_htons( ( uint16_t ) ulWinSize );
  40b056:	6dbb      	ldr	r3, [r7, #88]	; 0x58
  40b058:	b29b      	uxth	r3, r3
  40b05a:	021b      	lsls	r3, r3, #8
  40b05c:	b21a      	sxth	r2, r3
  40b05e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
  40b060:	b29b      	uxth	r3, r3
  40b062:	0a1b      	lsrs	r3, r3, #8
  40b064:	b29b      	uxth	r3, r3
  40b066:	b21b      	sxth	r3, r3
  40b068:	4313      	orrs	r3, r2
  40b06a:	b21b      	sxth	r3, r3
  40b06c:	b29a      	uxth	r2, r3
  40b06e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  40b070:	861a      	strh	r2, [r3, #48]	; 0x30

			#if( ipconfigHAS_DEBUG_PRINTF != 0 )
			{
				if( ipconfigTCP_MAY_LOG_PORT( pxSocket->usLocalPort ) != pdFALSE )
  40b072:	68fb      	ldr	r3, [r7, #12]
  40b074:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
  40b076:	2b17      	cmp	r3, #23
  40b078:	d001      	beq.n	40b07e <prvTCPReturnPacket+0x10a>
  40b07a:	2301      	movs	r3, #1
  40b07c:	e000      	b.n	40b080 <prvTCPReturnPacket+0x10c>
  40b07e:	2300      	movs	r3, #0
  40b080:	2b00      	cmp	r3, #0
  40b082:	d044      	beq.n	40b10e <prvTCPReturnPacket+0x19a>
				{
					if( ( xTCPWindowLoggingLevel != 0 ) && ( pxSocket->u.xTCP.bits.bWinChange != pdFALSE_UNSIGNED ) )
  40b084:	4b6b      	ldr	r3, [pc, #428]	; (40b234 <prvTCPReturnPacket+0x2c0>)
  40b086:	681b      	ldr	r3, [r3, #0]
  40b088:	2b00      	cmp	r3, #0
  40b08a:	d040      	beq.n	40b10e <prvTCPReturnPacket+0x19a>
  40b08c:	68fb      	ldr	r3, [r7, #12]
  40b08e:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
  40b092:	f003 0301 	and.w	r3, r3, #1
  40b096:	b2db      	uxtb	r3, r3
  40b098:	2b00      	cmp	r3, #0
  40b09a:	d038      	beq.n	40b10e <prvTCPReturnPacket+0x19a>
					{
					size_t uxFrontSpace;

						if(pxSocket->u.xTCP.rxStream != NULL)
  40b09c:	68fb      	ldr	r3, [r7, #12]
  40b09e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
  40b0a0:	2b00      	cmp	r3, #0
  40b0a2:	d006      	beq.n	40b0b2 <prvTCPReturnPacket+0x13e>
						{
							uxFrontSpace =  uxStreamBufferFrontSpace( pxSocket->u.xTCP.rxStream ) ;
  40b0a4:	68fb      	ldr	r3, [r7, #12]
  40b0a6:	6edb      	ldr	r3, [r3, #108]	; 0x6c
  40b0a8:	4618      	mov	r0, r3
  40b0aa:	4b60      	ldr	r3, [pc, #384]	; (40b22c <prvTCPReturnPacket+0x2b8>)
  40b0ac:	4798      	blx	r3
  40b0ae:	6578      	str	r0, [r7, #84]	; 0x54
  40b0b0:	e001      	b.n	40b0b6 <prvTCPReturnPacket+0x142>
						}
						else
						{
							uxFrontSpace = 0u;
  40b0b2:	2300      	movs	r3, #0
  40b0b4:	657b      	str	r3, [r7, #84]	; 0x54
						}

						FreeRTOS_debug_printf( ( "%s: %lxip:%u: [%lu < %lu] winSize %ld\n",
  40b0b6:	68fb      	ldr	r3, [r7, #12]
  40b0b8:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
  40b0bc:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
  40b0c0:	b2db      	uxtb	r3, r3
  40b0c2:	2b00      	cmp	r3, #0
  40b0c4:	d001      	beq.n	40b0ca <prvTCPReturnPacket+0x156>
  40b0c6:	4c5c      	ldr	r4, [pc, #368]	; (40b238 <prvTCPReturnPacket+0x2c4>)
  40b0c8:	e000      	b.n	40b0cc <prvTCPReturnPacket+0x158>
  40b0ca:	4c5c      	ldr	r4, [pc, #368]	; (40b23c <prvTCPReturnPacket+0x2c8>)
  40b0cc:	68fb      	ldr	r3, [r7, #12]
  40b0ce:	6b9d      	ldr	r5, [r3, #56]	; 0x38
  40b0d0:	68fb      	ldr	r3, [r7, #12]
  40b0d2:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
  40b0d4:	461e      	mov	r6, r3
  40b0d6:	68fb      	ldr	r3, [r7, #12]
  40b0d8:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
  40b0dc:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
  40b0e0:	b2db      	uxtb	r3, r3
  40b0e2:	2b00      	cmp	r3, #0
  40b0e4:	d002      	beq.n	40b0ec <prvTCPReturnPacket+0x178>
  40b0e6:	68fb      	ldr	r3, [r7, #12]
  40b0e8:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
  40b0ea:	e000      	b.n	40b0ee <prvTCPReturnPacket+0x17a>
  40b0ec:	6d7b      	ldr	r3, [r7, #84]	; 0x54
  40b0ee:	68fa      	ldr	r2, [r7, #12]
  40b0f0:	6e12      	ldr	r2, [r2, #96]	; 0x60
  40b0f2:	6c79      	ldr	r1, [r7, #68]	; 0x44
  40b0f4:	6988      	ldr	r0, [r1, #24]
  40b0f6:	6c79      	ldr	r1, [r7, #68]	; 0x44
  40b0f8:	6909      	ldr	r1, [r1, #16]
  40b0fa:	1a41      	subs	r1, r0, r1
  40b0fc:	9102      	str	r1, [sp, #8]
  40b0fe:	9201      	str	r2, [sp, #4]
  40b100:	9300      	str	r3, [sp, #0]
  40b102:	4633      	mov	r3, r6
  40b104:	462a      	mov	r2, r5
  40b106:	4621      	mov	r1, r4
  40b108:	484d      	ldr	r0, [pc, #308]	; (40b240 <prvTCPReturnPacket+0x2cc>)
  40b10a:	4c4e      	ldr	r4, [pc, #312]	; (40b244 <prvTCPReturnPacket+0x2d0>)
  40b10c:	47a0      	blx	r4
				}
			}
			#endif /* ipconfigHAS_DEBUG_PRINTF != 0 */

			/* The new window size has been advertised, switch off the flag. */
			pxSocket->u.xTCP.bits.bWinChange = pdFALSE_UNSIGNED;
  40b10e:	68fa      	ldr	r2, [r7, #12]
  40b110:	f892 3041 	ldrb.w	r3, [r2, #65]	; 0x41
  40b114:	f36f 0300 	bfc	r3, #0, #1
  40b118:	f882 3041 	strb.w	r3, [r2, #65]	; 0x41

			/* Later on, when deciding to delay an ACK, a precise estimate is needed
			of the free RX space.  At this moment, 'ulHighestRxAllowed' would be the
			highest sequence number minus 1 that the socket will accept. */
			pxSocket->u.xTCP.ulHighestRxAllowed = pxTCPWindow->rx.ulCurrentSequenceNumber + ulSpace;
  40b11c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  40b11e:	691a      	ldr	r2, [r3, #16]
  40b120:	6e3b      	ldr	r3, [r7, #96]	; 0x60
  40b122:	441a      	add	r2, r3
  40b124:	68fb      	ldr	r3, [r7, #12]
  40b126:	645a      	str	r2, [r3, #68]	; 0x44
					pxTCPPacket->xTCPHeader.ulSequenceNumber = FreeRTOS_htonl( pxTCPPacket->xTCPHeader.ulSequenceNumber );
				}
				else
			#endif
			{
				pxTCPPacket->xTCPHeader.ulSequenceNumber = FreeRTOS_htonl( pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber );
  40b128:	68fb      	ldr	r3, [r7, #12]
  40b12a:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
  40b12e:	061a      	lsls	r2, r3, #24
  40b130:	68fb      	ldr	r3, [r7, #12]
  40b132:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
  40b136:	021b      	lsls	r3, r3, #8
  40b138:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
  40b13c:	431a      	orrs	r2, r3
  40b13e:	68fb      	ldr	r3, [r7, #12]
  40b140:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
  40b144:	0a1b      	lsrs	r3, r3, #8
  40b146:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
  40b14a:	431a      	orrs	r2, r3
  40b14c:	68fb      	ldr	r3, [r7, #12]
  40b14e:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
  40b152:	0e1b      	lsrs	r3, r3, #24
  40b154:	431a      	orrs	r2, r3
  40b156:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  40b158:	f8c3 2026 	str.w	r2, [r3, #38]	; 0x26

				if( ( pxTCPPacket->xTCPHeader.ucTCPFlags & ( uint8_t ) ipTCP_FLAG_FIN ) != 0u )
  40b15c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  40b15e:	f893 302f 	ldrb.w	r3, [r3, #47]	; 0x2f
  40b162:	f003 0301 	and.w	r3, r3, #1
  40b166:	2b00      	cmp	r3, #0
  40b168:	d021      	beq.n	40b1ae <prvTCPReturnPacket+0x23a>
				{
					/* Suppress FIN in case this packet carries earlier data to be
					retransmitted. */
					uint32_t ulDataLen = ( uint32_t ) ( ulLen - ( ipSIZE_OF_TCP_HEADER + ipSIZE_OF_IPv4_HEADER ) );
  40b16a:	687b      	ldr	r3, [r7, #4]
  40b16c:	3b28      	subs	r3, #40	; 0x28
  40b16e:	643b      	str	r3, [r7, #64]	; 0x40
					if( ( pxTCPWindow->ulOurSequenceNumber + ulDataLen ) != pxTCPWindow->tx.ulFINSequenceNumber )
  40b170:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  40b172:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  40b174:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  40b176:	441a      	add	r2, r3
  40b178:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  40b17a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  40b17c:	429a      	cmp	r2, r3
  40b17e:	d016      	beq.n	40b1ae <prvTCPReturnPacket+0x23a>
					{
						pxTCPPacket->xTCPHeader.ucTCPFlags &= ( ( uint8_t ) ~ipTCP_FLAG_FIN );
  40b180:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  40b182:	f893 302f 	ldrb.w	r3, [r3, #47]	; 0x2f
  40b186:	f023 0301 	bic.w	r3, r3, #1
  40b18a:	b2da      	uxtb	r2, r3
  40b18c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  40b18e:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f
						FreeRTOS_debug_printf( ( "Suppress FIN for %lu + %lu < %lu\n",
  40b192:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  40b194:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  40b196:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  40b198:	69db      	ldr	r3, [r3, #28]
  40b19a:	1ad1      	subs	r1, r2, r3
  40b19c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  40b19e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
  40b1a0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  40b1a2:	69db      	ldr	r3, [r3, #28]
  40b1a4:	1ad3      	subs	r3, r2, r3
  40b1a6:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  40b1a8:	4827      	ldr	r0, [pc, #156]	; (40b248 <prvTCPReturnPacket+0x2d4>)
  40b1aa:	4c26      	ldr	r4, [pc, #152]	; (40b244 <prvTCPReturnPacket+0x2d0>)
  40b1ac:	47a0      	blx	r4
					}
				}
			}

			/* Tell which sequence number is expected next time */
			pxTCPPacket->xTCPHeader.ulAckNr = FreeRTOS_htonl( pxTCPWindow->rx.ulCurrentSequenceNumber );
  40b1ae:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  40b1b0:	691b      	ldr	r3, [r3, #16]
  40b1b2:	061a      	lsls	r2, r3, #24
  40b1b4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  40b1b6:	691b      	ldr	r3, [r3, #16]
  40b1b8:	021b      	lsls	r3, r3, #8
  40b1ba:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
  40b1be:	431a      	orrs	r2, r3
  40b1c0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  40b1c2:	691b      	ldr	r3, [r3, #16]
  40b1c4:	0a1b      	lsrs	r3, r3, #8
  40b1c6:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
  40b1ca:	431a      	orrs	r2, r3
  40b1cc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  40b1ce:	691b      	ldr	r3, [r3, #16]
  40b1d0:	0e1b      	lsrs	r3, r3, #24
  40b1d2:	431a      	orrs	r2, r3
  40b1d4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  40b1d6:	f8c3 202a 	str.w	r2, [r3, #42]	; 0x2a
  40b1da:	e00d      	b.n	40b1f8 <prvTCPReturnPacket+0x284>
		}
		else
		{
			/* Sending data without a socket, probably replying with a RST flag
			Just swap the two sequence numbers. */
			vFlip_32( pxTCPPacket->xTCPHeader.ulSequenceNumber, pxTCPPacket->xTCPHeader.ulAckNr );
  40b1dc:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  40b1de:	f8d3 3026 	ldr.w	r3, [r3, #38]	; 0x26
  40b1e2:	63fb      	str	r3, [r7, #60]	; 0x3c
  40b1e4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  40b1e6:	f8d3 202a 	ldr.w	r2, [r3, #42]	; 0x2a
  40b1ea:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  40b1ec:	f8c3 2026 	str.w	r2, [r3, #38]	; 0x26
  40b1f0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  40b1f2:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
  40b1f4:	f8c3 202a 	str.w	r2, [r3, #42]	; 0x2a
		}

		pxIPHeader->ucTimeToLive		   = ( uint8_t ) ipconfigTCP_TIME_TO_LIVE;
  40b1f8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  40b1fa:	2280      	movs	r2, #128	; 0x80
  40b1fc:	721a      	strb	r2, [r3, #8]
		pxIPHeader->usLength			   = FreeRTOS_htons( ulLen );
  40b1fe:	687b      	ldr	r3, [r7, #4]
  40b200:	b29b      	uxth	r3, r3
  40b202:	021b      	lsls	r3, r3, #8
  40b204:	b29a      	uxth	r2, r3
  40b206:	687b      	ldr	r3, [r7, #4]
  40b208:	0a1b      	lsrs	r3, r3, #8
  40b20a:	b29b      	uxth	r3, r3
  40b20c:	4313      	orrs	r3, r2
  40b20e:	b29a      	uxth	r2, r3
  40b210:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  40b212:	805a      	strh	r2, [r3, #2]
		if( ( pxSocket == NULL ) || ( *ipLOCAL_IP_ADDRESS_POINTER == 0ul ) )
  40b214:	68fb      	ldr	r3, [r7, #12]
  40b216:	2b00      	cmp	r3, #0
  40b218:	d003      	beq.n	40b222 <prvTCPReturnPacket+0x2ae>
  40b21a:	4b0c      	ldr	r3, [pc, #48]	; (40b24c <prvTCPReturnPacket+0x2d8>)
  40b21c:	695b      	ldr	r3, [r3, #20]
  40b21e:	2b00      	cmp	r3, #0
  40b220:	d116      	bne.n	40b250 <prvTCPReturnPacket+0x2dc>
		{
			/* When pxSocket is NULL, this function is called by prvTCPSendReset()
			and the IP-addresses must be swapped.
			Also swap the IP-addresses in case the IP-tack doesn't have an
			IP-address yet, i.e. when ( *ipLOCAL_IP_ADDRESS_POINTER == 0ul ). */
			ulSourceAddress = pxIPHeader->ulDestinationIPAddress;
  40b222:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  40b224:	691b      	ldr	r3, [r3, #16]
  40b226:	65fb      	str	r3, [r7, #92]	; 0x5c
  40b228:	e015      	b.n	40b256 <prvTCPReturnPacket+0x2e2>
  40b22a:	bf00      	nop
  40b22c:	0040aa89 	.word	0x0040aa89
  40b230:	0040a9c1 	.word	0x0040a9c1
  40b234:	20006d60 	.word	0x20006d60
  40b238:	0041d1d8 	.word	0x0041d1d8
  40b23c:	0041d1e0 	.word	0x0041d1e0
  40b240:	0041d1e4 	.word	0x0041d1e4
  40b244:	00416c7d 	.word	0x00416c7d
  40b248:	0041d20c 	.word	0x0041d20c
  40b24c:	20000108 	.word	0x20000108
		}
		else
		{
			ulSourceAddress = *ipLOCAL_IP_ADDRESS_POINTER;
  40b250:	4b53      	ldr	r3, [pc, #332]	; (40b3a0 <prvTCPReturnPacket+0x42c>)
  40b252:	695b      	ldr	r3, [r3, #20]
  40b254:	65fb      	str	r3, [r7, #92]	; 0x5c
		}
		pxIPHeader->ulDestinationIPAddress = pxIPHeader->ulSourceIPAddress;
  40b256:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  40b258:	68da      	ldr	r2, [r3, #12]
  40b25a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  40b25c:	611a      	str	r2, [r3, #16]
		pxIPHeader->ulSourceIPAddress = ulSourceAddress;
  40b25e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  40b260:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
  40b262:	60da      	str	r2, [r3, #12]
		vFlip_16( pxTCPPacket->xTCPHeader.usSourcePort, pxTCPPacket->xTCPHeader.usDestinationPort );
  40b264:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  40b266:	f893 2022 	ldrb.w	r2, [r3, #34]	; 0x22
  40b26a:	f893 3023 	ldrb.w	r3, [r3, #35]	; 0x23
  40b26e:	021b      	lsls	r3, r3, #8
  40b270:	4313      	orrs	r3, r2
  40b272:	877b      	strh	r3, [r7, #58]	; 0x3a
  40b274:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  40b276:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
  40b278:	b29a      	uxth	r2, r3
  40b27a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  40b27c:	845a      	strh	r2, [r3, #34]	; 0x22
  40b27e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  40b280:	8f7a      	ldrh	r2, [r7, #58]	; 0x3a
  40b282:	849a      	strh	r2, [r3, #36]	; 0x24

		/* Just an increasing number. */
		pxIPHeader->usIdentification = FreeRTOS_htons( usPacketIdentifier );
  40b284:	4b47      	ldr	r3, [pc, #284]	; (40b3a4 <prvTCPReturnPacket+0x430>)
  40b286:	881b      	ldrh	r3, [r3, #0]
  40b288:	021b      	lsls	r3, r3, #8
  40b28a:	b21a      	sxth	r2, r3
  40b28c:	4b45      	ldr	r3, [pc, #276]	; (40b3a4 <prvTCPReturnPacket+0x430>)
  40b28e:	881b      	ldrh	r3, [r3, #0]
  40b290:	0a1b      	lsrs	r3, r3, #8
  40b292:	b29b      	uxth	r3, r3
  40b294:	b21b      	sxth	r3, r3
  40b296:	4313      	orrs	r3, r2
  40b298:	b21b      	sxth	r3, r3
  40b29a:	b29a      	uxth	r2, r3
  40b29c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  40b29e:	809a      	strh	r2, [r3, #4]
		usPacketIdentifier++;
  40b2a0:	4b40      	ldr	r3, [pc, #256]	; (40b3a4 <prvTCPReturnPacket+0x430>)
  40b2a2:	881b      	ldrh	r3, [r3, #0]
  40b2a4:	3301      	adds	r3, #1
  40b2a6:	b29a      	uxth	r2, r3
  40b2a8:	4b3e      	ldr	r3, [pc, #248]	; (40b3a4 <prvTCPReturnPacket+0x430>)
  40b2aa:	801a      	strh	r2, [r3, #0]
		pxIPHeader->usFragmentOffset = 0u;
  40b2ac:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  40b2ae:	2200      	movs	r2, #0
  40b2b0:	719a      	strb	r2, [r3, #6]
  40b2b2:	2200      	movs	r2, #0
  40b2b4:	71da      	strb	r2, [r3, #7]

		#if( ipconfigDRIVER_INCLUDED_TX_IP_CHECKSUM == 0 )
		{
			/* calculate the IP header checksum, in case the driver won't do that. */
			pxIPHeader->usHeaderChecksum = 0x00u;
  40b2b6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  40b2b8:	2200      	movs	r2, #0
  40b2ba:	729a      	strb	r2, [r3, #10]
  40b2bc:	2200      	movs	r2, #0
  40b2be:	72da      	strb	r2, [r3, #11]
			pxIPHeader->usHeaderChecksum = usGenerateChecksum( 0UL, ( uint8_t * ) &( pxIPHeader->ucVersionHeaderLength ), ipSIZE_OF_IPv4_HEADER );
  40b2c0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  40b2c2:	2214      	movs	r2, #20
  40b2c4:	4619      	mov	r1, r3
  40b2c6:	2000      	movs	r0, #0
  40b2c8:	4b37      	ldr	r3, [pc, #220]	; (40b3a8 <prvTCPReturnPacket+0x434>)
  40b2ca:	4798      	blx	r3
  40b2cc:	4603      	mov	r3, r0
  40b2ce:	461a      	mov	r2, r3
  40b2d0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  40b2d2:	815a      	strh	r2, [r3, #10]
			pxIPHeader->usHeaderChecksum = ~FreeRTOS_htons( pxIPHeader->usHeaderChecksum );
  40b2d4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  40b2d6:	895b      	ldrh	r3, [r3, #10]
  40b2d8:	b29b      	uxth	r3, r3
  40b2da:	021b      	lsls	r3, r3, #8
  40b2dc:	b21a      	sxth	r2, r3
  40b2de:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  40b2e0:	895b      	ldrh	r3, [r3, #10]
  40b2e2:	b29b      	uxth	r3, r3
  40b2e4:	0a1b      	lsrs	r3, r3, #8
  40b2e6:	b29b      	uxth	r3, r3
  40b2e8:	b21b      	sxth	r3, r3
  40b2ea:	4313      	orrs	r3, r2
  40b2ec:	b21b      	sxth	r3, r3
  40b2ee:	b29b      	uxth	r3, r3
  40b2f0:	43db      	mvns	r3, r3
  40b2f2:	b29a      	uxth	r2, r3
  40b2f4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  40b2f6:	815a      	strh	r2, [r3, #10]

			/* calculate the TCP checksum for an outgoing packet. */
			usGenerateProtocolChecksum( (uint8_t*)pxTCPPacket, pxNetworkBuffer->xDataLength, pdTRUE );
  40b2f8:	68bb      	ldr	r3, [r7, #8]
  40b2fa:	69db      	ldr	r3, [r3, #28]
  40b2fc:	2201      	movs	r2, #1
  40b2fe:	4619      	mov	r1, r3
  40b300:	6d38      	ldr	r0, [r7, #80]	; 0x50
  40b302:	4b2a      	ldr	r3, [pc, #168]	; (40b3ac <prvTCPReturnPacket+0x438>)
  40b304:	4798      	blx	r3

			/* A calculated checksum of 0 must be inverted as 0 means the checksum
			is disabled. */
			if( pxTCPPacket->xTCPHeader.usChecksum == 0x00u )
  40b306:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  40b308:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
  40b30a:	b29b      	uxth	r3, r3
  40b30c:	2b00      	cmp	r3, #0
  40b30e:	d108      	bne.n	40b322 <prvTCPReturnPacket+0x3ae>
			{
				pxTCPPacket->xTCPHeader.usChecksum = 0xffffU;
  40b310:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  40b312:	f04f 32ff 	mov.w	r2, #4294967295
  40b316:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
  40b31a:	f04f 32ff 	mov.w	r2, #4294967295
  40b31e:	f883 2033 	strb.w	r2, [r3, #51]	; 0x33
			}
		}
		#endif

	#if( ipconfigUSE_LINKED_RX_MESSAGES != 0 )
		pxNetworkBuffer->pxNextBuffer = NULL;
  40b322:	68bb      	ldr	r3, [r7, #8]
  40b324:	2200      	movs	r2, #0
  40b326:	625a      	str	r2, [r3, #36]	; 0x24
	#endif

		/* Important: tell NIC driver how many bytes must be sent. */
		pxNetworkBuffer->xDataLength = ulLen + ipSIZE_OF_ETH_HEADER;
  40b328:	687b      	ldr	r3, [r7, #4]
  40b32a:	f103 020e 	add.w	r2, r3, #14
  40b32e:	68bb      	ldr	r3, [r7, #8]
  40b330:	61da      	str	r2, [r3, #28]

		/* Fill in the destination MAC addresses. */
		memcpy( ( void * ) &( pxEthernetHeader->xDestinationAddress ), ( void * ) &( pxEthernetHeader->xSourceAddress ),
  40b332:	6cb8      	ldr	r0, [r7, #72]	; 0x48
  40b334:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  40b336:	3306      	adds	r3, #6
  40b338:	2206      	movs	r2, #6
  40b33a:	4619      	mov	r1, r3
  40b33c:	4b1c      	ldr	r3, [pc, #112]	; (40b3b0 <prvTCPReturnPacket+0x43c>)
  40b33e:	4798      	blx	r3
			sizeof( pxEthernetHeader->xDestinationAddress ) );

		/* The source MAC addresses is fixed to 'ipLOCAL_MAC_ADDRESS'. */
		memcpy( ( void * ) &( pxEthernetHeader->xSourceAddress) , ( void * ) ipLOCAL_MAC_ADDRESS, ( size_t ) ipMAC_ADDRESS_LENGTH_BYTES );
  40b340:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  40b342:	3306      	adds	r3, #6
  40b344:	2206      	movs	r2, #6
  40b346:	4916      	ldr	r1, [pc, #88]	; (40b3a0 <prvTCPReturnPacket+0x42c>)
  40b348:	4618      	mov	r0, r3
  40b34a:	4b19      	ldr	r3, [pc, #100]	; (40b3b0 <prvTCPReturnPacket+0x43c>)
  40b34c:	4798      	blx	r3
			}
		}
		#endif

		/* Send! */
		xNetworkInterfaceOutput( pxNetworkBuffer, xReleaseAfterSend );
  40b34e:	6839      	ldr	r1, [r7, #0]
  40b350:	68b8      	ldr	r0, [r7, #8]
  40b352:	4b18      	ldr	r3, [pc, #96]	; (40b3b4 <prvTCPReturnPacket+0x440>)
  40b354:	4798      	blx	r3

		if( xReleaseAfterSend == pdFALSE )
  40b356:	683b      	ldr	r3, [r7, #0]
  40b358:	2b00      	cmp	r3, #0
  40b35a:	d11c      	bne.n	40b396 <prvTCPReturnPacket+0x422>
		{
			/* Swap-back some fields, as pxBuffer probably points to a socket field
			containing the packet header. */
			vFlip_16( pxTCPPacket->xTCPHeader.usSourcePort, pxTCPPacket->xTCPHeader.usDestinationPort);
  40b35c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  40b35e:	f893 2022 	ldrb.w	r2, [r3, #34]	; 0x22
  40b362:	f893 3023 	ldrb.w	r3, [r3, #35]	; 0x23
  40b366:	021b      	lsls	r3, r3, #8
  40b368:	4313      	orrs	r3, r2
  40b36a:	873b      	strh	r3, [r7, #56]	; 0x38
  40b36c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  40b36e:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
  40b370:	b29a      	uxth	r2, r3
  40b372:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  40b374:	845a      	strh	r2, [r3, #34]	; 0x22
  40b376:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  40b378:	8f3a      	ldrh	r2, [r7, #56]	; 0x38
  40b37a:	849a      	strh	r2, [r3, #36]	; 0x24
			pxTCPPacket->xIPHeader.ulSourceIPAddress = pxTCPPacket->xIPHeader.ulDestinationIPAddress;
  40b37c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  40b37e:	f8d3 201e 	ldr.w	r2, [r3, #30]
  40b382:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  40b384:	f8c3 201a 	str.w	r2, [r3, #26]
			memcpy( pxEthernetHeader->xSourceAddress.ucBytes, pxEthernetHeader->xDestinationAddress.ucBytes, ( size_t ) ipMAC_ADDRESS_LENGTH_BYTES );
  40b388:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  40b38a:	3306      	adds	r3, #6
  40b38c:	6cb9      	ldr	r1, [r7, #72]	; 0x48
  40b38e:	2206      	movs	r2, #6
  40b390:	4618      	mov	r0, r3
  40b392:	4b07      	ldr	r3, [pc, #28]	; (40b3b0 <prvTCPReturnPacket+0x43c>)
  40b394:	4798      	blx	r3
		else
		{
			/* Nothing to do: the buffer has been passed to DMA and will be released after use */
		}
	} /* if( pxNetworkBuffer != NULL ) */
}
  40b396:	bf00      	nop
  40b398:	376c      	adds	r7, #108	; 0x6c
  40b39a:	46bd      	mov	sp, r7
  40b39c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  40b39e:	bf00      	nop
  40b3a0:	20000108 	.word	0x20000108
  40b3a4:	20006ccc 	.word	0x20006ccc
  40b3a8:	004085c5 	.word	0x004085c5
  40b3ac:	004082e5 	.word	0x004082e5
  40b3b0:	00416d05 	.word	0x00416d05
  40b3b4:	004102dd 	.word	0x004102dd

0040b3b8 <prvTCPCreateWindow>:
 * random starting value, are being synchronised.  The sliding window manager
 * (in FreeRTOS_TCP_WIN.c) needs to know them, along with the Maximum Segment
 * Size (MSS) in use.
 */
static void prvTCPCreateWindow( FreeRTOS_Socket_t *pxSocket )
{
  40b3b8:	b5b0      	push	{r4, r5, r7, lr}
  40b3ba:	b084      	sub	sp, #16
  40b3bc:	af02      	add	r7, sp, #8
  40b3be:	6078      	str	r0, [r7, #4]
	if( xTCPWindowLoggingLevel )
  40b3c0:	4b1c      	ldr	r3, [pc, #112]	; (40b434 <prvTCPCreateWindow+0x7c>)
  40b3c2:	681b      	ldr	r3, [r3, #0]
  40b3c4:	2b00      	cmp	r3, #0
  40b3c6:	d011      	beq.n	40b3ec <prvTCPCreateWindow+0x34>
		FreeRTOS_debug_printf( ( "Limits (using): TCP Win size %lu Water %lu <= %lu <= %lu\n",
  40b3c8:	687b      	ldr	r3, [r7, #4]
  40b3ca:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
  40b3ce:	f44f 62aa 	mov.w	r2, #1360	; 0x550
  40b3d2:	fb02 f103 	mul.w	r1, r2, r3
  40b3d6:	687b      	ldr	r3, [r7, #4]
  40b3d8:	6dda      	ldr	r2, [r3, #92]	; 0x5c
  40b3da:	687b      	ldr	r3, [r7, #4]
  40b3dc:	6e18      	ldr	r0, [r3, #96]	; 0x60
  40b3de:	687b      	ldr	r3, [r7, #4]
  40b3e0:	6e5b      	ldr	r3, [r3, #100]	; 0x64
  40b3e2:	9300      	str	r3, [sp, #0]
  40b3e4:	4603      	mov	r3, r0
  40b3e6:	4814      	ldr	r0, [pc, #80]	; (40b438 <prvTCPCreateWindow+0x80>)
  40b3e8:	4c14      	ldr	r4, [pc, #80]	; (40b43c <prvTCPCreateWindow+0x84>)
  40b3ea:	47a0      	blx	r4
			pxSocket->u.xTCP.uxRxWinSize * ipconfigTCP_MSS,
			pxSocket->u.xTCP.uxLittleSpace ,
			pxSocket->u.xTCP.uxEnoughSpace,
			pxSocket->u.xTCP.uxRxStreamSize ) );
	vTCPWindowCreate(
  40b3ec:	687b      	ldr	r3, [r7, #4]
  40b3ee:	f103 00d0 	add.w	r0, r3, #208	; 0xd0
		&pxSocket->u.xTCP.xTCPWindow,
		ipconfigTCP_MSS * pxSocket->u.xTCP.uxRxWinSize,
  40b3f2:	687b      	ldr	r3, [r7, #4]
  40b3f4:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
  40b3f8:	f44f 62aa 	mov.w	r2, #1360	; 0x550
  40b3fc:	fb02 f103 	mul.w	r1, r2, r3
		ipconfigTCP_MSS * pxSocket->u.xTCP.uxTxWinSize,
  40b400:	687b      	ldr	r3, [r7, #4]
  40b402:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
  40b406:	f44f 62aa 	mov.w	r2, #1360	; 0x550
  40b40a:	fb02 f403 	mul.w	r4, r2, r3
	vTCPWindowCreate(
  40b40e:	687b      	ldr	r3, [r7, #4]
  40b410:	f8d3 50e0 	ldr.w	r5, [r3, #224]	; 0xe0
  40b414:	687b      	ldr	r3, [r7, #4]
  40b416:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
		pxSocket->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber,
		pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber,
		( uint32_t ) pxSocket->u.xTCP.usInitMSS );
  40b41a:	687a      	ldr	r2, [r7, #4]
  40b41c:	f8b2 204c 	ldrh.w	r2, [r2, #76]	; 0x4c
	vTCPWindowCreate(
  40b420:	9201      	str	r2, [sp, #4]
  40b422:	9300      	str	r3, [sp, #0]
  40b424:	462b      	mov	r3, r5
  40b426:	4622      	mov	r2, r4
  40b428:	4c05      	ldr	r4, [pc, #20]	; (40b440 <prvTCPCreateWindow+0x88>)
  40b42a:	47a0      	blx	r4
}
  40b42c:	bf00      	nop
  40b42e:	3708      	adds	r7, #8
  40b430:	46bd      	mov	sp, r7
  40b432:	bdb0      	pop	{r4, r5, r7, pc}
  40b434:	20006d60 	.word	0x20006d60
  40b438:	0041d230 	.word	0x0041d230
  40b43c:	00416c7d 	.word	0x00416c7d
  40b440:	0040de99 	.word	0x0040de99

0040b444 <prvTCPPrepareConnect>:
 * the Ethernet address of the target will be found using ARP.  In case the
 * target IP address is not within the netmask, the hardware address of the
 * gateway will be used.
 */
static BaseType_t prvTCPPrepareConnect( FreeRTOS_Socket_t *pxSocket )
{
  40b444:	b5f0      	push	{r4, r5, r6, r7, lr}
  40b446:	b091      	sub	sp, #68	; 0x44
  40b448:	af06      	add	r7, sp, #24
  40b44a:	6078      	str	r0, [r7, #4]
TCPPacket_t *pxTCPPacket;
IPHeader_t *pxIPHeader;
eARPLookupResult_t eReturned;
uint32_t ulRemoteIP;
MACAddress_t xEthAddress;
BaseType_t xReturn = pdTRUE;
  40b44c:	2301      	movs	r3, #1
  40b44e:	627b      	str	r3, [r7, #36]	; 0x24
uint32_t ulInitialSequenceNumber = 0;
  40b450:	2300      	movs	r3, #0
  40b452:	623b      	str	r3, [r7, #32]

	#if( ipconfigHAS_PRINTF != 0 )
	{
		/* Only necessary for nicer logging. */
		memset( xEthAddress.ucBytes, '\0', sizeof( xEthAddress.ucBytes ) );
  40b454:	f107 0308 	add.w	r3, r7, #8
  40b458:	2206      	movs	r2, #6
  40b45a:	2100      	movs	r1, #0
  40b45c:	4618      	mov	r0, r3
  40b45e:	4b7d      	ldr	r3, [pc, #500]	; (40b654 <prvTCPPrepareConnect+0x210>)
  40b460:	4798      	blx	r3
	}
	#endif /* ipconfigHAS_PRINTF != 0 */

	ulRemoteIP = FreeRTOS_htonl( pxSocket->u.xTCP.ulRemoteIP );
  40b462:	687b      	ldr	r3, [r7, #4]
  40b464:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  40b466:	061a      	lsls	r2, r3, #24
  40b468:	687b      	ldr	r3, [r7, #4]
  40b46a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  40b46c:	021b      	lsls	r3, r3, #8
  40b46e:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
  40b472:	431a      	orrs	r2, r3
  40b474:	687b      	ldr	r3, [r7, #4]
  40b476:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  40b478:	0a1b      	lsrs	r3, r3, #8
  40b47a:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
  40b47e:	431a      	orrs	r2, r3
  40b480:	687b      	ldr	r3, [r7, #4]
  40b482:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  40b484:	0e1b      	lsrs	r3, r3, #24
  40b486:	4313      	orrs	r3, r2
  40b488:	613b      	str	r3, [r7, #16]

	/* Determine the ARP cache status for the requested IP address. */
	eReturned = eARPGetCacheEntry( &( ulRemoteIP ), &( xEthAddress ) );
  40b48a:	f107 0208 	add.w	r2, r7, #8
  40b48e:	f107 0310 	add.w	r3, r7, #16
  40b492:	4611      	mov	r1, r2
  40b494:	4618      	mov	r0, r3
  40b496:	4b70      	ldr	r3, [pc, #448]	; (40b658 <prvTCPPrepareConnect+0x214>)
  40b498:	4798      	blx	r3
  40b49a:	4603      	mov	r3, r0
  40b49c:	77fb      	strb	r3, [r7, #31]

	switch( eReturned )
  40b49e:	7ffb      	ldrb	r3, [r7, #31]
  40b4a0:	2b01      	cmp	r3, #1
  40b4a2:	d037      	beq.n	40b514 <prvTCPPrepareConnect+0xd0>
		break;				/* We can now prepare the SYN packet. */
	case eARPCacheMiss:		/* An ARP table lookup did not find a valid entry. */
	case eCantSendPacket:	/* There is no IP address, or an ARP is still in progress. */
	default:
		/* Count the number of times it couldn't find the ARP address. */
		pxSocket->u.xTCP.ucRepCount++;
  40b4a4:	687b      	ldr	r3, [r7, #4]
  40b4a6:	f893 3052 	ldrb.w	r3, [r3, #82]	; 0x52
  40b4aa:	3301      	adds	r3, #1
  40b4ac:	b2da      	uxtb	r2, r3
  40b4ae:	687b      	ldr	r3, [r7, #4]
  40b4b0:	f883 2052 	strb.w	r2, [r3, #82]	; 0x52

		FreeRTOS_debug_printf( ( "ARP for %lxip (using %lxip): rc=%d %02X:%02X:%02X %02X:%02X:%02X\n",
  40b4b4:	687b      	ldr	r3, [r7, #4]
  40b4b6:	6b99      	ldr	r1, [r3, #56]	; 0x38
  40b4b8:	693b      	ldr	r3, [r7, #16]
  40b4ba:	061a      	lsls	r2, r3, #24
  40b4bc:	693b      	ldr	r3, [r7, #16]
  40b4be:	021b      	lsls	r3, r3, #8
  40b4c0:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
  40b4c4:	431a      	orrs	r2, r3
  40b4c6:	693b      	ldr	r3, [r7, #16]
  40b4c8:	0a1b      	lsrs	r3, r3, #8
  40b4ca:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
  40b4ce:	431a      	orrs	r2, r3
  40b4d0:	693b      	ldr	r3, [r7, #16]
  40b4d2:	0e1b      	lsrs	r3, r3, #24
  40b4d4:	431a      	orrs	r2, r3
  40b4d6:	f897 c01f 	ldrb.w	ip, [r7, #31]
  40b4da:	7a38      	ldrb	r0, [r7, #8]
  40b4dc:	7a7c      	ldrb	r4, [r7, #9]
  40b4de:	7abd      	ldrb	r5, [r7, #10]
  40b4e0:	7afe      	ldrb	r6, [r7, #11]
  40b4e2:	f897 e00c 	ldrb.w	lr, [r7, #12]
  40b4e6:	f8c7 e000 	str.w	lr, [r7]
  40b4ea:	f897 e00d 	ldrb.w	lr, [r7, #13]
  40b4ee:	4673      	mov	r3, lr
  40b4f0:	9305      	str	r3, [sp, #20]
  40b4f2:	683b      	ldr	r3, [r7, #0]
  40b4f4:	9304      	str	r3, [sp, #16]
  40b4f6:	9603      	str	r6, [sp, #12]
  40b4f8:	9502      	str	r5, [sp, #8]
  40b4fa:	9401      	str	r4, [sp, #4]
  40b4fc:	9000      	str	r0, [sp, #0]
  40b4fe:	4663      	mov	r3, ip
  40b500:	4856      	ldr	r0, [pc, #344]	; (40b65c <prvTCPPrepareConnect+0x218>)
  40b502:	4c57      	ldr	r4, [pc, #348]	; (40b660 <prvTCPPrepareConnect+0x21c>)
  40b504:	47a0      	blx	r4
			xEthAddress.ucBytes[ 3 ],
			xEthAddress.ucBytes[ 4 ],
			xEthAddress.ucBytes[ 5 ] ) );

		/* And issue a (new) ARP request */
		FreeRTOS_OutputARPRequest( ulRemoteIP );
  40b506:	693b      	ldr	r3, [r7, #16]
  40b508:	4618      	mov	r0, r3
  40b50a:	4b56      	ldr	r3, [pc, #344]	; (40b664 <prvTCPPrepareConnect+0x220>)
  40b50c:	4798      	blx	r3

		xReturn = pdFALSE;
  40b50e:	2300      	movs	r3, #0
  40b510:	627b      	str	r3, [r7, #36]	; 0x24
  40b512:	e000      	b.n	40b516 <prvTCPPrepareConnect+0xd2>
		break;				/* We can now prepare the SYN packet. */
  40b514:	bf00      	nop
	}

	if( xReturn != pdFALSE )
  40b516:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40b518:	2b00      	cmp	r3, #0
  40b51a:	d00f      	beq.n	40b53c <prvTCPPrepareConnect+0xf8>
	{
		/* Get a difficult-to-predict initial sequence number for this 4-tuple. */
		ulInitialSequenceNumber = ulApplicationGetNextSequenceNumber( *ipLOCAL_IP_ADDRESS_POINTER,
  40b51c:	4b52      	ldr	r3, [pc, #328]	; (40b668 <prvTCPPrepareConnect+0x224>)
  40b51e:	6958      	ldr	r0, [r3, #20]
  40b520:	687b      	ldr	r3, [r7, #4]
  40b522:	8c99      	ldrh	r1, [r3, #36]	; 0x24
  40b524:	687b      	ldr	r3, [r7, #4]
  40b526:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  40b528:	687b      	ldr	r3, [r7, #4]
  40b52a:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
  40b52c:	4c4f      	ldr	r4, [pc, #316]	; (40b66c <prvTCPPrepareConnect+0x228>)
  40b52e:	47a0      	blx	r4
  40b530:	6238      	str	r0, [r7, #32]
																	  pxSocket->usLocalPort,
																	  pxSocket->u.xTCP.ulRemoteIP,
																	  pxSocket->u.xTCP.usRemotePort );

		/* Check for a random number generation error. */
		if( 0 == ulInitialSequenceNumber )
  40b532:	6a3b      	ldr	r3, [r7, #32]
  40b534:	2b00      	cmp	r3, #0
  40b536:	d101      	bne.n	40b53c <prvTCPPrepareConnect+0xf8>
		{
			xReturn = pdFALSE;
  40b538:	2300      	movs	r3, #0
  40b53a:	627b      	str	r3, [r7, #36]	; 0x24
		}
	}

	if( xReturn != pdFALSE )
  40b53c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40b53e:	2b00      	cmp	r3, #0
  40b540:	f000 8083 	beq.w	40b64a <prvTCPPrepareConnect+0x206>
	{
		/* The MAC-address of the peer (or gateway) has been found,
		now prepare the initial TCP packet and some fields in the socket. */
		pxTCPPacket = ( TCPPacket_t * )pxSocket->u.xTCP.xPacket.u.ucLastPacket;
  40b544:	687b      	ldr	r3, [r7, #4]
  40b546:	337a      	adds	r3, #122	; 0x7a
  40b548:	61bb      	str	r3, [r7, #24]
		pxIPHeader = &pxTCPPacket->xIPHeader;
  40b54a:	69bb      	ldr	r3, [r7, #24]
  40b54c:	330e      	adds	r3, #14
  40b54e:	617b      	str	r3, [r7, #20]

		/* reset the retry counter to zero. */
		pxSocket->u.xTCP.ucRepCount = 0u;
  40b550:	687b      	ldr	r3, [r7, #4]
  40b552:	2200      	movs	r2, #0
  40b554:	f883 2052 	strb.w	r2, [r3, #82]	; 0x52

		/* And remember that the connect/SYN data are prepared. */
		pxSocket->u.xTCP.bits.bConnPrepared = pdTRUE_UNSIGNED;
  40b558:	687a      	ldr	r2, [r7, #4]
  40b55a:	f892 3041 	ldrb.w	r3, [r2, #65]	; 0x41
  40b55e:	f043 0308 	orr.w	r3, r3, #8
  40b562:	f882 3041 	strb.w	r3, [r2, #65]	; 0x41

		/* Now that the Ethernet address is known, the initial packet can be
		prepared. */
		memset( pxSocket->u.xTCP.xPacket.u.ucLastPacket, '\0', sizeof( pxSocket->u.xTCP.xPacket.u.ucLastPacket ) );
  40b566:	687b      	ldr	r3, [r7, #4]
  40b568:	337a      	adds	r3, #122	; 0x7a
  40b56a:	2246      	movs	r2, #70	; 0x46
  40b56c:	2100      	movs	r1, #0
  40b56e:	4618      	mov	r0, r3
  40b570:	4b38      	ldr	r3, [pc, #224]	; (40b654 <prvTCPPrepareConnect+0x210>)
  40b572:	4798      	blx	r3

		/* Write the Ethernet address in Source, because it will be swapped by
		prvTCPReturnPacket(). */
		memcpy( &pxTCPPacket->xEthernetHeader.xSourceAddress, &xEthAddress, sizeof( xEthAddress ) );
  40b574:	69bb      	ldr	r3, [r7, #24]
  40b576:	3306      	adds	r3, #6
  40b578:	461a      	mov	r2, r3
  40b57a:	f107 0308 	add.w	r3, r7, #8
  40b57e:	6818      	ldr	r0, [r3, #0]
  40b580:	6010      	str	r0, [r2, #0]
  40b582:	889b      	ldrh	r3, [r3, #4]
  40b584:	8093      	strh	r3, [r2, #4]

		/* 'ipIPv4_FRAME_TYPE' is already in network-byte-order. */
		pxTCPPacket->xEthernetHeader.usFrameType = ipIPv4_FRAME_TYPE;
  40b586:	69bb      	ldr	r3, [r7, #24]
  40b588:	2200      	movs	r2, #0
  40b58a:	f042 0208 	orr.w	r2, r2, #8
  40b58e:	731a      	strb	r2, [r3, #12]
  40b590:	2200      	movs	r2, #0
  40b592:	735a      	strb	r2, [r3, #13]

		pxIPHeader->ucVersionHeaderLength = 0x45u;
  40b594:	697b      	ldr	r3, [r7, #20]
  40b596:	2245      	movs	r2, #69	; 0x45
  40b598:	701a      	strb	r2, [r3, #0]
		pxIPHeader->usLength = FreeRTOS_htons( sizeof( TCPPacket_t ) - sizeof( pxTCPPacket->xEthernetHeader ) );
  40b59a:	697b      	ldr	r3, [r7, #20]
  40b59c:	2200      	movs	r2, #0
  40b59e:	709a      	strb	r2, [r3, #2]
  40b5a0:	2200      	movs	r2, #0
  40b5a2:	f042 0238 	orr.w	r2, r2, #56	; 0x38
  40b5a6:	70da      	strb	r2, [r3, #3]
		pxIPHeader->ucTimeToLive = ( uint8_t ) ipconfigTCP_TIME_TO_LIVE;
  40b5a8:	697b      	ldr	r3, [r7, #20]
  40b5aa:	2280      	movs	r2, #128	; 0x80
  40b5ac:	721a      	strb	r2, [r3, #8]

		pxIPHeader->ucProtocol = ( uint8_t ) ipPROTOCOL_TCP;
  40b5ae:	697b      	ldr	r3, [r7, #20]
  40b5b0:	2206      	movs	r2, #6
  40b5b2:	725a      	strb	r2, [r3, #9]

		/* Addresses and ports will be stored swapped because prvTCPReturnPacket
		will swap them back while replying. */
		pxIPHeader->ulDestinationIPAddress = *ipLOCAL_IP_ADDRESS_POINTER;
  40b5b4:	4b2c      	ldr	r3, [pc, #176]	; (40b668 <prvTCPPrepareConnect+0x224>)
  40b5b6:	695a      	ldr	r2, [r3, #20]
  40b5b8:	697b      	ldr	r3, [r7, #20]
  40b5ba:	611a      	str	r2, [r3, #16]
		pxIPHeader->ulSourceIPAddress = FreeRTOS_htonl( pxSocket->u.xTCP.ulRemoteIP );
  40b5bc:	687b      	ldr	r3, [r7, #4]
  40b5be:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  40b5c0:	061a      	lsls	r2, r3, #24
  40b5c2:	687b      	ldr	r3, [r7, #4]
  40b5c4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  40b5c6:	021b      	lsls	r3, r3, #8
  40b5c8:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
  40b5cc:	431a      	orrs	r2, r3
  40b5ce:	687b      	ldr	r3, [r7, #4]
  40b5d0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  40b5d2:	0a1b      	lsrs	r3, r3, #8
  40b5d4:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
  40b5d8:	431a      	orrs	r2, r3
  40b5da:	687b      	ldr	r3, [r7, #4]
  40b5dc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  40b5de:	0e1b      	lsrs	r3, r3, #24
  40b5e0:	431a      	orrs	r2, r3
  40b5e2:	697b      	ldr	r3, [r7, #20]
  40b5e4:	60da      	str	r2, [r3, #12]

		pxTCPPacket->xTCPHeader.usSourcePort = FreeRTOS_htons( pxSocket->u.xTCP.usRemotePort );
  40b5e6:	687b      	ldr	r3, [r7, #4]
  40b5e8:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
  40b5ea:	021b      	lsls	r3, r3, #8
  40b5ec:	b21a      	sxth	r2, r3
  40b5ee:	687b      	ldr	r3, [r7, #4]
  40b5f0:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
  40b5f2:	0a1b      	lsrs	r3, r3, #8
  40b5f4:	b29b      	uxth	r3, r3
  40b5f6:	b21b      	sxth	r3, r3
  40b5f8:	4313      	orrs	r3, r2
  40b5fa:	b21b      	sxth	r3, r3
  40b5fc:	b29a      	uxth	r2, r3
  40b5fe:	69bb      	ldr	r3, [r7, #24]
  40b600:	845a      	strh	r2, [r3, #34]	; 0x22
		pxTCPPacket->xTCPHeader.usDestinationPort = FreeRTOS_htons( pxSocket->usLocalPort );
  40b602:	687b      	ldr	r3, [r7, #4]
  40b604:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
  40b606:	021b      	lsls	r3, r3, #8
  40b608:	b21a      	sxth	r2, r3
  40b60a:	687b      	ldr	r3, [r7, #4]
  40b60c:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
  40b60e:	0a1b      	lsrs	r3, r3, #8
  40b610:	b29b      	uxth	r3, r3
  40b612:	b21b      	sxth	r3, r3
  40b614:	4313      	orrs	r3, r2
  40b616:	b21b      	sxth	r3, r3
  40b618:	b29a      	uxth	r2, r3
  40b61a:	69bb      	ldr	r3, [r7, #24]
  40b61c:	849a      	strh	r2, [r3, #36]	; 0x24

		/* We are actively connecting, so the peer's Initial Sequence Number (ISN)
		isn't known yet. */
		pxSocket->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber = 0ul;
  40b61e:	687b      	ldr	r3, [r7, #4]
  40b620:	2200      	movs	r2, #0
  40b622:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0

		/* Start with ISN (Initial Sequence Number). */
		pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber = ulInitialSequenceNumber;
  40b626:	687b      	ldr	r3, [r7, #4]
  40b628:	6a3a      	ldr	r2, [r7, #32]
  40b62a:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc

		/* The TCP header size is 20 bytes, divided by 4 equals 5, which is put in
		the high nibble of the TCP offset field. */
		pxTCPPacket->xTCPHeader.ucTCPOffset = 0x50u;
  40b62e:	69bb      	ldr	r3, [r7, #24]
  40b630:	2250      	movs	r2, #80	; 0x50
  40b632:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e

		/* Only set the SYN flag. */
		pxTCPPacket->xTCPHeader.ucTCPFlags = ipTCP_FLAG_SYN;
  40b636:	69bb      	ldr	r3, [r7, #24]
  40b638:	2202      	movs	r2, #2
  40b63a:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f

		/* Set the values of usInitMSS / usCurMSS for this socket. */
		prvSocketSetMSS( pxSocket );
  40b63e:	6878      	ldr	r0, [r7, #4]
  40b640:	4b0b      	ldr	r3, [pc, #44]	; (40b670 <prvTCPPrepareConnect+0x22c>)
  40b642:	4798      	blx	r3

		/* The initial sequence numbers at our side are known.  Later
		vTCPWindowInit() will be called to fill in the peer's sequence numbers, but
		first wait for a SYN+ACK reply. */
		prvTCPCreateWindow( pxSocket );
  40b644:	6878      	ldr	r0, [r7, #4]
  40b646:	4b0b      	ldr	r3, [pc, #44]	; (40b674 <prvTCPPrepareConnect+0x230>)
  40b648:	4798      	blx	r3
	}

	return xReturn;
  40b64a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
  40b64c:	4618      	mov	r0, r3
  40b64e:	372c      	adds	r7, #44	; 0x2c
  40b650:	46bd      	mov	sp, r7
  40b652:	bdf0      	pop	{r4, r5, r6, r7, pc}
  40b654:	00416f01 	.word	0x00416f01
  40b658:	00407359 	.word	0x00407359
  40b65c:	0041d26c 	.word	0x0041d26c
  40b660:	00416c7d 	.word	0x00416c7d
  40b664:	004075bd 	.word	0x004075bd
  40b668:	20000108 	.word	0x20000108
  40b66c:	0040ab91 	.word	0x0040ab91
  40b670:	0040d149 	.word	0x0040d149
  40b674:	0040b3b9 	.word	0x0040b3b9

0040b678 <prvTCPFlagMeaning>:
/* For logging and debugging: make a string showing the TCP flags
*/
#if( ipconfigHAS_DEBUG_PRINTF != 0 )

	static const char *prvTCPFlagMeaning( UBaseType_t xFlags)
	{
  40b678:	b5f0      	push	{r4, r5, r6, r7, lr}
  40b67a:	b08b      	sub	sp, #44	; 0x2c
  40b67c:	af08      	add	r7, sp, #32
  40b67e:	6078      	str	r0, [r7, #4]
		static char retString[10];
		snprintf(retString, sizeof( retString ), "%c%c%c%c%c%c%c%c%c",
			( xFlags & ipTCP_FLAG_FIN )  ? 'F' : '.',	/* 0x0001: No more data from sender */
  40b680:	687b      	ldr	r3, [r7, #4]
  40b682:	f003 0301 	and.w	r3, r3, #1
		snprintf(retString, sizeof( retString ), "%c%c%c%c%c%c%c%c%c",
  40b686:	2b00      	cmp	r3, #0
  40b688:	d002      	beq.n	40b690 <prvTCPFlagMeaning+0x18>
  40b68a:	f04f 0c46 	mov.w	ip, #70	; 0x46
  40b68e:	e001      	b.n	40b694 <prvTCPFlagMeaning+0x1c>
  40b690:	f04f 0c2e 	mov.w	ip, #46	; 0x2e
			( xFlags & ipTCP_FLAG_SYN )  ? 'S' : '.',	/* 0x0002: Synchronize sequence numbers */
  40b694:	687b      	ldr	r3, [r7, #4]
  40b696:	f003 0302 	and.w	r3, r3, #2
		snprintf(retString, sizeof( retString ), "%c%c%c%c%c%c%c%c%c",
  40b69a:	2b00      	cmp	r3, #0
  40b69c:	d002      	beq.n	40b6a4 <prvTCPFlagMeaning+0x2c>
  40b69e:	2353      	movs	r3, #83	; 0x53
  40b6a0:	603b      	str	r3, [r7, #0]
  40b6a2:	e001      	b.n	40b6a8 <prvTCPFlagMeaning+0x30>
  40b6a4:	232e      	movs	r3, #46	; 0x2e
  40b6a6:	603b      	str	r3, [r7, #0]
			( xFlags & ipTCP_FLAG_RST )  ? 'R' : '.',	/* 0x0004: Reset the connection */
  40b6a8:	687a      	ldr	r2, [r7, #4]
  40b6aa:	f002 0204 	and.w	r2, r2, #4
		snprintf(retString, sizeof( retString ), "%c%c%c%c%c%c%c%c%c",
  40b6ae:	2a00      	cmp	r2, #0
  40b6b0:	d001      	beq.n	40b6b6 <prvTCPFlagMeaning+0x3e>
  40b6b2:	2252      	movs	r2, #82	; 0x52
  40b6b4:	e000      	b.n	40b6b8 <prvTCPFlagMeaning+0x40>
  40b6b6:	222e      	movs	r2, #46	; 0x2e
			( xFlags & ipTCP_FLAG_PSH )  ? 'P' : '.',	/* 0x0008: Push function: please push buffered data to the recv application */
  40b6b8:	6879      	ldr	r1, [r7, #4]
  40b6ba:	f001 0108 	and.w	r1, r1, #8
		snprintf(retString, sizeof( retString ), "%c%c%c%c%c%c%c%c%c",
  40b6be:	2900      	cmp	r1, #0
  40b6c0:	d001      	beq.n	40b6c6 <prvTCPFlagMeaning+0x4e>
  40b6c2:	2150      	movs	r1, #80	; 0x50
  40b6c4:	e000      	b.n	40b6c8 <prvTCPFlagMeaning+0x50>
  40b6c6:	212e      	movs	r1, #46	; 0x2e
			( xFlags & ipTCP_FLAG_ACK )  ? 'A' : '.',	/* 0x0010: Acknowledgment field is significant */
  40b6c8:	6878      	ldr	r0, [r7, #4]
  40b6ca:	f000 0010 	and.w	r0, r0, #16
		snprintf(retString, sizeof( retString ), "%c%c%c%c%c%c%c%c%c",
  40b6ce:	2800      	cmp	r0, #0
  40b6d0:	d001      	beq.n	40b6d6 <prvTCPFlagMeaning+0x5e>
  40b6d2:	2041      	movs	r0, #65	; 0x41
  40b6d4:	e000      	b.n	40b6d8 <prvTCPFlagMeaning+0x60>
  40b6d6:	202e      	movs	r0, #46	; 0x2e
			( xFlags & ipTCP_FLAG_URG )  ? 'U' : '.',	/* 0x0020: Urgent pointer field is significant */
  40b6d8:	687c      	ldr	r4, [r7, #4]
  40b6da:	f004 0420 	and.w	r4, r4, #32
		snprintf(retString, sizeof( retString ), "%c%c%c%c%c%c%c%c%c",
  40b6de:	2c00      	cmp	r4, #0
  40b6e0:	d001      	beq.n	40b6e6 <prvTCPFlagMeaning+0x6e>
  40b6e2:	2455      	movs	r4, #85	; 0x55
  40b6e4:	e000      	b.n	40b6e8 <prvTCPFlagMeaning+0x70>
  40b6e6:	242e      	movs	r4, #46	; 0x2e
			( xFlags & ipTCP_FLAG_ECN )  ? 'E' : '.',	/* 0x0040: ECN-Echo */
  40b6e8:	687d      	ldr	r5, [r7, #4]
  40b6ea:	f005 0540 	and.w	r5, r5, #64	; 0x40
		snprintf(retString, sizeof( retString ), "%c%c%c%c%c%c%c%c%c",
  40b6ee:	2d00      	cmp	r5, #0
  40b6f0:	d001      	beq.n	40b6f6 <prvTCPFlagMeaning+0x7e>
  40b6f2:	2545      	movs	r5, #69	; 0x45
  40b6f4:	e000      	b.n	40b6f8 <prvTCPFlagMeaning+0x80>
  40b6f6:	252e      	movs	r5, #46	; 0x2e
			( xFlags & ipTCP_FLAG_CWR )  ? 'C' : '.',	/* 0x0080: Congestion Window Reduced */
  40b6f8:	687e      	ldr	r6, [r7, #4]
  40b6fa:	f006 0680 	and.w	r6, r6, #128	; 0x80
		snprintf(retString, sizeof( retString ), "%c%c%c%c%c%c%c%c%c",
  40b6fe:	2e00      	cmp	r6, #0
  40b700:	d001      	beq.n	40b706 <prvTCPFlagMeaning+0x8e>
  40b702:	2643      	movs	r6, #67	; 0x43
  40b704:	e000      	b.n	40b708 <prvTCPFlagMeaning+0x90>
  40b706:	262e      	movs	r6, #46	; 0x2e
			( xFlags & ipTCP_FLAG_NS )   ? 'N' : '.');	/* 0x0100: ECN-nonce concealment protection */
  40b708:	687b      	ldr	r3, [r7, #4]
  40b70a:	f403 7e80 	and.w	lr, r3, #256	; 0x100
		snprintf(retString, sizeof( retString ), "%c%c%c%c%c%c%c%c%c",
  40b70e:	f1be 0f00 	cmp.w	lr, #0
  40b712:	d001      	beq.n	40b718 <prvTCPFlagMeaning+0xa0>
  40b714:	234e      	movs	r3, #78	; 0x4e
  40b716:	e000      	b.n	40b71a <prvTCPFlagMeaning+0xa2>
  40b718:	232e      	movs	r3, #46	; 0x2e
  40b71a:	9307      	str	r3, [sp, #28]
  40b71c:	9606      	str	r6, [sp, #24]
  40b71e:	9505      	str	r5, [sp, #20]
  40b720:	9404      	str	r4, [sp, #16]
  40b722:	9003      	str	r0, [sp, #12]
  40b724:	9102      	str	r1, [sp, #8]
  40b726:	9201      	str	r2, [sp, #4]
  40b728:	683b      	ldr	r3, [r7, #0]
  40b72a:	9300      	str	r3, [sp, #0]
  40b72c:	4663      	mov	r3, ip
  40b72e:	4a05      	ldr	r2, [pc, #20]	; (40b744 <prvTCPFlagMeaning+0xcc>)
  40b730:	210a      	movs	r1, #10
  40b732:	4805      	ldr	r0, [pc, #20]	; (40b748 <prvTCPFlagMeaning+0xd0>)
  40b734:	4c05      	ldr	r4, [pc, #20]	; (40b74c <prvTCPFlagMeaning+0xd4>)
  40b736:	47a0      	blx	r4
		return retString;
  40b738:	4b03      	ldr	r3, [pc, #12]	; (40b748 <prvTCPFlagMeaning+0xd0>)
	}
  40b73a:	4618      	mov	r0, r3
  40b73c:	370c      	adds	r7, #12
  40b73e:	46bd      	mov	sp, r7
  40b740:	bdf0      	pop	{r4, r5, r6, r7, pc}
  40b742:	bf00      	nop
  40b744:	0041d2b0 	.word	0x0041d2b0
  40b748:	20006d3c 	.word	0x20006d3c
  40b74c:	0041713d 	.word	0x0041713d

0040b750 <prvCheckOptions>:
 * Parse the TCP option(s) received, if present.  It has already been verified
 * that: ((pxTCPHeader->ucTCPOffset & 0xf0) > 0x50), meaning that the TP header
 * is longer than the usual 20 (5 x 4) bytes.
 */
static void prvCheckOptions( FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t *pxNetworkBuffer )
{
  40b750:	b590      	push	{r4, r7, lr}
  40b752:	b089      	sub	sp, #36	; 0x24
  40b754:	af00      	add	r7, sp, #0
  40b756:	6078      	str	r0, [r7, #4]
  40b758:	6039      	str	r1, [r7, #0]
const unsigned char *pucPtr;
const unsigned char *pucLast;
TCPWindow_t *pxTCPWindow;
BaseType_t xShouldContinueLoop;

	pxTCPPacket = ( TCPPacket_t * ) ( pxNetworkBuffer->pucEthernetBuffer );
  40b75a:	683b      	ldr	r3, [r7, #0]
  40b75c:	699b      	ldr	r3, [r3, #24]
  40b75e:	61bb      	str	r3, [r7, #24]
	pxTCPHeader = &pxTCPPacket->xTCPHeader;
  40b760:	69bb      	ldr	r3, [r7, #24]
  40b762:	3322      	adds	r3, #34	; 0x22
  40b764:	617b      	str	r3, [r7, #20]

	/* A character pointer to iterate through the option data */
	pucPtr = pxTCPHeader->ucOptdata;
  40b766:	697b      	ldr	r3, [r7, #20]
  40b768:	3314      	adds	r3, #20
  40b76a:	613b      	str	r3, [r7, #16]
	pucLast = pucPtr + (((pxTCPHeader->ucTCPOffset >> 4) - 5) << 2);
  40b76c:	693b      	ldr	r3, [r7, #16]
  40b76e:	697a      	ldr	r2, [r7, #20]
  40b770:	7b12      	ldrb	r2, [r2, #12]
  40b772:	0912      	lsrs	r2, r2, #4
  40b774:	b2d2      	uxtb	r2, r2
  40b776:	3a05      	subs	r2, #5
  40b778:	0092      	lsls	r2, r2, #2
  40b77a:	4413      	add	r3, r2
  40b77c:	60fb      	str	r3, [r7, #12]
	pxTCPWindow = &pxSocket->u.xTCP.xTCPWindow;
  40b77e:	687b      	ldr	r3, [r7, #4]
  40b780:	33d0      	adds	r3, #208	; 0xd0
  40b782:	60bb      	str	r3, [r7, #8]

	/* Validate options size calculation. */
	if( pucLast > ( pxNetworkBuffer->pucEthernetBuffer + pxNetworkBuffer->xDataLength ) )
  40b784:	683b      	ldr	r3, [r7, #0]
  40b786:	699a      	ldr	r2, [r3, #24]
  40b788:	683b      	ldr	r3, [r7, #0]
  40b78a:	69db      	ldr	r3, [r3, #28]
  40b78c:	441a      	add	r2, r3
  40b78e:	68fb      	ldr	r3, [r7, #12]
  40b790:	429a      	cmp	r2, r3
  40b792:	d314      	bcc.n	40b7be <prvCheckOptions+0x6e>
		return;
	}

	/* The comparison with pucLast is only necessary in case the option data are
	corrupted, we don't like to run into invalid memory and crash. */
	xShouldContinueLoop = pdTRUE;
  40b794:	2301      	movs	r3, #1
  40b796:	61fb      	str	r3, [r7, #28]
	while( ( pucPtr < pucLast ) && ( xShouldContinueLoop == pdTRUE ) )
  40b798:	e009      	b.n	40b7ae <prvCheckOptions+0x5e>
	{
		xShouldContinueLoop = prvSingleStepTCPHeaderOptions( &pucPtr, &pucLast, &pxSocket, &pxTCPWindow );
  40b79a:	f107 0308 	add.w	r3, r7, #8
  40b79e:	1d3a      	adds	r2, r7, #4
  40b7a0:	f107 010c 	add.w	r1, r7, #12
  40b7a4:	f107 0010 	add.w	r0, r7, #16
  40b7a8:	4c07      	ldr	r4, [pc, #28]	; (40b7c8 <prvCheckOptions+0x78>)
  40b7aa:	47a0      	blx	r4
  40b7ac:	61f8      	str	r0, [r7, #28]
	while( ( pucPtr < pucLast ) && ( xShouldContinueLoop == pdTRUE ) )
  40b7ae:	693a      	ldr	r2, [r7, #16]
  40b7b0:	68fb      	ldr	r3, [r7, #12]
  40b7b2:	429a      	cmp	r2, r3
  40b7b4:	d204      	bcs.n	40b7c0 <prvCheckOptions+0x70>
  40b7b6:	69fb      	ldr	r3, [r7, #28]
  40b7b8:	2b01      	cmp	r3, #1
  40b7ba:	d0ee      	beq.n	40b79a <prvCheckOptions+0x4a>
  40b7bc:	e000      	b.n	40b7c0 <prvCheckOptions+0x70>
		return;
  40b7be:	bf00      	nop
	}
}
  40b7c0:	3724      	adds	r7, #36	; 0x24
  40b7c2:	46bd      	mov	sp, r7
  40b7c4:	bd90      	pop	{r4, r7, pc}
  40b7c6:	bf00      	nop
  40b7c8:	0040b7cd 	.word	0x0040b7cd

0040b7cc <prvSingleStepTCPHeaderOptions>:

/*-----------------------------------------------------------*/

static BaseType_t prvSingleStepTCPHeaderOptions( const unsigned char ** const ppucPtr, const unsigned char ** const ppucLast, FreeRTOS_Socket_t ** const ppxSocket, TCPWindow_t ** const ppxTCPWindow)
{
  40b7cc:	b580      	push	{r7, lr}
  40b7ce:	b088      	sub	sp, #32
  40b7d0:	af00      	add	r7, sp, #0
  40b7d2:	60f8      	str	r0, [r7, #12]
  40b7d4:	60b9      	str	r1, [r7, #8]
  40b7d6:	607a      	str	r2, [r7, #4]
  40b7d8:	603b      	str	r3, [r7, #0]
	UBaseType_t uxNewMSS;
	UBaseType_t xRemainingOptionsBytes = ( *ppucLast ) - ( *ppucPtr );
  40b7da:	68bb      	ldr	r3, [r7, #8]
  40b7dc:	681b      	ldr	r3, [r3, #0]
  40b7de:	461a      	mov	r2, r3
  40b7e0:	68fb      	ldr	r3, [r7, #12]
  40b7e2:	681b      	ldr	r3, [r3, #0]
  40b7e4:	1ad3      	subs	r3, r2, r3
  40b7e6:	61fb      	str	r3, [r7, #28]
	unsigned char ucLen;

	if( ( *ppucPtr )[ 0 ] == TCP_OPT_END )
  40b7e8:	68fb      	ldr	r3, [r7, #12]
  40b7ea:	681b      	ldr	r3, [r3, #0]
  40b7ec:	781b      	ldrb	r3, [r3, #0]
  40b7ee:	2b00      	cmp	r3, #0
  40b7f0:	d101      	bne.n	40b7f6 <prvSingleStepTCPHeaderOptions+0x2a>
	{
		/* End of options. */
		return pdFALSE;
  40b7f2:	2300      	movs	r3, #0
  40b7f4:	e0e6      	b.n	40b9c4 <prvSingleStepTCPHeaderOptions+0x1f8>
	}
	if( ( *ppucPtr )[ 0 ] == TCP_OPT_NOOP)
  40b7f6:	68fb      	ldr	r3, [r7, #12]
  40b7f8:	681b      	ldr	r3, [r3, #0]
  40b7fa:	781b      	ldrb	r3, [r3, #0]
  40b7fc:	2b01      	cmp	r3, #1
  40b7fe:	d106      	bne.n	40b80e <prvSingleStepTCPHeaderOptions+0x42>
	{
		/* NOP option, inserted to make the length a multiple of 4. */
		( *ppucPtr )++;
  40b800:	68fb      	ldr	r3, [r7, #12]
  40b802:	681b      	ldr	r3, [r3, #0]
  40b804:	1c5a      	adds	r2, r3, #1
  40b806:	68fb      	ldr	r3, [r7, #12]
  40b808:	601a      	str	r2, [r3, #0]
		return pdTRUE;
  40b80a:	2301      	movs	r3, #1
  40b80c:	e0da      	b.n	40b9c4 <prvSingleStepTCPHeaderOptions+0x1f8>
	}

	/* Any other well-formed option must be at least two bytes: the option
	type byte followed by a length byte. */
	if( xRemainingOptionsBytes < 2 )
  40b80e:	69fb      	ldr	r3, [r7, #28]
  40b810:	2b01      	cmp	r3, #1
  40b812:	d801      	bhi.n	40b818 <prvSingleStepTCPHeaderOptions+0x4c>
	{
		return pdFALSE;
  40b814:	2300      	movs	r3, #0
  40b816:	e0d5      	b.n	40b9c4 <prvSingleStepTCPHeaderOptions+0x1f8>
	}
#if( ipconfigUSE_TCP_WIN != 0 )
	else if( ( *ppucPtr )[ 0 ] == TCP_OPT_WSOPT )
  40b818:	68fb      	ldr	r3, [r7, #12]
  40b81a:	681b      	ldr	r3, [r3, #0]
  40b81c:	781b      	ldrb	r3, [r3, #0]
  40b81e:	2b03      	cmp	r3, #3
  40b820:	d11f      	bne.n	40b862 <prvSingleStepTCPHeaderOptions+0x96>
	{
		/* Confirm that the option fits in the remaining buffer space. */
		if( ( xRemainingOptionsBytes < TCP_OPT_WSOPT_LEN ) || ( ( *ppucPtr )[ 1 ] != TCP_OPT_WSOPT_LEN ) )
  40b822:	69fb      	ldr	r3, [r7, #28]
  40b824:	2b02      	cmp	r3, #2
  40b826:	d905      	bls.n	40b834 <prvSingleStepTCPHeaderOptions+0x68>
  40b828:	68fb      	ldr	r3, [r7, #12]
  40b82a:	681b      	ldr	r3, [r3, #0]
  40b82c:	3301      	adds	r3, #1
  40b82e:	781b      	ldrb	r3, [r3, #0]
  40b830:	2b03      	cmp	r3, #3
  40b832:	d001      	beq.n	40b838 <prvSingleStepTCPHeaderOptions+0x6c>
		{
			return pdFALSE;
  40b834:	2300      	movs	r3, #0
  40b836:	e0c5      	b.n	40b9c4 <prvSingleStepTCPHeaderOptions+0x1f8>
		}

		( *ppxSocket )->u.xTCP.ucPeerWinScaleFactor = ( *ppucPtr )[ 2 ];
  40b838:	687b      	ldr	r3, [r7, #4]
  40b83a:	681b      	ldr	r3, [r3, #0]
  40b83c:	68fa      	ldr	r2, [r7, #12]
  40b83e:	6812      	ldr	r2, [r2, #0]
  40b840:	7892      	ldrb	r2, [r2, #2]
  40b842:	f883 20c2 	strb.w	r2, [r3, #194]	; 0xc2
		( *ppxSocket )->u.xTCP.bits.bWinScaling = pdTRUE_UNSIGNED;
  40b846:	687b      	ldr	r3, [r7, #4]
  40b848:	681a      	ldr	r2, [r3, #0]
  40b84a:	f892 3042 	ldrb.w	r3, [r2, #66]	; 0x42
  40b84e:	f043 0310 	orr.w	r3, r3, #16
  40b852:	f882 3042 	strb.w	r3, [r2, #66]	; 0x42
		( *ppucPtr ) += TCP_OPT_WSOPT_LEN;
  40b856:	68fb      	ldr	r3, [r7, #12]
  40b858:	681b      	ldr	r3, [r3, #0]
  40b85a:	1cda      	adds	r2, r3, #3
  40b85c:	68fb      	ldr	r3, [r7, #12]
  40b85e:	601a      	str	r2, [r3, #0]
  40b860:	e0af      	b.n	40b9c2 <prvSingleStepTCPHeaderOptions+0x1f6>
	}
#endif	/* ipconfigUSE_TCP_WIN */
	else if( ( *ppucPtr )[ 0 ] == TCP_OPT_MSS )
  40b862:	68fb      	ldr	r3, [r7, #12]
  40b864:	681b      	ldr	r3, [r3, #0]
  40b866:	781b      	ldrb	r3, [r3, #0]
  40b868:	2b02      	cmp	r3, #2
  40b86a:	d17d      	bne.n	40b968 <prvSingleStepTCPHeaderOptions+0x19c>
	{
		/* Confirm that the option fits in the remaining buffer space. */
		if( ( xRemainingOptionsBytes < TCP_OPT_MSS_LEN )|| ( ( *ppucPtr )[ 1 ] != TCP_OPT_MSS_LEN ) )
  40b86c:	69fb      	ldr	r3, [r7, #28]
  40b86e:	2b03      	cmp	r3, #3
  40b870:	d905      	bls.n	40b87e <prvSingleStepTCPHeaderOptions+0xb2>
  40b872:	68fb      	ldr	r3, [r7, #12]
  40b874:	681b      	ldr	r3, [r3, #0]
  40b876:	3301      	adds	r3, #1
  40b878:	781b      	ldrb	r3, [r3, #0]
  40b87a:	2b04      	cmp	r3, #4
  40b87c:	d001      	beq.n	40b882 <prvSingleStepTCPHeaderOptions+0xb6>
		{
			return pdFALSE;
  40b87e:	2300      	movs	r3, #0
  40b880:	e0a0      	b.n	40b9c4 <prvSingleStepTCPHeaderOptions+0x1f8>
		}

		/* An MSS option with the correct option length.  FreeRTOS_htons()
		is not needed here because usChar2u16() already returns a host
		endian number. */
		uxNewMSS = usChar2u16( ( *ppucPtr ) + 2 );
  40b882:	68fb      	ldr	r3, [r7, #12]
  40b884:	681b      	ldr	r3, [r3, #0]
  40b886:	3302      	adds	r3, #2
  40b888:	4618      	mov	r0, r3
  40b88a:	4b50      	ldr	r3, [pc, #320]	; (40b9cc <prvSingleStepTCPHeaderOptions+0x200>)
  40b88c:	4798      	blx	r3
  40b88e:	4603      	mov	r3, r0
  40b890:	61bb      	str	r3, [r7, #24]

		if( ( *ppxSocket )->u.xTCP.usInitMSS != uxNewMSS )
  40b892:	687b      	ldr	r3, [r7, #4]
  40b894:	681b      	ldr	r3, [r3, #0]
  40b896:	f8b3 304c 	ldrh.w	r3, [r3, #76]	; 0x4c
  40b89a:	461a      	mov	r2, r3
  40b89c:	69bb      	ldr	r3, [r7, #24]
  40b89e:	429a      	cmp	r2, r3
  40b8a0:	d00d      	beq.n	40b8be <prvSingleStepTCPHeaderOptions+0xf2>
		{
			/* Perform a basic check on the the new MSS. */
			if( uxNewMSS == 0 )
  40b8a2:	69bb      	ldr	r3, [r7, #24]
  40b8a4:	2b00      	cmp	r3, #0
  40b8a6:	d101      	bne.n	40b8ac <prvSingleStepTCPHeaderOptions+0xe0>
			{
				return pdFALSE;
  40b8a8:	2300      	movs	r3, #0
  40b8aa:	e08b      	b.n	40b9c4 <prvSingleStepTCPHeaderOptions+0x1f8>
			}

			FreeRTOS_debug_printf( ( "MSS change %u -> %lu\n", ( *ppxSocket )->u.xTCP.usInitMSS, uxNewMSS ) );
  40b8ac:	687b      	ldr	r3, [r7, #4]
  40b8ae:	681b      	ldr	r3, [r3, #0]
  40b8b0:	f8b3 304c 	ldrh.w	r3, [r3, #76]	; 0x4c
  40b8b4:	69ba      	ldr	r2, [r7, #24]
  40b8b6:	4619      	mov	r1, r3
  40b8b8:	4845      	ldr	r0, [pc, #276]	; (40b9d0 <prvSingleStepTCPHeaderOptions+0x204>)
  40b8ba:	4b46      	ldr	r3, [pc, #280]	; (40b9d4 <prvSingleStepTCPHeaderOptions+0x208>)
  40b8bc:	4798      	blx	r3
		}

		if( ( *ppxSocket )->u.xTCP.usInitMSS > uxNewMSS )
  40b8be:	687b      	ldr	r3, [r7, #4]
  40b8c0:	681b      	ldr	r3, [r3, #0]
  40b8c2:	f8b3 304c 	ldrh.w	r3, [r3, #76]	; 0x4c
  40b8c6:	461a      	mov	r2, r3
  40b8c8:	69bb      	ldr	r3, [r7, #24]
  40b8ca:	429a      	cmp	r2, r3
  40b8cc:	d946      	bls.n	40b95c <prvSingleStepTCPHeaderOptions+0x190>
		{
			/* our MSS was bigger than the MSS of the other party: adapt it. */
			( *ppxSocket )->u.xTCP.bits.bMssChange = pdTRUE_UNSIGNED;
  40b8ce:	687b      	ldr	r3, [r7, #4]
  40b8d0:	681a      	ldr	r2, [r3, #0]
  40b8d2:	f892 3040 	ldrb.w	r3, [r2, #64]	; 0x40
  40b8d6:	f043 0301 	orr.w	r3, r3, #1
  40b8da:	f882 3040 	strb.w	r3, [r2, #64]	; 0x40
			if( ( ( *ppxTCPWindow ) != NULL ) && ( ( *ppxSocket )->u.xTCP.usCurMSS > uxNewMSS ) )
  40b8de:	683b      	ldr	r3, [r7, #0]
  40b8e0:	681b      	ldr	r3, [r3, #0]
  40b8e2:	2b00      	cmp	r3, #0
  40b8e4:	d016      	beq.n	40b914 <prvSingleStepTCPHeaderOptions+0x148>
  40b8e6:	687b      	ldr	r3, [r7, #4]
  40b8e8:	681b      	ldr	r3, [r3, #0]
  40b8ea:	f8b3 304a 	ldrh.w	r3, [r3, #74]	; 0x4a
  40b8ee:	461a      	mov	r2, r3
  40b8f0:	69bb      	ldr	r3, [r7, #24]
  40b8f2:	429a      	cmp	r2, r3
  40b8f4:	d90e      	bls.n	40b914 <prvSingleStepTCPHeaderOptions+0x148>
			{
				/* The peer advertises a smaller MSS than this socket was
				using.  Use that as well. */
				FreeRTOS_debug_printf( ( "Change mss %d => %lu\n", ( *ppxSocket )->u.xTCP.usCurMSS, uxNewMSS ) );
  40b8f6:	687b      	ldr	r3, [r7, #4]
  40b8f8:	681b      	ldr	r3, [r3, #0]
  40b8fa:	f8b3 304a 	ldrh.w	r3, [r3, #74]	; 0x4a
  40b8fe:	69ba      	ldr	r2, [r7, #24]
  40b900:	4619      	mov	r1, r3
  40b902:	4835      	ldr	r0, [pc, #212]	; (40b9d8 <prvSingleStepTCPHeaderOptions+0x20c>)
  40b904:	4b33      	ldr	r3, [pc, #204]	; (40b9d4 <prvSingleStepTCPHeaderOptions+0x208>)
  40b906:	4798      	blx	r3
				( *ppxSocket )->u.xTCP.usCurMSS = ( uint16_t ) uxNewMSS;
  40b908:	687b      	ldr	r3, [r7, #4]
  40b90a:	681b      	ldr	r3, [r3, #0]
  40b90c:	69ba      	ldr	r2, [r7, #24]
  40b90e:	b292      	uxth	r2, r2
  40b910:	f8a3 204a 	strh.w	r2, [r3, #74]	; 0x4a
			}
			( *ppxTCPWindow )->xSize.ulRxWindowLength = ( ( uint32_t ) uxNewMSS ) * ( ( *ppxTCPWindow )->xSize.ulRxWindowLength / ( ( uint32_t ) uxNewMSS ) );
  40b914:	683b      	ldr	r3, [r7, #0]
  40b916:	681b      	ldr	r3, [r3, #0]
  40b918:	683a      	ldr	r2, [r7, #0]
  40b91a:	6812      	ldr	r2, [r2, #0]
  40b91c:	6851      	ldr	r1, [r2, #4]
  40b91e:	69ba      	ldr	r2, [r7, #24]
  40b920:	fbb1 f2f2 	udiv	r2, r1, r2
  40b924:	69b9      	ldr	r1, [r7, #24]
  40b926:	fb01 f202 	mul.w	r2, r1, r2
  40b92a:	605a      	str	r2, [r3, #4]
			( *ppxTCPWindow )->usMSSInit = ( uint16_t ) uxNewMSS;
  40b92c:	683b      	ldr	r3, [r7, #0]
  40b92e:	681b      	ldr	r3, [r3, #0]
  40b930:	69ba      	ldr	r2, [r7, #24]
  40b932:	b292      	uxth	r2, r2
  40b934:	f8a3 20be 	strh.w	r2, [r3, #190]	; 0xbe
			( *ppxTCPWindow )->usMSS = ( uint16_t ) uxNewMSS;
  40b938:	683b      	ldr	r3, [r7, #0]
  40b93a:	681b      	ldr	r3, [r3, #0]
  40b93c:	69ba      	ldr	r2, [r7, #24]
  40b93e:	b292      	uxth	r2, r2
  40b940:	f8a3 20bc 	strh.w	r2, [r3, #188]	; 0xbc
			( *ppxSocket )->u.xTCP.usInitMSS = ( uint16_t ) uxNewMSS;
  40b944:	687b      	ldr	r3, [r7, #4]
  40b946:	681b      	ldr	r3, [r3, #0]
  40b948:	69ba      	ldr	r2, [r7, #24]
  40b94a:	b292      	uxth	r2, r2
  40b94c:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
			( *ppxSocket )->u.xTCP.usCurMSS = ( uint16_t ) uxNewMSS;
  40b950:	687b      	ldr	r3, [r7, #4]
  40b952:	681b      	ldr	r3, [r3, #0]
  40b954:	69ba      	ldr	r2, [r7, #24]
  40b956:	b292      	uxth	r2, r2
  40b958:	f8a3 204a 	strh.w	r2, [r3, #74]	; 0x4a
		#if( ipconfigUSE_TCP_WIN != 1 )
			/* Without scaled windows, MSS is the only interesting option. */
			return pdFALSE;
		#else
			/* Or else we continue to check another option: selective ACK. */
			( *ppucPtr ) += TCP_OPT_MSS_LEN;
  40b95c:	68fb      	ldr	r3, [r7, #12]
  40b95e:	681b      	ldr	r3, [r3, #0]
  40b960:	1d1a      	adds	r2, r3, #4
  40b962:	68fb      	ldr	r3, [r7, #12]
  40b964:	601a      	str	r2, [r3, #0]
  40b966:	e02c      	b.n	40b9c2 <prvSingleStepTCPHeaderOptions+0x1f6>
	}
	else
	{
		/* All other options have a length field, so that we easily
		can skip past them. */
		ucLen = ( *ppucPtr )[ 1 ];
  40b968:	68fb      	ldr	r3, [r7, #12]
  40b96a:	681b      	ldr	r3, [r3, #0]
  40b96c:	785b      	ldrb	r3, [r3, #1]
  40b96e:	75fb      	strb	r3, [r7, #23]
		if( ( ucLen < 2 ) || ( ucLen > xRemainingOptionsBytes ) )
  40b970:	7dfb      	ldrb	r3, [r7, #23]
  40b972:	2b01      	cmp	r3, #1
  40b974:	d904      	bls.n	40b980 <prvSingleStepTCPHeaderOptions+0x1b4>
  40b976:	7dfb      	ldrb	r3, [r7, #23]
  40b978:	461a      	mov	r2, r3
  40b97a:	69fb      	ldr	r3, [r7, #28]
  40b97c:	429a      	cmp	r2, r3
  40b97e:	d901      	bls.n	40b984 <prvSingleStepTCPHeaderOptions+0x1b8>
		{
			/* If the length field is too small or too big, the options are
			 * malformed, don't process them further.
			 */
			return pdFALSE;
  40b980:	2300      	movs	r3, #0
  40b982:	e01f      	b.n	40b9c4 <prvSingleStepTCPHeaderOptions+0x1f8>
		{
			/* Selective ACK: the peer has received a packet but it is missing
			 * earlier packets. At least this packet does not need retransmission
			 * anymore. ulTCPWindowTxSack( ) takes care of this administration.
			 */
			if( ( *ppucPtr )[0] == TCP_OPT_SACK_A )
  40b984:	68fb      	ldr	r3, [r7, #12]
  40b986:	681b      	ldr	r3, [r3, #0]
  40b988:	781b      	ldrb	r3, [r3, #0]
  40b98a:	2b05      	cmp	r3, #5
  40b98c:	d113      	bne.n	40b9b6 <prvSingleStepTCPHeaderOptions+0x1ea>
			{
				ucLen -= 2;
  40b98e:	7dfb      	ldrb	r3, [r7, #23]
  40b990:	3b02      	subs	r3, #2
  40b992:	b2db      	uxtb	r3, r3
  40b994:	75fb      	strb	r3, [r7, #23]
				( *ppucPtr ) += 2;
  40b996:	68fb      	ldr	r3, [r7, #12]
  40b998:	681b      	ldr	r3, [r3, #0]
  40b99a:	1c9a      	adds	r2, r3, #2
  40b99c:	68fb      	ldr	r3, [r7, #12]
  40b99e:	601a      	str	r2, [r3, #0]

				while( ucLen >= 8 )
  40b9a0:	e006      	b.n	40b9b0 <prvSingleStepTCPHeaderOptions+0x1e4>
				{
					prvSkipPastRemainingOptions( ppucPtr, ppxSocket, &ucLen );
  40b9a2:	f107 0317 	add.w	r3, r7, #23
  40b9a6:	461a      	mov	r2, r3
  40b9a8:	6879      	ldr	r1, [r7, #4]
  40b9aa:	68f8      	ldr	r0, [r7, #12]
  40b9ac:	4b0b      	ldr	r3, [pc, #44]	; (40b9dc <prvSingleStepTCPHeaderOptions+0x210>)
  40b9ae:	4798      	blx	r3
				while( ucLen >= 8 )
  40b9b0:	7dfb      	ldrb	r3, [r7, #23]
  40b9b2:	2b07      	cmp	r3, #7
  40b9b4:	d8f5      	bhi.n	40b9a2 <prvSingleStepTCPHeaderOptions+0x1d6>
				/* ucLen should be 0 by now. */
			}
		}
		#endif	/* ipconfigUSE_TCP_WIN == 1 */

		( *ppucPtr ) += ucLen;
  40b9b6:	68fb      	ldr	r3, [r7, #12]
  40b9b8:	681b      	ldr	r3, [r3, #0]
  40b9ba:	7dfa      	ldrb	r2, [r7, #23]
  40b9bc:	441a      	add	r2, r3
  40b9be:	68fb      	ldr	r3, [r7, #12]
  40b9c0:	601a      	str	r2, [r3, #0]
	}
	return pdTRUE;
  40b9c2:	2301      	movs	r3, #1
}
  40b9c4:	4618      	mov	r0, r3
  40b9c6:	3720      	adds	r7, #32
  40b9c8:	46bd      	mov	sp, r7
  40b9ca:	bd80      	pop	{r7, pc}
  40b9cc:	0040ab67 	.word	0x0040ab67
  40b9d0:	0041d2c4 	.word	0x0041d2c4
  40b9d4:	00416c7d 	.word	0x00416c7d
  40b9d8:	0041d2dc 	.word	0x0041d2dc
  40b9dc:	0040b9e1 	.word	0x0040b9e1

0040b9e0 <prvSkipPastRemainingOptions>:

/*-----------------------------------------------------------*/

static void prvSkipPastRemainingOptions( const unsigned char ** const ppucPtr, FreeRTOS_Socket_t ** const ppxSocket, unsigned char * const pucLen )
{
  40b9e0:	b590      	push	{r4, r7, lr}
  40b9e2:	b08b      	sub	sp, #44	; 0x2c
  40b9e4:	af02      	add	r7, sp, #8
  40b9e6:	60f8      	str	r0, [r7, #12]
  40b9e8:	60b9      	str	r1, [r7, #8]
  40b9ea:	607a      	str	r2, [r7, #4]
uint32_t ulFirst = ulChar2u32( ( *ppucPtr ) );
  40b9ec:	68fb      	ldr	r3, [r7, #12]
  40b9ee:	681b      	ldr	r3, [r3, #0]
  40b9f0:	4618      	mov	r0, r3
  40b9f2:	4b26      	ldr	r3, [pc, #152]	; (40ba8c <prvSkipPastRemainingOptions+0xac>)
  40b9f4:	4798      	blx	r3
  40b9f6:	61f8      	str	r0, [r7, #28]
uint32_t ulLast  = ulChar2u32( ( *ppucPtr ) + 4 );
  40b9f8:	68fb      	ldr	r3, [r7, #12]
  40b9fa:	681b      	ldr	r3, [r3, #0]
  40b9fc:	3304      	adds	r3, #4
  40b9fe:	4618      	mov	r0, r3
  40ba00:	4b22      	ldr	r3, [pc, #136]	; (40ba8c <prvSkipPastRemainingOptions+0xac>)
  40ba02:	4798      	blx	r3
  40ba04:	61b8      	str	r0, [r7, #24]
uint32_t ulCount = ulTCPWindowTxSack( &( *ppxSocket )->u.xTCP.xTCPWindow, ulFirst, ulLast );
  40ba06:	68bb      	ldr	r3, [r7, #8]
  40ba08:	681b      	ldr	r3, [r3, #0]
  40ba0a:	33d0      	adds	r3, #208	; 0xd0
  40ba0c:	69ba      	ldr	r2, [r7, #24]
  40ba0e:	69f9      	ldr	r1, [r7, #28]
  40ba10:	4618      	mov	r0, r3
  40ba12:	4b1f      	ldr	r3, [pc, #124]	; (40ba90 <prvSkipPastRemainingOptions+0xb0>)
  40ba14:	4798      	blx	r3
  40ba16:	6178      	str	r0, [r7, #20]
	/* ulTCPWindowTxSack( ) returns the number of bytes which have been acked
	 * starting from the head position.  Advance the tail pointer in txStream.
	 */
	if( ( ( *ppxSocket )->u.xTCP.txStream  != NULL ) && ( ulCount > 0 ) )
  40ba18:	68bb      	ldr	r3, [r7, #8]
  40ba1a:	681b      	ldr	r3, [r3, #0]
  40ba1c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  40ba1e:	2b00      	cmp	r3, #0
  40ba20:	d023      	beq.n	40ba6a <prvSkipPastRemainingOptions+0x8a>
  40ba22:	697b      	ldr	r3, [r7, #20]
  40ba24:	2b00      	cmp	r3, #0
  40ba26:	d020      	beq.n	40ba6a <prvSkipPastRemainingOptions+0x8a>
	{
		/* Just advancing the tail index, 'ulCount' bytes have been confirmed. */
		uxStreamBufferGet( ( *ppxSocket )->u.xTCP.txStream, 0, NULL, ( size_t ) ulCount, pdFALSE );
  40ba28:	68bb      	ldr	r3, [r7, #8]
  40ba2a:	681b      	ldr	r3, [r3, #0]
  40ba2c:	6f18      	ldr	r0, [r3, #112]	; 0x70
  40ba2e:	2300      	movs	r3, #0
  40ba30:	9300      	str	r3, [sp, #0]
  40ba32:	697b      	ldr	r3, [r7, #20]
  40ba34:	2200      	movs	r2, #0
  40ba36:	2100      	movs	r1, #0
  40ba38:	4c16      	ldr	r4, [pc, #88]	; (40ba94 <prvSkipPastRemainingOptions+0xb4>)
  40ba3a:	47a0      	blx	r4
		( *ppxSocket )->xEventBits |= eSOCKET_SEND;
  40ba3c:	68bb      	ldr	r3, [r7, #8]
  40ba3e:	681b      	ldr	r3, [r3, #0]
  40ba40:	68ba      	ldr	r2, [r7, #8]
  40ba42:	6812      	ldr	r2, [r2, #0]
  40ba44:	6812      	ldr	r2, [r2, #0]
  40ba46:	f042 0202 	orr.w	r2, r2, #2
  40ba4a:	601a      	str	r2, [r3, #0]

		#if ipconfigSUPPORT_SELECT_FUNCTION == 1
		{
			if( ( *ppxSocket )->xSelectBits & eSELECT_WRITE )
  40ba4c:	68bb      	ldr	r3, [r7, #8]
  40ba4e:	681b      	ldr	r3, [r3, #0]
  40ba50:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  40ba52:	f003 0302 	and.w	r3, r3, #2
  40ba56:	2b00      	cmp	r3, #0
  40ba58:	d007      	beq.n	40ba6a <prvSkipPastRemainingOptions+0x8a>
			{
				/* The field 'xEventBits' is used to store regular socket events
				 * (at most 8), as well as 'select events', which will be left-shifted.
				 */
				( *ppxSocket )->xEventBits |= ( eSELECT_WRITE << SOCKET_EVENT_BIT_COUNT );
  40ba5a:	68bb      	ldr	r3, [r7, #8]
  40ba5c:	681b      	ldr	r3, [r3, #0]
  40ba5e:	68ba      	ldr	r2, [r7, #8]
  40ba60:	6812      	ldr	r2, [r2, #0]
  40ba62:	6812      	ldr	r2, [r2, #0]
  40ba64:	f442 7200 	orr.w	r2, r2, #512	; 0x200
  40ba68:	601a      	str	r2, [r3, #0]
				( *ppxSocket )->u.xTCP.pxHandleSent( (Socket_t )( *ppxSocket ), ulCount );
			}
		}
		#endif /* ipconfigUSE_CALLBACKS == 1  */
	}
	( *ppucPtr ) += 8;
  40ba6a:	68fb      	ldr	r3, [r7, #12]
  40ba6c:	681b      	ldr	r3, [r3, #0]
  40ba6e:	f103 0208 	add.w	r2, r3, #8
  40ba72:	68fb      	ldr	r3, [r7, #12]
  40ba74:	601a      	str	r2, [r3, #0]
	( *pucLen ) -= 8;
  40ba76:	687b      	ldr	r3, [r7, #4]
  40ba78:	781b      	ldrb	r3, [r3, #0]
  40ba7a:	3b08      	subs	r3, #8
  40ba7c:	b2da      	uxtb	r2, r3
  40ba7e:	687b      	ldr	r3, [r7, #4]
  40ba80:	701a      	strb	r2, [r3, #0]
}
  40ba82:	bf00      	nop
  40ba84:	3724      	adds	r7, #36	; 0x24
  40ba86:	46bd      	mov	sp, r7
  40ba88:	bd90      	pop	{r4, r7, pc}
  40ba8a:	bf00      	nop
  40ba8c:	0040ab31 	.word	0x0040ab31
  40ba90:	0040ed59 	.word	0x0040ed59
  40ba94:	0040a88d 	.word	0x0040a88d

0040ba98 <prvWinScaleFactor>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN != 0 )

	static uint8_t prvWinScaleFactor( FreeRTOS_Socket_t *pxSocket )
	{
  40ba98:	b590      	push	{r4, r7, lr}
  40ba9a:	b085      	sub	sp, #20
  40ba9c:	af00      	add	r7, sp, #0
  40ba9e:	6078      	str	r0, [r7, #4]
	size_t uxWinSize;
	uint8_t ucFactor;

		/* 'xTCP.uxRxWinSize' is the size of the reception window in units of MSS. */
		uxWinSize = pxSocket->u.xTCP.uxRxWinSize * ( size_t ) pxSocket->u.xTCP.usInitMSS;
  40baa0:	687b      	ldr	r3, [r7, #4]
  40baa2:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
  40baa6:	687a      	ldr	r2, [r7, #4]
  40baa8:	f8b2 204c 	ldrh.w	r2, [r2, #76]	; 0x4c
  40baac:	fb02 f303 	mul.w	r3, r2, r3
  40bab0:	60fb      	str	r3, [r7, #12]
		ucFactor = 0u;
  40bab2:	2300      	movs	r3, #0
  40bab4:	72fb      	strb	r3, [r7, #11]
		while( uxWinSize > 0xfffful )
  40bab6:	e005      	b.n	40bac4 <prvWinScaleFactor+0x2c>
		{
			/* Divide by two and increase the binary factor by 1. */
			uxWinSize >>= 1;
  40bab8:	68fb      	ldr	r3, [r7, #12]
  40baba:	085b      	lsrs	r3, r3, #1
  40babc:	60fb      	str	r3, [r7, #12]
			ucFactor++;
  40babe:	7afb      	ldrb	r3, [r7, #11]
  40bac0:	3301      	adds	r3, #1
  40bac2:	72fb      	strb	r3, [r7, #11]
		while( uxWinSize > 0xfffful )
  40bac4:	68fb      	ldr	r3, [r7, #12]
  40bac6:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
  40baca:	d2f5      	bcs.n	40bab8 <prvWinScaleFactor+0x20>
		}

		FreeRTOS_debug_printf( ( "prvWinScaleFactor: uxRxWinSize %lu MSS %lu Factor %u\n",
  40bacc:	687b      	ldr	r3, [r7, #4]
  40bace:	f8d3 10c8 	ldr.w	r1, [r3, #200]	; 0xc8
  40bad2:	687b      	ldr	r3, [r7, #4]
  40bad4:	f8b3 304c 	ldrh.w	r3, [r3, #76]	; 0x4c
  40bad8:	461a      	mov	r2, r3
  40bada:	7afb      	ldrb	r3, [r7, #11]
  40badc:	4803      	ldr	r0, [pc, #12]	; (40baec <prvWinScaleFactor+0x54>)
  40bade:	4c04      	ldr	r4, [pc, #16]	; (40baf0 <prvWinScaleFactor+0x58>)
  40bae0:	47a0      	blx	r4
			pxSocket->u.xTCP.uxRxWinSize,
			pxSocket->u.xTCP.usInitMSS,
			ucFactor ) );

		return ucFactor;
  40bae2:	7afb      	ldrb	r3, [r7, #11]
	}
  40bae4:	4618      	mov	r0, r3
  40bae6:	3714      	adds	r7, #20
  40bae8:	46bd      	mov	sp, r7
  40baea:	bd90      	pop	{r4, r7, pc}
  40baec:	0041d2f4 	.word	0x0041d2f4
  40baf0:	00416c7d 	.word	0x00416c7d

0040baf4 <prvSetSynAckOptions>:
 * When opening a TCP connection, while SYN's are being sent, the  parties may
 * communicate what MSS (Maximum Segment Size) they intend to use.   MSS is the
 * nett size of the payload, always smaller than MTU.
*/
static UBaseType_t prvSetSynAckOptions( FreeRTOS_Socket_t *pxSocket, TCPPacket_t * pxTCPPacket )
{
  40baf4:	b580      	push	{r7, lr}
  40baf6:	b086      	sub	sp, #24
  40baf8:	af00      	add	r7, sp, #0
  40bafa:	6078      	str	r0, [r7, #4]
  40bafc:	6039      	str	r1, [r7, #0]
TCPHeader_t *pxTCPHeader = &pxTCPPacket->xTCPHeader;
  40bafe:	683b      	ldr	r3, [r7, #0]
  40bb00:	3322      	adds	r3, #34	; 0x22
  40bb02:	617b      	str	r3, [r7, #20]
uint16_t usMSS = pxSocket->u.xTCP.usInitMSS;
  40bb04:	687b      	ldr	r3, [r7, #4]
  40bb06:	f8b3 304c 	ldrh.w	r3, [r3, #76]	; 0x4c
  40bb0a:	827b      	strh	r3, [r7, #18]
UBaseType_t uxOptionsLength;

	/* We send out the TCP Maximum Segment Size option with our SYN[+ACK]. */

	pxTCPHeader->ucOptdata[ 0 ] = ( uint8_t ) TCP_OPT_MSS;
  40bb0c:	697b      	ldr	r3, [r7, #20]
  40bb0e:	2202      	movs	r2, #2
  40bb10:	751a      	strb	r2, [r3, #20]
	pxTCPHeader->ucOptdata[ 1 ] = ( uint8_t ) TCP_OPT_MSS_LEN;
  40bb12:	697b      	ldr	r3, [r7, #20]
  40bb14:	2204      	movs	r2, #4
  40bb16:	755a      	strb	r2, [r3, #21]
	pxTCPHeader->ucOptdata[ 2 ] = ( uint8_t ) ( usMSS >> 8 );
  40bb18:	8a7b      	ldrh	r3, [r7, #18]
  40bb1a:	0a1b      	lsrs	r3, r3, #8
  40bb1c:	b29b      	uxth	r3, r3
  40bb1e:	b2da      	uxtb	r2, r3
  40bb20:	697b      	ldr	r3, [r7, #20]
  40bb22:	759a      	strb	r2, [r3, #22]
	pxTCPHeader->ucOptdata[ 3 ] = ( uint8_t ) ( usMSS & 0xffu );
  40bb24:	8a7b      	ldrh	r3, [r7, #18]
  40bb26:	b2da      	uxtb	r2, r3
  40bb28:	697b      	ldr	r3, [r7, #20]
  40bb2a:	75da      	strb	r2, [r3, #23]

	#if( ipconfigUSE_TCP_WIN != 0 )
	{
		pxSocket->u.xTCP.ucMyWinScaleFactor = prvWinScaleFactor( pxSocket );
  40bb2c:	6878      	ldr	r0, [r7, #4]
  40bb2e:	4b1b      	ldr	r3, [pc, #108]	; (40bb9c <prvSetSynAckOptions+0xa8>)
  40bb30:	4798      	blx	r3
  40bb32:	4603      	mov	r3, r0
  40bb34:	461a      	mov	r2, r3
  40bb36:	687b      	ldr	r3, [r7, #4]
  40bb38:	f883 20c1 	strb.w	r2, [r3, #193]	; 0xc1

		pxTCPHeader->ucOptdata[ 4 ] = TCP_OPT_NOOP;
  40bb3c:	697b      	ldr	r3, [r7, #20]
  40bb3e:	2201      	movs	r2, #1
  40bb40:	761a      	strb	r2, [r3, #24]
		pxTCPHeader->ucOptdata[ 5 ] = ( uint8_t ) ( TCP_OPT_WSOPT );
  40bb42:	697b      	ldr	r3, [r7, #20]
  40bb44:	2203      	movs	r2, #3
  40bb46:	765a      	strb	r2, [r3, #25]
		pxTCPHeader->ucOptdata[ 6 ] = ( uint8_t ) ( TCP_OPT_WSOPT_LEN );
  40bb48:	697b      	ldr	r3, [r7, #20]
  40bb4a:	2203      	movs	r2, #3
  40bb4c:	769a      	strb	r2, [r3, #26]
		pxTCPHeader->ucOptdata[ 7 ] = ( uint8_t ) pxSocket->u.xTCP.ucMyWinScaleFactor;
  40bb4e:	687b      	ldr	r3, [r7, #4]
  40bb50:	f893 20c1 	ldrb.w	r2, [r3, #193]	; 0xc1
  40bb54:	697b      	ldr	r3, [r7, #20]
  40bb56:	76da      	strb	r2, [r3, #27]
		uxOptionsLength = 8u;
  40bb58:	2308      	movs	r3, #8
  40bb5a:	60fb      	str	r3, [r7, #12]
	{
		return uxOptionsLength;
	}
	#else
	{
		pxTCPHeader->ucOptdata[ uxOptionsLength + 0 ] = TCP_OPT_NOOP;
  40bb5c:	697a      	ldr	r2, [r7, #20]
  40bb5e:	68fb      	ldr	r3, [r7, #12]
  40bb60:	4413      	add	r3, r2
  40bb62:	3314      	adds	r3, #20
  40bb64:	2201      	movs	r2, #1
  40bb66:	701a      	strb	r2, [r3, #0]
		pxTCPHeader->ucOptdata[ uxOptionsLength + 1 ] = TCP_OPT_NOOP;
  40bb68:	68fb      	ldr	r3, [r7, #12]
  40bb6a:	3301      	adds	r3, #1
  40bb6c:	697a      	ldr	r2, [r7, #20]
  40bb6e:	4413      	add	r3, r2
  40bb70:	2201      	movs	r2, #1
  40bb72:	751a      	strb	r2, [r3, #20]
		pxTCPHeader->ucOptdata[ uxOptionsLength + 2 ] = TCP_OPT_SACK_P;	/* 4: Sack-Permitted Option. */
  40bb74:	68fb      	ldr	r3, [r7, #12]
  40bb76:	3302      	adds	r3, #2
  40bb78:	697a      	ldr	r2, [r7, #20]
  40bb7a:	4413      	add	r3, r2
  40bb7c:	2204      	movs	r2, #4
  40bb7e:	751a      	strb	r2, [r3, #20]
		pxTCPHeader->ucOptdata[ uxOptionsLength + 3 ] = 2;	/* 2: length of this option. */
  40bb80:	68fb      	ldr	r3, [r7, #12]
  40bb82:	3303      	adds	r3, #3
  40bb84:	697a      	ldr	r2, [r7, #20]
  40bb86:	4413      	add	r3, r2
  40bb88:	2202      	movs	r2, #2
  40bb8a:	751a      	strb	r2, [r3, #20]
		uxOptionsLength += 4u;
  40bb8c:	68fb      	ldr	r3, [r7, #12]
  40bb8e:	3304      	adds	r3, #4
  40bb90:	60fb      	str	r3, [r7, #12]

		return uxOptionsLength; /* bytes, not words. */
  40bb92:	68fb      	ldr	r3, [r7, #12]
	}
	#endif	/* ipconfigUSE_TCP_WIN == 0 */
}
  40bb94:	4618      	mov	r0, r3
  40bb96:	3718      	adds	r7, #24
  40bb98:	46bd      	mov	sp, r7
  40bb9a:	bd80      	pop	{r7, pc}
  40bb9c:	0040ba99 	.word	0x0040ba99

0040bba0 <prvTCPTouchSocket>:
 * For anti-hanging protection and TCP keep-alive messages.  Called in two
 * places: after receiving a packet and after a state change.  The socket's
 * alive timer may be reset.
 */
static void prvTCPTouchSocket( FreeRTOS_Socket_t *pxSocket )
{
  40bba0:	b580      	push	{r7, lr}
  40bba2:	b082      	sub	sp, #8
  40bba4:	af00      	add	r7, sp, #0
  40bba6:	6078      	str	r0, [r7, #4]
	#if( ipconfigTCP_HANG_PROTECTION == 1 )
	{
		pxSocket->u.xTCP.xLastActTime = xTaskGetTickCount( );
  40bba8:	4b04      	ldr	r3, [pc, #16]	; (40bbbc <prvTCPTouchSocket+0x1c>)
  40bbaa:	4798      	blx	r3
  40bbac:	4602      	mov	r2, r0
  40bbae:	687b      	ldr	r3, [r7, #4]
  40bbb0:	659a      	str	r2, [r3, #88]	; 0x58
		pxSocket->u.xTCP.xLastAliveTime = xTaskGetTickCount();
	}
	#endif

	( void ) pxSocket;
}
  40bbb2:	bf00      	nop
  40bbb4:	3708      	adds	r7, #8
  40bbb6:	46bd      	mov	sp, r7
  40bbb8:	bd80      	pop	{r7, pc}
  40bbba:	bf00      	nop
  40bbbc:	004127d1 	.word	0x004127d1

0040bbc0 <vTCPStateChange>:
 * resetting the alive timer, calling the user's OnConnect handler to notify
 * that a socket has got (dis)connected, and setting bit to unblock a call to
 * FreeRTOS_select()
 */
void vTCPStateChange( FreeRTOS_Socket_t *pxSocket, enum eTCP_STATE eTCPState )
{
  40bbc0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  40bbc4:	b088      	sub	sp, #32
  40bbc6:	af02      	add	r7, sp, #8
  40bbc8:	6078      	str	r0, [r7, #4]
  40bbca:	460b      	mov	r3, r1
  40bbcc:	70fb      	strb	r3, [r7, #3]
FreeRTOS_Socket_t *xParent = NULL;
  40bbce:	2300      	movs	r3, #0
  40bbd0:	617b      	str	r3, [r7, #20]
BaseType_t bBefore = ( BaseType_t ) NOW_CONNECTED( pxSocket->u.xTCP.ucTCPState );	/* Was it connected ? */
  40bbd2:	687b      	ldr	r3, [r7, #4]
  40bbd4:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
  40bbd8:	2b04      	cmp	r3, #4
  40bbda:	d906      	bls.n	40bbea <vTCPStateChange+0x2a>
  40bbdc:	687b      	ldr	r3, [r7, #4]
  40bbde:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
  40bbe2:	2b08      	cmp	r3, #8
  40bbe4:	d001      	beq.n	40bbea <vTCPStateChange+0x2a>
  40bbe6:	2301      	movs	r3, #1
  40bbe8:	e000      	b.n	40bbec <vTCPStateChange+0x2c>
  40bbea:	2300      	movs	r3, #0
  40bbec:	613b      	str	r3, [r7, #16]
BaseType_t bAfter  = ( BaseType_t ) NOW_CONNECTED( eTCPState );						/* Is it connected now ? */
  40bbee:	78fb      	ldrb	r3, [r7, #3]
  40bbf0:	2b04      	cmp	r3, #4
  40bbf2:	d904      	bls.n	40bbfe <vTCPStateChange+0x3e>
  40bbf4:	78fb      	ldrb	r3, [r7, #3]
  40bbf6:	2b08      	cmp	r3, #8
  40bbf8:	d001      	beq.n	40bbfe <vTCPStateChange+0x3e>
  40bbfa:	2301      	movs	r3, #1
  40bbfc:	e000      	b.n	40bc00 <vTCPStateChange+0x40>
  40bbfe:	2300      	movs	r3, #0
  40bc00:	60fb      	str	r3, [r7, #12]
#if( ipconfigHAS_DEBUG_PRINTF != 0 )
	BaseType_t xPreviousState = ( BaseType_t ) pxSocket->u.xTCP.ucTCPState;
  40bc02:	687b      	ldr	r3, [r7, #4]
  40bc04:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
  40bc08:	60bb      	str	r3, [r7, #8]
#if( ipconfigUSE_CALLBACKS == 1 )
	FreeRTOS_Socket_t *xConnected = NULL;
#endif

	/* Has the connected status changed? */
	if( bBefore != bAfter )
  40bc0a:	693a      	ldr	r2, [r7, #16]
  40bc0c:	68fb      	ldr	r3, [r7, #12]
  40bc0e:	429a      	cmp	r2, r3
  40bc10:	f000 8083 	beq.w	40bd1a <vTCPStateChange+0x15a>
	{
		/* Is the socket connected now ? */
		if( bAfter != pdFALSE )
  40bc14:	68fb      	ldr	r3, [r7, #12]
  40bc16:	2b00      	cmp	r3, #0
  40bc18:	d05f      	beq.n	40bcda <vTCPStateChange+0x11a>
		{
			/* if bPassQueued is true, this socket is an orphan until it gets connected. */
			if( pxSocket->u.xTCP.bits.bPassQueued != pdFALSE_UNSIGNED )
  40bc1a:	687b      	ldr	r3, [r7, #4]
  40bc1c:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
  40bc20:	f003 0304 	and.w	r3, r3, #4
  40bc24:	b2db      	uxtb	r3, r3
  40bc26:	2b00      	cmp	r3, #0
  40bc28:	d044      	beq.n	40bcb4 <vTCPStateChange+0xf4>
			{
				/* Now that it is connected, find it's parent. */
				if( pxSocket->u.xTCP.bits.bReuseSocket != pdFALSE_UNSIGNED )
  40bc2a:	687b      	ldr	r3, [r7, #4]
  40bc2c:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
  40bc30:	f003 0308 	and.w	r3, r3, #8
  40bc34:	b2db      	uxtb	r3, r3
  40bc36:	2b00      	cmp	r3, #0
  40bc38:	d002      	beq.n	40bc40 <vTCPStateChange+0x80>
				{
					xParent = pxSocket;
  40bc3a:	687b      	ldr	r3, [r7, #4]
  40bc3c:	617b      	str	r3, [r7, #20]
  40bc3e:	e00b      	b.n	40bc58 <vTCPStateChange+0x98>
				}
				else
				{
					xParent = pxSocket->u.xTCP.pxPeerSocket;
  40bc40:	687b      	ldr	r3, [r7, #4]
  40bc42:	6d5b      	ldr	r3, [r3, #84]	; 0x54
  40bc44:	617b      	str	r3, [r7, #20]
					configASSERT( xParent != NULL );
  40bc46:	697b      	ldr	r3, [r7, #20]
  40bc48:	2b00      	cmp	r3, #0
  40bc4a:	d105      	bne.n	40bc58 <vTCPStateChange+0x98>
  40bc4c:	f240 52f5 	movw	r2, #1525	; 0x5f5
  40bc50:	495f      	ldr	r1, [pc, #380]	; (40bdd0 <vTCPStateChange+0x210>)
  40bc52:	4860      	ldr	r0, [pc, #384]	; (40bdd4 <vTCPStateChange+0x214>)
  40bc54:	4b60      	ldr	r3, [pc, #384]	; (40bdd8 <vTCPStateChange+0x218>)
  40bc56:	4798      	blx	r3
				}
				if( xParent != NULL )
  40bc58:	697b      	ldr	r3, [r7, #20]
  40bc5a:	2b00      	cmp	r3, #0
  40bc5c:	d018      	beq.n	40bc90 <vTCPStateChange+0xd0>
				{
					if( xParent->u.xTCP.pxPeerSocket == NULL )
  40bc5e:	697b      	ldr	r3, [r7, #20]
  40bc60:	6d5b      	ldr	r3, [r3, #84]	; 0x54
  40bc62:	2b00      	cmp	r3, #0
  40bc64:	d102      	bne.n	40bc6c <vTCPStateChange+0xac>
					{
						xParent->u.xTCP.pxPeerSocket = pxSocket;
  40bc66:	697b      	ldr	r3, [r7, #20]
  40bc68:	687a      	ldr	r2, [r7, #4]
  40bc6a:	655a      	str	r2, [r3, #84]	; 0x54
					}

					xParent->xEventBits |= eSOCKET_ACCEPT;
  40bc6c:	697b      	ldr	r3, [r7, #20]
  40bc6e:	681b      	ldr	r3, [r3, #0]
  40bc70:	f043 0204 	orr.w	r2, r3, #4
  40bc74:	697b      	ldr	r3, [r7, #20]
  40bc76:	601a      	str	r2, [r3, #0]

					#if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
					{
						/* Library support FreeRTOS_select().  Receiving a new
						connection is being translated as a READ event. */
						if( ( xParent->xSelectBits & eSELECT_READ ) != 0 )
  40bc78:	697b      	ldr	r3, [r7, #20]
  40bc7a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  40bc7c:	f003 0301 	and.w	r3, r3, #1
  40bc80:	2b00      	cmp	r3, #0
  40bc82:	d005      	beq.n	40bc90 <vTCPStateChange+0xd0>
						{
							xParent->xEventBits |= ( eSELECT_READ << SOCKET_EVENT_BIT_COUNT );
  40bc84:	697b      	ldr	r3, [r7, #20]
  40bc86:	681b      	ldr	r3, [r3, #0]
  40bc88:	f443 7280 	orr.w	r2, r3, #256	; 0x100
  40bc8c:	697b      	ldr	r3, [r7, #20]
  40bc8e:	601a      	str	r2, [r3, #0]
					#endif
				}

				/* Don't need to access the parent socket anymore, so the
				reference 'pxPeerSocket' may be cleared. */
				pxSocket->u.xTCP.pxPeerSocket = NULL;
  40bc90:	687b      	ldr	r3, [r7, #4]
  40bc92:	2200      	movs	r2, #0
  40bc94:	655a      	str	r2, [r3, #84]	; 0x54
				pxSocket->u.xTCP.bits.bPassQueued = pdFALSE_UNSIGNED;
  40bc96:	687a      	ldr	r2, [r7, #4]
  40bc98:	f892 3040 	ldrb.w	r3, [r2, #64]	; 0x40
  40bc9c:	f36f 0382 	bfc	r3, #2, #1
  40bca0:	f882 3040 	strb.w	r3, [r2, #64]	; 0x40

				/* When true, this socket may be returned in a call to accept(). */
				pxSocket->u.xTCP.bits.bPassAccept = pdTRUE_UNSIGNED;
  40bca4:	687a      	ldr	r2, [r7, #4]
  40bca6:	f892 3040 	ldrb.w	r3, [r2, #64]	; 0x40
  40bcaa:	f043 0302 	orr.w	r3, r3, #2
  40bcae:	f882 3040 	strb.w	r3, [r2, #64]	; 0x40
  40bcb2:	e024      	b.n	40bcfe <vTCPStateChange+0x13e>
			}
			else
			{
				pxSocket->xEventBits |= eSOCKET_CONNECT;
  40bcb4:	687b      	ldr	r3, [r7, #4]
  40bcb6:	681b      	ldr	r3, [r3, #0]
  40bcb8:	f043 0208 	orr.w	r2, r3, #8
  40bcbc:	687b      	ldr	r3, [r7, #4]
  40bcbe:	601a      	str	r2, [r3, #0]

				#if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
				{
					if( pxSocket->xSelectBits & eSELECT_WRITE )
  40bcc0:	687b      	ldr	r3, [r7, #4]
  40bcc2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  40bcc4:	f003 0302 	and.w	r3, r3, #2
  40bcc8:	2b00      	cmp	r3, #0
  40bcca:	d018      	beq.n	40bcfe <vTCPStateChange+0x13e>
					{
						pxSocket->xEventBits |= ( eSELECT_WRITE << SOCKET_EVENT_BIT_COUNT );
  40bccc:	687b      	ldr	r3, [r7, #4]
  40bcce:	681b      	ldr	r3, [r3, #0]
  40bcd0:	f443 7200 	orr.w	r2, r3, #512	; 0x200
  40bcd4:	687b      	ldr	r3, [r7, #4]
  40bcd6:	601a      	str	r2, [r3, #0]
  40bcd8:	e011      	b.n	40bcfe <vTCPStateChange+0x13e>
			}
		}
		else  /* bAfter == pdFALSE, connection is closed. */
		{
			/* Notify/wake-up the socket-owner by setting a semaphore. */
			pxSocket->xEventBits |= eSOCKET_CLOSED;
  40bcda:	687b      	ldr	r3, [r7, #4]
  40bcdc:	681b      	ldr	r3, [r3, #0]
  40bcde:	f043 0220 	orr.w	r2, r3, #32
  40bce2:	687b      	ldr	r3, [r7, #4]
  40bce4:	601a      	str	r2, [r3, #0]

			#if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
			{
				if( ( pxSocket->xSelectBits & eSELECT_EXCEPT ) != 0 )
  40bce6:	687b      	ldr	r3, [r7, #4]
  40bce8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  40bcea:	f003 0304 	and.w	r3, r3, #4
  40bcee:	2b00      	cmp	r3, #0
  40bcf0:	d005      	beq.n	40bcfe <vTCPStateChange+0x13e>
				{
					pxSocket->xEventBits |= ( eSELECT_EXCEPT << SOCKET_EVENT_BIT_COUNT );
  40bcf2:	687b      	ldr	r3, [r7, #4]
  40bcf4:	681b      	ldr	r3, [r3, #0]
  40bcf6:	f443 6280 	orr.w	r2, r3, #1024	; 0x400
  40bcfa:	687b      	ldr	r3, [r7, #4]
  40bcfc:	601a      	str	r2, [r3, #0]
				xConnected = pxSocket;
			}
		}
		#endif /* ipconfigUSE_CALLBACKS */

		if( prvTCPSocketIsActive( ( UBaseType_t ) pxSocket->u.xTCP.ucTCPState ) == pdFALSE )
  40bcfe:	687b      	ldr	r3, [r7, #4]
  40bd00:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
  40bd04:	4618      	mov	r0, r3
  40bd06:	4b35      	ldr	r3, [pc, #212]	; (40bddc <vTCPStateChange+0x21c>)
  40bd08:	4798      	blx	r3
  40bd0a:	4603      	mov	r3, r0
  40bd0c:	2b00      	cmp	r3, #0
  40bd0e:	d125      	bne.n	40bd5c <vTCPStateChange+0x19c>
		{
			/* Now the socket isn't in an active state anymore so it
			won't need further attention of the IP-task.
			Setting time-out to zero means that the socket won't get checked during
			timer events. */
			pxSocket->u.xTCP.usTimeout = 0u;
  40bd10:	687b      	ldr	r3, [r7, #4]
  40bd12:	2200      	movs	r2, #0
  40bd14:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48
  40bd18:	e020      	b.n	40bd5c <vTCPStateChange+0x19c>
		}
	}
	else
	{
		if( eTCPState == eCLOSED )
  40bd1a:	78fb      	ldrb	r3, [r7, #3]
  40bd1c:	2b00      	cmp	r3, #0
  40bd1e:	d11d      	bne.n	40bd5c <vTCPStateChange+0x19c>
		{
			/* Socket goes to status eCLOSED because of a RST.
			When nobody owns the socket yet, delete it. */
			if( ( pxSocket->u.xTCP.bits.bPassQueued != pdFALSE_UNSIGNED ) ||
  40bd20:	687b      	ldr	r3, [r7, #4]
  40bd22:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
  40bd26:	f003 0304 	and.w	r3, r3, #4
  40bd2a:	b2db      	uxtb	r3, r3
  40bd2c:	2b00      	cmp	r3, #0
  40bd2e:	d107      	bne.n	40bd40 <vTCPStateChange+0x180>
				( pxSocket->u.xTCP.bits.bPassAccept != pdFALSE_UNSIGNED ) )
  40bd30:	687b      	ldr	r3, [r7, #4]
  40bd32:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
  40bd36:	f003 0302 	and.w	r3, r3, #2
  40bd3a:	b2db      	uxtb	r3, r3
			if( ( pxSocket->u.xTCP.bits.bPassQueued != pdFALSE_UNSIGNED ) ||
  40bd3c:	2b00      	cmp	r3, #0
  40bd3e:	d00d      	beq.n	40bd5c <vTCPStateChange+0x19c>
			{
				FreeRTOS_debug_printf( ( "vTCPStateChange: Closing socket\n" ) );
  40bd40:	4827      	ldr	r0, [pc, #156]	; (40bde0 <vTCPStateChange+0x220>)
  40bd42:	4b25      	ldr	r3, [pc, #148]	; (40bdd8 <vTCPStateChange+0x218>)
  40bd44:	4798      	blx	r3
				if( pxSocket->u.xTCP.bits.bReuseSocket == pdFALSE_UNSIGNED )
  40bd46:	687b      	ldr	r3, [r7, #4]
  40bd48:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
  40bd4c:	f003 0308 	and.w	r3, r3, #8
  40bd50:	b2db      	uxtb	r3, r3
  40bd52:	2b00      	cmp	r3, #0
  40bd54:	d102      	bne.n	40bd5c <vTCPStateChange+0x19c>
				{
					FreeRTOS_closesocket( pxSocket );
  40bd56:	6878      	ldr	r0, [r7, #4]
  40bd58:	4b22      	ldr	r3, [pc, #136]	; (40bde4 <vTCPStateChange+0x224>)
  40bd5a:	4798      	blx	r3
			}
		}
	}

	/* Fill in the new state. */
	pxSocket->u.xTCP.ucTCPState = ( uint8_t ) eTCPState;
  40bd5c:	687b      	ldr	r3, [r7, #4]
  40bd5e:	78fa      	ldrb	r2, [r7, #3]
  40bd60:	f883 2053 	strb.w	r2, [r3, #83]	; 0x53

	/* touch the alive timers because moving to another state. */
	prvTCPTouchSocket( pxSocket );
  40bd64:	6878      	ldr	r0, [r7, #4]
  40bd66:	4b20      	ldr	r3, [pc, #128]	; (40bde8 <vTCPStateChange+0x228>)
  40bd68:	4798      	blx	r3

	#if( ipconfigHAS_DEBUG_PRINTF == 1 )
	{
	if( ( xTCPWindowLoggingLevel >= 0 ) && ( ipconfigTCP_MAY_LOG_PORT( pxSocket->usLocalPort ) != pdFALSE ) )
  40bd6a:	4b20      	ldr	r3, [pc, #128]	; (40bdec <vTCPStateChange+0x22c>)
  40bd6c:	681b      	ldr	r3, [r3, #0]
  40bd6e:	2b00      	cmp	r3, #0
  40bd70:	db22      	blt.n	40bdb8 <vTCPStateChange+0x1f8>
  40bd72:	687b      	ldr	r3, [r7, #4]
  40bd74:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
  40bd76:	2b17      	cmp	r3, #23
  40bd78:	d001      	beq.n	40bd7e <vTCPStateChange+0x1be>
  40bd7a:	2301      	movs	r3, #1
  40bd7c:	e000      	b.n	40bd80 <vTCPStateChange+0x1c0>
  40bd7e:	2300      	movs	r3, #0
  40bd80:	2b00      	cmp	r3, #0
  40bd82:	d019      	beq.n	40bdb8 <vTCPStateChange+0x1f8>
		FreeRTOS_debug_printf( ( "Socket %d -> %lxip:%u State %s->%s\n",
  40bd84:	687b      	ldr	r3, [r7, #4]
  40bd86:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
  40bd88:	461e      	mov	r6, r3
  40bd8a:	687b      	ldr	r3, [r7, #4]
  40bd8c:	6b9c      	ldr	r4, [r3, #56]	; 0x38
  40bd8e:	687b      	ldr	r3, [r7, #4]
  40bd90:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
  40bd92:	4698      	mov	r8, r3
  40bd94:	68bb      	ldr	r3, [r7, #8]
  40bd96:	4618      	mov	r0, r3
  40bd98:	4b15      	ldr	r3, [pc, #84]	; (40bdf0 <vTCPStateChange+0x230>)
  40bd9a:	4798      	blx	r3
  40bd9c:	4605      	mov	r5, r0
  40bd9e:	78fb      	ldrb	r3, [r7, #3]
  40bda0:	4618      	mov	r0, r3
  40bda2:	4b13      	ldr	r3, [pc, #76]	; (40bdf0 <vTCPStateChange+0x230>)
  40bda4:	4798      	blx	r3
  40bda6:	4603      	mov	r3, r0
  40bda8:	9301      	str	r3, [sp, #4]
  40bdaa:	9500      	str	r5, [sp, #0]
  40bdac:	4643      	mov	r3, r8
  40bdae:	4622      	mov	r2, r4
  40bdb0:	4631      	mov	r1, r6
  40bdb2:	4810      	ldr	r0, [pc, #64]	; (40bdf4 <vTCPStateChange+0x234>)
  40bdb4:	4c08      	ldr	r4, [pc, #32]	; (40bdd8 <vTCPStateChange+0x218>)
  40bdb6:	47a0      	blx	r4
			/* The 'connected' state has changed, call the OnConnect handler of the parent. */
			xConnected->u.xTCP.pxHandleConnected( ( Socket_t ) xConnected, bAfter );
		}
	}
	#endif
	if( xParent != NULL )
  40bdb8:	697b      	ldr	r3, [r7, #20]
  40bdba:	2b00      	cmp	r3, #0
  40bdbc:	d002      	beq.n	40bdc4 <vTCPStateChange+0x204>
	{
		vSocketWakeUpUser( xParent );
  40bdbe:	6978      	ldr	r0, [r7, #20]
  40bdc0:	4b0d      	ldr	r3, [pc, #52]	; (40bdf8 <vTCPStateChange+0x238>)
  40bdc2:	4798      	blx	r3
	}
}
  40bdc4:	bf00      	nop
  40bdc6:	3718      	adds	r7, #24
  40bdc8:	46bd      	mov	sp, r7
  40bdca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40bdce:	bf00      	nop
  40bdd0:	0041d32c 	.word	0x0041d32c
  40bdd4:	0041d384 	.word	0x0041d384
  40bdd8:	00416c7d 	.word	0x00416c7d
  40bddc:	0040abb9 	.word	0x0040abb9
  40bde0:	0041d394 	.word	0x0041d394
  40bde4:	00409189 	.word	0x00409189
  40bde8:	0040bba1 	.word	0x0040bba1
  40bdec:	20006d60 	.word	0x20006d60
  40bdf0:	0040d8b5 	.word	0x0040d8b5
  40bdf4:	0041d3b8 	.word	0x0041d3b8
  40bdf8:	00409611 	.word	0x00409611

0040bdfc <prvTCPBufferResize>:
/*-----------------------------------------------------------*/

static NetworkBufferDescriptor_t *prvTCPBufferResize( FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t *pxNetworkBuffer,
	int32_t lDataLen, UBaseType_t uxOptionsLength )
{
  40bdfc:	b580      	push	{r7, lr}
  40bdfe:	b088      	sub	sp, #32
  40be00:	af00      	add	r7, sp, #0
  40be02:	60f8      	str	r0, [r7, #12]
  40be04:	60b9      	str	r1, [r7, #8]
  40be06:	607a      	str	r2, [r7, #4]
  40be08:	603b      	str	r3, [r7, #0]
NetworkBufferDescriptor_t *pxReturn;
int32_t lNeeded;
BaseType_t xResize;

	if( xBufferAllocFixedSize != pdFALSE )
  40be0a:	4b2d      	ldr	r3, [pc, #180]	; (40bec0 <prvTCPBufferResize+0xc4>)
  40be0c:	681b      	ldr	r3, [r3, #0]
  40be0e:	2b00      	cmp	r3, #0
  40be10:	d00a      	beq.n	40be28 <prvTCPBufferResize+0x2c>
	{
		/* Network buffers are created with a fixed size and can hold the largest
		MTU. */
		lNeeded = ( int32_t ) ipTOTAL_ETHERNET_FRAME_SIZE;
  40be12:	f240 538e 	movw	r3, #1422	; 0x58e
  40be16:	61bb      	str	r3, [r7, #24]
		/* and therefore, the buffer won't be too small.
		Only ask for a new network buffer in case none was supplied. */
		xResize = ( pxNetworkBuffer == NULL );
  40be18:	68bb      	ldr	r3, [r7, #8]
  40be1a:	2b00      	cmp	r3, #0
  40be1c:	bf0c      	ite	eq
  40be1e:	2301      	moveq	r3, #1
  40be20:	2300      	movne	r3, #0
  40be22:	b2db      	uxtb	r3, r3
  40be24:	617b      	str	r3, [r7, #20]
  40be26:	e014      	b.n	40be52 <prvTCPBufferResize+0x56>
	else
	{
		/* Network buffers are created with a variable size. See if it must
		grow. */
		lNeeded = FreeRTOS_max_int32( ( int32_t ) sizeof( pxSocket->u.xTCP.xPacket.u.ucLastPacket ),
			( int32_t ) ( ipSIZE_OF_ETH_HEADER + ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER + uxOptionsLength ) + lDataLen );
  40be28:	687a      	ldr	r2, [r7, #4]
  40be2a:	683b      	ldr	r3, [r7, #0]
  40be2c:	4413      	add	r3, r2
  40be2e:	3336      	adds	r3, #54	; 0x36
		lNeeded = FreeRTOS_max_int32( ( int32_t ) sizeof( pxSocket->u.xTCP.xPacket.u.ucLastPacket ),
  40be30:	4619      	mov	r1, r3
  40be32:	2046      	movs	r0, #70	; 0x46
  40be34:	4b23      	ldr	r3, [pc, #140]	; (40bec4 <prvTCPBufferResize+0xc8>)
  40be36:	4798      	blx	r3
  40be38:	61b8      	str	r0, [r7, #24]
		/* In case we were called from a TCP timer event, a buffer must be
		created.  Otherwise, test 'xDataLength' of the provided buffer. */
		xResize = ( pxNetworkBuffer == NULL ) || ( pxNetworkBuffer->xDataLength < (size_t)lNeeded );
  40be3a:	68bb      	ldr	r3, [r7, #8]
  40be3c:	2b00      	cmp	r3, #0
  40be3e:	d004      	beq.n	40be4a <prvTCPBufferResize+0x4e>
  40be40:	68bb      	ldr	r3, [r7, #8]
  40be42:	69da      	ldr	r2, [r3, #28]
  40be44:	69bb      	ldr	r3, [r7, #24]
  40be46:	429a      	cmp	r2, r3
  40be48:	d201      	bcs.n	40be4e <prvTCPBufferResize+0x52>
  40be4a:	2301      	movs	r3, #1
  40be4c:	e000      	b.n	40be50 <prvTCPBufferResize+0x54>
  40be4e:	2300      	movs	r3, #0
  40be50:	617b      	str	r3, [r7, #20]
	}

	if( xResize != pdFALSE )
  40be52:	697b      	ldr	r3, [r7, #20]
  40be54:	2b00      	cmp	r3, #0
  40be56:	d024      	beq.n	40bea2 <prvTCPBufferResize+0xa6>
	{
		/* The caller didn't provide a network buffer or the provided buffer is
		too small.  As we must send-out a data packet, a buffer will be created
		here. */

		pxReturn = pxGetNetworkBufferWithDescriptor( ( uint32_t ) lNeeded, 0u );
  40be58:	69bb      	ldr	r3, [r7, #24]
  40be5a:	2100      	movs	r1, #0
  40be5c:	4618      	mov	r0, r3
  40be5e:	4b1a      	ldr	r3, [pc, #104]	; (40bec8 <prvTCPBufferResize+0xcc>)
  40be60:	4798      	blx	r3
  40be62:	61f8      	str	r0, [r7, #28]

		if( pxReturn != NULL )
  40be64:	69fb      	ldr	r3, [r7, #28]
  40be66:	2b00      	cmp	r3, #0
  40be68:	d024      	beq.n	40beb4 <prvTCPBufferResize+0xb8>
		{
			/* Set the actual packet size, in case the returned buffer is larger. */
			pxReturn->xDataLength = lNeeded;
  40be6a:	69ba      	ldr	r2, [r7, #24]
  40be6c:	69fb      	ldr	r3, [r7, #28]
  40be6e:	61da      	str	r2, [r3, #28]

			/* Copy the existing data to the new created buffer. */
			if( pxNetworkBuffer )
  40be70:	68bb      	ldr	r3, [r7, #8]
  40be72:	2b00      	cmp	r3, #0
  40be74:	d00c      	beq.n	40be90 <prvTCPBufferResize+0x94>
			{
				/* Either from the previous buffer... */
				memcpy( pxReturn->pucEthernetBuffer, pxNetworkBuffer->pucEthernetBuffer, pxNetworkBuffer->xDataLength );
  40be76:	69fb      	ldr	r3, [r7, #28]
  40be78:	6998      	ldr	r0, [r3, #24]
  40be7a:	68bb      	ldr	r3, [r7, #8]
  40be7c:	6999      	ldr	r1, [r3, #24]
  40be7e:	68bb      	ldr	r3, [r7, #8]
  40be80:	69db      	ldr	r3, [r3, #28]
  40be82:	461a      	mov	r2, r3
  40be84:	4b11      	ldr	r3, [pc, #68]	; (40becc <prvTCPBufferResize+0xd0>)
  40be86:	4798      	blx	r3

				/* ...and release it. */
				vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
  40be88:	68b8      	ldr	r0, [r7, #8]
  40be8a:	4b11      	ldr	r3, [pc, #68]	; (40bed0 <prvTCPBufferResize+0xd4>)
  40be8c:	4798      	blx	r3
  40be8e:	e011      	b.n	40beb4 <prvTCPBufferResize+0xb8>
			}
			else
			{
				/* Or from the socket field 'xTCP.xPacket'. */
				memcpy( pxReturn->pucEthernetBuffer, pxSocket->u.xTCP.xPacket.u.ucLastPacket, sizeof( pxSocket->u.xTCP.xPacket.u.ucLastPacket ) );
  40be90:	69fb      	ldr	r3, [r7, #28]
  40be92:	6998      	ldr	r0, [r3, #24]
  40be94:	68fb      	ldr	r3, [r7, #12]
  40be96:	337a      	adds	r3, #122	; 0x7a
  40be98:	2246      	movs	r2, #70	; 0x46
  40be9a:	4619      	mov	r1, r3
  40be9c:	4b0b      	ldr	r3, [pc, #44]	; (40becc <prvTCPBufferResize+0xd0>)
  40be9e:	4798      	blx	r3
  40bea0:	e008      	b.n	40beb4 <prvTCPBufferResize+0xb8>
		}
	}
	else
	{
		/* xResize is false, the network buffer provided was big enough. */
		pxReturn = pxNetworkBuffer;
  40bea2:	68bb      	ldr	r3, [r7, #8]
  40bea4:	61fb      	str	r3, [r7, #28]

		/* Thanks to Andrey Ivanov from swissEmbedded for reporting that the
		xDataLength member must get the correct length too! */
		pxNetworkBuffer->xDataLength = ( size_t ) ( ipSIZE_OF_ETH_HEADER + ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER + uxOptionsLength ) + ( size_t ) lDataLen;
  40bea6:	687a      	ldr	r2, [r7, #4]
  40bea8:	683b      	ldr	r3, [r7, #0]
  40beaa:	4413      	add	r3, r2
  40beac:	f103 0236 	add.w	r2, r3, #54	; 0x36
  40beb0:	68bb      	ldr	r3, [r7, #8]
  40beb2:	61da      	str	r2, [r3, #28]
	}

	return pxReturn;
  40beb4:	69fb      	ldr	r3, [r7, #28]
}
  40beb6:	4618      	mov	r0, r3
  40beb8:	3720      	adds	r7, #32
  40beba:	46bd      	mov	sp, r7
  40bebc:	bd80      	pop	{r7, pc}
  40bebe:	bf00      	nop
  40bec0:	0041dea0 	.word	0x0041dea0
  40bec4:	0040a981 	.word	0x0040a981
  40bec8:	0040f1d5 	.word	0x0040f1d5
  40becc:	00416d05 	.word	0x00416d05
  40bed0:	0040f2ed 	.word	0x0040f2ed

0040bed4 <prvTCPPrepareSend>:

/*
 * Prepare an outgoing message, in case anything has to be sent.
 */
static int32_t prvTCPPrepareSend( FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t **ppxNetworkBuffer, UBaseType_t uxOptionsLength )
{
  40bed4:	b590      	push	{r4, r7, lr}
  40bed6:	b095      	sub	sp, #84	; 0x54
  40bed8:	af02      	add	r7, sp, #8
  40beda:	60f8      	str	r0, [r7, #12]
  40bedc:	60b9      	str	r1, [r7, #8]
  40bede:	607a      	str	r2, [r7, #4]
uint32_t ulDataGot, ulDistance;
TCPWindow_t *pxTCPWindow;
NetworkBufferDescriptor_t *pxNewBuffer;
int32_t lStreamPos;

	if( ( *ppxNetworkBuffer ) != NULL )
  40bee0:	68bb      	ldr	r3, [r7, #8]
  40bee2:	681b      	ldr	r3, [r3, #0]
  40bee4:	2b00      	cmp	r3, #0
  40bee6:	d004      	beq.n	40bef2 <prvTCPPrepareSend+0x1e>
	{
		/* A network buffer descriptor was already supplied */
		pucEthernetBuffer = ( *ppxNetworkBuffer )->pucEthernetBuffer;
  40bee8:	68bb      	ldr	r3, [r7, #8]
  40beea:	681b      	ldr	r3, [r3, #0]
  40beec:	699b      	ldr	r3, [r3, #24]
  40beee:	643b      	str	r3, [r7, #64]	; 0x40
  40bef0:	e002      	b.n	40bef8 <prvTCPPrepareSend+0x24>
	}
	else
	{
		/* For now let it point to the last packet header */
		pucEthernetBuffer = pxSocket->u.xTCP.xPacket.u.ucLastPacket;
  40bef2:	68fb      	ldr	r3, [r7, #12]
  40bef4:	337a      	adds	r3, #122	; 0x7a
  40bef6:	643b      	str	r3, [r7, #64]	; 0x40
	}

	pxTCPPacket = ( TCPPacket_t * ) ( pucEthernetBuffer );
  40bef8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  40befa:	63fb      	str	r3, [r7, #60]	; 0x3c
	pxTCPWindow = &pxSocket->u.xTCP.xTCPWindow;
  40befc:	68fb      	ldr	r3, [r7, #12]
  40befe:	33d0      	adds	r3, #208	; 0xd0
  40bf00:	63bb      	str	r3, [r7, #56]	; 0x38
	lDataLen = 0;
  40bf02:	2300      	movs	r3, #0
  40bf04:	647b      	str	r3, [r7, #68]	; 0x44
	lStreamPos = 0;
  40bf06:	2300      	movs	r3, #0
  40bf08:	617b      	str	r3, [r7, #20]
	pxTCPPacket->xTCPHeader.ucTCPFlags |= ipTCP_FLAG_ACK;
  40bf0a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  40bf0c:	f893 302f 	ldrb.w	r3, [r3, #47]	; 0x2f
  40bf10:	f043 0310 	orr.w	r3, r3, #16
  40bf14:	b2da      	uxtb	r2, r3
  40bf16:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  40bf18:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f

	if( pxSocket->u.xTCP.txStream != NULL )
  40bf1c:	68fb      	ldr	r3, [r7, #12]
  40bf1e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  40bf20:	2b00      	cmp	r3, #0
  40bf22:	f000 809c 	beq.w	40c05e <prvTCPPrepareSend+0x18a>
	{
		/* ulTCPWindowTxGet will return the amount of data which may be sent
		along with the position in the txStream.
		Why check for MSS > 1 ?
		Because some TCP-stacks (like uIP) use it for flow-control. */
		if( pxSocket->u.xTCP.usCurMSS > 1u )
  40bf26:	68fb      	ldr	r3, [r7, #12]
  40bf28:	f8b3 304a 	ldrh.w	r3, [r3, #74]	; 0x4a
  40bf2c:	2b01      	cmp	r3, #1
  40bf2e:	d90a      	bls.n	40bf46 <prvTCPPrepareSend+0x72>
		{
			lDataLen = ( int32_t ) ulTCPWindowTxGet( pxTCPWindow, pxSocket->u.xTCP.ulWindowSize, &lStreamPos );
  40bf30:	68fb      	ldr	r3, [r7, #12]
  40bf32:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
  40bf36:	f107 0214 	add.w	r2, r7, #20
  40bf3a:	4619      	mov	r1, r3
  40bf3c:	6bb8      	ldr	r0, [r7, #56]	; 0x38
  40bf3e:	4b88      	ldr	r3, [pc, #544]	; (40c160 <prvTCPPrepareSend+0x28c>)
  40bf40:	4798      	blx	r3
  40bf42:	4603      	mov	r3, r0
  40bf44:	647b      	str	r3, [r7, #68]	; 0x44
		}

		if( lDataLen > 0 )
  40bf46:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  40bf48:	2b00      	cmp	r3, #0
  40bf4a:	f340 8088 	ble.w	40c05e <prvTCPPrepareSend+0x18a>
		{
			/* Check if the current network buffer is big enough, if not,
			resize it. */
			pxNewBuffer = prvTCPBufferResize( pxSocket, *ppxNetworkBuffer, lDataLen, uxOptionsLength );
  40bf4e:	68bb      	ldr	r3, [r7, #8]
  40bf50:	6819      	ldr	r1, [r3, #0]
  40bf52:	687b      	ldr	r3, [r7, #4]
  40bf54:	6c7a      	ldr	r2, [r7, #68]	; 0x44
  40bf56:	68f8      	ldr	r0, [r7, #12]
  40bf58:	4c82      	ldr	r4, [pc, #520]	; (40c164 <prvTCPPrepareSend+0x290>)
  40bf5a:	47a0      	blx	r4
  40bf5c:	6378      	str	r0, [r7, #52]	; 0x34

			if( pxNewBuffer != NULL )
  40bf5e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40bf60:	2b00      	cmp	r3, #0
  40bf62:	d079      	beq.n	40c058 <prvTCPPrepareSend+0x184>
			{
				*ppxNetworkBuffer = pxNewBuffer;
  40bf64:	68bb      	ldr	r3, [r7, #8]
  40bf66:	6b7a      	ldr	r2, [r7, #52]	; 0x34
  40bf68:	601a      	str	r2, [r3, #0]
				pucEthernetBuffer = pxNewBuffer->pucEthernetBuffer;
  40bf6a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40bf6c:	699b      	ldr	r3, [r3, #24]
  40bf6e:	643b      	str	r3, [r7, #64]	; 0x40
				pxTCPPacket = ( TCPPacket_t * ) ( pucEthernetBuffer );
  40bf70:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  40bf72:	63fb      	str	r3, [r7, #60]	; 0x3c

				pucSendData = pucEthernetBuffer + ipSIZE_OF_ETH_HEADER + ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER + uxOptionsLength;
  40bf74:	687b      	ldr	r3, [r7, #4]
  40bf76:	3336      	adds	r3, #54	; 0x36
  40bf78:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  40bf7a:	4413      	add	r3, r2
  40bf7c:	633b      	str	r3, [r7, #48]	; 0x30

				/* Translate the position in txStream to an offset from the tail
				marker. */
				uxOffset = uxStreamBufferDistance( pxSocket->u.xTCP.txStream, pxSocket->u.xTCP.txStream->uxTail, ( size_t ) lStreamPos );
  40bf7e:	68fb      	ldr	r3, [r7, #12]
  40bf80:	6f18      	ldr	r0, [r3, #112]	; 0x70
  40bf82:	68fb      	ldr	r3, [r7, #12]
  40bf84:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  40bf86:	681b      	ldr	r3, [r3, #0]
  40bf88:	697a      	ldr	r2, [r7, #20]
  40bf8a:	4619      	mov	r1, r3
  40bf8c:	4b76      	ldr	r3, [pc, #472]	; (40c168 <prvTCPPrepareSend+0x294>)
  40bf8e:	4798      	blx	r3
  40bf90:	62f8      	str	r0, [r7, #44]	; 0x2c

				/* Here data is copied from the txStream in 'peek' mode.  Only
				when the packets are acked, the tail marker will be updated. */
				ulDataGot = ( uint32_t ) uxStreamBufferGet( pxSocket->u.xTCP.txStream, uxOffset, pucSendData, ( size_t ) lDataLen, pdTRUE );
  40bf92:	68fb      	ldr	r3, [r7, #12]
  40bf94:	6f18      	ldr	r0, [r3, #112]	; 0x70
  40bf96:	6c7a      	ldr	r2, [r7, #68]	; 0x44
  40bf98:	2301      	movs	r3, #1
  40bf9a:	9300      	str	r3, [sp, #0]
  40bf9c:	4613      	mov	r3, r2
  40bf9e:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  40bfa0:	6af9      	ldr	r1, [r7, #44]	; 0x2c
  40bfa2:	4c72      	ldr	r4, [pc, #456]	; (40c16c <prvTCPPrepareSend+0x298>)
  40bfa4:	47a0      	blx	r4
  40bfa6:	62b8      	str	r0, [r7, #40]	; 0x28

				#if( ipconfigHAS_DEBUG_PRINTF != 0 )
				{
					if( ulDataGot != ( uint32_t ) lDataLen )
  40bfa8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  40bfaa:	6aba      	ldr	r2, [r7, #40]	; 0x28
  40bfac:	429a      	cmp	r2, r3
  40bfae:	d007      	beq.n	40bfc0 <prvTCPPrepareSend+0xec>
					{
						FreeRTOS_debug_printf( ( "uxStreamBufferGet: pos %lu offs %lu only %lu != %lu\n",
  40bfb0:	6979      	ldr	r1, [r7, #20]
  40bfb2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  40bfb4:	9300      	str	r3, [sp, #0]
  40bfb6:	6abb      	ldr	r3, [r7, #40]	; 0x28
  40bfb8:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  40bfba:	486d      	ldr	r0, [pc, #436]	; (40c170 <prvTCPPrepareSend+0x29c>)
  40bfbc:	4c6d      	ldr	r4, [pc, #436]	; (40c174 <prvTCPPrepareSend+0x2a0>)
  40bfbe:	47a0      	blx	r4
				}
				#endif

				/* If the owner of the socket requests a closure, add the FIN
				flag to the last packet. */
				if( ( pxSocket->u.xTCP.bits.bCloseRequested != pdFALSE_UNSIGNED ) && ( pxSocket->u.xTCP.bits.bFinSent == pdFALSE_UNSIGNED ) )
  40bfc0:	68fb      	ldr	r3, [r7, #12]
  40bfc2:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
  40bfc6:	f003 0340 	and.w	r3, r3, #64	; 0x40
  40bfca:	b2db      	uxtb	r3, r3
  40bfcc:	2b00      	cmp	r3, #0
  40bfce:	d046      	beq.n	40c05e <prvTCPPrepareSend+0x18a>
  40bfd0:	68fb      	ldr	r3, [r7, #12]
  40bfd2:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
  40bfd6:	f003 0340 	and.w	r3, r3, #64	; 0x40
  40bfda:	b2db      	uxtb	r3, r3
  40bfdc:	2b00      	cmp	r3, #0
  40bfde:	d13e      	bne.n	40c05e <prvTCPPrepareSend+0x18a>
				{
					ulDistance = ( uint32_t ) uxStreamBufferDistance( pxSocket->u.xTCP.txStream, ( size_t ) lStreamPos, pxSocket->u.xTCP.txStream->uxHead );
  40bfe0:	68fb      	ldr	r3, [r7, #12]
  40bfe2:	6f18      	ldr	r0, [r3, #112]	; 0x70
  40bfe4:	697b      	ldr	r3, [r7, #20]
  40bfe6:	4619      	mov	r1, r3
  40bfe8:	68fb      	ldr	r3, [r7, #12]
  40bfea:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  40bfec:	689b      	ldr	r3, [r3, #8]
  40bfee:	461a      	mov	r2, r3
  40bff0:	4b5d      	ldr	r3, [pc, #372]	; (40c168 <prvTCPPrepareSend+0x294>)
  40bff2:	4798      	blx	r3
  40bff4:	6278      	str	r0, [r7, #36]	; 0x24

					if( ulDistance == ulDataGot )
  40bff6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  40bff8:	6abb      	ldr	r3, [r7, #40]	; 0x28
  40bffa:	429a      	cmp	r2, r3
  40bffc:	d12f      	bne.n	40c05e <prvTCPPrepareSend+0x18a>
					{
						#if (ipconfigHAS_DEBUG_PRINTF == 1)
						{
						/* the order of volatile accesses is undefined
							so such workaround */
							size_t uxHead = pxSocket->u.xTCP.txStream->uxHead;
  40bffe:	68fb      	ldr	r3, [r7, #12]
  40c000:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  40c002:	689b      	ldr	r3, [r3, #8]
  40c004:	623b      	str	r3, [r7, #32]
							size_t uxMid = pxSocket->u.xTCP.txStream->uxMid;
  40c006:	68fb      	ldr	r3, [r7, #12]
  40c008:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  40c00a:	685b      	ldr	r3, [r3, #4]
  40c00c:	61fb      	str	r3, [r7, #28]
							size_t uxTail = pxSocket->u.xTCP.txStream->uxTail;
  40c00e:	68fb      	ldr	r3, [r7, #12]
  40c010:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  40c012:	681b      	ldr	r3, [r3, #0]
  40c014:	61bb      	str	r3, [r7, #24]

							FreeRTOS_debug_printf( ( "CheckClose %lu <= %lu (%lu <= %lu <= %lu)\n", ulDataGot, ulDistance,
  40c016:	6a3b      	ldr	r3, [r7, #32]
  40c018:	9301      	str	r3, [sp, #4]
  40c01a:	69fb      	ldr	r3, [r7, #28]
  40c01c:	9300      	str	r3, [sp, #0]
  40c01e:	69bb      	ldr	r3, [r7, #24]
  40c020:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  40c022:	6ab9      	ldr	r1, [r7, #40]	; 0x28
  40c024:	4854      	ldr	r0, [pc, #336]	; (40c178 <prvTCPPrepareSend+0x2a4>)
  40c026:	4c53      	ldr	r4, [pc, #332]	; (40c174 <prvTCPPrepareSend+0x2a0>)
  40c028:	47a0      	blx	r4
						}
						#endif
						/* Although the socket sends a FIN, it will stay in
						ESTABLISHED until all current data has been received or
						delivered. */
						pxTCPPacket->xTCPHeader.ucTCPFlags |= ipTCP_FLAG_FIN;
  40c02a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  40c02c:	f893 302f 	ldrb.w	r3, [r3, #47]	; 0x2f
  40c030:	f043 0301 	orr.w	r3, r3, #1
  40c034:	b2da      	uxtb	r2, r3
  40c036:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  40c038:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f
						pxTCPWindow->tx.ulFINSequenceNumber = pxTCPWindow->ulOurSequenceNumber + ( uint32_t ) lDataLen;
  40c03c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  40c03e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  40c040:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  40c042:	441a      	add	r2, r3
  40c044:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  40c046:	625a      	str	r2, [r3, #36]	; 0x24
						pxSocket->u.xTCP.bits.bFinSent = pdTRUE_UNSIGNED;
  40c048:	68fa      	ldr	r2, [r7, #12]
  40c04a:	f892 3041 	ldrb.w	r3, [r2, #65]	; 0x41
  40c04e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  40c052:	f882 3041 	strb.w	r3, [r2, #65]	; 0x41
  40c056:	e002      	b.n	40c05e <prvTCPPrepareSend+0x18a>
					}
				}
			}
			else
			{
				lDataLen = -1;
  40c058:	f04f 33ff 	mov.w	r3, #4294967295
  40c05c:	647b      	str	r3, [r7, #68]	; 0x44
			}
		}
	}

	if( ( lDataLen >= 0 ) && ( pxSocket->u.xTCP.ucTCPState == eESTABLISHED ) )
  40c05e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  40c060:	2b00      	cmp	r3, #0
  40c062:	db38      	blt.n	40c0d6 <prvTCPPrepareSend+0x202>
  40c064:	68fb      	ldr	r3, [r7, #12]
  40c066:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
  40c06a:	2b05      	cmp	r3, #5
  40c06c:	d133      	bne.n	40c0d6 <prvTCPPrepareSend+0x202>
	{
		/* See if the socket owner wants to shutdown this connection. */
		if( ( pxSocket->u.xTCP.bits.bUserShutdown != pdFALSE_UNSIGNED ) &&
  40c06e:	68fb      	ldr	r3, [r7, #12]
  40c070:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
  40c074:	f003 0320 	and.w	r3, r3, #32
  40c078:	b2db      	uxtb	r3, r3
  40c07a:	2b00      	cmp	r3, #0
  40c07c:	d02b      	beq.n	40c0d6 <prvTCPPrepareSend+0x202>
			( xTCPWindowTxDone( pxTCPWindow ) != pdFALSE ) )
  40c07e:	6bb8      	ldr	r0, [r7, #56]	; 0x38
  40c080:	4b3e      	ldr	r3, [pc, #248]	; (40c17c <prvTCPPrepareSend+0x2a8>)
  40c082:	4798      	blx	r3
  40c084:	4603      	mov	r3, r0
		if( ( pxSocket->u.xTCP.bits.bUserShutdown != pdFALSE_UNSIGNED ) &&
  40c086:	2b00      	cmp	r3, #0
  40c088:	d025      	beq.n	40c0d6 <prvTCPPrepareSend+0x202>
		{
			pxSocket->u.xTCP.bits.bUserShutdown = pdFALSE_UNSIGNED;
  40c08a:	68fa      	ldr	r2, [r7, #12]
  40c08c:	f892 3040 	ldrb.w	r3, [r2, #64]	; 0x40
  40c090:	f36f 1345 	bfc	r3, #5, #1
  40c094:	f882 3040 	strb.w	r3, [r2, #64]	; 0x40
			pxTCPPacket->xTCPHeader.ucTCPFlags |= ipTCP_FLAG_FIN;
  40c098:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  40c09a:	f893 302f 	ldrb.w	r3, [r3, #47]	; 0x2f
  40c09e:	f043 0301 	orr.w	r3, r3, #1
  40c0a2:	b2da      	uxtb	r2, r3
  40c0a4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  40c0a6:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f
			pxSocket->u.xTCP.bits.bFinSent = pdTRUE_UNSIGNED;
  40c0aa:	68fa      	ldr	r2, [r7, #12]
  40c0ac:	f892 3041 	ldrb.w	r3, [r2, #65]	; 0x41
  40c0b0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  40c0b4:	f882 3041 	strb.w	r3, [r2, #65]	; 0x41
			pxSocket->u.xTCP.bits.bWinChange = pdTRUE_UNSIGNED;
  40c0b8:	68fa      	ldr	r2, [r7, #12]
  40c0ba:	f892 3041 	ldrb.w	r3, [r2, #65]	; 0x41
  40c0be:	f043 0301 	orr.w	r3, r3, #1
  40c0c2:	f882 3041 	strb.w	r3, [r2, #65]	; 0x41
			pxTCPWindow->tx.ulFINSequenceNumber = pxTCPWindow->tx.ulCurrentSequenceNumber;
  40c0c6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  40c0c8:	6a1a      	ldr	r2, [r3, #32]
  40c0ca:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  40c0cc:	625a      	str	r2, [r3, #36]	; 0x24
			vTCPStateChange( pxSocket, eFIN_WAIT_1 );
  40c0ce:	2106      	movs	r1, #6
  40c0d0:	68f8      	ldr	r0, [r7, #12]
  40c0d2:	4b2b      	ldr	r3, [pc, #172]	; (40c180 <prvTCPPrepareSend+0x2ac>)
  40c0d4:	4798      	blx	r3
		#endif /* ipconfigTCP_KEEP_ALIVE */
	}

	/* Anything to send, a change of the advertised window size, or maybe send a
	keep-alive message? */
	if( ( lDataLen > 0 ) ||
  40c0d6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  40c0d8:	2b00      	cmp	r3, #0
  40c0da:	dc0f      	bgt.n	40c0fc <prvTCPPrepareSend+0x228>
		( pxSocket->u.xTCP.bits.bWinChange != pdFALSE_UNSIGNED ) ||
  40c0dc:	68fb      	ldr	r3, [r7, #12]
  40c0de:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
  40c0e2:	f003 0301 	and.w	r3, r3, #1
  40c0e6:	b2db      	uxtb	r3, r3
	if( ( lDataLen > 0 ) ||
  40c0e8:	2b00      	cmp	r3, #0
  40c0ea:	d107      	bne.n	40c0fc <prvTCPPrepareSend+0x228>
		( pxSocket->u.xTCP.bits.bSendKeepAlive != pdFALSE_UNSIGNED ) )
  40c0ec:	68fb      	ldr	r3, [r7, #12]
  40c0ee:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
  40c0f2:	f003 0302 	and.w	r3, r3, #2
  40c0f6:	b2db      	uxtb	r3, r3
		( pxSocket->u.xTCP.bits.bWinChange != pdFALSE_UNSIGNED ) ||
  40c0f8:	2b00      	cmp	r3, #0
  40c0fa:	d02b      	beq.n	40c154 <prvTCPPrepareSend+0x280>
	{
		pxTCPPacket->xTCPHeader.ucTCPFlags &= ( ( uint8_t ) ~ipTCP_FLAG_PSH );
  40c0fc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  40c0fe:	f893 302f 	ldrb.w	r3, [r3, #47]	; 0x2f
  40c102:	f023 0308 	bic.w	r3, r3, #8
  40c106:	b2da      	uxtb	r2, r3
  40c108:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  40c10a:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f
		pxTCPPacket->xTCPHeader.ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
  40c10e:	687b      	ldr	r3, [r7, #4]
  40c110:	b2db      	uxtb	r3, r3
  40c112:	3314      	adds	r3, #20
  40c114:	b2db      	uxtb	r3, r3
  40c116:	009b      	lsls	r3, r3, #2
  40c118:	b2da      	uxtb	r2, r3
  40c11a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  40c11c:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e

		pxTCPPacket->xTCPHeader.ucTCPFlags |= ( uint8_t ) ipTCP_FLAG_ACK;
  40c120:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  40c122:	f893 302f 	ldrb.w	r3, [r3, #47]	; 0x2f
  40c126:	f043 0310 	orr.w	r3, r3, #16
  40c12a:	b2da      	uxtb	r2, r3
  40c12c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  40c12e:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f

		if( lDataLen != 0l )
  40c132:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  40c134:	2b00      	cmp	r3, #0
  40c136:	d008      	beq.n	40c14a <prvTCPPrepareSend+0x276>
		{
			pxTCPPacket->xTCPHeader.ucTCPFlags |= ( uint8_t ) ipTCP_FLAG_PSH;
  40c138:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  40c13a:	f893 302f 	ldrb.w	r3, [r3, #47]	; 0x2f
  40c13e:	f043 0308 	orr.w	r3, r3, #8
  40c142:	b2da      	uxtb	r2, r3
  40c144:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  40c146:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f
		}

		lDataLen += ( int32_t ) ( ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER + uxOptionsLength );
  40c14a:	6c7a      	ldr	r2, [r7, #68]	; 0x44
  40c14c:	687b      	ldr	r3, [r7, #4]
  40c14e:	4413      	add	r3, r2
  40c150:	3328      	adds	r3, #40	; 0x28
  40c152:	647b      	str	r3, [r7, #68]	; 0x44
	}

	return lDataLen;
  40c154:	6c7b      	ldr	r3, [r7, #68]	; 0x44
}
  40c156:	4618      	mov	r0, r3
  40c158:	374c      	adds	r7, #76	; 0x4c
  40c15a:	46bd      	mov	sp, r7
  40c15c:	bd90      	pop	{r4, r7, pc}
  40c15e:	bf00      	nop
  40c160:	0040e765 	.word	0x0040e765
  40c164:	0040bdfd 	.word	0x0040bdfd
  40c168:	0040aa1f 	.word	0x0040aa1f
  40c16c:	0040a88d 	.word	0x0040a88d
  40c170:	0041d3dc 	.word	0x0041d3dc
  40c174:	00416c7d 	.word	0x00416c7d
  40c178:	0041d414 	.word	0x0041d414
  40c17c:	0040e5e1 	.word	0x0040e5e1
  40c180:	0040bbc1 	.word	0x0040bbc1

0040c184 <prvTCPNextTimeout>:

/*
 * Calculate after how much time this socket needs to be checked again.
 */
static TickType_t prvTCPNextTimeout ( FreeRTOS_Socket_t *pxSocket )
{
  40c184:	b590      	push	{r4, r7, lr}
  40c186:	b087      	sub	sp, #28
  40c188:	af02      	add	r7, sp, #8
  40c18a:	6078      	str	r0, [r7, #4]
TickType_t ulDelayMs = ( TickType_t ) tcpMAXIMUM_TCP_WAKEUP_TIME_MS;
  40c18c:	f644 6320 	movw	r3, #20000	; 0x4e20
  40c190:	60bb      	str	r3, [r7, #8]

	if( pxSocket->u.xTCP.ucTCPState == eCONNECT_SYN )
  40c192:	687b      	ldr	r3, [r7, #4]
  40c194:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
  40c198:	2b02      	cmp	r3, #2
  40c19a:	d144      	bne.n	40c226 <prvTCPNextTimeout+0xa2>
	{
		/* The socket is actively connecting to a peer. */
		if( pxSocket->u.xTCP.bits.bConnPrepared )
  40c19c:	687b      	ldr	r3, [r7, #4]
  40c19e:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
  40c1a2:	f003 0308 	and.w	r3, r3, #8
  40c1a6:	b2db      	uxtb	r3, r3
  40c1a8:	2b00      	cmp	r3, #0
  40c1aa:	d012      	beq.n	40c1d2 <prvTCPNextTimeout+0x4e>
		{
			/* Ethernet address has been found, use progressive timeout for
			active connect(). */
			if( pxSocket->u.xTCP.ucRepCount < 3u )
  40c1ac:	687b      	ldr	r3, [r7, #4]
  40c1ae:	f893 3052 	ldrb.w	r3, [r3, #82]	; 0x52
  40c1b2:	2b02      	cmp	r3, #2
  40c1b4:	d809      	bhi.n	40c1ca <prvTCPNextTimeout+0x46>
			{
				ulDelayMs = ( 3000UL << ( pxSocket->u.xTCP.ucRepCount - 1u ) );
  40c1b6:	687b      	ldr	r3, [r7, #4]
  40c1b8:	f893 3052 	ldrb.w	r3, [r3, #82]	; 0x52
  40c1bc:	3b01      	subs	r3, #1
  40c1be:	f640 32b8 	movw	r2, #3000	; 0xbb8
  40c1c2:	fa02 f303 	lsl.w	r3, r2, r3
  40c1c6:	60bb      	str	r3, [r7, #8]
  40c1c8:	e006      	b.n	40c1d8 <prvTCPNextTimeout+0x54>
			}
			else
			{
				ulDelayMs = 11000UL;
  40c1ca:	f642 23f8 	movw	r3, #11000	; 0x2af8
  40c1ce:	60bb      	str	r3, [r7, #8]
  40c1d0:	e002      	b.n	40c1d8 <prvTCPNextTimeout+0x54>
			}
		}
		else
		{
			/* Still in the ARP phase: check every half second. */
			ulDelayMs = 500UL;
  40c1d2:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
  40c1d6:	60bb      	str	r3, [r7, #8]
		}

		FreeRTOS_debug_printf( ( "Connect[%lxip:%u]: next timeout %u: %lu ms\n",
  40c1d8:	687b      	ldr	r3, [r7, #4]
  40c1da:	6b99      	ldr	r1, [r3, #56]	; 0x38
  40c1dc:	687b      	ldr	r3, [r7, #4]
  40c1de:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
  40c1e0:	461a      	mov	r2, r3
  40c1e2:	687b      	ldr	r3, [r7, #4]
  40c1e4:	f893 3052 	ldrb.w	r3, [r3, #82]	; 0x52
  40c1e8:	4618      	mov	r0, r3
  40c1ea:	68bb      	ldr	r3, [r7, #8]
  40c1ec:	9300      	str	r3, [sp, #0]
  40c1ee:	4603      	mov	r3, r0
  40c1f0:	482a      	ldr	r0, [pc, #168]	; (40c29c <prvTCPNextTimeout+0x118>)
  40c1f2:	4c2b      	ldr	r4, [pc, #172]	; (40c2a0 <prvTCPNextTimeout+0x11c>)
  40c1f4:	47a0      	blx	r4
			pxSocket->u.xTCP.ulRemoteIP, pxSocket->u.xTCP.usRemotePort,
			pxSocket->u.xTCP.ucRepCount, ulDelayMs ) );
		pxSocket->u.xTCP.usTimeout = ( uint16_t )pdMS_TO_MIN_TICKS( ulDelayMs );
  40c1f6:	68bb      	ldr	r3, [r7, #8]
  40c1f8:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
  40c1fc:	fb02 f303 	mul.w	r3, r2, r3
  40c200:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
  40c204:	d30a      	bcc.n	40c21c <prvTCPNextTimeout+0x98>
  40c206:	68bb      	ldr	r3, [r7, #8]
  40c208:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
  40c20c:	fb02 f303 	mul.w	r3, r2, r3
  40c210:	4a24      	ldr	r2, [pc, #144]	; (40c2a4 <prvTCPNextTimeout+0x120>)
  40c212:	fba2 2303 	umull	r2, r3, r2, r3
  40c216:	099b      	lsrs	r3, r3, #6
  40c218:	b29a      	uxth	r2, r3
  40c21a:	e000      	b.n	40c21e <prvTCPNextTimeout+0x9a>
  40c21c:	2201      	movs	r2, #1
  40c21e:	687b      	ldr	r3, [r7, #4]
  40c220:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48
  40c224:	e033      	b.n	40c28e <prvTCPNextTimeout+0x10a>
	}
	else if( pxSocket->u.xTCP.usTimeout == 0u )
  40c226:	687b      	ldr	r3, [r7, #4]
  40c228:	f8b3 3048 	ldrh.w	r3, [r3, #72]	; 0x48
  40c22c:	2b00      	cmp	r3, #0
  40c22e:	d12e      	bne.n	40c28e <prvTCPNextTimeout+0x10a>
	{
		/* Let the sliding window mechanism decide what time-out is appropriate. */
		BaseType_t xResult = xTCPWindowTxHasData( &pxSocket->u.xTCP.xTCPWindow, pxSocket->u.xTCP.ulWindowSize, &ulDelayMs );
  40c230:	687b      	ldr	r3, [r7, #4]
  40c232:	f103 00d0 	add.w	r0, r3, #208	; 0xd0
  40c236:	687b      	ldr	r3, [r7, #4]
  40c238:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
  40c23c:	f107 0208 	add.w	r2, r7, #8
  40c240:	4619      	mov	r1, r3
  40c242:	4b19      	ldr	r3, [pc, #100]	; (40c2a8 <prvTCPNextTimeout+0x124>)
  40c244:	4798      	blx	r3
  40c246:	60f8      	str	r0, [r7, #12]
		if( ulDelayMs == 0u )
  40c248:	68bb      	ldr	r3, [r7, #8]
  40c24a:	2b00      	cmp	r3, #0
  40c24c:	d108      	bne.n	40c260 <prvTCPNextTimeout+0xdc>
		{
			if( xResult != ( BaseType_t )0 )
  40c24e:	68fb      	ldr	r3, [r7, #12]
  40c250:	2b00      	cmp	r3, #0
  40c252:	d002      	beq.n	40c25a <prvTCPNextTimeout+0xd6>
			{
				ulDelayMs = 1UL;
  40c254:	2301      	movs	r3, #1
  40c256:	60bb      	str	r3, [r7, #8]
  40c258:	e002      	b.n	40c260 <prvTCPNextTimeout+0xdc>
			}
			else
			{
				ulDelayMs = tcpMAXIMUM_TCP_WAKEUP_TIME_MS;
  40c25a:	f644 6320 	movw	r3, #20000	; 0x4e20
  40c25e:	60bb      	str	r3, [r7, #8]
		}
		else
		{
			/* ulDelayMs contains the time to wait before a re-transmission. */
		}
		pxSocket->u.xTCP.usTimeout = ( uint16_t )pdMS_TO_MIN_TICKS( ulDelayMs );
  40c260:	68bb      	ldr	r3, [r7, #8]
  40c262:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
  40c266:	fb02 f303 	mul.w	r3, r2, r3
  40c26a:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
  40c26e:	d30a      	bcc.n	40c286 <prvTCPNextTimeout+0x102>
  40c270:	68bb      	ldr	r3, [r7, #8]
  40c272:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
  40c276:	fb02 f303 	mul.w	r3, r2, r3
  40c27a:	4a0a      	ldr	r2, [pc, #40]	; (40c2a4 <prvTCPNextTimeout+0x120>)
  40c27c:	fba2 2303 	umull	r2, r3, r2, r3
  40c280:	099b      	lsrs	r3, r3, #6
  40c282:	b29a      	uxth	r2, r3
  40c284:	e000      	b.n	40c288 <prvTCPNextTimeout+0x104>
  40c286:	2201      	movs	r2, #1
  40c288:	687b      	ldr	r3, [r7, #4]
  40c28a:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48
		/* field '.usTimeout' has already been set (by the
		keep-alive/delayed-ACK mechanism). */
	}

	/* Return the number of clock ticks before the timer expires. */
	return ( TickType_t ) pxSocket->u.xTCP.usTimeout;
  40c28e:	687b      	ldr	r3, [r7, #4]
  40c290:	f8b3 3048 	ldrh.w	r3, [r3, #72]	; 0x48
}
  40c294:	4618      	mov	r0, r3
  40c296:	3714      	adds	r7, #20
  40c298:	46bd      	mov	sp, r7
  40c29a:	bd90      	pop	{r4, r7, pc}
  40c29c:	0041d440 	.word	0x0041d440
  40c2a0:	00416c7d 	.word	0x00416c7d
  40c2a4:	10624dd3 	.word	0x10624dd3
  40c2a8:	0040e699 	.word	0x0040e699

0040c2ac <prvTCPAddTxData>:
/*-----------------------------------------------------------*/

static void prvTCPAddTxData( FreeRTOS_Socket_t *pxSocket )
{
  40c2ac:	b590      	push	{r4, r7, lr}
  40c2ae:	b085      	sub	sp, #20
  40c2b0:	af00      	add	r7, sp, #0
  40c2b2:	6078      	str	r0, [r7, #4]
	the sliding window.

	uxStreamBufferMidSpace() returns the distance between rxHead and rxMid.  It contains new
	Tx data which has not been passed to the sliding window yet.  The oldest
	data not-yet-confirmed can be found at rxTail. */
	lLength = ( int32_t ) uxStreamBufferMidSpace( pxSocket->u.xTCP.txStream );
  40c2b4:	687b      	ldr	r3, [r7, #4]
  40c2b6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  40c2b8:	4618      	mov	r0, r3
  40c2ba:	4b11      	ldr	r3, [pc, #68]	; (40c300 <prvTCPAddTxData+0x54>)
  40c2bc:	4798      	blx	r3
  40c2be:	4603      	mov	r3, r0
  40c2c0:	60fb      	str	r3, [r7, #12]

	if( lLength > 0 )
  40c2c2:	68fb      	ldr	r3, [r7, #12]
  40c2c4:	2b00      	cmp	r3, #0
  40c2c6:	dd17      	ble.n	40c2f8 <prvTCPAddTxData+0x4c>
		window manager, so it can start transmitting them.

		Hand over the new data to the sliding window handler.  It will be
		split-up in chunks of 1460 bytes each (or less, depending on
		ipconfigTCP_MSS). */
		lCount = lTCPWindowTxAdd(	&pxSocket->u.xTCP.xTCPWindow,
  40c2c8:	687b      	ldr	r3, [r7, #4]
  40c2ca:	f103 00d0 	add.w	r0, r3, #208	; 0xd0
  40c2ce:	68f9      	ldr	r1, [r7, #12]
								( uint32_t ) lLength,
								( int32_t ) pxSocket->u.xTCP.txStream->uxMid,
  40c2d0:	687b      	ldr	r3, [r7, #4]
  40c2d2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  40c2d4:	685b      	ldr	r3, [r3, #4]
		lCount = lTCPWindowTxAdd(	&pxSocket->u.xTCP.xTCPWindow,
  40c2d6:	461a      	mov	r2, r3
								( int32_t ) pxSocket->u.xTCP.txStream->LENGTH );
  40c2d8:	687b      	ldr	r3, [r7, #4]
  40c2da:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  40c2dc:	691b      	ldr	r3, [r3, #16]
		lCount = lTCPWindowTxAdd(	&pxSocket->u.xTCP.xTCPWindow,
  40c2de:	4c09      	ldr	r4, [pc, #36]	; (40c304 <prvTCPAddTxData+0x58>)
  40c2e0:	47a0      	blx	r4
  40c2e2:	60b8      	str	r0, [r7, #8]

		/* Move the rxMid pointer forward up to rxHead. */
		if( lCount > 0 )
  40c2e4:	68bb      	ldr	r3, [r7, #8]
  40c2e6:	2b00      	cmp	r3, #0
  40c2e8:	dd06      	ble.n	40c2f8 <prvTCPAddTxData+0x4c>
		{
			vStreamBufferMoveMid( pxSocket->u.xTCP.txStream, ( size_t ) lCount );
  40c2ea:	687b      	ldr	r3, [r7, #4]
  40c2ec:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  40c2ee:	68ba      	ldr	r2, [r7, #8]
  40c2f0:	4611      	mov	r1, r2
  40c2f2:	4618      	mov	r0, r3
  40c2f4:	4b04      	ldr	r3, [pc, #16]	; (40c308 <prvTCPAddTxData+0x5c>)
  40c2f6:	4798      	blx	r3
		}
	}
}
  40c2f8:	bf00      	nop
  40c2fa:	3714      	adds	r7, #20
  40c2fc:	46bd      	mov	sp, r7
  40c2fe:	bd90      	pop	{r4, r7, pc}
  40c300:	0040aab5 	.word	0x0040aab5
  40c304:	0040e3d9 	.word	0x0040e3d9
  40c308:	0040aae1 	.word	0x0040aae1

0040c30c <prvTCPHandleFin>:
 * Or when the socket has sent a FIN flag to the peer
 * Before being called, it has been checked that both reception and transmission
 * are complete.
 */
static BaseType_t prvTCPHandleFin( FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t *pxNetworkBuffer )
{
  40c30c:	b5b0      	push	{r4, r5, r7, lr}
  40c30e:	b08a      	sub	sp, #40	; 0x28
  40c310:	af02      	add	r7, sp, #8
  40c312:	6078      	str	r0, [r7, #4]
  40c314:	6039      	str	r1, [r7, #0]
TCPPacket_t *pxTCPPacket = ( TCPPacket_t * ) ( pxNetworkBuffer->pucEthernetBuffer );
  40c316:	683b      	ldr	r3, [r7, #0]
  40c318:	699b      	ldr	r3, [r3, #24]
  40c31a:	61bb      	str	r3, [r7, #24]
TCPHeader_t *pxTCPHeader = &pxTCPPacket->xTCPHeader;
  40c31c:	69bb      	ldr	r3, [r7, #24]
  40c31e:	3322      	adds	r3, #34	; 0x22
  40c320:	617b      	str	r3, [r7, #20]
uint8_t ucTCPFlags = pxTCPHeader->ucTCPFlags;
  40c322:	697b      	ldr	r3, [r7, #20]
  40c324:	7b5b      	ldrb	r3, [r3, #13]
  40c326:	74fb      	strb	r3, [r7, #19]
TCPWindow_t *pxTCPWindow = &pxSocket->u.xTCP.xTCPWindow;
  40c328:	687b      	ldr	r3, [r7, #4]
  40c32a:	33d0      	adds	r3, #208	; 0xd0
  40c32c:	60fb      	str	r3, [r7, #12]
BaseType_t xSendLength = 0;
  40c32e:	2300      	movs	r3, #0
  40c330:	61fb      	str	r3, [r7, #28]
uint32_t ulAckNr = FreeRTOS_ntohl( pxTCPHeader->ulAckNr );
  40c332:	697b      	ldr	r3, [r7, #20]
  40c334:	689b      	ldr	r3, [r3, #8]
  40c336:	061a      	lsls	r2, r3, #24
  40c338:	697b      	ldr	r3, [r7, #20]
  40c33a:	689b      	ldr	r3, [r3, #8]
  40c33c:	021b      	lsls	r3, r3, #8
  40c33e:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
  40c342:	431a      	orrs	r2, r3
  40c344:	697b      	ldr	r3, [r7, #20]
  40c346:	689b      	ldr	r3, [r3, #8]
  40c348:	0a1b      	lsrs	r3, r3, #8
  40c34a:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
  40c34e:	431a      	orrs	r2, r3
  40c350:	697b      	ldr	r3, [r7, #20]
  40c352:	689b      	ldr	r3, [r3, #8]
  40c354:	0e1b      	lsrs	r3, r3, #24
  40c356:	4313      	orrs	r3, r2
  40c358:	60bb      	str	r3, [r7, #8]

	if( ( ucTCPFlags & ipTCP_FLAG_FIN ) != 0u )
  40c35a:	7cfb      	ldrb	r3, [r7, #19]
  40c35c:	f003 0301 	and.w	r3, r3, #1
  40c360:	2b00      	cmp	r3, #0
  40c362:	d004      	beq.n	40c36e <prvTCPHandleFin+0x62>
	{
		pxTCPWindow->rx.ulCurrentSequenceNumber = pxTCPWindow->rx.ulFINSequenceNumber + 1u;
  40c364:	68fb      	ldr	r3, [r7, #12]
  40c366:	695b      	ldr	r3, [r3, #20]
  40c368:	1c5a      	adds	r2, r3, #1
  40c36a:	68fb      	ldr	r3, [r7, #12]
  40c36c:	611a      	str	r2, [r3, #16]
	}
	if( pxSocket->u.xTCP.bits.bFinSent == pdFALSE_UNSIGNED )
  40c36e:	687b      	ldr	r3, [r7, #4]
  40c370:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
  40c374:	f003 0340 	and.w	r3, r3, #64	; 0x40
  40c378:	b2db      	uxtb	r3, r3
  40c37a:	2b00      	cmp	r3, #0
  40c37c:	d10b      	bne.n	40c396 <prvTCPHandleFin+0x8a>
	{
		/* We haven't yet replied with a FIN, do so now. */
		pxTCPWindow->tx.ulFINSequenceNumber = pxTCPWindow->tx.ulCurrentSequenceNumber;
  40c37e:	68fb      	ldr	r3, [r7, #12]
  40c380:	6a1a      	ldr	r2, [r3, #32]
  40c382:	68fb      	ldr	r3, [r7, #12]
  40c384:	625a      	str	r2, [r3, #36]	; 0x24
		pxSocket->u.xTCP.bits.bFinSent = pdTRUE_UNSIGNED;
  40c386:	687a      	ldr	r2, [r7, #4]
  40c388:	f892 3041 	ldrb.w	r3, [r2, #65]	; 0x41
  40c38c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  40c390:	f882 3041 	strb.w	r3, [r2, #65]	; 0x41
  40c394:	e00c      	b.n	40c3b0 <prvTCPHandleFin+0xa4>
	}
	else
	{
		/* We did send a FIN already, see if it's ACK'd. */
		if( ulAckNr == pxTCPWindow->tx.ulFINSequenceNumber + 1u )
  40c396:	68fb      	ldr	r3, [r7, #12]
  40c398:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  40c39a:	1c5a      	adds	r2, r3, #1
  40c39c:	68bb      	ldr	r3, [r7, #8]
  40c39e:	429a      	cmp	r2, r3
  40c3a0:	d106      	bne.n	40c3b0 <prvTCPHandleFin+0xa4>
		{
			pxSocket->u.xTCP.bits.bFinAcked = pdTRUE_UNSIGNED;
  40c3a2:	687a      	ldr	r2, [r7, #4]
  40c3a4:	f892 3042 	ldrb.w	r3, [r2, #66]	; 0x42
  40c3a8:	f043 0301 	orr.w	r3, r3, #1
  40c3ac:	f882 3042 	strb.w	r3, [r2, #66]	; 0x42
		}
	}

	if( pxSocket->u.xTCP.bits.bFinAcked == pdFALSE_UNSIGNED )
  40c3b0:	687b      	ldr	r3, [r7, #4]
  40c3b2:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
  40c3b6:	f003 0301 	and.w	r3, r3, #1
  40c3ba:	b2db      	uxtb	r3, r3
  40c3bc:	2b00      	cmp	r3, #0
  40c3be:	d10b      	bne.n	40c3d8 <prvTCPHandleFin+0xcc>
	{
		pxTCPWindow->tx.ulCurrentSequenceNumber = pxTCPWindow->tx.ulFINSequenceNumber;
  40c3c0:	68fb      	ldr	r3, [r7, #12]
  40c3c2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
  40c3c4:	68fb      	ldr	r3, [r7, #12]
  40c3c6:	621a      	str	r2, [r3, #32]
		pxTCPHeader->ucTCPFlags = ipTCP_FLAG_ACK | ipTCP_FLAG_FIN;
  40c3c8:	697b      	ldr	r3, [r7, #20]
  40c3ca:	2211      	movs	r2, #17
  40c3cc:	735a      	strb	r2, [r3, #13]

		/* And wait for the final ACK. */
		vTCPStateChange( pxSocket, eLAST_ACK );
  40c3ce:	210a      	movs	r1, #10
  40c3d0:	6878      	ldr	r0, [r7, #4]
  40c3d2:	4b33      	ldr	r3, [pc, #204]	; (40c4a0 <prvTCPHandleFin+0x194>)
  40c3d4:	4798      	blx	r3
  40c3d6:	e023      	b.n	40c420 <prvTCPHandleFin+0x114>
	}
	else
	{
		/* Our FIN has been ACK'd, the outgoing sequence number is now fixed. */
		pxTCPWindow->tx.ulCurrentSequenceNumber = pxTCPWindow->tx.ulFINSequenceNumber + 1u;
  40c3d8:	68fb      	ldr	r3, [r7, #12]
  40c3da:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  40c3dc:	1c5a      	adds	r2, r3, #1
  40c3de:	68fb      	ldr	r3, [r7, #12]
  40c3e0:	621a      	str	r2, [r3, #32]
		if( pxSocket->u.xTCP.bits.bFinRecv == pdFALSE_UNSIGNED )
  40c3e2:	687b      	ldr	r3, [r7, #4]
  40c3e4:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
  40c3e8:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
  40c3ec:	b2db      	uxtb	r3, r3
  40c3ee:	2b00      	cmp	r3, #0
  40c3f0:	d103      	bne.n	40c3fa <prvTCPHandleFin+0xee>
		{
			/* We have sent out a FIN but the peer hasn't replied with a FIN
			yet. Do nothing for the moment. */
			pxTCPHeader->ucTCPFlags = 0u;
  40c3f2:	697b      	ldr	r3, [r7, #20]
  40c3f4:	2200      	movs	r2, #0
  40c3f6:	735a      	strb	r2, [r3, #13]
  40c3f8:	e012      	b.n	40c420 <prvTCPHandleFin+0x114>
		}
		else
		{
			if( pxSocket->u.xTCP.bits.bFinLast == pdFALSE_UNSIGNED )
  40c3fa:	687b      	ldr	r3, [r7, #4]
  40c3fc:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
  40c400:	f003 0302 	and.w	r3, r3, #2
  40c404:	b2db      	uxtb	r3, r3
  40c406:	2b00      	cmp	r3, #0
  40c408:	d103      	bne.n	40c412 <prvTCPHandleFin+0x106>
			{
				/* This is the third of the three-way hand shake: the last
				ACK. */
				pxTCPHeader->ucTCPFlags = ipTCP_FLAG_ACK;
  40c40a:	697b      	ldr	r3, [r7, #20]
  40c40c:	2210      	movs	r2, #16
  40c40e:	735a      	strb	r2, [r3, #13]
  40c410:	e002      	b.n	40c418 <prvTCPHandleFin+0x10c>
			}
			else
			{
				/* The other party started the closure, so we just wait for the
				last ACK. */
				pxTCPHeader->ucTCPFlags = 0u;
  40c412:	697b      	ldr	r3, [r7, #20]
  40c414:	2200      	movs	r2, #0
  40c416:	735a      	strb	r2, [r3, #13]
			}

			/* And wait for the user to close this socket. */
			vTCPStateChange( pxSocket, eCLOSE_WAIT );
  40c418:	2108      	movs	r1, #8
  40c41a:	6878      	ldr	r0, [r7, #4]
  40c41c:	4b20      	ldr	r3, [pc, #128]	; (40c4a0 <prvTCPHandleFin+0x194>)
  40c41e:	4798      	blx	r3
		}
	}

	pxTCPWindow->ulOurSequenceNumber = pxTCPWindow->tx.ulCurrentSequenceNumber;
  40c420:	68fb      	ldr	r3, [r7, #12]
  40c422:	6a1a      	ldr	r2, [r3, #32]
  40c424:	68fb      	ldr	r3, [r7, #12]
  40c426:	62da      	str	r2, [r3, #44]	; 0x2c

	if( pxTCPHeader->ucTCPFlags != 0u )
  40c428:	697b      	ldr	r3, [r7, #20]
  40c42a:	7b5b      	ldrb	r3, [r3, #13]
  40c42c:	2b00      	cmp	r3, #0
  40c42e:	d004      	beq.n	40c43a <prvTCPHandleFin+0x12e>
	{
		xSendLength = ( BaseType_t ) ( ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER + pxTCPWindow->ucOptionLength );
  40c430:	68fb      	ldr	r3, [r7, #12]
  40c432:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
  40c436:	3328      	adds	r3, #40	; 0x28
  40c438:	61fb      	str	r3, [r7, #28]
	}

	pxTCPHeader->ucTCPOffset = ( uint8_t ) ( ( ipSIZE_OF_TCP_HEADER + pxTCPWindow->ucOptionLength ) << 2 );
  40c43a:	68fb      	ldr	r3, [r7, #12]
  40c43c:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
  40c440:	3314      	adds	r3, #20
  40c442:	b2db      	uxtb	r3, r3
  40c444:	009b      	lsls	r3, r3, #2
  40c446:	b2da      	uxtb	r2, r3
  40c448:	697b      	ldr	r3, [r7, #20]
  40c44a:	731a      	strb	r2, [r3, #12]

	if( xTCPWindowLoggingLevel != 0 )
  40c44c:	4b15      	ldr	r3, [pc, #84]	; (40c4a4 <prvTCPHandleFin+0x198>)
  40c44e:	681b      	ldr	r3, [r3, #0]
  40c450:	2b00      	cmp	r3, #0
  40c452:	d01f      	beq.n	40c494 <prvTCPHandleFin+0x188>
	{
		FreeRTOS_debug_printf( ( "TCP: send FIN+ACK (ack %lu, cur/nxt %lu/%lu) ourSeqNr %lu | Rx %lu\n",
  40c454:	68fb      	ldr	r3, [r7, #12]
  40c456:	69db      	ldr	r3, [r3, #28]
  40c458:	68ba      	ldr	r2, [r7, #8]
  40c45a:	1ad0      	subs	r0, r2, r3
  40c45c:	68fb      	ldr	r3, [r7, #12]
  40c45e:	6a1a      	ldr	r2, [r3, #32]
  40c460:	68fb      	ldr	r3, [r7, #12]
  40c462:	69db      	ldr	r3, [r3, #28]
  40c464:	1ad4      	subs	r4, r2, r3
  40c466:	68fb      	ldr	r3, [r7, #12]
  40c468:	6b5a      	ldr	r2, [r3, #52]	; 0x34
  40c46a:	68fb      	ldr	r3, [r7, #12]
  40c46c:	69db      	ldr	r3, [r3, #28]
  40c46e:	1ad5      	subs	r5, r2, r3
  40c470:	68fb      	ldr	r3, [r7, #12]
  40c472:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  40c474:	68fb      	ldr	r3, [r7, #12]
  40c476:	69db      	ldr	r3, [r3, #28]
  40c478:	1ad3      	subs	r3, r2, r3
  40c47a:	68fa      	ldr	r2, [r7, #12]
  40c47c:	6911      	ldr	r1, [r2, #16]
  40c47e:	68fa      	ldr	r2, [r7, #12]
  40c480:	68d2      	ldr	r2, [r2, #12]
  40c482:	1a8a      	subs	r2, r1, r2
  40c484:	9201      	str	r2, [sp, #4]
  40c486:	9300      	str	r3, [sp, #0]
  40c488:	462b      	mov	r3, r5
  40c48a:	4622      	mov	r2, r4
  40c48c:	4601      	mov	r1, r0
  40c48e:	4806      	ldr	r0, [pc, #24]	; (40c4a8 <prvTCPHandleFin+0x19c>)
  40c490:	4c06      	ldr	r4, [pc, #24]	; (40c4ac <prvTCPHandleFin+0x1a0>)
  40c492:	47a0      	blx	r4
			pxTCPWindow->ulNextTxSequenceNumber - pxTCPWindow->tx.ulFirstSequenceNumber,
			pxTCPWindow->ulOurSequenceNumber - pxTCPWindow->tx.ulFirstSequenceNumber,
			pxTCPWindow->rx.ulCurrentSequenceNumber - pxTCPWindow->rx.ulFirstSequenceNumber ) );
	}

	return xSendLength;
  40c494:	69fb      	ldr	r3, [r7, #28]
}
  40c496:	4618      	mov	r0, r3
  40c498:	3720      	adds	r7, #32
  40c49a:	46bd      	mov	sp, r7
  40c49c:	bdb0      	pop	{r4, r5, r7, pc}
  40c49e:	bf00      	nop
  40c4a0:	0040bbc1 	.word	0x0040bbc1
  40c4a4:	20006d60 	.word	0x20006d60
  40c4a8:	0041d46c 	.word	0x0041d46c
  40c4ac:	00416c7d 	.word	0x00416c7d

0040c4b0 <prvCheckRxData>:
 *
 * The first thing that will be done is find the TCP payload data
 * and check the length of this data.
 */
static BaseType_t prvCheckRxData( NetworkBufferDescriptor_t *pxNetworkBuffer, uint8_t **ppucRecvData )
{
  40c4b0:	b580      	push	{r7, lr}
  40c4b2:	b088      	sub	sp, #32
  40c4b4:	af00      	add	r7, sp, #0
  40c4b6:	6078      	str	r0, [r7, #4]
  40c4b8:	6039      	str	r1, [r7, #0]
TCPPacket_t *pxTCPPacket = ( TCPPacket_t * ) ( pxNetworkBuffer->pucEthernetBuffer );
  40c4ba:	687b      	ldr	r3, [r7, #4]
  40c4bc:	699b      	ldr	r3, [r3, #24]
  40c4be:	61bb      	str	r3, [r7, #24]
TCPHeader_t *pxTCPHeader = &( pxTCPPacket->xTCPHeader );
  40c4c0:	69bb      	ldr	r3, [r7, #24]
  40c4c2:	3322      	adds	r3, #34	; 0x22
  40c4c4:	617b      	str	r3, [r7, #20]
	node.

	The size of the TCP header is given in a multiple of 4-byte words (single
	byte, needs no ntoh() translation).  A shift-right 2: is the same as
	(offset >> 4) * 4. */
	lTCPHeaderLength = ( BaseType_t ) ( ( pxTCPHeader->ucTCPOffset & VALID_BITS_IN_TCP_OFFSET_BYTE ) >> 2 );
  40c4c6:	697b      	ldr	r3, [r7, #20]
  40c4c8:	7b1b      	ldrb	r3, [r3, #12]
  40c4ca:	089b      	lsrs	r3, r3, #2
  40c4cc:	f003 033c 	and.w	r3, r3, #60	; 0x3c
  40c4d0:	613b      	str	r3, [r7, #16]

	/* Let pucRecvData point to the first byte received. */
	*ppucRecvData = pxNetworkBuffer->pucEthernetBuffer + ipSIZE_OF_ETH_HEADER + ipSIZE_OF_IPv4_HEADER + lTCPHeaderLength;
  40c4d2:	687b      	ldr	r3, [r7, #4]
  40c4d4:	699a      	ldr	r2, [r3, #24]
  40c4d6:	693b      	ldr	r3, [r7, #16]
  40c4d8:	3322      	adds	r3, #34	; 0x22
  40c4da:	441a      	add	r2, r3
  40c4dc:	683b      	ldr	r3, [r7, #0]
  40c4de:	601a      	str	r2, [r3, #0]

	/* Calculate lReceiveLength - the length of the TCP data received.  This is
	equal to the total packet length minus:
	( LinkLayer length (14) + IP header length (20) + size of TCP header(20 +) ).*/
	lReceiveLength = ( ( int32_t ) pxNetworkBuffer->xDataLength ) - ( int32_t ) ipSIZE_OF_ETH_HEADER;
  40c4e0:	687b      	ldr	r3, [r7, #4]
  40c4e2:	69db      	ldr	r3, [r3, #28]
  40c4e4:	3b0e      	subs	r3, #14
  40c4e6:	61fb      	str	r3, [r7, #28]
	lLength =  ( int32_t )FreeRTOS_htons( pxTCPPacket->xIPHeader.usLength );
  40c4e8:	69bb      	ldr	r3, [r7, #24]
  40c4ea:	8a1b      	ldrh	r3, [r3, #16]
  40c4ec:	b29b      	uxth	r3, r3
  40c4ee:	021b      	lsls	r3, r3, #8
  40c4f0:	b21a      	sxth	r2, r3
  40c4f2:	69bb      	ldr	r3, [r7, #24]
  40c4f4:	8a1b      	ldrh	r3, [r3, #16]
  40c4f6:	b29b      	uxth	r3, r3
  40c4f8:	0a1b      	lsrs	r3, r3, #8
  40c4fa:	b29b      	uxth	r3, r3
  40c4fc:	b21b      	sxth	r3, r3
  40c4fe:	4313      	orrs	r3, r2
  40c500:	b21b      	sxth	r3, r3
  40c502:	b29b      	uxth	r3, r3
  40c504:	60fb      	str	r3, [r7, #12]

	if( lReceiveLength > lLength )
  40c506:	69fa      	ldr	r2, [r7, #28]
  40c508:	68fb      	ldr	r3, [r7, #12]
  40c50a:	429a      	cmp	r2, r3
  40c50c:	dd01      	ble.n	40c512 <prvCheckRxData+0x62>
	{
		/* More bytes were received than the reported length, often because of
		padding bytes at the end. */
		lReceiveLength = lLength;
  40c50e:	68fb      	ldr	r3, [r7, #12]
  40c510:	61fb      	str	r3, [r7, #28]
	}

	/* Subtract the size of the TCP and IP headers and the actual data size is
	known. */
	if( lReceiveLength > ( lTCPHeaderLength + ( int32_t ) ipSIZE_OF_IPv4_HEADER ) )
  40c512:	693b      	ldr	r3, [r7, #16]
  40c514:	f103 0214 	add.w	r2, r3, #20
  40c518:	69fb      	ldr	r3, [r7, #28]
  40c51a:	429a      	cmp	r2, r3
  40c51c:	da05      	bge.n	40c52a <prvCheckRxData+0x7a>
	{
		lReceiveLength -= ( lTCPHeaderLength + ( int32_t ) ipSIZE_OF_IPv4_HEADER );
  40c51e:	693b      	ldr	r3, [r7, #16]
  40c520:	3314      	adds	r3, #20
  40c522:	69fa      	ldr	r2, [r7, #28]
  40c524:	1ad3      	subs	r3, r2, r3
  40c526:	61fb      	str	r3, [r7, #28]
  40c528:	e001      	b.n	40c52e <prvCheckRxData+0x7e>
	}
	else
	{
		lReceiveLength = 0;
  40c52a:	2300      	movs	r3, #0
  40c52c:	61fb      	str	r3, [r7, #28]
	This field communicates the current value of the urgent pointer as a
	positive offset from the sequence number in this segment.  The urgent
	pointer points to the sequence number of the octet following the urgent
	data.  This field is only be interpreted in segments with the URG control
	bit set. */
	if( ( pxTCPHeader->ucTCPFlags & ipTCP_FLAG_URG ) != 0u )
  40c52e:	697b      	ldr	r3, [r7, #20]
  40c530:	7b5b      	ldrb	r3, [r3, #13]
  40c532:	f003 0320 	and.w	r3, r3, #32
  40c536:	2b00      	cmp	r3, #0
  40c538:	d01c      	beq.n	40c574 <prvCheckRxData+0xc4>
	{
		/* Although we ignore the urgent data, we have to skip it. */
		lUrgentLength = ( int32_t ) FreeRTOS_htons( pxTCPHeader->usUrgent );
  40c53a:	697b      	ldr	r3, [r7, #20]
  40c53c:	8a5b      	ldrh	r3, [r3, #18]
  40c53e:	b29b      	uxth	r3, r3
  40c540:	021b      	lsls	r3, r3, #8
  40c542:	b21a      	sxth	r2, r3
  40c544:	697b      	ldr	r3, [r7, #20]
  40c546:	8a5b      	ldrh	r3, [r3, #18]
  40c548:	b29b      	uxth	r3, r3
  40c54a:	0a1b      	lsrs	r3, r3, #8
  40c54c:	b29b      	uxth	r3, r3
  40c54e:	b21b      	sxth	r3, r3
  40c550:	4313      	orrs	r3, r2
  40c552:	b21b      	sxth	r3, r3
  40c554:	b29b      	uxth	r3, r3
  40c556:	60bb      	str	r3, [r7, #8]
		*ppucRecvData += lUrgentLength;
  40c558:	683b      	ldr	r3, [r7, #0]
  40c55a:	681a      	ldr	r2, [r3, #0]
  40c55c:	68bb      	ldr	r3, [r7, #8]
  40c55e:	441a      	add	r2, r3
  40c560:	683b      	ldr	r3, [r7, #0]
  40c562:	601a      	str	r2, [r3, #0]
		lReceiveLength -= FreeRTOS_min_int32( lReceiveLength, lUrgentLength );
  40c564:	68b9      	ldr	r1, [r7, #8]
  40c566:	69f8      	ldr	r0, [r7, #28]
  40c568:	4b05      	ldr	r3, [pc, #20]	; (40c580 <prvCheckRxData+0xd0>)
  40c56a:	4798      	blx	r3
  40c56c:	4602      	mov	r2, r0
  40c56e:	69fb      	ldr	r3, [r7, #28]
  40c570:	1a9b      	subs	r3, r3, r2
  40c572:	61fb      	str	r3, [r7, #28]
	}

	return ( BaseType_t ) lReceiveLength;
  40c574:	69fb      	ldr	r3, [r7, #28]
}
  40c576:	4618      	mov	r0, r3
  40c578:	3720      	adds	r7, #32
  40c57a:	46bd      	mov	sp, r7
  40c57c:	bd80      	pop	{r7, pc}
  40c57e:	bf00      	nop
  40c580:	0040a9a1 	.word	0x0040a9a1

0040c584 <prvStoreRxData>:
 * The second thing is to do is check if the payload data may be accepted
 * If so, they will be added to the reception queue.
 */
static BaseType_t prvStoreRxData( FreeRTOS_Socket_t *pxSocket, uint8_t *pucRecvData,
	NetworkBufferDescriptor_t *pxNetworkBuffer, uint32_t ulReceiveLength )
{
  40c584:	b590      	push	{r4, r7, lr}
  40c586:	b08d      	sub	sp, #52	; 0x34
  40c588:	af00      	add	r7, sp, #0
  40c58a:	60f8      	str	r0, [r7, #12]
  40c58c:	60b9      	str	r1, [r7, #8]
  40c58e:	607a      	str	r2, [r7, #4]
  40c590:	603b      	str	r3, [r7, #0]
TCPPacket_t *pxTCPPacket = ( TCPPacket_t * ) ( pxNetworkBuffer->pucEthernetBuffer );
  40c592:	687b      	ldr	r3, [r7, #4]
  40c594:	699b      	ldr	r3, [r3, #24]
  40c596:	627b      	str	r3, [r7, #36]	; 0x24
TCPHeader_t *pxTCPHeader = &pxTCPPacket->xTCPHeader;
  40c598:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40c59a:	3322      	adds	r3, #34	; 0x22
  40c59c:	623b      	str	r3, [r7, #32]
TCPWindow_t *pxTCPWindow = &pxSocket->u.xTCP.xTCPWindow;
  40c59e:	68fb      	ldr	r3, [r7, #12]
  40c5a0:	33d0      	adds	r3, #208	; 0xd0
  40c5a2:	61fb      	str	r3, [r7, #28]
uint32_t ulSequenceNumber, ulSpace;
int32_t lOffset, lStored;
BaseType_t xResult = 0;
  40c5a4:	2300      	movs	r3, #0
  40c5a6:	62bb      	str	r3, [r7, #40]	; 0x28

	ulSequenceNumber = FreeRTOS_ntohl( pxTCPHeader->ulSequenceNumber );
  40c5a8:	6a3b      	ldr	r3, [r7, #32]
  40c5aa:	685b      	ldr	r3, [r3, #4]
  40c5ac:	061a      	lsls	r2, r3, #24
  40c5ae:	6a3b      	ldr	r3, [r7, #32]
  40c5b0:	685b      	ldr	r3, [r3, #4]
  40c5b2:	021b      	lsls	r3, r3, #8
  40c5b4:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
  40c5b8:	431a      	orrs	r2, r3
  40c5ba:	6a3b      	ldr	r3, [r7, #32]
  40c5bc:	685b      	ldr	r3, [r3, #4]
  40c5be:	0a1b      	lsrs	r3, r3, #8
  40c5c0:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
  40c5c4:	431a      	orrs	r2, r3
  40c5c6:	6a3b      	ldr	r3, [r7, #32]
  40c5c8:	685b      	ldr	r3, [r3, #4]
  40c5ca:	0e1b      	lsrs	r3, r3, #24
  40c5cc:	4313      	orrs	r3, r2
  40c5ce:	61bb      	str	r3, [r7, #24]

	if( ( ulReceiveLength > 0u ) && ( pxSocket->u.xTCP.ucTCPState >= eSYN_RECEIVED ) )
  40c5d0:	683b      	ldr	r3, [r7, #0]
  40c5d2:	2b00      	cmp	r3, #0
  40c5d4:	d044      	beq.n	40c660 <prvStoreRxData+0xdc>
  40c5d6:	68fb      	ldr	r3, [r7, #12]
  40c5d8:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
  40c5dc:	2b03      	cmp	r3, #3
  40c5de:	d93f      	bls.n	40c660 <prvStoreRxData+0xdc>

		If it can't be "accept"ed it may have to be stored and send a selective
		ack (SACK) option to confirm it.  In that case, xTCPWindowRxStore() will be
		called later to store an out-of-order packet (in case lOffset is
		negative). */
		if ( pxSocket->u.xTCP.rxStream )
  40c5e0:	68fb      	ldr	r3, [r7, #12]
  40c5e2:	6edb      	ldr	r3, [r3, #108]	; 0x6c
  40c5e4:	2b00      	cmp	r3, #0
  40c5e6:	d006      	beq.n	40c5f6 <prvStoreRxData+0x72>
		{
			ulSpace = ( uint32_t )uxStreamBufferGetSpace ( pxSocket->u.xTCP.rxStream );
  40c5e8:	68fb      	ldr	r3, [r7, #12]
  40c5ea:	6edb      	ldr	r3, [r3, #108]	; 0x6c
  40c5ec:	4618      	mov	r0, r3
  40c5ee:	4b22      	ldr	r3, [pc, #136]	; (40c678 <prvStoreRxData+0xf4>)
  40c5f0:	4798      	blx	r3
  40c5f2:	62f8      	str	r0, [r7, #44]	; 0x2c
  40c5f4:	e002      	b.n	40c5fc <prvStoreRxData+0x78>
		}
		else
		{
			ulSpace = ( uint32_t )pxSocket->u.xTCP.uxRxStreamSize;
  40c5f6:	68fb      	ldr	r3, [r7, #12]
  40c5f8:	6e5b      	ldr	r3, [r3, #100]	; 0x64
  40c5fa:	62fb      	str	r3, [r7, #44]	; 0x2c
		}

		lOffset = lTCPWindowRxCheck( pxTCPWindow, ulSequenceNumber, ulReceiveLength, ulSpace );
  40c5fc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40c5fe:	683a      	ldr	r2, [r7, #0]
  40c600:	69b9      	ldr	r1, [r7, #24]
  40c602:	69f8      	ldr	r0, [r7, #28]
  40c604:	4c1d      	ldr	r4, [pc, #116]	; (40c67c <prvStoreRxData+0xf8>)
  40c606:	47a0      	blx	r4
  40c608:	6178      	str	r0, [r7, #20]

		if( lOffset >= 0 )
  40c60a:	697b      	ldr	r3, [r7, #20]
  40c60c:	2b00      	cmp	r3, #0
  40c60e:	db15      	blt.n	40c63c <prvStoreRxData+0xb8>
		{
			/* New data has arrived and may be made available to the user.  See
			if the head marker in rxStream may be advanced,	only if lOffset == 0.
			In case the low-water mark is reached, bLowWater will be set
			"low-water" here stands for "little space". */
			lStored = lTCPAddRxdata( pxSocket, ( uint32_t ) lOffset, pucRecvData, ulReceiveLength );
  40c610:	6979      	ldr	r1, [r7, #20]
  40c612:	683b      	ldr	r3, [r7, #0]
  40c614:	68ba      	ldr	r2, [r7, #8]
  40c616:	68f8      	ldr	r0, [r7, #12]
  40c618:	4c19      	ldr	r4, [pc, #100]	; (40c680 <prvStoreRxData+0xfc>)
  40c61a:	47a0      	blx	r4
  40c61c:	6138      	str	r0, [r7, #16]

			if( lStored != ( int32_t ) ulReceiveLength )
  40c61e:	683b      	ldr	r3, [r7, #0]
  40c620:	693a      	ldr	r2, [r7, #16]
  40c622:	429a      	cmp	r2, r3
  40c624:	d00a      	beq.n	40c63c <prvStoreRxData+0xb8>
			{
				FreeRTOS_debug_printf( ( "lTCPAddRxdata: stored %ld / %lu bytes??\n", lStored, ulReceiveLength ) );
  40c626:	683a      	ldr	r2, [r7, #0]
  40c628:	6939      	ldr	r1, [r7, #16]
  40c62a:	4816      	ldr	r0, [pc, #88]	; (40c684 <prvStoreRxData+0x100>)
  40c62c:	4b16      	ldr	r3, [pc, #88]	; (40c688 <prvStoreRxData+0x104>)
  40c62e:	4798      	blx	r3

				/* Received data could not be stored.  The socket's flag
				bMallocError has been set.  The socket now has the status
				eCLOSE_WAIT and a RST packet will be sent back. */
				prvTCPSendReset( pxNetworkBuffer );
  40c630:	6878      	ldr	r0, [r7, #4]
  40c632:	4b16      	ldr	r3, [pc, #88]	; (40c68c <prvStoreRxData+0x108>)
  40c634:	4798      	blx	r3
				xResult = -1;
  40c636:	f04f 33ff 	mov.w	r3, #4294967295
  40c63a:	62bb      	str	r3, [r7, #40]	; 0x28
		#if( ipconfigUSE_TCP_WIN == 1 )
		{
			/* Now lTCPAddRxdata() will move the rxHead pointer forward
			so data becomes available to the user immediately
			In case the low-water mark is reached, bLowWater will be set. */
			if( ( xResult == 0 ) && ( pxTCPWindow->ulUserDataLength > 0 ) )
  40c63c:	6abb      	ldr	r3, [r7, #40]	; 0x28
  40c63e:	2b00      	cmp	r3, #0
  40c640:	d113      	bne.n	40c66a <prvStoreRxData+0xe6>
  40c642:	69fb      	ldr	r3, [r7, #28]
  40c644:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  40c646:	2b00      	cmp	r3, #0
  40c648:	d00f      	beq.n	40c66a <prvStoreRxData+0xe6>
			{
				lTCPAddRxdata( pxSocket, 0ul, NULL, pxTCPWindow->ulUserDataLength );
  40c64a:	69fb      	ldr	r3, [r7, #28]
  40c64c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  40c64e:	2200      	movs	r2, #0
  40c650:	2100      	movs	r1, #0
  40c652:	68f8      	ldr	r0, [r7, #12]
  40c654:	4c0a      	ldr	r4, [pc, #40]	; (40c680 <prvStoreRxData+0xfc>)
  40c656:	47a0      	blx	r4
				pxTCPWindow->ulUserDataLength = 0;
  40c658:	69fb      	ldr	r3, [r7, #28]
  40c65a:	2200      	movs	r2, #0
  40c65c:	631a      	str	r2, [r3, #48]	; 0x30
			if( ( xResult == 0 ) && ( pxTCPWindow->ulUserDataLength > 0 ) )
  40c65e:	e004      	b.n	40c66a <prvStoreRxData+0xe6>
		}
		#endif /* ipconfigUSE_TCP_WIN */
	}
	else
	{
		pxTCPWindow->ucOptionLength = 0u;
  40c660:	69fb      	ldr	r3, [r7, #28]
  40c662:	2200      	movs	r2, #0
  40c664:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  40c668:	e000      	b.n	40c66c <prvStoreRxData+0xe8>
			if( ( xResult == 0 ) && ( pxTCPWindow->ulUserDataLength > 0 ) )
  40c66a:	bf00      	nop
	}

	return xResult;
  40c66c:	6abb      	ldr	r3, [r7, #40]	; 0x28
}
  40c66e:	4618      	mov	r0, r3
  40c670:	3734      	adds	r7, #52	; 0x34
  40c672:	46bd      	mov	sp, r7
  40c674:	bd90      	pop	{r4, r7, pc}
  40c676:	bf00      	nop
  40c678:	0040aa5d 	.word	0x0040aa5d
  40c67c:	0040e0ed 	.word	0x0040e0ed
  40c680:	0040a031 	.word	0x0040a031
  40c684:	0041d4b0 	.word	0x0041d4b0
  40c688:	00416c7d 	.word	0x00416c7d
  40c68c:	0040d129 	.word	0x0040d129

0040c690 <prvSetOptions>:
/*-----------------------------------------------------------*/

/* Set the TCP options (if any) for the outgoing packet. */
static UBaseType_t prvSetOptions( FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t *pxNetworkBuffer )
{
  40c690:	b590      	push	{r4, r7, lr}
  40c692:	b089      	sub	sp, #36	; 0x24
  40c694:	af02      	add	r7, sp, #8
  40c696:	6078      	str	r0, [r7, #4]
  40c698:	6039      	str	r1, [r7, #0]
TCPPacket_t *pxTCPPacket = ( TCPPacket_t * ) ( pxNetworkBuffer->pucEthernetBuffer );
  40c69a:	683b      	ldr	r3, [r7, #0]
  40c69c:	699b      	ldr	r3, [r3, #24]
  40c69e:	613b      	str	r3, [r7, #16]
TCPHeader_t *pxTCPHeader = &pxTCPPacket->xTCPHeader;
  40c6a0:	693b      	ldr	r3, [r7, #16]
  40c6a2:	3322      	adds	r3, #34	; 0x22
  40c6a4:	60fb      	str	r3, [r7, #12]
TCPWindow_t *pxTCPWindow = &pxSocket->u.xTCP.xTCPWindow;
  40c6a6:	687b      	ldr	r3, [r7, #4]
  40c6a8:	33d0      	adds	r3, #208	; 0xd0
  40c6aa:	60bb      	str	r3, [r7, #8]
UBaseType_t uxOptionsLength = pxTCPWindow->ucOptionLength;
  40c6ac:	68bb      	ldr	r3, [r7, #8]
  40c6ae:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
  40c6b2:	617b      	str	r3, [r7, #20]

	#if(	ipconfigUSE_TCP_WIN == 1 )
		if( uxOptionsLength != 0u )
  40c6b4:	697b      	ldr	r3, [r7, #20]
  40c6b6:	2b00      	cmp	r3, #0
  40c6b8:	d059      	beq.n	40c76e <prvSetOptions+0xde>
		{
			/* TCP options must be sent because a packet which is out-of-order
			was received. */
			if( xTCPWindowLoggingLevel >= 0 )
  40c6ba:	4b4e      	ldr	r3, [pc, #312]	; (40c7f4 <prvSetOptions+0x164>)
  40c6bc:	681b      	ldr	r3, [r3, #0]
  40c6be:	2b00      	cmp	r3, #0
  40c6c0:	db43      	blt.n	40c74a <prvSetOptions+0xba>
				FreeRTOS_debug_printf( ( "SACK[%d,%d]: optlen %lu sending %lu - %lu\n",
  40c6c2:	687b      	ldr	r3, [r7, #4]
  40c6c4:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
  40c6c6:	4618      	mov	r0, r3
  40c6c8:	687b      	ldr	r3, [r7, #4]
  40c6ca:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
  40c6cc:	461c      	mov	r4, r3
  40c6ce:	68bb      	ldr	r3, [r7, #8]
  40c6d0:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
  40c6d4:	061a      	lsls	r2, r3, #24
  40c6d6:	68bb      	ldr	r3, [r7, #8]
  40c6d8:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
  40c6dc:	021b      	lsls	r3, r3, #8
  40c6de:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
  40c6e2:	431a      	orrs	r2, r3
  40c6e4:	68bb      	ldr	r3, [r7, #8]
  40c6e6:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
  40c6ea:	0a1b      	lsrs	r3, r3, #8
  40c6ec:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
  40c6f0:	431a      	orrs	r2, r3
  40c6f2:	68bb      	ldr	r3, [r7, #8]
  40c6f4:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
  40c6f8:	0e1b      	lsrs	r3, r3, #24
  40c6fa:	431a      	orrs	r2, r3
  40c6fc:	687b      	ldr	r3, [r7, #4]
  40c6fe:	f8d3 30dc 	ldr.w	r3, [r3, #220]	; 0xdc
  40c702:	1ad3      	subs	r3, r2, r3
  40c704:	68ba      	ldr	r2, [r7, #8]
  40c706:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
  40c70a:	0611      	lsls	r1, r2, #24
  40c70c:	68ba      	ldr	r2, [r7, #8]
  40c70e:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
  40c712:	0212      	lsls	r2, r2, #8
  40c714:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
  40c718:	4311      	orrs	r1, r2
  40c71a:	68ba      	ldr	r2, [r7, #8]
  40c71c:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
  40c720:	0a12      	lsrs	r2, r2, #8
  40c722:	f402 427f 	and.w	r2, r2, #65280	; 0xff00
  40c726:	4311      	orrs	r1, r2
  40c728:	68ba      	ldr	r2, [r7, #8]
  40c72a:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
  40c72e:	0e12      	lsrs	r2, r2, #24
  40c730:	4311      	orrs	r1, r2
  40c732:	687a      	ldr	r2, [r7, #4]
  40c734:	f8d2 20dc 	ldr.w	r2, [r2, #220]	; 0xdc
  40c738:	1a8a      	subs	r2, r1, r2
  40c73a:	9201      	str	r2, [sp, #4]
  40c73c:	9300      	str	r3, [sp, #0]
  40c73e:	697b      	ldr	r3, [r7, #20]
  40c740:	4622      	mov	r2, r4
  40c742:	4601      	mov	r1, r0
  40c744:	482c      	ldr	r0, [pc, #176]	; (40c7f8 <prvSetOptions+0x168>)
  40c746:	4c2d      	ldr	r4, [pc, #180]	; (40c7fc <prvSetOptions+0x16c>)
  40c748:	47a0      	blx	r4
					pxSocket->usLocalPort,
					pxSocket->u.xTCP.usRemotePort,
					uxOptionsLength,
					FreeRTOS_ntohl( pxTCPWindow->ulOptionsData[ 1 ] ) - pxSocket->u.xTCP.xTCPWindow.rx.ulFirstSequenceNumber,
					FreeRTOS_ntohl( pxTCPWindow->ulOptionsData[ 2 ] ) - pxSocket->u.xTCP.xTCPWindow.rx.ulFirstSequenceNumber ) );
			memcpy( pxTCPHeader->ucOptdata, pxTCPWindow->ulOptionsData, ( size_t ) uxOptionsLength );
  40c74a:	68fb      	ldr	r3, [r7, #12]
  40c74c:	f103 0014 	add.w	r0, r3, #20
  40c750:	68bb      	ldr	r3, [r7, #8]
  40c752:	3380      	adds	r3, #128	; 0x80
  40c754:	697a      	ldr	r2, [r7, #20]
  40c756:	4619      	mov	r1, r3
  40c758:	4b29      	ldr	r3, [pc, #164]	; (40c800 <prvSetOptions+0x170>)
  40c75a:	4798      	blx	r3

			/* The header length divided by 4, goes into the higher nibble,
			effectively a shift-left 2. */
			pxTCPHeader->ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
  40c75c:	697b      	ldr	r3, [r7, #20]
  40c75e:	b2db      	uxtb	r3, r3
  40c760:	3314      	adds	r3, #20
  40c762:	b2db      	uxtb	r3, r3
  40c764:	009b      	lsls	r3, r3, #2
  40c766:	b2da      	uxtb	r2, r3
  40c768:	68fb      	ldr	r3, [r7, #12]
  40c76a:	731a      	strb	r2, [r3, #12]
  40c76c:	e03c      	b.n	40c7e8 <prvSetOptions+0x158>
		}
		else
	#endif	/* ipconfigUSE_TCP_WIN */
	if( ( pxSocket->u.xTCP.ucTCPState >= eESTABLISHED ) && ( pxSocket->u.xTCP.bits.bMssChange != pdFALSE_UNSIGNED ) )
  40c76e:	687b      	ldr	r3, [r7, #4]
  40c770:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
  40c774:	2b04      	cmp	r3, #4
  40c776:	d937      	bls.n	40c7e8 <prvSetOptions+0x158>
  40c778:	687b      	ldr	r3, [r7, #4]
  40c77a:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
  40c77e:	f003 0301 	and.w	r3, r3, #1
  40c782:	b2db      	uxtb	r3, r3
  40c784:	2b00      	cmp	r3, #0
  40c786:	d02f      	beq.n	40c7e8 <prvSetOptions+0x158>
	{
		/* TCP options must be sent because the MSS has changed. */
		pxSocket->u.xTCP.bits.bMssChange = pdFALSE_UNSIGNED;
  40c788:	687a      	ldr	r2, [r7, #4]
  40c78a:	f892 3040 	ldrb.w	r3, [r2, #64]	; 0x40
  40c78e:	f36f 0300 	bfc	r3, #0, #1
  40c792:	f882 3040 	strb.w	r3, [r2, #64]	; 0x40
		if( xTCPWindowLoggingLevel >= 0 )
  40c796:	4b17      	ldr	r3, [pc, #92]	; (40c7f4 <prvSetOptions+0x164>)
  40c798:	681b      	ldr	r3, [r3, #0]
  40c79a:	2b00      	cmp	r3, #0
  40c79c:	db06      	blt.n	40c7ac <prvSetOptions+0x11c>
		{
			FreeRTOS_debug_printf( ( "MSS: sending %d\n", pxSocket->u.xTCP.usCurMSS ) );
  40c79e:	687b      	ldr	r3, [r7, #4]
  40c7a0:	f8b3 304a 	ldrh.w	r3, [r3, #74]	; 0x4a
  40c7a4:	4619      	mov	r1, r3
  40c7a6:	4817      	ldr	r0, [pc, #92]	; (40c804 <prvSetOptions+0x174>)
  40c7a8:	4b14      	ldr	r3, [pc, #80]	; (40c7fc <prvSetOptions+0x16c>)
  40c7aa:	4798      	blx	r3
		}

		pxTCPHeader->ucOptdata[ 0 ] = TCP_OPT_MSS;
  40c7ac:	68fb      	ldr	r3, [r7, #12]
  40c7ae:	2202      	movs	r2, #2
  40c7b0:	751a      	strb	r2, [r3, #20]
		pxTCPHeader->ucOptdata[ 1 ] = TCP_OPT_MSS_LEN;
  40c7b2:	68fb      	ldr	r3, [r7, #12]
  40c7b4:	2204      	movs	r2, #4
  40c7b6:	755a      	strb	r2, [r3, #21]
		pxTCPHeader->ucOptdata[ 2 ] = ( uint8_t ) ( ( pxSocket->u.xTCP.usCurMSS ) >> 8 );
  40c7b8:	687b      	ldr	r3, [r7, #4]
  40c7ba:	f8b3 304a 	ldrh.w	r3, [r3, #74]	; 0x4a
  40c7be:	0a1b      	lsrs	r3, r3, #8
  40c7c0:	b29b      	uxth	r3, r3
  40c7c2:	b2da      	uxtb	r2, r3
  40c7c4:	68fb      	ldr	r3, [r7, #12]
  40c7c6:	759a      	strb	r2, [r3, #22]
		pxTCPHeader->ucOptdata[ 3 ] = ( uint8_t ) ( ( pxSocket->u.xTCP.usCurMSS ) & 0xffu );
  40c7c8:	687b      	ldr	r3, [r7, #4]
  40c7ca:	f8b3 304a 	ldrh.w	r3, [r3, #74]	; 0x4a
  40c7ce:	b2da      	uxtb	r2, r3
  40c7d0:	68fb      	ldr	r3, [r7, #12]
  40c7d2:	75da      	strb	r2, [r3, #23]
		uxOptionsLength = 4u;
  40c7d4:	2304      	movs	r3, #4
  40c7d6:	617b      	str	r3, [r7, #20]
		pxTCPHeader->ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
  40c7d8:	697b      	ldr	r3, [r7, #20]
  40c7da:	b2db      	uxtb	r3, r3
  40c7dc:	3314      	adds	r3, #20
  40c7de:	b2db      	uxtb	r3, r3
  40c7e0:	009b      	lsls	r3, r3, #2
  40c7e2:	b2da      	uxtb	r2, r3
  40c7e4:	68fb      	ldr	r3, [r7, #12]
  40c7e6:	731a      	strb	r2, [r3, #12]
	}

	return uxOptionsLength;
  40c7e8:	697b      	ldr	r3, [r7, #20]
}
  40c7ea:	4618      	mov	r0, r3
  40c7ec:	371c      	adds	r7, #28
  40c7ee:	46bd      	mov	sp, r7
  40c7f0:	bd90      	pop	{r4, r7, pc}
  40c7f2:	bf00      	nop
  40c7f4:	20006d60 	.word	0x20006d60
  40c7f8:	0041d4dc 	.word	0x0041d4dc
  40c7fc:	00416c7d 	.word	0x00416c7d
  40c800:	00416d05 	.word	0x00416d05
  40c804:	0041d508 	.word	0x0041d508

0040c808 <prvHandleSynReceived>:
 * Called from the states: eSYN_RECEIVED and eCONNECT_SYN
 * If the flags received are correct, the socket will move to eESTABLISHED.
 */
static BaseType_t prvHandleSynReceived( FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t **ppxNetworkBuffer,
	uint32_t ulReceiveLength, UBaseType_t uxOptionsLength )
{
  40c808:	b590      	push	{r4, r7, lr}
  40c80a:	b08f      	sub	sp, #60	; 0x3c
  40c80c:	af02      	add	r7, sp, #8
  40c80e:	60f8      	str	r0, [r7, #12]
  40c810:	60b9      	str	r1, [r7, #8]
  40c812:	607a      	str	r2, [r7, #4]
  40c814:	603b      	str	r3, [r7, #0]
TCPPacket_t *pxTCPPacket = ( TCPPacket_t * ) ( (*ppxNetworkBuffer)->pucEthernetBuffer );
  40c816:	68bb      	ldr	r3, [r7, #8]
  40c818:	681b      	ldr	r3, [r3, #0]
  40c81a:	699b      	ldr	r3, [r3, #24]
  40c81c:	627b      	str	r3, [r7, #36]	; 0x24
TCPHeader_t *pxTCPHeader = &pxTCPPacket->xTCPHeader;
  40c81e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40c820:	3322      	adds	r3, #34	; 0x22
  40c822:	623b      	str	r3, [r7, #32]
TCPWindow_t *pxTCPWindow = &pxSocket->u.xTCP.xTCPWindow;
  40c824:	68fb      	ldr	r3, [r7, #12]
  40c826:	33d0      	adds	r3, #208	; 0xd0
  40c828:	61fb      	str	r3, [r7, #28]
uint8_t ucTCPFlags = pxTCPHeader->ucTCPFlags;
  40c82a:	6a3b      	ldr	r3, [r7, #32]
  40c82c:	7b5b      	ldrb	r3, [r3, #13]
  40c82e:	76fb      	strb	r3, [r7, #27]
uint32_t ulSequenceNumber = FreeRTOS_ntohl( pxTCPHeader->ulSequenceNumber );
  40c830:	6a3b      	ldr	r3, [r7, #32]
  40c832:	685b      	ldr	r3, [r3, #4]
  40c834:	061a      	lsls	r2, r3, #24
  40c836:	6a3b      	ldr	r3, [r7, #32]
  40c838:	685b      	ldr	r3, [r3, #4]
  40c83a:	021b      	lsls	r3, r3, #8
  40c83c:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
  40c840:	431a      	orrs	r2, r3
  40c842:	6a3b      	ldr	r3, [r7, #32]
  40c844:	685b      	ldr	r3, [r3, #4]
  40c846:	0a1b      	lsrs	r3, r3, #8
  40c848:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
  40c84c:	431a      	orrs	r2, r3
  40c84e:	6a3b      	ldr	r3, [r7, #32]
  40c850:	685b      	ldr	r3, [r3, #4]
  40c852:	0e1b      	lsrs	r3, r3, #24
  40c854:	4313      	orrs	r3, r2
  40c856:	617b      	str	r3, [r7, #20]
BaseType_t xSendLength = 0;
  40c858:	2300      	movs	r3, #0
  40c85a:	62fb      	str	r3, [r7, #44]	; 0x2c

	/* Either expect a ACK or a SYN+ACK. */
	uint16_t usExpect = ( uint16_t ) ipTCP_FLAG_ACK;
  40c85c:	2310      	movs	r3, #16
  40c85e:	857b      	strh	r3, [r7, #42]	; 0x2a
	if( pxSocket->u.xTCP.ucTCPState == eCONNECT_SYN )
  40c860:	68fb      	ldr	r3, [r7, #12]
  40c862:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
  40c866:	2b02      	cmp	r3, #2
  40c868:	d103      	bne.n	40c872 <prvHandleSynReceived+0x6a>
	{
		usExpect |= ( uint16_t ) ipTCP_FLAG_SYN;
  40c86a:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
  40c86c:	f043 0302 	orr.w	r3, r3, #2
  40c870:	857b      	strh	r3, [r7, #42]	; 0x2a
	}

	if( ( ucTCPFlags & 0x17u ) != usExpect )
  40c872:	7efb      	ldrb	r3, [r7, #27]
  40c874:	f003 0217 	and.w	r2, r3, #23
  40c878:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
  40c87a:	429a      	cmp	r2, r3
  40c87c:	d023      	beq.n	40c8c6 <prvHandleSynReceived+0xbe>
	{
		/* eSYN_RECEIVED: flags 0010 expected, not 0002. */
		/* eSYN_RECEIVED: flags ACK  expected, not SYN. */
		FreeRTOS_debug_printf( ( "%s: flags %04X expected, not %04X\n",
  40c87e:	68fb      	ldr	r3, [r7, #12]
  40c880:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
  40c884:	2b04      	cmp	r3, #4
  40c886:	d101      	bne.n	40c88c <prvHandleSynReceived+0x84>
  40c888:	4955      	ldr	r1, [pc, #340]	; (40c9e0 <prvHandleSynReceived+0x1d8>)
  40c88a:	e000      	b.n	40c88e <prvHandleSynReceived+0x86>
  40c88c:	4955      	ldr	r1, [pc, #340]	; (40c9e4 <prvHandleSynReceived+0x1dc>)
  40c88e:	8d7a      	ldrh	r2, [r7, #42]	; 0x2a
  40c890:	7efb      	ldrb	r3, [r7, #27]
  40c892:	4855      	ldr	r0, [pc, #340]	; (40c9e8 <prvHandleSynReceived+0x1e0>)
  40c894:	4c55      	ldr	r4, [pc, #340]	; (40c9ec <prvHandleSynReceived+0x1e4>)
  40c896:	47a0      	blx	r4
			pxSocket->u.xTCP.ucTCPState == eSYN_RECEIVED ? "eSYN_RECEIVED" : "eCONNECT_SYN",
			usExpect, ucTCPFlags ) );
		vTCPStateChange( pxSocket, eCLOSE_WAIT );
  40c898:	2108      	movs	r1, #8
  40c89a:	68f8      	ldr	r0, [r7, #12]
  40c89c:	4b54      	ldr	r3, [pc, #336]	; (40c9f0 <prvHandleSynReceived+0x1e8>)
  40c89e:	4798      	blx	r3
		pxTCPHeader->ucTCPFlags |= ipTCP_FLAG_RST;
  40c8a0:	6a3b      	ldr	r3, [r7, #32]
  40c8a2:	7b5b      	ldrb	r3, [r3, #13]
  40c8a4:	f043 0304 	orr.w	r3, r3, #4
  40c8a8:	b2da      	uxtb	r2, r3
  40c8aa:	6a3b      	ldr	r3, [r7, #32]
  40c8ac:	735a      	strb	r2, [r3, #13]
		xSendLength = ( BaseType_t ) ( ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER + uxOptionsLength );
  40c8ae:	683b      	ldr	r3, [r7, #0]
  40c8b0:	3328      	adds	r3, #40	; 0x28
  40c8b2:	62fb      	str	r3, [r7, #44]	; 0x2c
		pxTCPHeader->ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
  40c8b4:	683b      	ldr	r3, [r7, #0]
  40c8b6:	b2db      	uxtb	r3, r3
  40c8b8:	3314      	adds	r3, #20
  40c8ba:	b2db      	uxtb	r3, r3
  40c8bc:	009b      	lsls	r3, r3, #2
  40c8be:	b2da      	uxtb	r2, r3
  40c8c0:	6a3b      	ldr	r3, [r7, #32]
  40c8c2:	731a      	strb	r2, [r3, #12]
  40c8c4:	e086      	b.n	40c9d4 <prvHandleSynReceived+0x1cc>
	}
	else
	{
		pxTCPWindow->usPeerPortNumber = pxSocket->u.xTCP.usRemotePort;
  40c8c6:	68fb      	ldr	r3, [r7, #12]
  40c8c8:	8f9a      	ldrh	r2, [r3, #60]	; 0x3c
  40c8ca:	69fb      	ldr	r3, [r7, #28]
  40c8cc:	f8a3 20ba 	strh.w	r2, [r3, #186]	; 0xba
		pxTCPWindow->usOurPortNumber = pxSocket->usLocalPort;
  40c8d0:	68fb      	ldr	r3, [r7, #12]
  40c8d2:	8c9a      	ldrh	r2, [r3, #36]	; 0x24
  40c8d4:	69fb      	ldr	r3, [r7, #28]
  40c8d6:	f8a3 20b8 	strh.w	r2, [r3, #184]	; 0xb8

		if( pxSocket->u.xTCP.ucTCPState == eCONNECT_SYN )
  40c8da:	68fb      	ldr	r3, [r7, #12]
  40c8dc:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
  40c8e0:	2b02      	cmp	r3, #2
  40c8e2:	d125      	bne.n	40c930 <prvHandleSynReceived+0x128>
		{
			TCPPacket_t *pxLastTCPPacket = ( TCPPacket_t * ) ( pxSocket->u.xTCP.xPacket.u.ucLastPacket );
  40c8e4:	68fb      	ldr	r3, [r7, #12]
  40c8e6:	337a      	adds	r3, #122	; 0x7a
  40c8e8:	613b      	str	r3, [r7, #16]

			/* Clear the SYN flag in lastPacket. */
			pxLastTCPPacket->xTCPHeader.ucTCPFlags = ipTCP_FLAG_ACK;
  40c8ea:	693b      	ldr	r3, [r7, #16]
  40c8ec:	2210      	movs	r2, #16
  40c8ee:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f

			/* This socket was the one connecting actively so now perofmr the
			synchronisation. */
			vTCPWindowInit( &pxSocket->u.xTCP.xTCPWindow,
  40c8f2:	68fb      	ldr	r3, [r7, #12]
  40c8f4:	f103 00d0 	add.w	r0, r3, #208	; 0xd0
  40c8f8:	68fb      	ldr	r3, [r7, #12]
  40c8fa:	f8d3 20fc 	ldr.w	r2, [r3, #252]	; 0xfc
				ulSequenceNumber, pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber, ( uint32_t ) pxSocket->u.xTCP.usCurMSS );
  40c8fe:	68fb      	ldr	r3, [r7, #12]
  40c900:	f8b3 304a 	ldrh.w	r3, [r3, #74]	; 0x4a
			vTCPWindowInit( &pxSocket->u.xTCP.xTCPWindow,
  40c904:	6979      	ldr	r1, [r7, #20]
  40c906:	4c3b      	ldr	r4, [pc, #236]	; (40c9f4 <prvHandleSynReceived+0x1ec>)
  40c908:	47a0      	blx	r4
			pxTCPWindow->rx.ulCurrentSequenceNumber = pxTCPWindow->rx.ulHighestSequenceNumber = ulSequenceNumber + 1u;
  40c90a:	697b      	ldr	r3, [r7, #20]
  40c90c:	1c5a      	adds	r2, r3, #1
  40c90e:	69fb      	ldr	r3, [r7, #28]
  40c910:	619a      	str	r2, [r3, #24]
  40c912:	69fb      	ldr	r3, [r7, #28]
  40c914:	699a      	ldr	r2, [r3, #24]
  40c916:	69fb      	ldr	r3, [r7, #28]
  40c918:	611a      	str	r2, [r3, #16]
			pxTCPWindow->tx.ulCurrentSequenceNumber++; /* because we send a TCP_SYN [ | TCP_ACK ]; */
  40c91a:	69fb      	ldr	r3, [r7, #28]
  40c91c:	6a1b      	ldr	r3, [r3, #32]
  40c91e:	1c5a      	adds	r2, r3, #1
  40c920:	69fb      	ldr	r3, [r7, #28]
  40c922:	621a      	str	r2, [r3, #32]
			pxTCPWindow->ulNextTxSequenceNumber++;
  40c924:	69fb      	ldr	r3, [r7, #28]
  40c926:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  40c928:	1c5a      	adds	r2, r3, #1
  40c92a:	69fb      	ldr	r3, [r7, #28]
  40c92c:	635a      	str	r2, [r3, #52]	; 0x34
  40c92e:	e005      	b.n	40c93c <prvHandleSynReceived+0x134>
		}
		else if( ulReceiveLength == 0u )
  40c930:	687b      	ldr	r3, [r7, #4]
  40c932:	2b00      	cmp	r3, #0
  40c934:	d102      	bne.n	40c93c <prvHandleSynReceived+0x134>
		{
			pxTCPWindow->rx.ulCurrentSequenceNumber = ulSequenceNumber;
  40c936:	69fb      	ldr	r3, [r7, #28]
  40c938:	697a      	ldr	r2, [r7, #20]
  40c93a:	611a      	str	r2, [r3, #16]
		}

		/* The SYN+ACK has been confirmed, increase the next sequence number by
		1. */
		pxTCPWindow->ulOurSequenceNumber = pxTCPWindow->tx.ulFirstSequenceNumber + 1u;
  40c93c:	69fb      	ldr	r3, [r7, #28]
  40c93e:	69db      	ldr	r3, [r3, #28]
  40c940:	1c5a      	adds	r2, r3, #1
  40c942:	69fb      	ldr	r3, [r7, #28]
  40c944:	62da      	str	r2, [r3, #44]	; 0x2c

		#if( ipconfigUSE_TCP_WIN == 1 )
		{
			FreeRTOS_debug_printf( ( "TCP: %s %d => %lxip:%d set ESTAB (scaling %u)\n",
  40c946:	68fb      	ldr	r3, [r7, #12]
  40c948:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
  40c94c:	2b02      	cmp	r3, #2
  40c94e:	d101      	bne.n	40c954 <prvHandleSynReceived+0x14c>
  40c950:	4929      	ldr	r1, [pc, #164]	; (40c9f8 <prvHandleSynReceived+0x1f0>)
  40c952:	e000      	b.n	40c956 <prvHandleSynReceived+0x14e>
  40c954:	4929      	ldr	r1, [pc, #164]	; (40c9fc <prvHandleSynReceived+0x1f4>)
  40c956:	68fb      	ldr	r3, [r7, #12]
  40c958:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
  40c95a:	461c      	mov	r4, r3
  40c95c:	68fb      	ldr	r3, [r7, #12]
  40c95e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  40c960:	68fb      	ldr	r3, [r7, #12]
  40c962:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
  40c964:	4618      	mov	r0, r3
  40c966:	68fb      	ldr	r3, [r7, #12]
  40c968:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
  40c96c:	f3c3 1300 	ubfx	r3, r3, #4, #1
  40c970:	b2db      	uxtb	r3, r3
  40c972:	9301      	str	r3, [sp, #4]
  40c974:	9000      	str	r0, [sp, #0]
  40c976:	4613      	mov	r3, r2
  40c978:	4622      	mov	r2, r4
  40c97a:	4821      	ldr	r0, [pc, #132]	; (40ca00 <prvHandleSynReceived+0x1f8>)
  40c97c:	4c1b      	ldr	r4, [pc, #108]	; (40c9ec <prvHandleSynReceived+0x1e4>)
  40c97e:	47a0      	blx	r4
				pxSocket->u.xTCP.usRemotePort,
				( unsigned ) pxSocket->u.xTCP.bits.bWinScaling ) );
		}
		#endif /* ipconfigUSE_TCP_WIN */

		if( ( pxSocket->u.xTCP.ucTCPState == eCONNECT_SYN ) || ( ulReceiveLength != 0u ) )
  40c980:	68fb      	ldr	r3, [r7, #12]
  40c982:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
  40c986:	2b02      	cmp	r3, #2
  40c988:	d002      	beq.n	40c990 <prvHandleSynReceived+0x188>
  40c98a:	687b      	ldr	r3, [r7, #4]
  40c98c:	2b00      	cmp	r3, #0
  40c98e:	d00d      	beq.n	40c9ac <prvHandleSynReceived+0x1a4>
		{
			pxTCPHeader->ucTCPFlags = ipTCP_FLAG_ACK;
  40c990:	6a3b      	ldr	r3, [r7, #32]
  40c992:	2210      	movs	r2, #16
  40c994:	735a      	strb	r2, [r3, #13]
			xSendLength = ( BaseType_t ) ( ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER + uxOptionsLength );
  40c996:	683b      	ldr	r3, [r7, #0]
  40c998:	3328      	adds	r3, #40	; 0x28
  40c99a:	62fb      	str	r3, [r7, #44]	; 0x2c
			pxTCPHeader->ucTCPOffset = ( uint8_t ) ( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
  40c99c:	683b      	ldr	r3, [r7, #0]
  40c99e:	b2db      	uxtb	r3, r3
  40c9a0:	3314      	adds	r3, #20
  40c9a2:	b2db      	uxtb	r3, r3
  40c9a4:	009b      	lsls	r3, r3, #2
  40c9a6:	b2da      	uxtb	r2, r3
  40c9a8:	6a3b      	ldr	r3, [r7, #32]
  40c9aa:	731a      	strb	r2, [r3, #12]
		}
		#if( ipconfigUSE_TCP_WIN != 0 )
		{
			if( pxSocket->u.xTCP.bits.bWinScaling == pdFALSE_UNSIGNED )
  40c9ac:	68fb      	ldr	r3, [r7, #12]
  40c9ae:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
  40c9b2:	f003 0310 	and.w	r3, r3, #16
  40c9b6:	b2db      	uxtb	r3, r3
  40c9b8:	2b00      	cmp	r3, #0
  40c9ba:	d107      	bne.n	40c9cc <prvHandleSynReceived+0x1c4>
			{
				/* The other party did not send a scaling factor.
				A shifting factor in this side must be canceled. */
				pxSocket->u.xTCP.ucMyWinScaleFactor = 0;
  40c9bc:	68fb      	ldr	r3, [r7, #12]
  40c9be:	2200      	movs	r2, #0
  40c9c0:	f883 20c1 	strb.w	r2, [r3, #193]	; 0xc1
				pxSocket->u.xTCP.ucPeerWinScaleFactor = 0;
  40c9c4:	68fb      	ldr	r3, [r7, #12]
  40c9c6:	2200      	movs	r2, #0
  40c9c8:	f883 20c2 	strb.w	r2, [r3, #194]	; 0xc2
			}
		}
		#endif /* ipconfigUSE_TCP_WIN */
		/* This was the third step of connecting: SYN, SYN+ACK, ACK	so now the
		connection is established. */
		vTCPStateChange( pxSocket, eESTABLISHED );
  40c9cc:	2105      	movs	r1, #5
  40c9ce:	68f8      	ldr	r0, [r7, #12]
  40c9d0:	4b07      	ldr	r3, [pc, #28]	; (40c9f0 <prvHandleSynReceived+0x1e8>)
  40c9d2:	4798      	blx	r3
	}

	return xSendLength;
  40c9d4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
}
  40c9d6:	4618      	mov	r0, r3
  40c9d8:	3734      	adds	r7, #52	; 0x34
  40c9da:	46bd      	mov	sp, r7
  40c9dc:	bd90      	pop	{r4, r7, pc}
  40c9de:	bf00      	nop
  40c9e0:	0041d0e0 	.word	0x0041d0e0
  40c9e4:	0041d0c4 	.word	0x0041d0c4
  40c9e8:	0041d51c 	.word	0x0041d51c
  40c9ec:	00416c7d 	.word	0x00416c7d
  40c9f0:	0040bbc1 	.word	0x0040bbc1
  40c9f4:	0040df35 	.word	0x0040df35
  40c9f8:	0041d540 	.word	0x0041d540
  40c9fc:	0041d548 	.word	0x0041d548
  40ca00:	0041d550 	.word	0x0041d550

0040ca04 <prvHandleEstablished>:
 * the code will check if it may be accepted, i.e. if all expected data has been
 * completely received.
 */
static BaseType_t prvHandleEstablished( FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t **ppxNetworkBuffer,
	uint32_t ulReceiveLength, UBaseType_t uxOptionsLength )
{
  40ca04:	b590      	push	{r4, r7, lr}
  40ca06:	b093      	sub	sp, #76	; 0x4c
  40ca08:	af02      	add	r7, sp, #8
  40ca0a:	60f8      	str	r0, [r7, #12]
  40ca0c:	60b9      	str	r1, [r7, #8]
  40ca0e:	607a      	str	r2, [r7, #4]
  40ca10:	603b      	str	r3, [r7, #0]
TCPPacket_t *pxTCPPacket = ( TCPPacket_t * ) ( (*ppxNetworkBuffer)->pucEthernetBuffer );
  40ca12:	68bb      	ldr	r3, [r7, #8]
  40ca14:	681b      	ldr	r3, [r3, #0]
  40ca16:	699b      	ldr	r3, [r3, #24]
  40ca18:	637b      	str	r3, [r7, #52]	; 0x34
TCPHeader_t *pxTCPHeader = &pxTCPPacket->xTCPHeader;
  40ca1a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40ca1c:	3322      	adds	r3, #34	; 0x22
  40ca1e:	633b      	str	r3, [r7, #48]	; 0x30
TCPWindow_t *pxTCPWindow = &pxSocket->u.xTCP.xTCPWindow;
  40ca20:	68fb      	ldr	r3, [r7, #12]
  40ca22:	33d0      	adds	r3, #208	; 0xd0
  40ca24:	62fb      	str	r3, [r7, #44]	; 0x2c
uint8_t ucTCPFlags = pxTCPHeader->ucTCPFlags;
  40ca26:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  40ca28:	7b5b      	ldrb	r3, [r3, #13]
  40ca2a:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
uint32_t ulSequenceNumber = FreeRTOS_ntohl( pxTCPHeader->ulSequenceNumber ), ulCount;
  40ca2e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  40ca30:	685b      	ldr	r3, [r3, #4]
  40ca32:	061a      	lsls	r2, r3, #24
  40ca34:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  40ca36:	685b      	ldr	r3, [r3, #4]
  40ca38:	021b      	lsls	r3, r3, #8
  40ca3a:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
  40ca3e:	431a      	orrs	r2, r3
  40ca40:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  40ca42:	685b      	ldr	r3, [r3, #4]
  40ca44:	0a1b      	lsrs	r3, r3, #8
  40ca46:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
  40ca4a:	431a      	orrs	r2, r3
  40ca4c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  40ca4e:	685b      	ldr	r3, [r3, #4]
  40ca50:	0e1b      	lsrs	r3, r3, #24
  40ca52:	4313      	orrs	r3, r2
  40ca54:	627b      	str	r3, [r7, #36]	; 0x24
BaseType_t xSendLength = 0, xMayClose = pdFALSE, bRxComplete, bTxDone;
  40ca56:	2300      	movs	r3, #0
  40ca58:	63fb      	str	r3, [r7, #60]	; 0x3c
  40ca5a:	2300      	movs	r3, #0
  40ca5c:	63bb      	str	r3, [r7, #56]	; 0x38
int32_t lDistance, lSendResult;

	/* Remember the window size the peer is advertising. */
	pxSocket->u.xTCP.ulWindowSize = FreeRTOS_ntohs( pxTCPHeader->usWindow );
  40ca5e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  40ca60:	89db      	ldrh	r3, [r3, #14]
  40ca62:	b29b      	uxth	r3, r3
  40ca64:	021b      	lsls	r3, r3, #8
  40ca66:	b21a      	sxth	r2, r3
  40ca68:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  40ca6a:	89db      	ldrh	r3, [r3, #14]
  40ca6c:	b29b      	uxth	r3, r3
  40ca6e:	0a1b      	lsrs	r3, r3, #8
  40ca70:	b29b      	uxth	r3, r3
  40ca72:	b21b      	sxth	r3, r3
  40ca74:	4313      	orrs	r3, r2
  40ca76:	b21b      	sxth	r3, r3
  40ca78:	b29b      	uxth	r3, r3
  40ca7a:	461a      	mov	r2, r3
  40ca7c:	68fb      	ldr	r3, [r7, #12]
  40ca7e:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
	#if( ipconfigUSE_TCP_WIN != 0 )
	{
		pxSocket->u.xTCP.ulWindowSize =
			( pxSocket->u.xTCP.ulWindowSize << pxSocket->u.xTCP.ucPeerWinScaleFactor );
  40ca82:	68fb      	ldr	r3, [r7, #12]
  40ca84:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
  40ca88:	68fa      	ldr	r2, [r7, #12]
  40ca8a:	f892 20c2 	ldrb.w	r2, [r2, #194]	; 0xc2
  40ca8e:	fa03 f202 	lsl.w	r2, r3, r2
		pxSocket->u.xTCP.ulWindowSize =
  40ca92:	68fb      	ldr	r3, [r7, #12]
  40ca94:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
	}
	#endif

	if( ( ucTCPFlags & ( uint8_t ) ipTCP_FLAG_ACK ) != 0u )
  40ca98:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
  40ca9c:	f003 0310 	and.w	r3, r3, #16
  40caa0:	2b00      	cmp	r3, #0
  40caa2:	d040      	beq.n	40cb26 <prvHandleEstablished+0x122>
	{
		ulCount = ulTCPWindowTxAck( pxTCPWindow, FreeRTOS_ntohl( pxTCPPacket->xTCPHeader.ulAckNr ) );
  40caa4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40caa6:	f8d3 302a 	ldr.w	r3, [r3, #42]	; 0x2a
  40caaa:	061a      	lsls	r2, r3, #24
  40caac:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40caae:	f8d3 302a 	ldr.w	r3, [r3, #42]	; 0x2a
  40cab2:	021b      	lsls	r3, r3, #8
  40cab4:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
  40cab8:	431a      	orrs	r2, r3
  40caba:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40cabc:	f8d3 302a 	ldr.w	r3, [r3, #42]	; 0x2a
  40cac0:	0a1b      	lsrs	r3, r3, #8
  40cac2:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
  40cac6:	431a      	orrs	r2, r3
  40cac8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40caca:	f8d3 302a 	ldr.w	r3, [r3, #42]	; 0x2a
  40cace:	0e1b      	lsrs	r3, r3, #24
  40cad0:	4313      	orrs	r3, r2
  40cad2:	4619      	mov	r1, r3
  40cad4:	6af8      	ldr	r0, [r7, #44]	; 0x2c
  40cad6:	4b6f      	ldr	r3, [pc, #444]	; (40cc94 <prvHandleEstablished+0x290>)
  40cad8:	4798      	blx	r3
  40cada:	6238      	str	r0, [r7, #32]

		/* ulTCPWindowTxAck() returns the number of bytes which have been acked,
		starting at 'tx.ulCurrentSequenceNumber'.  Advance the tail pointer in
		txStream. */
		if( ( pxSocket->u.xTCP.txStream != NULL ) && ( ulCount > 0u ) )
  40cadc:	68fb      	ldr	r3, [r7, #12]
  40cade:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  40cae0:	2b00      	cmp	r3, #0
  40cae2:	d020      	beq.n	40cb26 <prvHandleEstablished+0x122>
  40cae4:	6a3b      	ldr	r3, [r7, #32]
  40cae6:	2b00      	cmp	r3, #0
  40cae8:	d01d      	beq.n	40cb26 <prvHandleEstablished+0x122>
		{
			/* Just advancing the tail index, 'ulCount' bytes have been
			confirmed, and because there is new space in the txStream, the
			user/owner should be woken up. */
			/* _HT_ : only in case the socket's waiting? */
			if( uxStreamBufferGet( pxSocket->u.xTCP.txStream, 0u, NULL, ( size_t ) ulCount, pdFALSE ) != 0u )
  40caea:	68fb      	ldr	r3, [r7, #12]
  40caec:	6f18      	ldr	r0, [r3, #112]	; 0x70
  40caee:	2300      	movs	r3, #0
  40caf0:	9300      	str	r3, [sp, #0]
  40caf2:	6a3b      	ldr	r3, [r7, #32]
  40caf4:	2200      	movs	r2, #0
  40caf6:	2100      	movs	r1, #0
  40caf8:	4c67      	ldr	r4, [pc, #412]	; (40cc98 <prvHandleEstablished+0x294>)
  40cafa:	47a0      	blx	r4
  40cafc:	4603      	mov	r3, r0
  40cafe:	2b00      	cmp	r3, #0
  40cb00:	d011      	beq.n	40cb26 <prvHandleEstablished+0x122>
			{
				pxSocket->xEventBits |= eSOCKET_SEND;
  40cb02:	68fb      	ldr	r3, [r7, #12]
  40cb04:	681b      	ldr	r3, [r3, #0]
  40cb06:	f043 0202 	orr.w	r2, r3, #2
  40cb0a:	68fb      	ldr	r3, [r7, #12]
  40cb0c:	601a      	str	r2, [r3, #0]

				#if ipconfigSUPPORT_SELECT_FUNCTION == 1
				{
					if( ( pxSocket->xSelectBits & eSELECT_WRITE ) != 0 )
  40cb0e:	68fb      	ldr	r3, [r7, #12]
  40cb10:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  40cb12:	f003 0302 	and.w	r3, r3, #2
  40cb16:	2b00      	cmp	r3, #0
  40cb18:	d005      	beq.n	40cb26 <prvHandleEstablished+0x122>
					{
						pxSocket->xEventBits |= ( eSELECT_WRITE << SOCKET_EVENT_BIT_COUNT );
  40cb1a:	68fb      	ldr	r3, [r7, #12]
  40cb1c:	681b      	ldr	r3, [r3, #0]
  40cb1e:	f443 7200 	orr.w	r2, r3, #512	; 0x200
  40cb22:	68fb      	ldr	r3, [r7, #12]
  40cb24:	601a      	str	r2, [r3, #0]
		}
	}

	/* If this socket has a stream for transmission, add the data to the
	outgoing segment(s). */
	if( pxSocket->u.xTCP.txStream != NULL )
  40cb26:	68fb      	ldr	r3, [r7, #12]
  40cb28:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  40cb2a:	2b00      	cmp	r3, #0
  40cb2c:	d002      	beq.n	40cb34 <prvHandleEstablished+0x130>
	{
		prvTCPAddTxData( pxSocket );
  40cb2e:	68f8      	ldr	r0, [r7, #12]
  40cb30:	4b5a      	ldr	r3, [pc, #360]	; (40cc9c <prvHandleEstablished+0x298>)
  40cb32:	4798      	blx	r3
	}

	pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber = pxTCPWindow->tx.ulCurrentSequenceNumber;
  40cb34:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40cb36:	6a1a      	ldr	r2, [r3, #32]
  40cb38:	68fb      	ldr	r3, [r7, #12]
  40cb3a:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc

	if( ( pxSocket->u.xTCP.bits.bFinAccepted != pdFALSE_UNSIGNED ) || ( ( ucTCPFlags & ( uint8_t ) ipTCP_FLAG_FIN ) != 0u ) )
  40cb3e:	68fb      	ldr	r3, [r7, #12]
  40cb40:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
  40cb44:	f003 0320 	and.w	r3, r3, #32
  40cb48:	b2db      	uxtb	r3, r3
  40cb4a:	2b00      	cmp	r3, #0
  40cb4c:	d105      	bne.n	40cb5a <prvHandleEstablished+0x156>
  40cb4e:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
  40cb52:	f003 0301 	and.w	r3, r3, #1
  40cb56:	2b00      	cmp	r3, #0
  40cb58:	d068      	beq.n	40cc2c <prvHandleEstablished+0x228>
	{
		/* Peer is requesting to stop, see if we're really finished. */
		xMayClose = pdTRUE;
  40cb5a:	2301      	movs	r3, #1
  40cb5c:	63bb      	str	r3, [r7, #56]	; 0x38

		/* Checks are only necessary if we haven't sent a FIN yet. */
		if( pxSocket->u.xTCP.bits.bFinSent == pdFALSE_UNSIGNED )
  40cb5e:	68fb      	ldr	r3, [r7, #12]
  40cb60:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
  40cb64:	f003 0340 	and.w	r3, r3, #64	; 0x40
  40cb68:	b2db      	uxtb	r3, r3
  40cb6a:	2b00      	cmp	r3, #0
  40cb6c:	d137      	bne.n	40cbde <prvHandleEstablished+0x1da>
		{
			/* xTCPWindowTxDone returns true when all Tx queues are empty. */
			bRxComplete = xTCPWindowRxEmpty( pxTCPWindow );
  40cb6e:	6af8      	ldr	r0, [r7, #44]	; 0x2c
  40cb70:	4b4b      	ldr	r3, [pc, #300]	; (40cca0 <prvHandleEstablished+0x29c>)
  40cb72:	4798      	blx	r3
  40cb74:	61f8      	str	r0, [r7, #28]
			bTxDone	 = xTCPWindowTxDone( pxTCPWindow );
  40cb76:	6af8      	ldr	r0, [r7, #44]	; 0x2c
  40cb78:	4b4a      	ldr	r3, [pc, #296]	; (40cca4 <prvHandleEstablished+0x2a0>)
  40cb7a:	4798      	blx	r3
  40cb7c:	61b8      	str	r0, [r7, #24]

			if( ( bRxComplete == 0 ) || ( bTxDone == 0 ) )
  40cb7e:	69fb      	ldr	r3, [r7, #28]
  40cb80:	2b00      	cmp	r3, #0
  40cb82:	d002      	beq.n	40cb8a <prvHandleEstablished+0x186>
  40cb84:	69bb      	ldr	r3, [r7, #24]
  40cb86:	2b00      	cmp	r3, #0
  40cb88:	d10e      	bne.n	40cba8 <prvHandleEstablished+0x1a4>
			{
				/* Refusing FIN: Rx incomp 1 optlen 4 tx done 1. */
				FreeRTOS_debug_printf( ( "Refusing FIN[%u,%u]: RxCompl %lu tx done %ld\n",
  40cb8a:	68fb      	ldr	r3, [r7, #12]
  40cb8c:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
  40cb8e:	4619      	mov	r1, r3
  40cb90:	68fb      	ldr	r3, [r7, #12]
  40cb92:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
  40cb94:	461a      	mov	r2, r3
  40cb96:	69bb      	ldr	r3, [r7, #24]
  40cb98:	9300      	str	r3, [sp, #0]
  40cb9a:	69fb      	ldr	r3, [r7, #28]
  40cb9c:	4842      	ldr	r0, [pc, #264]	; (40cca8 <prvHandleEstablished+0x2a4>)
  40cb9e:	4c43      	ldr	r4, [pc, #268]	; (40ccac <prvHandleEstablished+0x2a8>)
  40cba0:	47a0      	blx	r4
					pxSocket->usLocalPort,
					pxSocket->u.xTCP.usRemotePort,
					bRxComplete, bTxDone ) );
				xMayClose = pdFALSE;
  40cba2:	2300      	movs	r3, #0
  40cba4:	63bb      	str	r3, [r7, #56]	; 0x38
  40cba6:	e01a      	b.n	40cbde <prvHandleEstablished+0x1da>
			}
			else
			{
				lDistance = ( int32_t ) ( ulSequenceNumber + ulReceiveLength - pxTCPWindow->rx.ulCurrentSequenceNumber );
  40cba8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  40cbaa:	687b      	ldr	r3, [r7, #4]
  40cbac:	441a      	add	r2, r3
  40cbae:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40cbb0:	691b      	ldr	r3, [r3, #16]
  40cbb2:	1ad3      	subs	r3, r2, r3
  40cbb4:	617b      	str	r3, [r7, #20]

				if( lDistance > 1 )
  40cbb6:	697b      	ldr	r3, [r7, #20]
  40cbb8:	2b01      	cmp	r3, #1
  40cbba:	dd10      	ble.n	40cbde <prvHandleEstablished+0x1da>
				{
					FreeRTOS_debug_printf( ( "Refusing FIN: Rx not complete %ld (cur %lu high %lu)\n",
  40cbbc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40cbbe:	691a      	ldr	r2, [r3, #16]
  40cbc0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40cbc2:	68db      	ldr	r3, [r3, #12]
  40cbc4:	1ad1      	subs	r1, r2, r3
  40cbc6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40cbc8:	699a      	ldr	r2, [r3, #24]
  40cbca:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40cbcc:	68db      	ldr	r3, [r3, #12]
  40cbce:	1ad3      	subs	r3, r2, r3
  40cbd0:	460a      	mov	r2, r1
  40cbd2:	6979      	ldr	r1, [r7, #20]
  40cbd4:	4836      	ldr	r0, [pc, #216]	; (40ccb0 <prvHandleEstablished+0x2ac>)
  40cbd6:	4c35      	ldr	r4, [pc, #212]	; (40ccac <prvHandleEstablished+0x2a8>)
  40cbd8:	47a0      	blx	r4
						lDistance, pxTCPWindow->rx.ulCurrentSequenceNumber - pxTCPWindow->rx.ulFirstSequenceNumber,
						pxTCPWindow->rx.ulHighestSequenceNumber - pxTCPWindow->rx.ulFirstSequenceNumber ) );

					xMayClose = pdFALSE;
  40cbda:	2300      	movs	r3, #0
  40cbdc:	63bb      	str	r3, [r7, #56]	; 0x38
				}
			}
		}

		if( xTCPWindowLoggingLevel > 0 )
  40cbde:	4b35      	ldr	r3, [pc, #212]	; (40ccb4 <prvHandleEstablished+0x2b0>)
  40cbe0:	681b      	ldr	r3, [r3, #0]
  40cbe2:	2b00      	cmp	r3, #0
  40cbe4:	dd11      	ble.n	40cc0a <prvHandleEstablished+0x206>
		{
			FreeRTOS_debug_printf( ( "TCP: FIN received, mayClose = %ld (Rx %lu Len %ld, Tx %lu)\n",
  40cbe6:	68fb      	ldr	r3, [r7, #12]
  40cbe8:	f8d3 30dc 	ldr.w	r3, [r3, #220]	; 0xdc
  40cbec:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  40cbee:	1ad1      	subs	r1, r2, r3
  40cbf0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40cbf2:	6a1a      	ldr	r2, [r3, #32]
  40cbf4:	68fb      	ldr	r3, [r7, #12]
  40cbf6:	f8d3 30ec 	ldr.w	r3, [r3, #236]	; 0xec
  40cbfa:	1ad3      	subs	r3, r2, r3
  40cbfc:	9300      	str	r3, [sp, #0]
  40cbfe:	687b      	ldr	r3, [r7, #4]
  40cc00:	460a      	mov	r2, r1
  40cc02:	6bb9      	ldr	r1, [r7, #56]	; 0x38
  40cc04:	482c      	ldr	r0, [pc, #176]	; (40ccb8 <prvHandleEstablished+0x2b4>)
  40cc06:	4c29      	ldr	r4, [pc, #164]	; (40ccac <prvHandleEstablished+0x2a8>)
  40cc08:	47a0      	blx	r4
				xMayClose, ulSequenceNumber - pxSocket->u.xTCP.xTCPWindow.rx.ulFirstSequenceNumber, ulReceiveLength,
				pxTCPWindow->tx.ulCurrentSequenceNumber - pxSocket->u.xTCP.xTCPWindow.tx.ulFirstSequenceNumber ) );
		}

		if( xMayClose != pdFALSE )
  40cc0a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  40cc0c:	2b00      	cmp	r3, #0
  40cc0e:	d00d      	beq.n	40cc2c <prvHandleEstablished+0x228>
		{
			pxSocket->u.xTCP.bits.bFinAccepted = pdTRUE_UNSIGNED;
  40cc10:	68fa      	ldr	r2, [r7, #12]
  40cc12:	f892 3041 	ldrb.w	r3, [r2, #65]	; 0x41
  40cc16:	f043 0320 	orr.w	r3, r3, #32
  40cc1a:	f882 3041 	strb.w	r3, [r2, #65]	; 0x41
			xSendLength = prvTCPHandleFin( pxSocket, *ppxNetworkBuffer );
  40cc1e:	68bb      	ldr	r3, [r7, #8]
  40cc20:	681b      	ldr	r3, [r3, #0]
  40cc22:	4619      	mov	r1, r3
  40cc24:	68f8      	ldr	r0, [r7, #12]
  40cc26:	4b25      	ldr	r3, [pc, #148]	; (40ccbc <prvHandleEstablished+0x2b8>)
  40cc28:	4798      	blx	r3
  40cc2a:	63f8      	str	r0, [r7, #60]	; 0x3c
		}
	}

	if( xMayClose == pdFALSE )
  40cc2c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  40cc2e:	2b00      	cmp	r3, #0
  40cc30:	d12a      	bne.n	40cc88 <prvHandleEstablished+0x284>
	{
		pxTCPHeader->ucTCPFlags = ipTCP_FLAG_ACK;
  40cc32:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  40cc34:	2210      	movs	r2, #16
  40cc36:	735a      	strb	r2, [r3, #13]

		if( ulReceiveLength != 0u )
  40cc38:	687b      	ldr	r3, [r7, #4]
  40cc3a:	2b00      	cmp	r3, #0
  40cc3c:	d016      	beq.n	40cc6c <prvHandleEstablished+0x268>
		{
			xSendLength = ( BaseType_t ) ( ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER + uxOptionsLength );
  40cc3e:	683b      	ldr	r3, [r7, #0]
  40cc40:	3328      	adds	r3, #40	; 0x28
  40cc42:	63fb      	str	r3, [r7, #60]	; 0x3c
			/* TCP-offsett equals '( ( length / 4 ) << 4 )', resulting in a shift-left 2 */
			pxTCPHeader->ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
  40cc44:	683b      	ldr	r3, [r7, #0]
  40cc46:	b2db      	uxtb	r3, r3
  40cc48:	3314      	adds	r3, #20
  40cc4a:	b2db      	uxtb	r3, r3
  40cc4c:	009b      	lsls	r3, r3, #2
  40cc4e:	b2da      	uxtb	r2, r3
  40cc50:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  40cc52:	731a      	strb	r2, [r3, #12]

			if( pxSocket->u.xTCP.bits.bFinSent != pdFALSE_UNSIGNED )
  40cc54:	68fb      	ldr	r3, [r7, #12]
  40cc56:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
  40cc5a:	f003 0340 	and.w	r3, r3, #64	; 0x40
  40cc5e:	b2db      	uxtb	r3, r3
  40cc60:	2b00      	cmp	r3, #0
  40cc62:	d003      	beq.n	40cc6c <prvHandleEstablished+0x268>
			{
				pxTCPWindow->tx.ulCurrentSequenceNumber = pxTCPWindow->tx.ulFINSequenceNumber;
  40cc64:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40cc66:	6a5a      	ldr	r2, [r3, #36]	; 0x24
  40cc68:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40cc6a:	621a      	str	r2, [r3, #32]
		/* Now get data to be transmitted. */
		/* _HT_ patch: since the MTU has be fixed at 1500 in stead of 1526, TCP
		can not	send-out both TCP options and also a full packet. Sending
		options (SACK) is always more urgent than sending data, which can be
		sent later. */
		if( uxOptionsLength == 0u )
  40cc6c:	683b      	ldr	r3, [r7, #0]
  40cc6e:	2b00      	cmp	r3, #0
  40cc70:	d10a      	bne.n	40cc88 <prvHandleEstablished+0x284>
		{
			/* prvTCPPrepareSend might allocate a bigger network buffer, if
			necessary. */
			lSendResult = prvTCPPrepareSend( pxSocket, ppxNetworkBuffer, uxOptionsLength );
  40cc72:	683a      	ldr	r2, [r7, #0]
  40cc74:	68b9      	ldr	r1, [r7, #8]
  40cc76:	68f8      	ldr	r0, [r7, #12]
  40cc78:	4b11      	ldr	r3, [pc, #68]	; (40ccc0 <prvHandleEstablished+0x2bc>)
  40cc7a:	4798      	blx	r3
  40cc7c:	6138      	str	r0, [r7, #16]
			if( lSendResult > 0 )
  40cc7e:	693b      	ldr	r3, [r7, #16]
  40cc80:	2b00      	cmp	r3, #0
  40cc82:	dd01      	ble.n	40cc88 <prvHandleEstablished+0x284>
			{
				xSendLength = ( BaseType_t ) lSendResult;
  40cc84:	693b      	ldr	r3, [r7, #16]
  40cc86:	63fb      	str	r3, [r7, #60]	; 0x3c
			}
		}
	}

	return xSendLength;
  40cc88:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
}
  40cc8a:	4618      	mov	r0, r3
  40cc8c:	3744      	adds	r7, #68	; 0x44
  40cc8e:	46bd      	mov	sp, r7
  40cc90:	bd90      	pop	{r4, r7, pc}
  40cc92:	bf00      	nop
  40cc94:	0040ed15 	.word	0x0040ed15
  40cc98:	0040a88d 	.word	0x0040a88d
  40cc9c:	0040c2ad 	.word	0x0040c2ad
  40cca0:	0040dcfd 	.word	0x0040dcfd
  40cca4:	0040e5e1 	.word	0x0040e5e1
  40cca8:	0041d580 	.word	0x0041d580
  40ccac:	00416c7d 	.word	0x00416c7d
  40ccb0:	0041d5b0 	.word	0x0041d5b0
  40ccb4:	20006d60 	.word	0x20006d60
  40ccb8:	0041d5e8 	.word	0x0041d5e8
  40ccbc:	0040c30d 	.word	0x0040c30d
  40ccc0:	0040bed5 	.word	0x0040bed5

0040ccc4 <prvSendData>:
 * ipconfigUSE_TCP_WIN is defined, and if only an ACK must be sent, it will be
 * checked if it would better be postponed for efficiency.
 */
static BaseType_t prvSendData( FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t **ppxNetworkBuffer,
	uint32_t ulReceiveLength, BaseType_t xSendLength )
{
  40ccc4:	b5b0      	push	{r4, r5, r7, lr}
  40ccc6:	b08e      	sub	sp, #56	; 0x38
  40ccc8:	af04      	add	r7, sp, #16
  40ccca:	60f8      	str	r0, [r7, #12]
  40cccc:	60b9      	str	r1, [r7, #8]
  40ccce:	607a      	str	r2, [r7, #4]
  40ccd0:	603b      	str	r3, [r7, #0]
TCPPacket_t *pxTCPPacket = ( TCPPacket_t * ) ( (*ppxNetworkBuffer)->pucEthernetBuffer );
  40ccd2:	68bb      	ldr	r3, [r7, #8]
  40ccd4:	681b      	ldr	r3, [r3, #0]
  40ccd6:	699b      	ldr	r3, [r3, #24]
  40ccd8:	627b      	str	r3, [r7, #36]	; 0x24
TCPHeader_t *pxTCPHeader = &pxTCPPacket->xTCPHeader;
  40ccda:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40ccdc:	3322      	adds	r3, #34	; 0x22
  40ccde:	623b      	str	r3, [r7, #32]
TCPWindow_t *pxTCPWindow = &pxSocket->u.xTCP.xTCPWindow;
  40cce0:	68fb      	ldr	r3, [r7, #12]
  40cce2:	33d0      	adds	r3, #208	; 0xd0
  40cce4:	61fb      	str	r3, [r7, #28]
	#endif
#endif

	/* Set the time-out field, so that we'll be called by the IP-task in case no
	next message will be received. */
	lRxSpace = (int32_t)( pxSocket->u.xTCP.ulHighestRxAllowed - pxTCPWindow->rx.ulCurrentSequenceNumber );
  40cce6:	68fb      	ldr	r3, [r7, #12]
  40cce8:	6c5a      	ldr	r2, [r3, #68]	; 0x44
  40ccea:	69fb      	ldr	r3, [r7, #28]
  40ccec:	691b      	ldr	r3, [r3, #16]
  40ccee:	1ad3      	subs	r3, r2, r3
  40ccf0:	61bb      	str	r3, [r7, #24]
	#if ipconfigUSE_TCP_WIN == 1
	{

		#if( ipconfigTCP_ACK_EARLIER_PACKET != 0 )
		{
			lMinLength = ( ( int32_t ) 2 ) * ( ( int32_t ) pxSocket->u.xTCP.usCurMSS );
  40ccf2:	68fb      	ldr	r3, [r7, #12]
  40ccf4:	f8b3 304a 	ldrh.w	r3, [r3, #74]	; 0x4a
  40ccf8:	005b      	lsls	r3, r3, #1
  40ccfa:	617b      	str	r3, [r7, #20]
		}
		#endif /* ipconfigTCP_ACK_EARLIER_PACKET */

		/* In case we're receiving data continuously, we might postpone sending
		an ACK to gain performance. */
		if( ( ulReceiveLength > 0 ) &&							/* Data was sent to this socket. */
  40ccfc:	687b      	ldr	r3, [r7, #4]
  40ccfe:	2b00      	cmp	r3, #0
  40cd00:	d076      	beq.n	40cdf0 <prvSendData+0x12c>
  40cd02:	69ba      	ldr	r2, [r7, #24]
  40cd04:	697b      	ldr	r3, [r7, #20]
  40cd06:	429a      	cmp	r2, r3
  40cd08:	db72      	blt.n	40cdf0 <prvSendData+0x12c>
			( lRxSpace >= lMinLength ) &&						/* There is Rx space for more data. */
			( pxSocket->u.xTCP.bits.bFinSent == pdFALSE_UNSIGNED ) &&	/* Not in a closure phase. */
  40cd0a:	68fb      	ldr	r3, [r7, #12]
  40cd0c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
  40cd10:	f003 0340 	and.w	r3, r3, #64	; 0x40
  40cd14:	b2db      	uxtb	r3, r3
			( lRxSpace >= lMinLength ) &&						/* There is Rx space for more data. */
  40cd16:	2b00      	cmp	r3, #0
  40cd18:	d16a      	bne.n	40cdf0 <prvSendData+0x12c>
			( pxSocket->u.xTCP.bits.bFinSent == pdFALSE_UNSIGNED ) &&	/* Not in a closure phase. */
  40cd1a:	683b      	ldr	r3, [r7, #0]
  40cd1c:	2b28      	cmp	r3, #40	; 0x28
  40cd1e:	d167      	bne.n	40cdf0 <prvSendData+0x12c>
			( xSendLength == ( ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER ) ) && /* No Tx data or options to be sent. */
			( pxSocket->u.xTCP.ucTCPState == eESTABLISHED ) &&	/* Connection established. */
  40cd20:	68fb      	ldr	r3, [r7, #12]
  40cd22:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
			( xSendLength == ( ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER ) ) && /* No Tx data or options to be sent. */
  40cd26:	2b05      	cmp	r3, #5
  40cd28:	d162      	bne.n	40cdf0 <prvSendData+0x12c>
			( pxTCPHeader->ucTCPFlags == ipTCP_FLAG_ACK ) )		/* There are no other flags than an ACK. */
  40cd2a:	6a3b      	ldr	r3, [r7, #32]
  40cd2c:	7b5b      	ldrb	r3, [r3, #13]
			( pxSocket->u.xTCP.ucTCPState == eESTABLISHED ) &&	/* Connection established. */
  40cd2e:	2b10      	cmp	r3, #16
  40cd30:	d15e      	bne.n	40cdf0 <prvSendData+0x12c>
		{
			if( pxSocket->u.xTCP.pxAckMessage != *ppxNetworkBuffer )
  40cd32:	68fb      	ldr	r3, [r7, #12]
  40cd34:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  40cd36:	68bb      	ldr	r3, [r7, #8]
  40cd38:	681b      	ldr	r3, [r3, #0]
  40cd3a:	429a      	cmp	r2, r3
  40cd3c:	d00c      	beq.n	40cd58 <prvSendData+0x94>
			{
				/* There was still a delayed in queue, delete it. */
				if( pxSocket->u.xTCP.pxAckMessage != 0 )
  40cd3e:	68fb      	ldr	r3, [r7, #12]
  40cd40:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  40cd42:	2b00      	cmp	r3, #0
  40cd44:	d004      	beq.n	40cd50 <prvSendData+0x8c>
				{
					vReleaseNetworkBufferAndDescriptor( pxSocket->u.xTCP.pxAckMessage );
  40cd46:	68fb      	ldr	r3, [r7, #12]
  40cd48:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  40cd4a:	4618      	mov	r0, r3
  40cd4c:	4b4c      	ldr	r3, [pc, #304]	; (40ce80 <prvSendData+0x1bc>)
  40cd4e:	4798      	blx	r3
				}

				pxSocket->u.xTCP.pxAckMessage = *ppxNetworkBuffer;
  40cd50:	68bb      	ldr	r3, [r7, #8]
  40cd52:	681a      	ldr	r2, [r3, #0]
  40cd54:	68fb      	ldr	r3, [r7, #12]
  40cd56:	675a      	str	r2, [r3, #116]	; 0x74
			}
			if( ( ulReceiveLength < ( uint32_t ) pxSocket->u.xTCP.usCurMSS ) ||	/* Received a small message. */
  40cd58:	68fb      	ldr	r3, [r7, #12]
  40cd5a:	f8b3 304a 	ldrh.w	r3, [r3, #74]	; 0x4a
  40cd5e:	461a      	mov	r2, r3
  40cd60:	687b      	ldr	r3, [r7, #4]
  40cd62:	429a      	cmp	r2, r3
  40cd64:	d807      	bhi.n	40cd76 <prvSendData+0xb2>
				( lRxSpace < ( int32_t ) ( 2U * pxSocket->u.xTCP.usCurMSS ) ) )	/* There are less than 2 x MSS space in the Rx buffer. */
  40cd66:	68fb      	ldr	r3, [r7, #12]
  40cd68:	f8b3 304a 	ldrh.w	r3, [r3, #74]	; 0x4a
  40cd6c:	005b      	lsls	r3, r3, #1
  40cd6e:	461a      	mov	r2, r3
			if( ( ulReceiveLength < ( uint32_t ) pxSocket->u.xTCP.usCurMSS ) ||	/* Received a small message. */
  40cd70:	69bb      	ldr	r3, [r7, #24]
  40cd72:	429a      	cmp	r2, r3
  40cd74:	dd04      	ble.n	40cd80 <prvSendData+0xbc>
			{
				pxSocket->u.xTCP.usTimeout = ( uint16_t ) pdMS_TO_MIN_TICKS( DELAYED_ACK_SHORT_DELAY_MS );
  40cd76:	68fb      	ldr	r3, [r7, #12]
  40cd78:	2202      	movs	r2, #2
  40cd7a:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48
  40cd7e:	e003      	b.n	40cd88 <prvSendData+0xc4>
			else
			{
				/* Normally a delayed ACK should wait 200 ms for a next incoming
				packet.  Only wait 20 ms here to gain performance.  A slow ACK
				for full-size message. */
				pxSocket->u.xTCP.usTimeout = ( uint16_t ) pdMS_TO_MIN_TICKS( DELAYED_ACK_LONGER_DELAY_MS );
  40cd80:	68fb      	ldr	r3, [r7, #12]
  40cd82:	2214      	movs	r2, #20
  40cd84:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48
			}

			if( ( xTCPWindowLoggingLevel > 1 ) && ( ipconfigTCP_MAY_LOG_PORT( pxSocket->usLocalPort ) != pdFALSE ) )
  40cd88:	4b3e      	ldr	r3, [pc, #248]	; (40ce84 <prvSendData+0x1c0>)
  40cd8a:	681b      	ldr	r3, [r3, #0]
  40cd8c:	2b01      	cmp	r3, #1
  40cd8e:	dd29      	ble.n	40cde4 <prvSendData+0x120>
  40cd90:	68fb      	ldr	r3, [r7, #12]
  40cd92:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
  40cd94:	2b17      	cmp	r3, #23
  40cd96:	d001      	beq.n	40cd9c <prvSendData+0xd8>
  40cd98:	2301      	movs	r3, #1
  40cd9a:	e000      	b.n	40cd9e <prvSendData+0xda>
  40cd9c:	2300      	movs	r3, #0
  40cd9e:	2b00      	cmp	r3, #0
  40cda0:	d020      	beq.n	40cde4 <prvSendData+0x120>
			{
				FreeRTOS_debug_printf( ( "Send[%u->%u] del ACK %lu SEQ %lu (len %lu) tmout %u d %lu\n",
  40cda2:	68fb      	ldr	r3, [r7, #12]
  40cda4:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
  40cda6:	461c      	mov	r4, r3
  40cda8:	68fb      	ldr	r3, [r7, #12]
  40cdaa:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
  40cdac:	461d      	mov	r5, r3
  40cdae:	69fb      	ldr	r3, [r7, #28]
  40cdb0:	691a      	ldr	r2, [r3, #16]
  40cdb2:	69fb      	ldr	r3, [r7, #28]
  40cdb4:	68db      	ldr	r3, [r3, #12]
  40cdb6:	1ad1      	subs	r1, r2, r3
  40cdb8:	68fb      	ldr	r3, [r7, #12]
  40cdba:	f8d3 20fc 	ldr.w	r2, [r3, #252]	; 0xfc
  40cdbe:	69fb      	ldr	r3, [r7, #28]
  40cdc0:	69db      	ldr	r3, [r3, #28]
  40cdc2:	1ad3      	subs	r3, r2, r3
  40cdc4:	68fa      	ldr	r2, [r7, #12]
  40cdc6:	f8b2 2048 	ldrh.w	r2, [r2, #72]	; 0x48
  40cdca:	4610      	mov	r0, r2
  40cdcc:	69ba      	ldr	r2, [r7, #24]
  40cdce:	9203      	str	r2, [sp, #12]
  40cdd0:	9002      	str	r0, [sp, #8]
  40cdd2:	683a      	ldr	r2, [r7, #0]
  40cdd4:	9201      	str	r2, [sp, #4]
  40cdd6:	9300      	str	r3, [sp, #0]
  40cdd8:	460b      	mov	r3, r1
  40cdda:	462a      	mov	r2, r5
  40cddc:	4621      	mov	r1, r4
  40cdde:	482a      	ldr	r0, [pc, #168]	; (40ce88 <prvSendData+0x1c4>)
  40cde0:	4c2a      	ldr	r4, [pc, #168]	; (40ce8c <prvSendData+0x1c8>)
  40cde2:	47a0      	blx	r4
					pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber - pxTCPWindow->tx.ulFirstSequenceNumber,
					xSendLength,
					pxSocket->u.xTCP.usTimeout, lRxSpace ) );
			}

			*ppxNetworkBuffer = NULL;
  40cde4:	68bb      	ldr	r3, [r7, #8]
  40cde6:	2200      	movs	r2, #0
  40cde8:	601a      	str	r2, [r3, #0]
			xSendLength = 0;
  40cdea:	2300      	movs	r3, #0
  40cdec:	603b      	str	r3, [r7, #0]
  40cdee:	e011      	b.n	40ce14 <prvSendData+0x150>
		}
		else if( pxSocket->u.xTCP.pxAckMessage != NULL )
  40cdf0:	68fb      	ldr	r3, [r7, #12]
  40cdf2:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  40cdf4:	2b00      	cmp	r3, #0
  40cdf6:	d00d      	beq.n	40ce14 <prvSendData+0x150>
		{
			/* As an ACK is not being delayed, remove any earlier delayed ACK
			message. */
			if( pxSocket->u.xTCP.pxAckMessage != *ppxNetworkBuffer )
  40cdf8:	68fb      	ldr	r3, [r7, #12]
  40cdfa:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  40cdfc:	68bb      	ldr	r3, [r7, #8]
  40cdfe:	681b      	ldr	r3, [r3, #0]
  40ce00:	429a      	cmp	r2, r3
  40ce02:	d004      	beq.n	40ce0e <prvSendData+0x14a>
			{
				vReleaseNetworkBufferAndDescriptor( pxSocket->u.xTCP.pxAckMessage );
  40ce04:	68fb      	ldr	r3, [r7, #12]
  40ce06:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  40ce08:	4618      	mov	r0, r3
  40ce0a:	4b1d      	ldr	r3, [pc, #116]	; (40ce80 <prvSendData+0x1bc>)
  40ce0c:	4798      	blx	r3
			}

			pxSocket->u.xTCP.pxAckMessage = NULL;
  40ce0e:	68fb      	ldr	r3, [r7, #12]
  40ce10:	2200      	movs	r2, #0
  40ce12:	675a      	str	r2, [r3, #116]	; 0x74
		( void ) pxTCPHeader;
		( void ) lRxSpace;
	}
	#endif /* ipconfigUSE_TCP_WIN */

	if( xSendLength != 0 )
  40ce14:	683b      	ldr	r3, [r7, #0]
  40ce16:	2b00      	cmp	r3, #0
  40ce18:	d02c      	beq.n	40ce74 <prvSendData+0x1b0>
	{
		if( ( xTCPWindowLoggingLevel > 1 ) && ( ipconfigTCP_MAY_LOG_PORT( pxSocket->usLocalPort ) != pdFALSE ) )
  40ce1a:	4b1a      	ldr	r3, [pc, #104]	; (40ce84 <prvSendData+0x1c0>)
  40ce1c:	681b      	ldr	r3, [r3, #0]
  40ce1e:	2b01      	cmp	r3, #1
  40ce20:	dd21      	ble.n	40ce66 <prvSendData+0x1a2>
  40ce22:	68fb      	ldr	r3, [r7, #12]
  40ce24:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
  40ce26:	2b17      	cmp	r3, #23
  40ce28:	d001      	beq.n	40ce2e <prvSendData+0x16a>
  40ce2a:	2301      	movs	r3, #1
  40ce2c:	e000      	b.n	40ce30 <prvSendData+0x16c>
  40ce2e:	2300      	movs	r3, #0
  40ce30:	2b00      	cmp	r3, #0
  40ce32:	d018      	beq.n	40ce66 <prvSendData+0x1a2>
		{
			FreeRTOS_debug_printf( ( "Send[%u->%u] imm ACK %lu SEQ %lu (len %lu)\n",
  40ce34:	68fb      	ldr	r3, [r7, #12]
  40ce36:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
  40ce38:	4618      	mov	r0, r3
  40ce3a:	68fb      	ldr	r3, [r7, #12]
  40ce3c:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
  40ce3e:	461c      	mov	r4, r3
  40ce40:	69fb      	ldr	r3, [r7, #28]
  40ce42:	691a      	ldr	r2, [r3, #16]
  40ce44:	69fb      	ldr	r3, [r7, #28]
  40ce46:	68db      	ldr	r3, [r3, #12]
  40ce48:	1ad1      	subs	r1, r2, r3
  40ce4a:	69fb      	ldr	r3, [r7, #28]
  40ce4c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  40ce4e:	69fb      	ldr	r3, [r7, #28]
  40ce50:	69db      	ldr	r3, [r3, #28]
  40ce52:	1ad3      	subs	r3, r2, r3
  40ce54:	683a      	ldr	r2, [r7, #0]
  40ce56:	9201      	str	r2, [sp, #4]
  40ce58:	9300      	str	r3, [sp, #0]
  40ce5a:	460b      	mov	r3, r1
  40ce5c:	4622      	mov	r2, r4
  40ce5e:	4601      	mov	r1, r0
  40ce60:	480b      	ldr	r0, [pc, #44]	; (40ce90 <prvSendData+0x1cc>)
  40ce62:	4c0a      	ldr	r4, [pc, #40]	; (40ce8c <prvSendData+0x1c8>)
  40ce64:	47a0      	blx	r4
				xSendLength ) );
		}

		/* Set the parameter 'xReleaseAfterSend' to the value of
		ipconfigZERO_COPY_TX_DRIVER. */
		prvTCPReturnPacket( pxSocket, *ppxNetworkBuffer, ( uint32_t ) xSendLength, ipconfigZERO_COPY_TX_DRIVER );
  40ce66:	68bb      	ldr	r3, [r7, #8]
  40ce68:	6819      	ldr	r1, [r3, #0]
  40ce6a:	683a      	ldr	r2, [r7, #0]
  40ce6c:	2300      	movs	r3, #0
  40ce6e:	68f8      	ldr	r0, [r7, #12]
  40ce70:	4c08      	ldr	r4, [pc, #32]	; (40ce94 <prvSendData+0x1d0>)
  40ce72:	47a0      	blx	r4
			*ppxNetworkBuffer = NULL;
		}
		#endif
	}

	return xSendLength;
  40ce74:	683b      	ldr	r3, [r7, #0]
}
  40ce76:	4618      	mov	r0, r3
  40ce78:	3728      	adds	r7, #40	; 0x28
  40ce7a:	46bd      	mov	sp, r7
  40ce7c:	bdb0      	pop	{r4, r5, r7, pc}
  40ce7e:	bf00      	nop
  40ce80:	0040f2ed 	.word	0x0040f2ed
  40ce84:	20006d60 	.word	0x20006d60
  40ce88:	0041d624 	.word	0x0041d624
  40ce8c:	00416c7d 	.word	0x00416c7d
  40ce90:	0041d660 	.word	0x0041d660
  40ce94:	0040af75 	.word	0x0040af75

0040ce98 <prvTCPHandleState>:
 *
 * As these functions are declared static, and they're called from one location
 * only, most compilers will inline them, thus avoiding a call and return.
 */
static BaseType_t prvTCPHandleState( FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t **ppxNetworkBuffer )
{
  40ce98:	b590      	push	{r4, r7, lr}
  40ce9a:	b08d      	sub	sp, #52	; 0x34
  40ce9c:	af00      	add	r7, sp, #0
  40ce9e:	6078      	str	r0, [r7, #4]
  40cea0:	6039      	str	r1, [r7, #0]
TCPPacket_t *pxTCPPacket = ( TCPPacket_t * ) ( (*ppxNetworkBuffer)->pucEthernetBuffer );
  40cea2:	683b      	ldr	r3, [r7, #0]
  40cea4:	681b      	ldr	r3, [r3, #0]
  40cea6:	699b      	ldr	r3, [r3, #24]
  40cea8:	62bb      	str	r3, [r7, #40]	; 0x28
TCPHeader_t *pxTCPHeader = &( pxTCPPacket->xTCPHeader );
  40ceaa:	6abb      	ldr	r3, [r7, #40]	; 0x28
  40ceac:	3322      	adds	r3, #34	; 0x22
  40ceae:	627b      	str	r3, [r7, #36]	; 0x24
BaseType_t xSendLength = 0;
  40ceb0:	2300      	movs	r3, #0
  40ceb2:	62fb      	str	r3, [r7, #44]	; 0x2c
uint32_t ulReceiveLength;	/* Number of bytes contained in the TCP message. */
uint8_t *pucRecvData;
uint32_t ulSequenceNumber = FreeRTOS_ntohl (pxTCPHeader->ulSequenceNumber);
  40ceb4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40ceb6:	685b      	ldr	r3, [r3, #4]
  40ceb8:	061a      	lsls	r2, r3, #24
  40ceba:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40cebc:	685b      	ldr	r3, [r3, #4]
  40cebe:	021b      	lsls	r3, r3, #8
  40cec0:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
  40cec4:	431a      	orrs	r2, r3
  40cec6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40cec8:	685b      	ldr	r3, [r3, #4]
  40ceca:	0a1b      	lsrs	r3, r3, #8
  40cecc:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
  40ced0:	431a      	orrs	r2, r3
  40ced2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40ced4:	685b      	ldr	r3, [r3, #4]
  40ced6:	0e1b      	lsrs	r3, r3, #24
  40ced8:	4313      	orrs	r3, r2
  40ceda:	623b      	str	r3, [r7, #32]
	/* uxOptionsLength: the size of the options to be sent (always a multiple of
	4 bytes)
	1. in the SYN phase, we shall communicate the MSS
	2. in case of a SACK, Selective ACK, ack a segment which comes in
	out-of-order. */
UBaseType_t uxOptionsLength = 0u;
  40cedc:	2300      	movs	r3, #0
  40cede:	61fb      	str	r3, [r7, #28]
uint8_t ucTCPFlags = pxTCPHeader->ucTCPFlags;
  40cee0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40cee2:	7b5b      	ldrb	r3, [r3, #13]
  40cee4:	76fb      	strb	r3, [r7, #27]
TCPWindow_t *pxTCPWindow = &( pxSocket->u.xTCP.xTCPWindow );
  40cee6:	687b      	ldr	r3, [r7, #4]
  40cee8:	33d0      	adds	r3, #208	; 0xd0
  40ceea:	617b      	str	r3, [r7, #20]

	/* First get the length and the position of the received data, if any.
	pucRecvData will point to the first byte of the TCP payload. */
	ulReceiveLength = ( uint32_t ) prvCheckRxData( *ppxNetworkBuffer, &pucRecvData );
  40ceec:	683b      	ldr	r3, [r7, #0]
  40ceee:	681b      	ldr	r3, [r3, #0]
  40cef0:	f107 020c 	add.w	r2, r7, #12
  40cef4:	4611      	mov	r1, r2
  40cef6:	4618      	mov	r0, r3
  40cef8:	4b71      	ldr	r3, [pc, #452]	; (40d0c0 <prvTCPHandleState+0x228>)
  40cefa:	4798      	blx	r3
  40cefc:	4603      	mov	r3, r0
  40cefe:	613b      	str	r3, [r7, #16]

	if( pxSocket->u.xTCP.ucTCPState >= eESTABLISHED )
  40cf00:	687b      	ldr	r3, [r7, #4]
  40cf02:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
  40cf06:	2b04      	cmp	r3, #4
  40cf08:	d90c      	bls.n	40cf24 <prvTCPHandleState+0x8c>
	{
		if ( pxTCPWindow->rx.ulCurrentSequenceNumber == ulSequenceNumber + 1u )
  40cf0a:	697b      	ldr	r3, [r7, #20]
  40cf0c:	691a      	ldr	r2, [r3, #16]
  40cf0e:	6a3b      	ldr	r3, [r7, #32]
  40cf10:	3301      	adds	r3, #1
  40cf12:	429a      	cmp	r2, r3
  40cf14:	d106      	bne.n	40cf24 <prvTCPHandleState+0x8c>
		{
			/* This is most probably a keep-alive message from peer.  Setting
			'bWinChange' doesn't cause a window-size-change, the flag is used
			here to force sending an immediate ACK. */
			pxSocket->u.xTCP.bits.bWinChange = pdTRUE_UNSIGNED;
  40cf16:	687a      	ldr	r2, [r7, #4]
  40cf18:	f892 3041 	ldrb.w	r3, [r2, #65]	; 0x41
  40cf1c:	f043 0301 	orr.w	r3, r3, #1
  40cf20:	f882 3041 	strb.w	r3, [r2, #65]	; 0x41
		}
	}

	/* Keep track of the highest sequence number that might be expected within
	this connection. */
	if( ( ( int32_t ) ( ulSequenceNumber + ulReceiveLength - pxTCPWindow->rx.ulHighestSequenceNumber ) ) > 0 )
  40cf24:	6a3a      	ldr	r2, [r7, #32]
  40cf26:	693b      	ldr	r3, [r7, #16]
  40cf28:	441a      	add	r2, r3
  40cf2a:	697b      	ldr	r3, [r7, #20]
  40cf2c:	699b      	ldr	r3, [r3, #24]
  40cf2e:	1ad3      	subs	r3, r2, r3
  40cf30:	2b00      	cmp	r3, #0
  40cf32:	dd04      	ble.n	40cf3e <prvTCPHandleState+0xa6>
	{
		pxTCPWindow->rx.ulHighestSequenceNumber = ulSequenceNumber + ulReceiveLength;
  40cf34:	6a3a      	ldr	r2, [r7, #32]
  40cf36:	693b      	ldr	r3, [r7, #16]
  40cf38:	441a      	add	r2, r3
  40cf3a:	697b      	ldr	r3, [r7, #20]
  40cf3c:	619a      	str	r2, [r3, #24]
	}

	/* Storing data may result in a fatal error if malloc() fails. */
	if( prvStoreRxData( pxSocket, pucRecvData, *ppxNetworkBuffer, ulReceiveLength ) < 0 )
  40cf3e:	68f9      	ldr	r1, [r7, #12]
  40cf40:	683b      	ldr	r3, [r7, #0]
  40cf42:	681a      	ldr	r2, [r3, #0]
  40cf44:	693b      	ldr	r3, [r7, #16]
  40cf46:	6878      	ldr	r0, [r7, #4]
  40cf48:	4c5e      	ldr	r4, [pc, #376]	; (40d0c4 <prvTCPHandleState+0x22c>)
  40cf4a:	47a0      	blx	r4
  40cf4c:	4603      	mov	r3, r0
  40cf4e:	2b00      	cmp	r3, #0
  40cf50:	da03      	bge.n	40cf5a <prvTCPHandleState+0xc2>
	{
		xSendLength = -1;
  40cf52:	f04f 33ff 	mov.w	r3, #4294967295
  40cf56:	62fb      	str	r3, [r7, #44]	; 0x2c
  40cf58:	e0a2      	b.n	40d0a0 <prvTCPHandleState+0x208>
	}
	else
	{
		uxOptionsLength = prvSetOptions( pxSocket, *ppxNetworkBuffer );
  40cf5a:	683b      	ldr	r3, [r7, #0]
  40cf5c:	681b      	ldr	r3, [r3, #0]
  40cf5e:	4619      	mov	r1, r3
  40cf60:	6878      	ldr	r0, [r7, #4]
  40cf62:	4b59      	ldr	r3, [pc, #356]	; (40d0c8 <prvTCPHandleState+0x230>)
  40cf64:	4798      	blx	r3
  40cf66:	61f8      	str	r0, [r7, #28]

		if( ( pxSocket->u.xTCP.ucTCPState == eSYN_RECEIVED ) && ( ( ucTCPFlags & ipTCP_FLAG_CTRL ) == ipTCP_FLAG_SYN ) )
  40cf68:	687b      	ldr	r3, [r7, #4]
  40cf6a:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
  40cf6e:	2b04      	cmp	r3, #4
  40cf70:	d10b      	bne.n	40cf8a <prvTCPHandleState+0xf2>
  40cf72:	7efb      	ldrb	r3, [r7, #27]
  40cf74:	f003 031f 	and.w	r3, r3, #31
  40cf78:	2b02      	cmp	r3, #2
  40cf7a:	d106      	bne.n	40cf8a <prvTCPHandleState+0xf2>
		{
			FreeRTOS_debug_printf( ( "eSYN_RECEIVED: ACK expected, not SYN: peer missed our SYN+ACK\n" ) );
  40cf7c:	4853      	ldr	r0, [pc, #332]	; (40d0cc <prvTCPHandleState+0x234>)
  40cf7e:	4b54      	ldr	r3, [pc, #336]	; (40d0d0 <prvTCPHandleState+0x238>)
  40cf80:	4798      	blx	r3

			/* In eSYN_RECEIVED a simple ACK is expected, but apparently the
			'SYN+ACK' didn't arrive.  Step back to the previous state in which
			a first incoming SYN is handled.  The SYN was counted already so
			decrease it first. */
			vTCPStateChange( pxSocket, eSYN_FIRST );
  40cf82:	2103      	movs	r1, #3
  40cf84:	6878      	ldr	r0, [r7, #4]
  40cf86:	4b53      	ldr	r3, [pc, #332]	; (40d0d4 <prvTCPHandleState+0x23c>)
  40cf88:	4798      	blx	r3
		}

		if( ( ( ucTCPFlags & ipTCP_FLAG_FIN ) != 0u ) && ( pxSocket->u.xTCP.bits.bFinRecv == pdFALSE_UNSIGNED ) )
  40cf8a:	7efb      	ldrb	r3, [r7, #27]
  40cf8c:	f003 0301 	and.w	r3, r3, #1
  40cf90:	2b00      	cmp	r3, #0
  40cf92:	d022      	beq.n	40cfda <prvTCPHandleState+0x142>
  40cf94:	687b      	ldr	r3, [r7, #4]
  40cf96:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
  40cf9a:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
  40cf9e:	b2db      	uxtb	r3, r3
  40cfa0:	2b00      	cmp	r3, #0
  40cfa2:	d11a      	bne.n	40cfda <prvTCPHandleState+0x142>
		{
			/* It's the first time a FIN has been received, remember its
			sequence number. */
			pxTCPWindow->rx.ulFINSequenceNumber = ulSequenceNumber + ulReceiveLength;
  40cfa4:	6a3a      	ldr	r2, [r7, #32]
  40cfa6:	693b      	ldr	r3, [r7, #16]
  40cfa8:	441a      	add	r2, r3
  40cfaa:	697b      	ldr	r3, [r7, #20]
  40cfac:	615a      	str	r2, [r3, #20]
			pxSocket->u.xTCP.bits.bFinRecv = pdTRUE_UNSIGNED;
  40cfae:	687a      	ldr	r2, [r7, #4]
  40cfb0:	f892 3041 	ldrb.w	r3, [r2, #65]	; 0x41
  40cfb4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  40cfb8:	f882 3041 	strb.w	r3, [r2, #65]	; 0x41

			/* Was peer the first one to send a FIN? */
			if( pxSocket->u.xTCP.bits.bFinSent == pdFALSE_UNSIGNED )
  40cfbc:	687b      	ldr	r3, [r7, #4]
  40cfbe:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
  40cfc2:	f003 0340 	and.w	r3, r3, #64	; 0x40
  40cfc6:	b2db      	uxtb	r3, r3
  40cfc8:	2b00      	cmp	r3, #0
  40cfca:	d106      	bne.n	40cfda <prvTCPHandleState+0x142>
			{
				/* If so, don't send the-last-ACK. */
				pxSocket->u.xTCP.bits.bFinLast = pdTRUE_UNSIGNED;
  40cfcc:	687a      	ldr	r2, [r7, #4]
  40cfce:	f892 3042 	ldrb.w	r3, [r2, #66]	; 0x42
  40cfd2:	f043 0302 	orr.w	r3, r3, #2
  40cfd6:	f882 3042 	strb.w	r3, [r2, #66]	; 0x42
			}
		}

		switch (pxSocket->u.xTCP.ucTCPState)
  40cfda:	687b      	ldr	r3, [r7, #4]
  40cfdc:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
  40cfe0:	2b0b      	cmp	r3, #11
  40cfe2:	d85c      	bhi.n	40d09e <prvTCPHandleState+0x206>
  40cfe4:	a201      	add	r2, pc, #4	; (adr r2, 40cfec <prvTCPHandleState+0x154>)
  40cfe6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40cfea:	bf00      	nop
  40cfec:	0040d09f 	.word	0x0040d09f
  40cff0:	0040d09f 	.word	0x0040d09f
  40cff4:	0040d06f 	.word	0x0040d06f
  40cff8:	0040d01d 	.word	0x0040d01d
  40cffc:	0040d06f 	.word	0x0040d06f
  40d000:	0040d07f 	.word	0x0040d07f
  40d004:	0040d08f 	.word	0x0040d08f
  40d008:	0040d08f 	.word	0x0040d08f
  40d00c:	0040d09f 	.word	0x0040d09f
  40d010:	0040d09f 	.word	0x0040d09f
  40d014:	0040d08f 	.word	0x0040d08f
  40d018:	0040d09f 	.word	0x0040d09f
							socket. */
			{
				/* A new socket has been created, reply with a SYN+ACK.
				Acknowledge with seq+1 because the SYN is seen as pseudo data
				with len = 1. */
				uxOptionsLength = prvSetSynAckOptions( pxSocket, pxTCPPacket );
  40d01c:	6ab9      	ldr	r1, [r7, #40]	; 0x28
  40d01e:	6878      	ldr	r0, [r7, #4]
  40d020:	4b2d      	ldr	r3, [pc, #180]	; (40d0d8 <prvTCPHandleState+0x240>)
  40d022:	4798      	blx	r3
  40d024:	61f8      	str	r0, [r7, #28]
				pxTCPHeader->ucTCPFlags = ipTCP_FLAG_SYN | ipTCP_FLAG_ACK;
  40d026:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40d028:	2212      	movs	r2, #18
  40d02a:	735a      	strb	r2, [r3, #13]

				xSendLength = ( BaseType_t ) ( ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER + uxOptionsLength );
  40d02c:	69fb      	ldr	r3, [r7, #28]
  40d02e:	3328      	adds	r3, #40	; 0x28
  40d030:	62fb      	str	r3, [r7, #44]	; 0x2c

				/* Set the TCP offset field:  ipSIZE_OF_TCP_HEADER equals 20 and
				uxOptionsLength is a multiple of 4.  The complete expression is:
				ucTCPOffset = ( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) / 4 ) << 4 */
				pxTCPHeader->ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
  40d032:	69fb      	ldr	r3, [r7, #28]
  40d034:	b2db      	uxtb	r3, r3
  40d036:	3314      	adds	r3, #20
  40d038:	b2db      	uxtb	r3, r3
  40d03a:	009b      	lsls	r3, r3, #2
  40d03c:	b2da      	uxtb	r2, r3
  40d03e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40d040:	731a      	strb	r2, [r3, #12]
				vTCPStateChange( pxSocket, eSYN_RECEIVED );
  40d042:	2104      	movs	r1, #4
  40d044:	6878      	ldr	r0, [r7, #4]
  40d046:	4b23      	ldr	r3, [pc, #140]	; (40d0d4 <prvTCPHandleState+0x23c>)
  40d048:	4798      	blx	r3

				pxTCPWindow->rx.ulCurrentSequenceNumber = pxTCPWindow->rx.ulHighestSequenceNumber = ulSequenceNumber + 1u;
  40d04a:	6a3b      	ldr	r3, [r7, #32]
  40d04c:	1c5a      	adds	r2, r3, #1
  40d04e:	697b      	ldr	r3, [r7, #20]
  40d050:	619a      	str	r2, [r3, #24]
  40d052:	697b      	ldr	r3, [r7, #20]
  40d054:	699a      	ldr	r2, [r3, #24]
  40d056:	697b      	ldr	r3, [r7, #20]
  40d058:	611a      	str	r2, [r3, #16]
				pxTCPWindow->tx.ulCurrentSequenceNumber = pxTCPWindow->ulNextTxSequenceNumber = pxTCPWindow->tx.ulFirstSequenceNumber + 1u; /* because we send a TCP_SYN. */
  40d05a:	697b      	ldr	r3, [r7, #20]
  40d05c:	69db      	ldr	r3, [r3, #28]
  40d05e:	1c5a      	adds	r2, r3, #1
  40d060:	697b      	ldr	r3, [r7, #20]
  40d062:	635a      	str	r2, [r3, #52]	; 0x34
  40d064:	697b      	ldr	r3, [r7, #20]
  40d066:	6b5a      	ldr	r2, [r3, #52]	; 0x34
  40d068:	697b      	ldr	r3, [r7, #20]
  40d06a:	621a      	str	r2, [r3, #32]
			}
			break;
  40d06c:	e018      	b.n	40d0a0 <prvTCPHandleState+0x208>
		case eCONNECT_SYN:	/* (client) also called SYN_SENT: we've just send a
							SYN, expect	a SYN+ACK and send a ACK now. */
			/* Fall through */
		case eSYN_RECEIVED:	/* (server) we've had a SYN, replied with SYN+SCK
							expect a ACK and do nothing. */
			xSendLength = prvHandleSynReceived( pxSocket, ppxNetworkBuffer, ulReceiveLength, uxOptionsLength );
  40d06e:	69fb      	ldr	r3, [r7, #28]
  40d070:	693a      	ldr	r2, [r7, #16]
  40d072:	6839      	ldr	r1, [r7, #0]
  40d074:	6878      	ldr	r0, [r7, #4]
  40d076:	4c19      	ldr	r4, [pc, #100]	; (40d0dc <prvTCPHandleState+0x244>)
  40d078:	47a0      	blx	r4
  40d07a:	62f8      	str	r0, [r7, #44]	; 0x2c
			break;
  40d07c:	e010      	b.n	40d0a0 <prvTCPHandleState+0x208>
		case eESTABLISHED:	/* (server + client) an open connection, data
							received can be	delivered to the user. The normal
							state for the data transfer phase of the connection
							The closing states are also handled here with the
							use of some flags. */
			xSendLength = prvHandleEstablished( pxSocket, ppxNetworkBuffer, ulReceiveLength, uxOptionsLength );
  40d07e:	69fb      	ldr	r3, [r7, #28]
  40d080:	693a      	ldr	r2, [r7, #16]
  40d082:	6839      	ldr	r1, [r7, #0]
  40d084:	6878      	ldr	r0, [r7, #4]
  40d086:	4c16      	ldr	r4, [pc, #88]	; (40d0e0 <prvTCPHandleState+0x248>)
  40d088:	47a0      	blx	r4
  40d08a:	62f8      	str	r0, [r7, #44]	; 0x2c
			break;
  40d08c:	e008      	b.n	40d0a0 <prvTCPHandleState+0x208>
			/* Fall through */
		case eFIN_WAIT_1:	/* (server + client) waiting for a connection termination request from the remote TCP,
							 * or an acknowledgement of the connection termination request previously sent. */
			/* Fall through */
		case eFIN_WAIT_2:	/* (server + client) waiting for a connection termination request from the remote TCP. */
			xSendLength = prvTCPHandleFin( pxSocket, *ppxNetworkBuffer );
  40d08e:	683b      	ldr	r3, [r7, #0]
  40d090:	681b      	ldr	r3, [r3, #0]
  40d092:	4619      	mov	r1, r3
  40d094:	6878      	ldr	r0, [r7, #4]
  40d096:	4b13      	ldr	r3, [pc, #76]	; (40d0e4 <prvTCPHandleState+0x24c>)
  40d098:	4798      	blx	r3
  40d09a:	62f8      	str	r0, [r7, #44]	; 0x2c
			break;
  40d09c:	e000      	b.n	40d0a0 <prvTCPHandleState+0x208>
							a MSL (maximum segment lifetime).]  These states are
							implemented implicitly by settings flags like
							'bFinSent', 'bFinRecv', and 'bFinAcked'. */
			break;
		default:
			break;
  40d09e:	bf00      	nop
		}
	}

	if( xSendLength > 0 )
  40d0a0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40d0a2:	2b00      	cmp	r3, #0
  40d0a4:	dd06      	ble.n	40d0b4 <prvTCPHandleState+0x21c>
	{
		xSendLength = prvSendData( pxSocket, ppxNetworkBuffer, ulReceiveLength, xSendLength );
  40d0a6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40d0a8:	693a      	ldr	r2, [r7, #16]
  40d0aa:	6839      	ldr	r1, [r7, #0]
  40d0ac:	6878      	ldr	r0, [r7, #4]
  40d0ae:	4c0e      	ldr	r4, [pc, #56]	; (40d0e8 <prvTCPHandleState+0x250>)
  40d0b0:	47a0      	blx	r4
  40d0b2:	62f8      	str	r0, [r7, #44]	; 0x2c
	}

	return xSendLength;
  40d0b4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
}
  40d0b6:	4618      	mov	r0, r3
  40d0b8:	3734      	adds	r7, #52	; 0x34
  40d0ba:	46bd      	mov	sp, r7
  40d0bc:	bd90      	pop	{r4, r7, pc}
  40d0be:	bf00      	nop
  40d0c0:	0040c4b1 	.word	0x0040c4b1
  40d0c4:	0040c585 	.word	0x0040c585
  40d0c8:	0040c691 	.word	0x0040c691
  40d0cc:	0041d68c 	.word	0x0041d68c
  40d0d0:	00416c7d 	.word	0x00416c7d
  40d0d4:	0040bbc1 	.word	0x0040bbc1
  40d0d8:	0040baf5 	.word	0x0040baf5
  40d0dc:	0040c809 	.word	0x0040c809
  40d0e0:	0040ca05 	.word	0x0040ca05
  40d0e4:	0040c30d 	.word	0x0040c30d
  40d0e8:	0040ccc5 	.word	0x0040ccc5

0040d0ec <prvTCPSendSpecialPacketHelper>:
/*-----------------------------------------------------------*/

static BaseType_t prvTCPSendSpecialPacketHelper( NetworkBufferDescriptor_t *pxNetworkBuffer,
                                                 uint8_t ucTCPFlags )
{
  40d0ec:	b480      	push	{r7}
  40d0ee:	b083      	sub	sp, #12
  40d0f0:	af00      	add	r7, sp, #0
  40d0f2:	6078      	str	r0, [r7, #4]
  40d0f4:	460b      	mov	r3, r1
  40d0f6:	70fb      	strb	r3, [r7, #3]
    /* Remove compiler warnings if ipconfigIGNORE_UNKNOWN_PACKETS == 1. */
    ( void )pxNetworkBuffer;
    ( void )ucTCPFlags;

    /* The packet was not consumed. */
    return pdFAIL;
  40d0f8:	2300      	movs	r3, #0
}
  40d0fa:	4618      	mov	r0, r3
  40d0fc:	370c      	adds	r7, #12
  40d0fe:	46bd      	mov	sp, r7
  40d100:	f85d 7b04 	ldr.w	r7, [sp], #4
  40d104:	4770      	bx	lr
	...

0040d108 <prvTCPSendChallengeAck>:
/*-----------------------------------------------------------*/

static BaseType_t prvTCPSendChallengeAck( NetworkBufferDescriptor_t *pxNetworkBuffer )
{
  40d108:	b580      	push	{r7, lr}
  40d10a:	b082      	sub	sp, #8
  40d10c:	af00      	add	r7, sp, #0
  40d10e:	6078      	str	r0, [r7, #4]
    return prvTCPSendSpecialPacketHelper( pxNetworkBuffer, ipTCP_FLAG_ACK );
  40d110:	2110      	movs	r1, #16
  40d112:	6878      	ldr	r0, [r7, #4]
  40d114:	4b03      	ldr	r3, [pc, #12]	; (40d124 <prvTCPSendChallengeAck+0x1c>)
  40d116:	4798      	blx	r3
  40d118:	4603      	mov	r3, r0
}
  40d11a:	4618      	mov	r0, r3
  40d11c:	3708      	adds	r7, #8
  40d11e:	46bd      	mov	sp, r7
  40d120:	bd80      	pop	{r7, pc}
  40d122:	bf00      	nop
  40d124:	0040d0ed 	.word	0x0040d0ed

0040d128 <prvTCPSendReset>:
/*-----------------------------------------------------------*/

static BaseType_t prvTCPSendReset( NetworkBufferDescriptor_t *pxNetworkBuffer )
{
  40d128:	b580      	push	{r7, lr}
  40d12a:	b082      	sub	sp, #8
  40d12c:	af00      	add	r7, sp, #0
  40d12e:	6078      	str	r0, [r7, #4]
    return prvTCPSendSpecialPacketHelper( pxNetworkBuffer,
  40d130:	2114      	movs	r1, #20
  40d132:	6878      	ldr	r0, [r7, #4]
  40d134:	4b03      	ldr	r3, [pc, #12]	; (40d144 <prvTCPSendReset+0x1c>)
  40d136:	4798      	blx	r3
  40d138:	4603      	mov	r3, r0
                                          ipTCP_FLAG_ACK | ipTCP_FLAG_RST );
}
  40d13a:	4618      	mov	r0, r3
  40d13c:	3708      	adds	r7, #8
  40d13e:	46bd      	mov	sp, r7
  40d140:	bd80      	pop	{r7, pc}
  40d142:	bf00      	nop
  40d144:	0040d0ed 	.word	0x0040d0ed

0040d148 <prvSocketSetMSS>:
/*-----------------------------------------------------------*/

static void prvSocketSetMSS( FreeRTOS_Socket_t *pxSocket )
{
  40d148:	b590      	push	{r4, r7, lr}
  40d14a:	b085      	sub	sp, #20
  40d14c:	af00      	add	r7, sp, #0
  40d14e:	6078      	str	r0, [r7, #4]
uint32_t ulMSS = ipconfigTCP_MSS;
  40d150:	f44f 63aa 	mov.w	r3, #1360	; 0x550
  40d154:	60fb      	str	r3, [r7, #12]

	if( ( ( FreeRTOS_ntohl( pxSocket->u.xTCP.ulRemoteIP ) ^ *ipLOCAL_IP_ADDRESS_POINTER ) & xNetworkAddressing.ulNetMask ) != 0ul )
  40d156:	687b      	ldr	r3, [r7, #4]
  40d158:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  40d15a:	061a      	lsls	r2, r3, #24
  40d15c:	687b      	ldr	r3, [r7, #4]
  40d15e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  40d160:	021b      	lsls	r3, r3, #8
  40d162:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
  40d166:	431a      	orrs	r2, r3
  40d168:	687b      	ldr	r3, [r7, #4]
  40d16a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  40d16c:	0a1b      	lsrs	r3, r3, #8
  40d16e:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
  40d172:	431a      	orrs	r2, r3
  40d174:	687b      	ldr	r3, [r7, #4]
  40d176:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  40d178:	0e1b      	lsrs	r3, r3, #24
  40d17a:	431a      	orrs	r2, r3
  40d17c:	4b12      	ldr	r3, [pc, #72]	; (40d1c8 <prvSocketSetMSS+0x80>)
  40d17e:	695b      	ldr	r3, [r3, #20]
  40d180:	405a      	eors	r2, r3
  40d182:	4b12      	ldr	r3, [pc, #72]	; (40d1cc <prvSocketSetMSS+0x84>)
  40d184:	685b      	ldr	r3, [r3, #4]
  40d186:	4013      	ands	r3, r2
  40d188:	2b00      	cmp	r3, #0
  40d18a:	d005      	beq.n	40d198 <prvSocketSetMSS+0x50>
	{
		/* Data for this peer will pass through a router, and maybe through
		the internet.  Limit the MSS to 1400 bytes or less. */
		ulMSS = FreeRTOS_min_uint32( ( uint32_t ) REDUCED_MSS_THROUGH_INTERNET, ulMSS );
  40d18c:	68f9      	ldr	r1, [r7, #12]
  40d18e:	f44f 60af 	mov.w	r0, #1400	; 0x578
  40d192:	4b0f      	ldr	r3, [pc, #60]	; (40d1d0 <prvSocketSetMSS+0x88>)
  40d194:	4798      	blx	r3
  40d196:	60f8      	str	r0, [r7, #12]
	}

	FreeRTOS_debug_printf( ( "prvSocketSetMSS: %lu bytes for %lxip:%u\n", ulMSS, pxSocket->u.xTCP.ulRemoteIP, pxSocket->u.xTCP.usRemotePort ) );
  40d198:	687b      	ldr	r3, [r7, #4]
  40d19a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  40d19c:	687b      	ldr	r3, [r7, #4]
  40d19e:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
  40d1a0:	68f9      	ldr	r1, [r7, #12]
  40d1a2:	480c      	ldr	r0, [pc, #48]	; (40d1d4 <prvSocketSetMSS+0x8c>)
  40d1a4:	4c0c      	ldr	r4, [pc, #48]	; (40d1d8 <prvSocketSetMSS+0x90>)
  40d1a6:	47a0      	blx	r4

	pxSocket->u.xTCP.usInitMSS = pxSocket->u.xTCP.usCurMSS = ( uint16_t ) ulMSS;
  40d1a8:	68fb      	ldr	r3, [r7, #12]
  40d1aa:	b29a      	uxth	r2, r3
  40d1ac:	687b      	ldr	r3, [r7, #4]
  40d1ae:	f8a3 204a 	strh.w	r2, [r3, #74]	; 0x4a
  40d1b2:	687b      	ldr	r3, [r7, #4]
  40d1b4:	f8b3 204a 	ldrh.w	r2, [r3, #74]	; 0x4a
  40d1b8:	687b      	ldr	r3, [r7, #4]
  40d1ba:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
}
  40d1be:	bf00      	nop
  40d1c0:	3714      	adds	r7, #20
  40d1c2:	46bd      	mov	sp, r7
  40d1c4:	bd90      	pop	{r4, r7, pc}
  40d1c6:	bf00      	nop
  40d1c8:	20000108 	.word	0x20000108
  40d1cc:	20006cd0 	.word	0x20006cd0
  40d1d0:	0040a9c1 	.word	0x0040a9c1
  40d1d4:	0041d6cc 	.word	0x0041d6cc
  40d1d8:	00416c7d 	.word	0x00416c7d

0040d1dc <xProcessReceivedTCPPacket>:
 *		prvTCPSendRepeated()
 *			prvTCPReturnPacket()		// Prepare for returning
 *			xNetworkInterfaceOutput()	// Sends data to the NIC
*/
BaseType_t xProcessReceivedTCPPacket( NetworkBufferDescriptor_t *pxNetworkBuffer )
{
  40d1dc:	b590      	push	{r4, r7, lr}
  40d1de:	b091      	sub	sp, #68	; 0x44
  40d1e0:	af02      	add	r7, sp, #8
  40d1e2:	6078      	str	r0, [r7, #4]
FreeRTOS_Socket_t *pxSocket;
TCPPacket_t * pxTCPPacket = ( TCPPacket_t * ) ( pxNetworkBuffer->pucEthernetBuffer );
  40d1e4:	687b      	ldr	r3, [r7, #4]
  40d1e6:	699b      	ldr	r3, [r3, #24]
  40d1e8:	62fb      	str	r3, [r7, #44]	; 0x2c
uint16_t xLocalPort;
uint32_t ulRemoteIP;
uint16_t xRemotePort;
uint32_t ulSequenceNumber;
uint32_t ulAckNumber;
BaseType_t xResult = pdPASS;
  40d1ea:	2301      	movs	r3, #1
  40d1ec:	633b      	str	r3, [r7, #48]	; 0x30
configASSERT(pxNetworkBuffer);
  40d1ee:	687b      	ldr	r3, [r7, #4]
  40d1f0:	2b00      	cmp	r3, #0
  40d1f2:	d105      	bne.n	40d200 <xProcessReceivedTCPPacket+0x24>
  40d1f4:	f640 329d 	movw	r2, #2973	; 0xb9d
  40d1f8:	49a1      	ldr	r1, [pc, #644]	; (40d480 <xProcessReceivedTCPPacket+0x2a4>)
  40d1fa:	48a2      	ldr	r0, [pc, #648]	; (40d484 <xProcessReceivedTCPPacket+0x2a8>)
  40d1fc:	4ba2      	ldr	r3, [pc, #648]	; (40d488 <xProcessReceivedTCPPacket+0x2ac>)
  40d1fe:	4798      	blx	r3
configASSERT(pxNetworkBuffer->pucEthernetBuffer);
  40d200:	687b      	ldr	r3, [r7, #4]
  40d202:	699b      	ldr	r3, [r3, #24]
  40d204:	2b00      	cmp	r3, #0
  40d206:	d105      	bne.n	40d214 <xProcessReceivedTCPPacket+0x38>
  40d208:	f640 329e 	movw	r2, #2974	; 0xb9e
  40d20c:	499c      	ldr	r1, [pc, #624]	; (40d480 <xProcessReceivedTCPPacket+0x2a4>)
  40d20e:	489d      	ldr	r0, [pc, #628]	; (40d484 <xProcessReceivedTCPPacket+0x2a8>)
  40d210:	4b9d      	ldr	r3, [pc, #628]	; (40d488 <xProcessReceivedTCPPacket+0x2ac>)
  40d212:	4798      	blx	r3

	/* Check for a minimum packet size. */
	if( pxNetworkBuffer->xDataLength >= ( ipSIZE_OF_ETH_HEADER + ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER ) )
  40d214:	687b      	ldr	r3, [r7, #4]
  40d216:	69db      	ldr	r3, [r3, #28]
  40d218:	2b35      	cmp	r3, #53	; 0x35
  40d21a:	f240 808b 	bls.w	40d334 <xProcessReceivedTCPPacket+0x158>
	{
		ucTCPFlags = pxTCPPacket->xTCPHeader.ucTCPFlags;
  40d21e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40d220:	f893 302f 	ldrb.w	r3, [r3, #47]	; 0x2f
  40d224:	857b      	strh	r3, [r7, #42]	; 0x2a
		ulLocalIP = FreeRTOS_htonl( pxTCPPacket->xIPHeader.ulDestinationIPAddress );
  40d226:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40d228:	f8d3 301e 	ldr.w	r3, [r3, #30]
  40d22c:	061a      	lsls	r2, r3, #24
  40d22e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40d230:	f8d3 301e 	ldr.w	r3, [r3, #30]
  40d234:	021b      	lsls	r3, r3, #8
  40d236:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
  40d23a:	431a      	orrs	r2, r3
  40d23c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40d23e:	f8d3 301e 	ldr.w	r3, [r3, #30]
  40d242:	0a1b      	lsrs	r3, r3, #8
  40d244:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
  40d248:	431a      	orrs	r2, r3
  40d24a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40d24c:	f8d3 301e 	ldr.w	r3, [r3, #30]
  40d250:	0e1b      	lsrs	r3, r3, #24
  40d252:	4313      	orrs	r3, r2
  40d254:	627b      	str	r3, [r7, #36]	; 0x24
		xLocalPort = FreeRTOS_htons( pxTCPPacket->xTCPHeader.usDestinationPort );
  40d256:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40d258:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
  40d25a:	b29b      	uxth	r3, r3
  40d25c:	021b      	lsls	r3, r3, #8
  40d25e:	b21a      	sxth	r2, r3
  40d260:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40d262:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
  40d264:	b29b      	uxth	r3, r3
  40d266:	0a1b      	lsrs	r3, r3, #8
  40d268:	b29b      	uxth	r3, r3
  40d26a:	b21b      	sxth	r3, r3
  40d26c:	4313      	orrs	r3, r2
  40d26e:	b21b      	sxth	r3, r3
  40d270:	847b      	strh	r3, [r7, #34]	; 0x22
		ulRemoteIP = FreeRTOS_htonl( pxTCPPacket->xIPHeader.ulSourceIPAddress );
  40d272:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40d274:	f8d3 301a 	ldr.w	r3, [r3, #26]
  40d278:	061a      	lsls	r2, r3, #24
  40d27a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40d27c:	f8d3 301a 	ldr.w	r3, [r3, #26]
  40d280:	021b      	lsls	r3, r3, #8
  40d282:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
  40d286:	431a      	orrs	r2, r3
  40d288:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40d28a:	f8d3 301a 	ldr.w	r3, [r3, #26]
  40d28e:	0a1b      	lsrs	r3, r3, #8
  40d290:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
  40d294:	431a      	orrs	r2, r3
  40d296:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40d298:	f8d3 301a 	ldr.w	r3, [r3, #26]
  40d29c:	0e1b      	lsrs	r3, r3, #24
  40d29e:	4313      	orrs	r3, r2
  40d2a0:	61fb      	str	r3, [r7, #28]
		xRemotePort = FreeRTOS_htons( pxTCPPacket->xTCPHeader.usSourcePort );
  40d2a2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40d2a4:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
  40d2a6:	b29b      	uxth	r3, r3
  40d2a8:	021b      	lsls	r3, r3, #8
  40d2aa:	b21a      	sxth	r2, r3
  40d2ac:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40d2ae:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
  40d2b0:	b29b      	uxth	r3, r3
  40d2b2:	0a1b      	lsrs	r3, r3, #8
  40d2b4:	b29b      	uxth	r3, r3
  40d2b6:	b21b      	sxth	r3, r3
  40d2b8:	4313      	orrs	r3, r2
  40d2ba:	b21b      	sxth	r3, r3
  40d2bc:	837b      	strh	r3, [r7, #26]
        ulSequenceNumber = FreeRTOS_ntohl( pxTCPPacket->xTCPHeader.ulSequenceNumber );
  40d2be:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40d2c0:	f8d3 3026 	ldr.w	r3, [r3, #38]	; 0x26
  40d2c4:	061a      	lsls	r2, r3, #24
  40d2c6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40d2c8:	f8d3 3026 	ldr.w	r3, [r3, #38]	; 0x26
  40d2cc:	021b      	lsls	r3, r3, #8
  40d2ce:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
  40d2d2:	431a      	orrs	r2, r3
  40d2d4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40d2d6:	f8d3 3026 	ldr.w	r3, [r3, #38]	; 0x26
  40d2da:	0a1b      	lsrs	r3, r3, #8
  40d2dc:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
  40d2e0:	431a      	orrs	r2, r3
  40d2e2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40d2e4:	f8d3 3026 	ldr.w	r3, [r3, #38]	; 0x26
  40d2e8:	0e1b      	lsrs	r3, r3, #24
  40d2ea:	4313      	orrs	r3, r2
  40d2ec:	617b      	str	r3, [r7, #20]
        ulAckNumber = FreeRTOS_ntohl( pxTCPPacket->xTCPHeader.ulAckNr );
  40d2ee:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40d2f0:	f8d3 302a 	ldr.w	r3, [r3, #42]	; 0x2a
  40d2f4:	061a      	lsls	r2, r3, #24
  40d2f6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40d2f8:	f8d3 302a 	ldr.w	r3, [r3, #42]	; 0x2a
  40d2fc:	021b      	lsls	r3, r3, #8
  40d2fe:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
  40d302:	431a      	orrs	r2, r3
  40d304:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40d306:	f8d3 302a 	ldr.w	r3, [r3, #42]	; 0x2a
  40d30a:	0a1b      	lsrs	r3, r3, #8
  40d30c:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
  40d310:	431a      	orrs	r2, r3
  40d312:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40d314:	f8d3 302a 	ldr.w	r3, [r3, #42]	; 0x2a
  40d318:	0e1b      	lsrs	r3, r3, #24
  40d31a:	4313      	orrs	r3, r2
  40d31c:	613b      	str	r3, [r7, #16]

		/* Find the destination socket, and if not found: return a socket listing to
		the destination PORT. */
		pxSocket = ( FreeRTOS_Socket_t * )pxTCPSocketLookup( ulLocalIP, xLocalPort, ulRemoteIP, xRemotePort );
  40d31e:	8c79      	ldrh	r1, [r7, #34]	; 0x22
  40d320:	8b7b      	ldrh	r3, [r7, #26]
  40d322:	69fa      	ldr	r2, [r7, #28]
  40d324:	6a78      	ldr	r0, [r7, #36]	; 0x24
  40d326:	4c59      	ldr	r4, [pc, #356]	; (40d48c <xProcessReceivedTCPPacket+0x2b0>)
  40d328:	47a0      	blx	r4
  40d32a:	6378      	str	r0, [r7, #52]	; 0x34
	else
	{
		return pdFAIL;
	}

	if( ( pxSocket == NULL ) || ( prvTCPSocketIsActive( ( UBaseType_t ) pxSocket->u.xTCP.ucTCPState ) == pdFALSE ) )
  40d32c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40d32e:	2b00      	cmp	r3, #0
  40d330:	d00b      	beq.n	40d34a <xProcessReceivedTCPPacket+0x16e>
  40d332:	e001      	b.n	40d338 <xProcessReceivedTCPPacket+0x15c>
		return pdFAIL;
  40d334:	2300      	movs	r3, #0
  40d336:	e119      	b.n	40d56c <xProcessReceivedTCPPacket+0x390>
	if( ( pxSocket == NULL ) || ( prvTCPSocketIsActive( ( UBaseType_t ) pxSocket->u.xTCP.ucTCPState ) == pdFALSE ) )
  40d338:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40d33a:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
  40d33e:	4618      	mov	r0, r3
  40d340:	4b53      	ldr	r3, [pc, #332]	; (40d490 <xProcessReceivedTCPPacket+0x2b4>)
  40d342:	4798      	blx	r3
  40d344:	4603      	mov	r3, r0
  40d346:	2b00      	cmp	r3, #0
  40d348:	d116      	bne.n	40d378 <xProcessReceivedTCPPacket+0x19c>
		/* A TCP messages is received but either there is no socket with the
		given port number or the there is a socket, but it is in one of these
		non-active states:  eCLOSED, eCLOSE_WAIT, eFIN_WAIT_2, eCLOSING, or
		eTIME_WAIT. */

		FreeRTOS_debug_printf( ( "TCP: No active socket on port %d (%lxip:%d)\n", xLocalPort, ulRemoteIP, xRemotePort ) );
  40d34a:	8c79      	ldrh	r1, [r7, #34]	; 0x22
  40d34c:	8b7b      	ldrh	r3, [r7, #26]
  40d34e:	69fa      	ldr	r2, [r7, #28]
  40d350:	4850      	ldr	r0, [pc, #320]	; (40d494 <xProcessReceivedTCPPacket+0x2b8>)
  40d352:	4c4d      	ldr	r4, [pc, #308]	; (40d488 <xProcessReceivedTCPPacket+0x2ac>)
  40d354:	47a0      	blx	r4
		the other party will get a ECONN error.  There are two exceptions:
		1) A packet that already has the RST flag set.
		2) A packet that only has the ACK flag set.
		A packet with only the ACK flag set might be the last ACK in
	 	a three-way hand-shake that closes a connection. */
		if( ( ( ucTCPFlags & ipTCP_FLAG_CTRL ) != ipTCP_FLAG_ACK ) &&
  40d356:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
  40d358:	f003 031f 	and.w	r3, r3, #31
  40d35c:	2b10      	cmp	r3, #16
  40d35e:	d008      	beq.n	40d372 <xProcessReceivedTCPPacket+0x196>
			( ( ucTCPFlags & ipTCP_FLAG_RST ) == 0u ) )
  40d360:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
  40d362:	f003 0304 	and.w	r3, r3, #4
		if( ( ( ucTCPFlags & ipTCP_FLAG_CTRL ) != ipTCP_FLAG_ACK ) &&
  40d366:	2b00      	cmp	r3, #0
  40d368:	d103      	bne.n	40d372 <xProcessReceivedTCPPacket+0x196>
		{
			prvTCPSendReset( pxNetworkBuffer );
  40d36a:	687b      	ldr	r3, [r7, #4]
  40d36c:	4618      	mov	r0, r3
  40d36e:	4b4a      	ldr	r3, [pc, #296]	; (40d498 <xProcessReceivedTCPPacket+0x2bc>)
  40d370:	4798      	blx	r3
		}

		/* The packet can't be handled. */
		xResult = pdFAIL;
  40d372:	2300      	movs	r3, #0
  40d374:	633b      	str	r3, [r7, #48]	; 0x30
  40d376:	e0ae      	b.n	40d4d6 <xProcessReceivedTCPPacket+0x2fa>
	}
	else
	{
		pxSocket->u.xTCP.ucRepCount = 0u;
  40d378:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40d37a:	2200      	movs	r2, #0
  40d37c:	f883 2052 	strb.w	r2, [r3, #82]	; 0x52

		if( pxSocket->u.xTCP.ucTCPState == eTCP_LISTEN )
  40d380:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40d382:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
  40d386:	2b01      	cmp	r3, #1
  40d388:	d129      	bne.n	40d3de <xProcessReceivedTCPPacket+0x202>
		{
			/* The matching socket is in a listening state.  Test if the peer
			has set the SYN flag. */
			if( ( ucTCPFlags & ipTCP_FLAG_CTRL ) != ipTCP_FLAG_SYN )
  40d38a:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
  40d38c:	f003 031f 	and.w	r3, r3, #31
  40d390:	2b02      	cmp	r3, #2
  40d392:	d018      	beq.n	40d3c6 <xProcessReceivedTCPPacket+0x1ea>
				/* What happens: maybe after a reboot, a client doesn't know the
				connection had gone.  Send a RST in order to get a new connect
				request. */
				#if( ipconfigHAS_DEBUG_PRINTF == 1 )
				{
				FreeRTOS_debug_printf( ( "TCP: Server can't handle flags: %s from %lxip:%u to port %u\n",
  40d394:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
  40d396:	4618      	mov	r0, r3
  40d398:	4b40      	ldr	r3, [pc, #256]	; (40d49c <xProcessReceivedTCPPacket+0x2c0>)
  40d39a:	4798      	blx	r3
  40d39c:	4601      	mov	r1, r0
  40d39e:	8b7a      	ldrh	r2, [r7, #26]
  40d3a0:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
  40d3a2:	9300      	str	r3, [sp, #0]
  40d3a4:	4613      	mov	r3, r2
  40d3a6:	69fa      	ldr	r2, [r7, #28]
  40d3a8:	483d      	ldr	r0, [pc, #244]	; (40d4a0 <xProcessReceivedTCPPacket+0x2c4>)
  40d3aa:	4c37      	ldr	r4, [pc, #220]	; (40d488 <xProcessReceivedTCPPacket+0x2ac>)
  40d3ac:	47a0      	blx	r4
					prvTCPFlagMeaning( ( UBaseType_t ) ucTCPFlags ), ulRemoteIP, xRemotePort, xLocalPort ) );
				}
				#endif /* ipconfigHAS_DEBUG_PRINTF */

				if( ( ucTCPFlags & ipTCP_FLAG_RST ) == 0u )
  40d3ae:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
  40d3b0:	f003 0304 	and.w	r3, r3, #4
  40d3b4:	2b00      	cmp	r3, #0
  40d3b6:	d103      	bne.n	40d3c0 <xProcessReceivedTCPPacket+0x1e4>
				{
					prvTCPSendReset( pxNetworkBuffer );
  40d3b8:	687b      	ldr	r3, [r7, #4]
  40d3ba:	4618      	mov	r0, r3
  40d3bc:	4b36      	ldr	r3, [pc, #216]	; (40d498 <xProcessReceivedTCPPacket+0x2bc>)
  40d3be:	4798      	blx	r3
				}
				xResult = pdFAIL;
  40d3c0:	2300      	movs	r3, #0
  40d3c2:	633b      	str	r3, [r7, #48]	; 0x30
  40d3c4:	e087      	b.n	40d4d6 <xProcessReceivedTCPPacket+0x2fa>
			else
			{
				/* prvHandleListen() will either return a newly created socket
				(if bReuseSocket is false), otherwise it returns the current
				socket which will later get connected. */
				pxSocket = prvHandleListen( pxSocket, pxNetworkBuffer );
  40d3c6:	687b      	ldr	r3, [r7, #4]
  40d3c8:	4619      	mov	r1, r3
  40d3ca:	6b78      	ldr	r0, [r7, #52]	; 0x34
  40d3cc:	4b35      	ldr	r3, [pc, #212]	; (40d4a4 <xProcessReceivedTCPPacket+0x2c8>)
  40d3ce:	4798      	blx	r3
  40d3d0:	6378      	str	r0, [r7, #52]	; 0x34

				if( pxSocket == NULL )
  40d3d2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40d3d4:	2b00      	cmp	r3, #0
  40d3d6:	d17e      	bne.n	40d4d6 <xProcessReceivedTCPPacket+0x2fa>
				{
					xResult = pdFAIL;
  40d3d8:	2300      	movs	r3, #0
  40d3da:	633b      	str	r3, [r7, #48]	; 0x30
  40d3dc:	e07b      	b.n	40d4d6 <xProcessReceivedTCPPacket+0x2fa>
		}	/* if( pxSocket->u.xTCP.ucTCPState == eTCP_LISTEN ). */
		else
		{
			/* This is not a socket in listening mode. Check for the RST
			flag. */
			if( ( ucTCPFlags & ipTCP_FLAG_RST ) != 0u )
  40d3de:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
  40d3e0:	f003 0304 	and.w	r3, r3, #4
  40d3e4:	2b00      	cmp	r3, #0
  40d3e6:	d038      	beq.n	40d45a <xProcessReceivedTCPPacket+0x27e>
			{
                FreeRTOS_debug_printf( ( "TCP: RST received from %lxip:%u for %u\n", ulRemoteIP, xRemotePort, xLocalPort ) );
  40d3e8:	8b7a      	ldrh	r2, [r7, #26]
  40d3ea:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
  40d3ec:	69f9      	ldr	r1, [r7, #28]
  40d3ee:	482e      	ldr	r0, [pc, #184]	; (40d4a8 <xProcessReceivedTCPPacket+0x2cc>)
  40d3f0:	4c25      	ldr	r4, [pc, #148]	; (40d488 <xProcessReceivedTCPPacket+0x2ac>)
  40d3f2:	47a0      	blx	r4

                /* Implement https://tools.ietf.org/html/rfc5961#section-3.2. */
                if( pxSocket->u.xTCP.ucTCPState == eCONNECT_SYN )
  40d3f4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40d3f6:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
  40d3fa:	2b02      	cmp	r3, #2
  40d3fc:	d10b      	bne.n	40d416 <xProcessReceivedTCPPacket+0x23a>
                {
                    /* Per the above RFC, "In the SYN-SENT state ... the RST is
                    acceptable if the ACK field acknowledges the SYN." */
                    if( ulAckNumber == pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber + 1 )
  40d3fe:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40d400:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
  40d404:	1c5a      	adds	r2, r3, #1
  40d406:	693b      	ldr	r3, [r7, #16]
  40d408:	429a      	cmp	r2, r3
  40d40a:	d123      	bne.n	40d454 <xProcessReceivedTCPPacket+0x278>
                    {
                        vTCPStateChange( pxSocket, eCLOSED );
  40d40c:	2100      	movs	r1, #0
  40d40e:	6b78      	ldr	r0, [r7, #52]	; 0x34
  40d410:	4b26      	ldr	r3, [pc, #152]	; (40d4ac <xProcessReceivedTCPPacket+0x2d0>)
  40d412:	4798      	blx	r3
  40d414:	e01e      	b.n	40d454 <xProcessReceivedTCPPacket+0x278>
                    }
                }
                else
                {
                    /* Check whether the packet matches the next expected sequence number. */
                    if( ulSequenceNumber == pxSocket->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber )
  40d416:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40d418:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
  40d41c:	697b      	ldr	r3, [r7, #20]
  40d41e:	429a      	cmp	r2, r3
  40d420:	d104      	bne.n	40d42c <xProcessReceivedTCPPacket+0x250>
                    {
                        vTCPStateChange( pxSocket, eCLOSED );
  40d422:	2100      	movs	r1, #0
  40d424:	6b78      	ldr	r0, [r7, #52]	; 0x34
  40d426:	4b21      	ldr	r3, [pc, #132]	; (40d4ac <xProcessReceivedTCPPacket+0x2d0>)
  40d428:	4798      	blx	r3
  40d42a:	e013      	b.n	40d454 <xProcessReceivedTCPPacket+0x278>
                    }
                    /* Otherwise, check whether the packet is within the receive window. */
                    else if( ulSequenceNumber > pxSocket->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber &&
  40d42c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40d42e:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
  40d432:	697b      	ldr	r3, [r7, #20]
  40d434:	429a      	cmp	r2, r3
  40d436:	d20d      	bcs.n	40d454 <xProcessReceivedTCPPacket+0x278>
                             ulSequenceNumber < ( pxSocket->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber +
  40d438:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40d43a:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
                                                  pxSocket->u.xTCP.xTCPWindow.xSize.ulRxWindowLength ) )
  40d43e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40d440:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
                             ulSequenceNumber < ( pxSocket->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber +
  40d444:	441a      	add	r2, r3
                    else if( ulSequenceNumber > pxSocket->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber &&
  40d446:	697b      	ldr	r3, [r7, #20]
  40d448:	429a      	cmp	r2, r3
  40d44a:	d903      	bls.n	40d454 <xProcessReceivedTCPPacket+0x278>
                    {
                        /* Send a challenge ACK. */
                        prvTCPSendChallengeAck( pxNetworkBuffer );
  40d44c:	687b      	ldr	r3, [r7, #4]
  40d44e:	4618      	mov	r0, r3
  40d450:	4b17      	ldr	r3, [pc, #92]	; (40d4b0 <xProcessReceivedTCPPacket+0x2d4>)
  40d452:	4798      	blx	r3
                    }
                }

                /* Otherwise, do nothing. In any case, the packet cannot be handled. */
				xResult = pdFAIL;
  40d454:	2300      	movs	r3, #0
  40d456:	633b      	str	r3, [r7, #48]	; 0x30
  40d458:	e03d      	b.n	40d4d6 <xProcessReceivedTCPPacket+0x2fa>
			}
			else if( ( ( ucTCPFlags & ipTCP_FLAG_CTRL ) == ipTCP_FLAG_SYN ) && ( pxSocket->u.xTCP.ucTCPState >= eESTABLISHED ) )
  40d45a:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
  40d45c:	f003 031f 	and.w	r3, r3, #31
  40d460:	2b02      	cmp	r3, #2
  40d462:	d129      	bne.n	40d4b8 <xProcessReceivedTCPPacket+0x2dc>
  40d464:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40d466:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
  40d46a:	2b04      	cmp	r3, #4
  40d46c:	d924      	bls.n	40d4b8 <xProcessReceivedTCPPacket+0x2dc>
			{
				/* SYN flag while this socket is already connected. */
				FreeRTOS_debug_printf( ( "TCP: SYN unexpected from %lxip:%u\n", ulRemoteIP, xRemotePort ) );
  40d46e:	8b7b      	ldrh	r3, [r7, #26]
  40d470:	461a      	mov	r2, r3
  40d472:	69f9      	ldr	r1, [r7, #28]
  40d474:	480f      	ldr	r0, [pc, #60]	; (40d4b4 <xProcessReceivedTCPPacket+0x2d8>)
  40d476:	4b04      	ldr	r3, [pc, #16]	; (40d488 <xProcessReceivedTCPPacket+0x2ac>)
  40d478:	4798      	blx	r3

				/* The packet cannot be handled. */
				xResult = pdFAIL;
  40d47a:	2300      	movs	r3, #0
  40d47c:	633b      	str	r3, [r7, #48]	; 0x30
  40d47e:	e02a      	b.n	40d4d6 <xProcessReceivedTCPPacket+0x2fa>
  40d480:	0041d32c 	.word	0x0041d32c
  40d484:	0041d384 	.word	0x0041d384
  40d488:	00416c7d 	.word	0x00416c7d
  40d48c:	00409e95 	.word	0x00409e95
  40d490:	0040abb9 	.word	0x0040abb9
  40d494:	0041d6f8 	.word	0x0041d6f8
  40d498:	0040d129 	.word	0x0040d129
  40d49c:	0040b679 	.word	0x0040b679
  40d4a0:	0041d728 	.word	0x0041d728
  40d4a4:	0040d591 	.word	0x0040d591
  40d4a8:	0041d768 	.word	0x0041d768
  40d4ac:	0040bbc1 	.word	0x0040bbc1
  40d4b0:	0040d109 	.word	0x0040d109
  40d4b4:	0041d790 	.word	0x0041d790
			else
			{
				/* Update the copy of the TCP header only (skipping eth and IP
				headers).  It might be used later on, whenever data must be sent
				to the peer. */
				const BaseType_t lOffset = ( BaseType_t ) ( ipSIZE_OF_ETH_HEADER + ipSIZE_OF_IPv4_HEADER );
  40d4b8:	2322      	movs	r3, #34	; 0x22
  40d4ba:	60fb      	str	r3, [r7, #12]
				memcpy( pxSocket->u.xTCP.xPacket.u.ucLastPacket + lOffset, pxNetworkBuffer->pucEthernetBuffer + lOffset, ipSIZE_OF_TCP_HEADER );
  40d4bc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40d4be:	f103 027a 	add.w	r2, r3, #122	; 0x7a
  40d4c2:	68fb      	ldr	r3, [r7, #12]
  40d4c4:	18d0      	adds	r0, r2, r3
  40d4c6:	687b      	ldr	r3, [r7, #4]
  40d4c8:	699a      	ldr	r2, [r3, #24]
  40d4ca:	68fb      	ldr	r3, [r7, #12]
  40d4cc:	4413      	add	r3, r2
  40d4ce:	2214      	movs	r2, #20
  40d4d0:	4619      	mov	r1, r3
  40d4d2:	4b28      	ldr	r3, [pc, #160]	; (40d574 <xProcessReceivedTCPPacket+0x398>)
  40d4d4:	4798      	blx	r3
			}
		}
	}

	if( xResult != pdFAIL )
  40d4d6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  40d4d8:	2b00      	cmp	r3, #0
  40d4da:	d046      	beq.n	40d56a <xProcessReceivedTCPPacket+0x38e>
	{
		/* Touch the alive timers because we received a message	for this
		socket. */
		prvTCPTouchSocket( pxSocket );
  40d4dc:	6b78      	ldr	r0, [r7, #52]	; 0x34
  40d4de:	4b26      	ldr	r3, [pc, #152]	; (40d578 <xProcessReceivedTCPPacket+0x39c>)
  40d4e0:	4798      	blx	r3
		/* _HT_ : if we're in the SYN phase, and peer does not send a MSS option,
		then we MUST assume an MSS size of 536 bytes for backward compatibility. */

		/* When there are no TCP options, the TCP offset equals 20 bytes, which is stored as
		the number 5 (words) in the higher niblle of the TCP-offset byte. */
		if( ( pxTCPPacket->xTCPHeader.ucTCPOffset & TCP_OFFSET_LENGTH_BITS ) > TCP_OFFSET_STANDARD_LENGTH )
  40d4e2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40d4e4:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
  40d4e8:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
  40d4ec:	2b50      	cmp	r3, #80	; 0x50
  40d4ee:	d904      	bls.n	40d4fa <xProcessReceivedTCPPacket+0x31e>
		{
			prvCheckOptions( pxSocket, pxNetworkBuffer );
  40d4f0:	687b      	ldr	r3, [r7, #4]
  40d4f2:	4619      	mov	r1, r3
  40d4f4:	6b78      	ldr	r0, [r7, #52]	; 0x34
  40d4f6:	4b21      	ldr	r3, [pc, #132]	; (40d57c <xProcessReceivedTCPPacket+0x3a0>)
  40d4f8:	4798      	blx	r3
		}


		#if( ipconfigUSE_TCP_WIN == 1 )
		{
			pxSocket->u.xTCP.ulWindowSize = FreeRTOS_ntohs( pxTCPPacket->xTCPHeader.usWindow );
  40d4fa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40d4fc:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
  40d4fe:	b29b      	uxth	r3, r3
  40d500:	021b      	lsls	r3, r3, #8
  40d502:	b21a      	sxth	r2, r3
  40d504:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40d506:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
  40d508:	b29b      	uxth	r3, r3
  40d50a:	0a1b      	lsrs	r3, r3, #8
  40d50c:	b29b      	uxth	r3, r3
  40d50e:	b21b      	sxth	r3, r3
  40d510:	4313      	orrs	r3, r2
  40d512:	b21b      	sxth	r3, r3
  40d514:	b29b      	uxth	r3, r3
  40d516:	461a      	mov	r2, r3
  40d518:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40d51a:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
			pxSocket->u.xTCP.ulWindowSize =
				( pxSocket->u.xTCP.ulWindowSize << pxSocket->u.xTCP.ucPeerWinScaleFactor );
  40d51e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40d520:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
  40d524:	6b7a      	ldr	r2, [r7, #52]	; 0x34
  40d526:	f892 20c2 	ldrb.w	r2, [r2, #194]	; 0xc2
  40d52a:	fa03 f202 	lsl.w	r2, r3, r2
			pxSocket->u.xTCP.ulWindowSize =
  40d52e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40d530:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
		}
		#endif

		/* In prvTCPHandleState() the incoming messages will be handled
		depending on the current state of the connection. */
		if( prvTCPHandleState( pxSocket, &pxNetworkBuffer ) > 0 )
  40d534:	1d3b      	adds	r3, r7, #4
  40d536:	4619      	mov	r1, r3
  40d538:	6b78      	ldr	r0, [r7, #52]	; 0x34
  40d53a:	4b11      	ldr	r3, [pc, #68]	; (40d580 <xProcessReceivedTCPPacket+0x3a4>)
  40d53c:	4798      	blx	r3
  40d53e:	4603      	mov	r3, r0
  40d540:	2b00      	cmp	r3, #0
  40d542:	dd04      	ble.n	40d54e <xProcessReceivedTCPPacket+0x372>
		{
			/* prvTCPHandleState() has sent a message, see if there are more to
			be transmitted. */
			#if( ipconfigUSE_TCP_WIN == 1 )
			{
				prvTCPSendRepeated( pxSocket, &pxNetworkBuffer );
  40d544:	1d3b      	adds	r3, r7, #4
  40d546:	4619      	mov	r1, r3
  40d548:	6b78      	ldr	r0, [r7, #52]	; 0x34
  40d54a:	4b0e      	ldr	r3, [pc, #56]	; (40d584 <xProcessReceivedTCPPacket+0x3a8>)
  40d54c:	4798      	blx	r3
			}
			#endif /* ipconfigUSE_TCP_WIN */
		}

		if( pxNetworkBuffer != NULL )
  40d54e:	687b      	ldr	r3, [r7, #4]
  40d550:	2b00      	cmp	r3, #0
  40d552:	d005      	beq.n	40d560 <xProcessReceivedTCPPacket+0x384>
		{
			/* We must check if the buffer is unequal to NULL, because the
			socket might keep a reference to it in case a delayed ACK must be
			sent. */
			vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
  40d554:	687b      	ldr	r3, [r7, #4]
  40d556:	4618      	mov	r0, r3
  40d558:	4b0b      	ldr	r3, [pc, #44]	; (40d588 <xProcessReceivedTCPPacket+0x3ac>)
  40d55a:	4798      	blx	r3
			pxNetworkBuffer = NULL;
  40d55c:	2300      	movs	r3, #0
  40d55e:	607b      	str	r3, [r7, #4]
		}

		/* And finally, calculate when this socket wants to be woken up. */
		prvTCPNextTimeout ( pxSocket );
  40d560:	6b78      	ldr	r0, [r7, #52]	; 0x34
  40d562:	4b0a      	ldr	r3, [pc, #40]	; (40d58c <xProcessReceivedTCPPacket+0x3b0>)
  40d564:	4798      	blx	r3
		/* Return pdPASS to tell that the network buffer is 'consumed'. */
		xResult = pdPASS;
  40d566:	2301      	movs	r3, #1
  40d568:	633b      	str	r3, [r7, #48]	; 0x30
	}

	/* pdPASS being returned means the buffer has been consumed. */
	return xResult;
  40d56a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
}
  40d56c:	4618      	mov	r0, r3
  40d56e:	373c      	adds	r7, #60	; 0x3c
  40d570:	46bd      	mov	sp, r7
  40d572:	bd90      	pop	{r4, r7, pc}
  40d574:	00416d05 	.word	0x00416d05
  40d578:	0040bba1 	.word	0x0040bba1
  40d57c:	0040b751 	.word	0x0040b751
  40d580:	0040ce99 	.word	0x0040ce99
  40d584:	0040af11 	.word	0x0040af11
  40d588:	0040f2ed 	.word	0x0040f2ed
  40d58c:	0040c185 	.word	0x0040c185

0040d590 <prvHandleListen>:
/*-----------------------------------------------------------*/

static FreeRTOS_Socket_t *prvHandleListen( FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t *pxNetworkBuffer )
{
  40d590:	b590      	push	{r4, r7, lr}
  40d592:	b089      	sub	sp, #36	; 0x24
  40d594:	af02      	add	r7, sp, #8
  40d596:	6078      	str	r0, [r7, #4]
  40d598:	6039      	str	r1, [r7, #0]
TCPPacket_t * pxTCPPacket = ( TCPPacket_t * ) ( pxNetworkBuffer->pucEthernetBuffer );
  40d59a:	683b      	ldr	r3, [r7, #0]
  40d59c:	699b      	ldr	r3, [r3, #24]
  40d59e:	613b      	str	r3, [r7, #16]
FreeRTOS_Socket_t *pxReturn = NULL;
  40d5a0:	2300      	movs	r3, #0
  40d5a2:	617b      	str	r3, [r7, #20]
uint32_t ulInitialSequenceNumber;

	/* Assume that a new Initial Sequence Number will be required. Request
	it now in order to fail out if necessary. */
	ulInitialSequenceNumber = ulApplicationGetNextSequenceNumber( *ipLOCAL_IP_ADDRESS_POINTER,
  40d5a4:	4b66      	ldr	r3, [pc, #408]	; (40d740 <prvHandleListen+0x1b0>)
  40d5a6:	6958      	ldr	r0, [r3, #20]
  40d5a8:	687b      	ldr	r3, [r7, #4]
  40d5aa:	8c99      	ldrh	r1, [r3, #36]	; 0x24
  40d5ac:	693b      	ldr	r3, [r7, #16]
  40d5ae:	f8d3 201a 	ldr.w	r2, [r3, #26]
  40d5b2:	693b      	ldr	r3, [r7, #16]
  40d5b4:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
  40d5b6:	b29b      	uxth	r3, r3
  40d5b8:	4c62      	ldr	r4, [pc, #392]	; (40d744 <prvHandleListen+0x1b4>)
  40d5ba:	47a0      	blx	r4
  40d5bc:	60f8      	str	r0, [r7, #12]
																  pxTCPPacket->xIPHeader.ulSourceIPAddress,
																  pxTCPPacket->xTCPHeader.usSourcePort );

	/* A pure SYN (without ACK) has come in, create a new socket to answer
	it. */
	if( 0 != ulInitialSequenceNumber )
  40d5be:	68fb      	ldr	r3, [r7, #12]
  40d5c0:	2b00      	cmp	r3, #0
  40d5c2:	d057      	beq.n	40d674 <prvHandleListen+0xe4>
	{
		if( pxSocket->u.xTCP.bits.bReuseSocket != pdFALSE_UNSIGNED )
  40d5c4:	687b      	ldr	r3, [r7, #4]
  40d5c6:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
  40d5ca:	f003 0308 	and.w	r3, r3, #8
  40d5ce:	b2db      	uxtb	r3, r3
  40d5d0:	2b00      	cmp	r3, #0
  40d5d2:	d00c      	beq.n	40d5ee <prvHandleListen+0x5e>
		{
			/* The flag bReuseSocket indicates that the same instance of the
			listening socket should be used for the connection. */
			pxReturn = pxSocket;
  40d5d4:	687b      	ldr	r3, [r7, #4]
  40d5d6:	617b      	str	r3, [r7, #20]
			pxSocket->u.xTCP.bits.bPassQueued = pdTRUE_UNSIGNED;
  40d5d8:	687a      	ldr	r2, [r7, #4]
  40d5da:	f892 3040 	ldrb.w	r3, [r2, #64]	; 0x40
  40d5de:	f043 0304 	orr.w	r3, r3, #4
  40d5e2:	f882 3040 	strb.w	r3, [r2, #64]	; 0x40
			pxSocket->u.xTCP.pxPeerSocket = pxSocket;
  40d5e6:	687b      	ldr	r3, [r7, #4]
  40d5e8:	687a      	ldr	r2, [r7, #4]
  40d5ea:	655a      	str	r2, [r3, #84]	; 0x54
  40d5ec:	e042      	b.n	40d674 <prvHandleListen+0xe4>
		}
		else
		{
			/* The socket does not have the bReuseSocket flag set meaning create a
			new socket when a connection comes in. */
			pxReturn = NULL;
  40d5ee:	2300      	movs	r3, #0
  40d5f0:	617b      	str	r3, [r7, #20]

			if( pxSocket->u.xTCP.usChildCount >= pxSocket->u.xTCP.usBacklog )
  40d5f2:	687b      	ldr	r3, [r7, #4]
  40d5f4:	f8b3 204e 	ldrh.w	r2, [r3, #78]	; 0x4e
  40d5f8:	687b      	ldr	r3, [r7, #4]
  40d5fa:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
  40d5fe:	429a      	cmp	r2, r3
  40d600:	d31b      	bcc.n	40d63a <prvHandleListen+0xaa>
			{
				FreeRTOS_printf( ( "Check: Socket %u already has %u / %u child%s\n",
  40d602:	687b      	ldr	r3, [r7, #4]
  40d604:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
  40d606:	4619      	mov	r1, r3
  40d608:	687b      	ldr	r3, [r7, #4]
  40d60a:	f8b3 304e 	ldrh.w	r3, [r3, #78]	; 0x4e
  40d60e:	461a      	mov	r2, r3
  40d610:	687b      	ldr	r3, [r7, #4]
  40d612:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
  40d616:	4618      	mov	r0, r3
  40d618:	687b      	ldr	r3, [r7, #4]
  40d61a:	f8b3 304e 	ldrh.w	r3, [r3, #78]	; 0x4e
  40d61e:	2b01      	cmp	r3, #1
  40d620:	d101      	bne.n	40d626 <prvHandleListen+0x96>
  40d622:	4b49      	ldr	r3, [pc, #292]	; (40d748 <prvHandleListen+0x1b8>)
  40d624:	e000      	b.n	40d628 <prvHandleListen+0x98>
  40d626:	4b49      	ldr	r3, [pc, #292]	; (40d74c <prvHandleListen+0x1bc>)
  40d628:	9300      	str	r3, [sp, #0]
  40d62a:	4603      	mov	r3, r0
  40d62c:	4848      	ldr	r0, [pc, #288]	; (40d750 <prvHandleListen+0x1c0>)
  40d62e:	4c49      	ldr	r4, [pc, #292]	; (40d754 <prvHandleListen+0x1c4>)
  40d630:	47a0      	blx	r4
					pxSocket->usLocalPort,
					pxSocket->u.xTCP.usChildCount,
					pxSocket->u.xTCP.usBacklog,
					pxSocket->u.xTCP.usChildCount == 1 ? "" : "ren" ) );
				prvTCPSendReset( pxNetworkBuffer );
  40d632:	6838      	ldr	r0, [r7, #0]
  40d634:	4b48      	ldr	r3, [pc, #288]	; (40d758 <prvHandleListen+0x1c8>)
  40d636:	4798      	blx	r3
  40d638:	e01c      	b.n	40d674 <prvHandleListen+0xe4>
			}
			else
			{
				FreeRTOS_Socket_t *pxNewSocket = ( FreeRTOS_Socket_t * )
  40d63a:	2206      	movs	r2, #6
  40d63c:	2101      	movs	r1, #1
  40d63e:	2002      	movs	r0, #2
  40d640:	4b46      	ldr	r3, [pc, #280]	; (40d75c <prvHandleListen+0x1cc>)
  40d642:	4798      	blx	r3
  40d644:	60b8      	str	r0, [r7, #8]
					FreeRTOS_socket( FREERTOS_AF_INET, FREERTOS_SOCK_STREAM, FREERTOS_IPPROTO_TCP );

				if( ( pxNewSocket == NULL ) || ( pxNewSocket == FREERTOS_INVALID_SOCKET ) )
  40d646:	68bb      	ldr	r3, [r7, #8]
  40d648:	2b00      	cmp	r3, #0
  40d64a:	d003      	beq.n	40d654 <prvHandleListen+0xc4>
  40d64c:	68bb      	ldr	r3, [r7, #8]
  40d64e:	f1b3 3fff 	cmp.w	r3, #4294967295
  40d652:	d106      	bne.n	40d662 <prvHandleListen+0xd2>
				{
					FreeRTOS_debug_printf( ( "TCP: Listen: new socket failed\n" ) );
  40d654:	4842      	ldr	r0, [pc, #264]	; (40d760 <prvHandleListen+0x1d0>)
  40d656:	4b3f      	ldr	r3, [pc, #252]	; (40d754 <prvHandleListen+0x1c4>)
  40d658:	4798      	blx	r3
					prvTCPSendReset( pxNetworkBuffer );
  40d65a:	6838      	ldr	r0, [r7, #0]
  40d65c:	4b3e      	ldr	r3, [pc, #248]	; (40d758 <prvHandleListen+0x1c8>)
  40d65e:	4798      	blx	r3
  40d660:	e008      	b.n	40d674 <prvHandleListen+0xe4>
				}
				else if( prvTCPSocketCopy( pxNewSocket, pxSocket ) != pdFALSE )
  40d662:	6879      	ldr	r1, [r7, #4]
  40d664:	68b8      	ldr	r0, [r7, #8]
  40d666:	4b3f      	ldr	r3, [pc, #252]	; (40d764 <prvHandleListen+0x1d4>)
  40d668:	4798      	blx	r3
  40d66a:	4603      	mov	r3, r0
  40d66c:	2b00      	cmp	r3, #0
  40d66e:	d001      	beq.n	40d674 <prvHandleListen+0xe4>
				{
					/* The socket will be connected immediately, no time for the
					owner to setsockopt's, therefore copy properties of the server
					socket to the new socket.  Only the binding might fail (due to
					lack of resources). */
					pxReturn = pxNewSocket;
  40d670:	68bb      	ldr	r3, [r7, #8]
  40d672:	617b      	str	r3, [r7, #20]
				}
			}
		}
	}

	if( ( 0 != ulInitialSequenceNumber ) && ( pxReturn != NULL ) )
  40d674:	68fb      	ldr	r3, [r7, #12]
  40d676:	2b00      	cmp	r3, #0
  40d678:	d05c      	beq.n	40d734 <prvHandleListen+0x1a4>
  40d67a:	697b      	ldr	r3, [r7, #20]
  40d67c:	2b00      	cmp	r3, #0
  40d67e:	d059      	beq.n	40d734 <prvHandleListen+0x1a4>
	{
		pxReturn->u.xTCP.usRemotePort = FreeRTOS_htons( pxTCPPacket->xTCPHeader.usSourcePort );
  40d680:	693b      	ldr	r3, [r7, #16]
  40d682:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
  40d684:	b29b      	uxth	r3, r3
  40d686:	021b      	lsls	r3, r3, #8
  40d688:	b21a      	sxth	r2, r3
  40d68a:	693b      	ldr	r3, [r7, #16]
  40d68c:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
  40d68e:	b29b      	uxth	r3, r3
  40d690:	0a1b      	lsrs	r3, r3, #8
  40d692:	b29b      	uxth	r3, r3
  40d694:	b21b      	sxth	r3, r3
  40d696:	4313      	orrs	r3, r2
  40d698:	b21b      	sxth	r3, r3
  40d69a:	b29a      	uxth	r2, r3
  40d69c:	697b      	ldr	r3, [r7, #20]
  40d69e:	879a      	strh	r2, [r3, #60]	; 0x3c
		pxReturn->u.xTCP.ulRemoteIP = FreeRTOS_htonl( pxTCPPacket->xIPHeader.ulSourceIPAddress );
  40d6a0:	693b      	ldr	r3, [r7, #16]
  40d6a2:	f8d3 301a 	ldr.w	r3, [r3, #26]
  40d6a6:	061a      	lsls	r2, r3, #24
  40d6a8:	693b      	ldr	r3, [r7, #16]
  40d6aa:	f8d3 301a 	ldr.w	r3, [r3, #26]
  40d6ae:	021b      	lsls	r3, r3, #8
  40d6b0:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
  40d6b4:	431a      	orrs	r2, r3
  40d6b6:	693b      	ldr	r3, [r7, #16]
  40d6b8:	f8d3 301a 	ldr.w	r3, [r3, #26]
  40d6bc:	0a1b      	lsrs	r3, r3, #8
  40d6be:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
  40d6c2:	431a      	orrs	r2, r3
  40d6c4:	693b      	ldr	r3, [r7, #16]
  40d6c6:	f8d3 301a 	ldr.w	r3, [r3, #26]
  40d6ca:	0e1b      	lsrs	r3, r3, #24
  40d6cc:	431a      	orrs	r2, r3
  40d6ce:	697b      	ldr	r3, [r7, #20]
  40d6d0:	639a      	str	r2, [r3, #56]	; 0x38
		pxReturn->u.xTCP.xTCPWindow.ulOurSequenceNumber = ulInitialSequenceNumber;
  40d6d2:	697b      	ldr	r3, [r7, #20]
  40d6d4:	68fa      	ldr	r2, [r7, #12]
  40d6d6:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc

		/* Here is the SYN action. */
		pxReturn->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber = FreeRTOS_ntohl( pxTCPPacket->xTCPHeader.ulSequenceNumber );
  40d6da:	693b      	ldr	r3, [r7, #16]
  40d6dc:	f8d3 3026 	ldr.w	r3, [r3, #38]	; 0x26
  40d6e0:	061a      	lsls	r2, r3, #24
  40d6e2:	693b      	ldr	r3, [r7, #16]
  40d6e4:	f8d3 3026 	ldr.w	r3, [r3, #38]	; 0x26
  40d6e8:	021b      	lsls	r3, r3, #8
  40d6ea:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
  40d6ee:	431a      	orrs	r2, r3
  40d6f0:	693b      	ldr	r3, [r7, #16]
  40d6f2:	f8d3 3026 	ldr.w	r3, [r3, #38]	; 0x26
  40d6f6:	0a1b      	lsrs	r3, r3, #8
  40d6f8:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
  40d6fc:	431a      	orrs	r2, r3
  40d6fe:	693b      	ldr	r3, [r7, #16]
  40d700:	f8d3 3026 	ldr.w	r3, [r3, #38]	; 0x26
  40d704:	0e1b      	lsrs	r3, r3, #24
  40d706:	431a      	orrs	r2, r3
  40d708:	697b      	ldr	r3, [r7, #20]
  40d70a:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
		prvSocketSetMSS( pxReturn );
  40d70e:	6978      	ldr	r0, [r7, #20]
  40d710:	4b15      	ldr	r3, [pc, #84]	; (40d768 <prvHandleListen+0x1d8>)
  40d712:	4798      	blx	r3

		prvTCPCreateWindow( pxReturn );
  40d714:	6978      	ldr	r0, [r7, #20]
  40d716:	4b15      	ldr	r3, [pc, #84]	; (40d76c <prvHandleListen+0x1dc>)
  40d718:	4798      	blx	r3

		vTCPStateChange( pxReturn, eSYN_FIRST );
  40d71a:	2103      	movs	r1, #3
  40d71c:	6978      	ldr	r0, [r7, #20]
  40d71e:	4b14      	ldr	r3, [pc, #80]	; (40d770 <prvHandleListen+0x1e0>)
  40d720:	4798      	blx	r3

		/* Make a copy of the header up to the TCP header.  It is needed later
		on, whenever data must be sent to the peer. */
		memcpy( pxReturn->u.xTCP.xPacket.u.ucLastPacket, pxNetworkBuffer->pucEthernetBuffer, sizeof( pxReturn->u.xTCP.xPacket.u.ucLastPacket ) );
  40d722:	697b      	ldr	r3, [r7, #20]
  40d724:	f103 007a 	add.w	r0, r3, #122	; 0x7a
  40d728:	683b      	ldr	r3, [r7, #0]
  40d72a:	699b      	ldr	r3, [r3, #24]
  40d72c:	2246      	movs	r2, #70	; 0x46
  40d72e:	4619      	mov	r1, r3
  40d730:	4b10      	ldr	r3, [pc, #64]	; (40d774 <prvHandleListen+0x1e4>)
  40d732:	4798      	blx	r3
	}
	return pxReturn;
  40d734:	697b      	ldr	r3, [r7, #20]
}
  40d736:	4618      	mov	r0, r3
  40d738:	371c      	adds	r7, #28
  40d73a:	46bd      	mov	sp, r7
  40d73c:	bd90      	pop	{r4, r7, pc}
  40d73e:	bf00      	nop
  40d740:	20000108 	.word	0x20000108
  40d744:	0040ab91 	.word	0x0040ab91
  40d748:	0041d7b4 	.word	0x0041d7b4
  40d74c:	0041d7b8 	.word	0x0041d7b8
  40d750:	0041d7bc 	.word	0x0041d7bc
  40d754:	00416c7d 	.word	0x00416c7d
  40d758:	0040d129 	.word	0x0040d129
  40d75c:	00408af5 	.word	0x00408af5
  40d760:	0041d7ec 	.word	0x0041d7ec
  40d764:	0040d779 	.word	0x0040d779
  40d768:	0040d149 	.word	0x0040d149
  40d76c:	0040b3b9 	.word	0x0040b3b9
  40d770:	0040bbc1 	.word	0x0040bbc1
  40d774:	00416d05 	.word	0x00416d05

0040d778 <prvTCPSocketCopy>:

/*
 * Duplicates a socket after a listening socket receives a connection.
 */
static BaseType_t prvTCPSocketCopy( FreeRTOS_Socket_t *pxNewSocket, FreeRTOS_Socket_t *pxSocket )
{
  40d778:	b590      	push	{r4, r7, lr}
  40d77a:	b087      	sub	sp, #28
  40d77c:	af02      	add	r7, sp, #8
  40d77e:	6078      	str	r0, [r7, #4]
  40d780:	6039      	str	r1, [r7, #0]
struct freertos_sockaddr xAddress;

	pxNewSocket->xReceiveBlockTime = pxSocket->xReceiveBlockTime;
  40d782:	683b      	ldr	r3, [r7, #0]
  40d784:	69da      	ldr	r2, [r3, #28]
  40d786:	687b      	ldr	r3, [r7, #4]
  40d788:	61da      	str	r2, [r3, #28]
	pxNewSocket->xSendBlockTime = pxSocket->xSendBlockTime;
  40d78a:	683b      	ldr	r3, [r7, #0]
  40d78c:	6a1a      	ldr	r2, [r3, #32]
  40d78e:	687b      	ldr	r3, [r7, #4]
  40d790:	621a      	str	r2, [r3, #32]
	pxNewSocket->ucSocketOptions = pxSocket->ucSocketOptions;
  40d792:	683b      	ldr	r3, [r7, #0]
  40d794:	f893 2026 	ldrb.w	r2, [r3, #38]	; 0x26
  40d798:	687b      	ldr	r3, [r7, #4]
  40d79a:	f883 2026 	strb.w	r2, [r3, #38]	; 0x26
	pxNewSocket->u.xTCP.uxRxStreamSize = pxSocket->u.xTCP.uxRxStreamSize;
  40d79e:	683b      	ldr	r3, [r7, #0]
  40d7a0:	6e5a      	ldr	r2, [r3, #100]	; 0x64
  40d7a2:	687b      	ldr	r3, [r7, #4]
  40d7a4:	665a      	str	r2, [r3, #100]	; 0x64
	pxNewSocket->u.xTCP.uxTxStreamSize = pxSocket->u.xTCP.uxTxStreamSize;
  40d7a6:	683b      	ldr	r3, [r7, #0]
  40d7a8:	6e9a      	ldr	r2, [r3, #104]	; 0x68
  40d7aa:	687b      	ldr	r3, [r7, #4]
  40d7ac:	669a      	str	r2, [r3, #104]	; 0x68
	pxNewSocket->u.xTCP.uxLittleSpace = pxSocket->u.xTCP.uxLittleSpace;
  40d7ae:	683b      	ldr	r3, [r7, #0]
  40d7b0:	6dda      	ldr	r2, [r3, #92]	; 0x5c
  40d7b2:	687b      	ldr	r3, [r7, #4]
  40d7b4:	65da      	str	r2, [r3, #92]	; 0x5c
	pxNewSocket->u.xTCP.uxEnoughSpace = pxSocket->u.xTCP.uxEnoughSpace;
  40d7b6:	683b      	ldr	r3, [r7, #0]
  40d7b8:	6e1a      	ldr	r2, [r3, #96]	; 0x60
  40d7ba:	687b      	ldr	r3, [r7, #4]
  40d7bc:	661a      	str	r2, [r3, #96]	; 0x60
	pxNewSocket->u.xTCP.uxRxWinSize  = pxSocket->u.xTCP.uxRxWinSize;
  40d7be:	683b      	ldr	r3, [r7, #0]
  40d7c0:	f8d3 20c8 	ldr.w	r2, [r3, #200]	; 0xc8
  40d7c4:	687b      	ldr	r3, [r7, #4]
  40d7c6:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
	pxNewSocket->u.xTCP.uxTxWinSize  = pxSocket->u.xTCP.uxTxWinSize;
  40d7ca:	683b      	ldr	r3, [r7, #0]
  40d7cc:	f8d3 20cc 	ldr.w	r2, [r3, #204]	; 0xcc
  40d7d0:	687b      	ldr	r3, [r7, #4]
  40d7d2:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc

	#if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
	{
		/* Child socket of listening sockets will inherit the Socket Set
		Otherwise the owner has no chance of including it into the set. */
		if( pxSocket->pxSocketSet )
  40d7d6:	683b      	ldr	r3, [r7, #0]
  40d7d8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  40d7da:	2b00      	cmp	r3, #0
  40d7dc:	d009      	beq.n	40d7f2 <prvTCPSocketCopy+0x7a>
		{
			pxNewSocket->pxSocketSet = pxSocket->pxSocketSet;
  40d7de:	683b      	ldr	r3, [r7, #0]
  40d7e0:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  40d7e2:	687b      	ldr	r3, [r7, #4]
  40d7e4:	629a      	str	r2, [r3, #40]	; 0x28
			pxNewSocket->xSelectBits = pxSocket->xSelectBits | eSELECT_READ | eSELECT_EXCEPT;
  40d7e6:	683b      	ldr	r3, [r7, #0]
  40d7e8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  40d7ea:	f043 0205 	orr.w	r2, r3, #5
  40d7ee:	687b      	ldr	r3, [r7, #4]
  40d7f0:	62da      	str	r2, [r3, #44]	; 0x2c
		}
	}
	#endif /* ipconfigSUPPORT_SELECT_FUNCTION */

	/* And bind it to the same local port as its parent. */
	xAddress.sin_addr = *ipLOCAL_IP_ADDRESS_POINTER;
  40d7f2:	4b28      	ldr	r3, [pc, #160]	; (40d894 <prvTCPSocketCopy+0x11c>)
  40d7f4:	695b      	ldr	r3, [r3, #20]
  40d7f6:	60fb      	str	r3, [r7, #12]
	xAddress.sin_port = FreeRTOS_htons( pxSocket->usLocalPort );
  40d7f8:	683b      	ldr	r3, [r7, #0]
  40d7fa:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
  40d7fc:	021b      	lsls	r3, r3, #8
  40d7fe:	b21a      	sxth	r2, r3
  40d800:	683b      	ldr	r3, [r7, #0]
  40d802:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
  40d804:	0a1b      	lsrs	r3, r3, #8
  40d806:	b29b      	uxth	r3, r3
  40d808:	b21b      	sxth	r3, r3
  40d80a:	4313      	orrs	r3, r2
  40d80c:	b21b      	sxth	r3, r3
  40d80e:	b29b      	uxth	r3, r3
  40d810:	817b      	strh	r3, [r7, #10]
		orphan temporarily.  Once this socket is really connected, the owner of
		the server socket will be notified. */

		/* When bPassQueued is true, the socket is an orphan until it gets
		connected. */
		pxNewSocket->u.xTCP.bits.bPassQueued = pdTRUE_UNSIGNED;
  40d812:	687a      	ldr	r2, [r7, #4]
  40d814:	f892 3040 	ldrb.w	r3, [r2, #64]	; 0x40
  40d818:	f043 0304 	orr.w	r3, r3, #4
  40d81c:	f882 3040 	strb.w	r3, [r2, #64]	; 0x40
		pxNewSocket->u.xTCP.pxPeerSocket = pxSocket;
  40d820:	687b      	ldr	r3, [r7, #4]
  40d822:	683a      	ldr	r2, [r7, #0]
  40d824:	655a      	str	r2, [r3, #84]	; 0x54
			pxSocket->u.xTCP.pxPeerSocket = pxNewSocket;
		}
	}
	#endif

	pxSocket->u.xTCP.usChildCount++;
  40d826:	683b      	ldr	r3, [r7, #0]
  40d828:	f8b3 304e 	ldrh.w	r3, [r3, #78]	; 0x4e
  40d82c:	3301      	adds	r3, #1
  40d82e:	b29a      	uxth	r2, r3
  40d830:	683b      	ldr	r3, [r7, #0]
  40d832:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e

	FreeRTOS_debug_printf( ( "Gain: Socket %u now has %u / %u child%s\n",
  40d836:	683b      	ldr	r3, [r7, #0]
  40d838:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
  40d83a:	4619      	mov	r1, r3
  40d83c:	683b      	ldr	r3, [r7, #0]
  40d83e:	f8b3 304e 	ldrh.w	r3, [r3, #78]	; 0x4e
  40d842:	461a      	mov	r2, r3
  40d844:	683b      	ldr	r3, [r7, #0]
  40d846:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
  40d84a:	4618      	mov	r0, r3
  40d84c:	683b      	ldr	r3, [r7, #0]
  40d84e:	f8b3 304e 	ldrh.w	r3, [r3, #78]	; 0x4e
  40d852:	2b01      	cmp	r3, #1
  40d854:	d101      	bne.n	40d85a <prvTCPSocketCopy+0xe2>
  40d856:	4b10      	ldr	r3, [pc, #64]	; (40d898 <prvTCPSocketCopy+0x120>)
  40d858:	e000      	b.n	40d85c <prvTCPSocketCopy+0xe4>
  40d85a:	4b10      	ldr	r3, [pc, #64]	; (40d89c <prvTCPSocketCopy+0x124>)
  40d85c:	9300      	str	r3, [sp, #0]
  40d85e:	4603      	mov	r3, r0
  40d860:	480f      	ldr	r0, [pc, #60]	; (40d8a0 <prvTCPSocketCopy+0x128>)
  40d862:	4c10      	ldr	r4, [pc, #64]	; (40d8a4 <prvTCPSocketCopy+0x12c>)
  40d864:	47a0      	blx	r4
		pxSocket->u.xTCP.usChildCount,
		pxSocket->u.xTCP.usBacklog,
		pxSocket->u.xTCP.usChildCount == 1u ? "" : "ren" ) );

	/* Now bind the child socket to the same port as the listening socket. */
	if( vSocketBind ( pxNewSocket, &xAddress, sizeof( xAddress ), pdTRUE ) != 0 )
  40d866:	f107 0108 	add.w	r1, r7, #8
  40d86a:	2301      	movs	r3, #1
  40d86c:	2208      	movs	r2, #8
  40d86e:	6878      	ldr	r0, [r7, #4]
  40d870:	4c0d      	ldr	r4, [pc, #52]	; (40d8a8 <prvTCPSocketCopy+0x130>)
  40d872:	47a0      	blx	r4
  40d874:	4603      	mov	r3, r0
  40d876:	2b00      	cmp	r3, #0
  40d878:	d007      	beq.n	40d88a <prvTCPSocketCopy+0x112>
	{
		FreeRTOS_debug_printf( ( "TCP: Listen: new socket bind error\n" ) );
  40d87a:	480c      	ldr	r0, [pc, #48]	; (40d8ac <prvTCPSocketCopy+0x134>)
  40d87c:	4b09      	ldr	r3, [pc, #36]	; (40d8a4 <prvTCPSocketCopy+0x12c>)
  40d87e:	4798      	blx	r3
		vSocketClose( pxNewSocket );
  40d880:	6878      	ldr	r0, [r7, #4]
  40d882:	4b0b      	ldr	r3, [pc, #44]	; (40d8b0 <prvTCPSocketCopy+0x138>)
  40d884:	4798      	blx	r3
		return pdFALSE;
  40d886:	2300      	movs	r3, #0
  40d888:	e000      	b.n	40d88c <prvTCPSocketCopy+0x114>
	}

	return pdTRUE;
  40d88a:	2301      	movs	r3, #1
}
  40d88c:	4618      	mov	r0, r3
  40d88e:	3714      	adds	r7, #20
  40d890:	46bd      	mov	sp, r7
  40d892:	bd90      	pop	{r4, r7, pc}
  40d894:	20000108 	.word	0x20000108
  40d898:	0041d7b4 	.word	0x0041d7b4
  40d89c:	0041d7b8 	.word	0x0041d7b8
  40d8a0:	0041d80c 	.word	0x0041d80c
  40d8a4:	00416c7d 	.word	0x00416c7d
  40d8a8:	00409005 	.word	0x00409005
  40d8ac:	0041d838 	.word	0x0041d838
  40d8b0:	004091e9 	.word	0x004091e9

0040d8b4 <FreeRTOS_GetTCPStateName>:
/*-----------------------------------------------------------*/

#if( ( ipconfigHAS_DEBUG_PRINTF != 0 ) || ( ipconfigHAS_PRINTF != 0 ) )

	const char *FreeRTOS_GetTCPStateName( UBaseType_t ulState )
	{
  40d8b4:	b480      	push	{r7}
  40d8b6:	b083      	sub	sp, #12
  40d8b8:	af00      	add	r7, sp, #0
  40d8ba:	6078      	str	r0, [r7, #4]
		if( ulState >= ( UBaseType_t ) ARRAY_SIZE( pcStateNames ) )
  40d8bc:	687b      	ldr	r3, [r7, #4]
  40d8be:	2b0c      	cmp	r3, #12
  40d8c0:	d901      	bls.n	40d8c6 <FreeRTOS_GetTCPStateName+0x12>
		{
			ulState = ( UBaseType_t ) ARRAY_SIZE( pcStateNames ) - 1u;
  40d8c2:	230c      	movs	r3, #12
  40d8c4:	607b      	str	r3, [r7, #4]
		}
		return pcStateNames[ ulState ];
  40d8c6:	4a05      	ldr	r2, [pc, #20]	; (40d8dc <FreeRTOS_GetTCPStateName+0x28>)
  40d8c8:	687b      	ldr	r3, [r7, #4]
  40d8ca:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
	}
  40d8ce:	4618      	mov	r0, r3
  40d8d0:	370c      	adds	r7, #12
  40d8d2:	46bd      	mov	sp, r7
  40d8d4:	f85d 7b04 	ldr.w	r7, [sp], #4
  40d8d8:	4770      	bx	lr
  40d8da:	bf00      	nop
  40d8dc:	200000d0 	.word	0x200000d0

0040d8e0 <xTCPCheckNewClient>:
/*
 * In the API accept(), the user asks is there is a new client?  As API's can
 * not walk through the xBoundTCPSocketsList the IP-task will do this.
 */
BaseType_t xTCPCheckNewClient( FreeRTOS_Socket_t *pxSocket )
{
  40d8e0:	b580      	push	{r7, lr}
  40d8e2:	b086      	sub	sp, #24
  40d8e4:	af00      	add	r7, sp, #0
  40d8e6:	6078      	str	r0, [r7, #4]
TickType_t xLocalPort = FreeRTOS_htons( pxSocket->usLocalPort );
  40d8e8:	687b      	ldr	r3, [r7, #4]
  40d8ea:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
  40d8ec:	021b      	lsls	r3, r3, #8
  40d8ee:	b21a      	sxth	r2, r3
  40d8f0:	687b      	ldr	r3, [r7, #4]
  40d8f2:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
  40d8f4:	0a1b      	lsrs	r3, r3, #8
  40d8f6:	b29b      	uxth	r3, r3
  40d8f8:	b21b      	sxth	r3, r3
  40d8fa:	4313      	orrs	r3, r2
  40d8fc:	b21b      	sxth	r3, r3
  40d8fe:	b29b      	uxth	r3, r3
  40d900:	60fb      	str	r3, [r7, #12]
ListItem_t *pxIterator;
FreeRTOS_Socket_t *pxFound;
BaseType_t xResult = pdFALSE;
  40d902:	2300      	movs	r3, #0
  40d904:	613b      	str	r3, [r7, #16]

	/* Here xBoundTCPSocketsList can be accessed safely IP-task is the only one
	who has access. */
	for( pxIterator = ( ListItem_t * ) listGET_HEAD_ENTRY( &xBoundTCPSocketsList );
  40d906:	4b18      	ldr	r3, [pc, #96]	; (40d968 <xTCPCheckNewClient+0x88>)
  40d908:	68db      	ldr	r3, [r3, #12]
  40d90a:	617b      	str	r3, [r7, #20]
  40d90c:	e023      	b.n	40d956 <xTCPCheckNewClient+0x76>
		pxIterator != ( ListItem_t * ) listGET_END_MARKER( &xBoundTCPSocketsList );
		pxIterator = ( ListItem_t * ) listGET_NEXT( pxIterator ) )
	{
		if( listGET_LIST_ITEM_VALUE( pxIterator ) == xLocalPort )
  40d90e:	697b      	ldr	r3, [r7, #20]
  40d910:	681a      	ldr	r2, [r3, #0]
  40d912:	68fb      	ldr	r3, [r7, #12]
  40d914:	429a      	cmp	r2, r3
  40d916:	d11b      	bne.n	40d950 <xTCPCheckNewClient+0x70>
		{
			pxFound = ( FreeRTOS_Socket_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
  40d918:	697b      	ldr	r3, [r7, #20]
  40d91a:	68db      	ldr	r3, [r3, #12]
  40d91c:	60bb      	str	r3, [r7, #8]
			if( ( pxFound->ucProtocol == FREERTOS_IPPROTO_TCP ) && ( pxFound->u.xTCP.bits.bPassAccept != pdFALSE_UNSIGNED ) )
  40d91e:	68bb      	ldr	r3, [r7, #8]
  40d920:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
  40d924:	2b06      	cmp	r3, #6
  40d926:	d113      	bne.n	40d950 <xTCPCheckNewClient+0x70>
  40d928:	68bb      	ldr	r3, [r7, #8]
  40d92a:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
  40d92e:	f003 0302 	and.w	r3, r3, #2
  40d932:	b2db      	uxtb	r3, r3
  40d934:	2b00      	cmp	r3, #0
  40d936:	d00b      	beq.n	40d950 <xTCPCheckNewClient+0x70>
			{
				pxSocket->u.xTCP.pxPeerSocket = pxFound;
  40d938:	687b      	ldr	r3, [r7, #4]
  40d93a:	68ba      	ldr	r2, [r7, #8]
  40d93c:	655a      	str	r2, [r3, #84]	; 0x54
				FreeRTOS_debug_printf( ( "xTCPCheckNewClient[0]: client on port %u\n", pxSocket->usLocalPort ) );
  40d93e:	687b      	ldr	r3, [r7, #4]
  40d940:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
  40d942:	4619      	mov	r1, r3
  40d944:	4809      	ldr	r0, [pc, #36]	; (40d96c <xTCPCheckNewClient+0x8c>)
  40d946:	4b0a      	ldr	r3, [pc, #40]	; (40d970 <xTCPCheckNewClient+0x90>)
  40d948:	4798      	blx	r3
				xResult = pdTRUE;
  40d94a:	2301      	movs	r3, #1
  40d94c:	613b      	str	r3, [r7, #16]
				break;
  40d94e:	e006      	b.n	40d95e <xTCPCheckNewClient+0x7e>
		pxIterator = ( ListItem_t * ) listGET_NEXT( pxIterator ) )
  40d950:	697b      	ldr	r3, [r7, #20]
  40d952:	685b      	ldr	r3, [r3, #4]
  40d954:	617b      	str	r3, [r7, #20]
	for( pxIterator = ( ListItem_t * ) listGET_HEAD_ENTRY( &xBoundTCPSocketsList );
  40d956:	697b      	ldr	r3, [r7, #20]
  40d958:	4a06      	ldr	r2, [pc, #24]	; (40d974 <xTCPCheckNewClient+0x94>)
  40d95a:	4293      	cmp	r3, r2
  40d95c:	d1d7      	bne.n	40d90e <xTCPCheckNewClient+0x2e>
			}
		}
	}
	return xResult;
  40d95e:	693b      	ldr	r3, [r7, #16]
}
  40d960:	4618      	mov	r0, r3
  40d962:	3718      	adds	r7, #24
  40d964:	46bd      	mov	sp, r7
  40d966:	bd80      	pop	{r7, pc}
  40d968:	2000b5b0 	.word	0x2000b5b0
  40d96c:	0041d85c 	.word	0x0041d85c
  40d970:	00416c7d 	.word	0x00416c7d
  40d974:	2000b5b8 	.word	0x2000b5b8

0040d978 <FreeRTOS_min_int32>:
	static portINLINE int32_t  FreeRTOS_min_int32  (int32_t  a, int32_t  b) { return a <= b ? a : b; }
  40d978:	b480      	push	{r7}
  40d97a:	b083      	sub	sp, #12
  40d97c:	af00      	add	r7, sp, #0
  40d97e:	6078      	str	r0, [r7, #4]
  40d980:	6039      	str	r1, [r7, #0]
  40d982:	687a      	ldr	r2, [r7, #4]
  40d984:	683b      	ldr	r3, [r7, #0]
  40d986:	4293      	cmp	r3, r2
  40d988:	bfa8      	it	ge
  40d98a:	4613      	movge	r3, r2
  40d98c:	4618      	mov	r0, r3
  40d98e:	370c      	adds	r7, #12
  40d990:	46bd      	mov	sp, r7
  40d992:	f85d 7b04 	ldr.w	r7, [sp], #4
  40d996:	4770      	bx	lr

0040d998 <FreeRTOS_min_uint32>:
	static portINLINE uint32_t FreeRTOS_min_uint32 (uint32_t a, uint32_t b) { return a <= b ? a : b; }
  40d998:	b480      	push	{r7}
  40d99a:	b083      	sub	sp, #12
  40d99c:	af00      	add	r7, sp, #0
  40d99e:	6078      	str	r0, [r7, #4]
  40d9a0:	6039      	str	r1, [r7, #0]
  40d9a2:	687a      	ldr	r2, [r7, #4]
  40d9a4:	683b      	ldr	r3, [r7, #0]
  40d9a6:	4293      	cmp	r3, r2
  40d9a8:	bf28      	it	cs
  40d9aa:	4613      	movcs	r3, r2
  40d9ac:	4618      	mov	r0, r3
  40d9ae:	370c      	adds	r7, #12
  40d9b0:	46bd      	mov	sp, r7
  40d9b2:	f85d 7b04 	ldr.w	r7, [sp], #4
  40d9b6:	4770      	bx	lr

0040d9b8 <xSequenceLessThanOrEqual>:

#if( ipconfigUSE_TCP_WIN == 1 )
	/* Some 32-bit arithmetic: comparing sequence numbers */
	static portINLINE BaseType_t xSequenceLessThanOrEqual( uint32_t a, uint32_t b );
	static portINLINE BaseType_t xSequenceLessThanOrEqual( uint32_t a, uint32_t b )
	{
  40d9b8:	b480      	push	{r7}
  40d9ba:	b083      	sub	sp, #12
  40d9bc:	af00      	add	r7, sp, #0
  40d9be:	6078      	str	r0, [r7, #4]
  40d9c0:	6039      	str	r1, [r7, #0]
		/* Test if a <= b
		Return true if the unsigned subtraction of (b-a) doesn't generate an
		arithmetic overflow. */
		return ( ( b - a ) & 0x80000000UL ) == 0UL;
  40d9c2:	683a      	ldr	r2, [r7, #0]
  40d9c4:	687b      	ldr	r3, [r7, #4]
  40d9c6:	1ad3      	subs	r3, r2, r3
  40d9c8:	43db      	mvns	r3, r3
  40d9ca:	0fdb      	lsrs	r3, r3, #31
  40d9cc:	b2db      	uxtb	r3, r3
	}
  40d9ce:	4618      	mov	r0, r3
  40d9d0:	370c      	adds	r7, #12
  40d9d2:	46bd      	mov	sp, r7
  40d9d4:	f85d 7b04 	ldr.w	r7, [sp], #4
  40d9d8:	4770      	bx	lr

0040d9da <xSequenceLessThan>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )
	static portINLINE BaseType_t xSequenceLessThan( uint32_t a, uint32_t b );
	static portINLINE BaseType_t xSequenceLessThan( uint32_t a, uint32_t b )
	{
  40d9da:	b480      	push	{r7}
  40d9dc:	b083      	sub	sp, #12
  40d9de:	af00      	add	r7, sp, #0
  40d9e0:	6078      	str	r0, [r7, #4]
  40d9e2:	6039      	str	r1, [r7, #0]
		/* Test if a < b */
		return ( ( b - a - 1UL ) & 0x80000000UL ) == 0UL;
  40d9e4:	683a      	ldr	r2, [r7, #0]
  40d9e6:	687b      	ldr	r3, [r7, #4]
  40d9e8:	1ad3      	subs	r3, r2, r3
  40d9ea:	3b01      	subs	r3, #1
  40d9ec:	43db      	mvns	r3, r3
  40d9ee:	0fdb      	lsrs	r3, r3, #31
  40d9f0:	b2db      	uxtb	r3, r3
	}
  40d9f2:	4618      	mov	r0, r3
  40d9f4:	370c      	adds	r7, #12
  40d9f6:	46bd      	mov	sp, r7
  40d9f8:	f85d 7b04 	ldr.w	r7, [sp], #4
  40d9fc:	4770      	bx	lr

0040d9fe <xSequenceGreaterThan>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )
	static portINLINE BaseType_t xSequenceGreaterThan( uint32_t a, uint32_t b );
	static portINLINE BaseType_t xSequenceGreaterThan( uint32_t a, uint32_t b )
	{
  40d9fe:	b480      	push	{r7}
  40da00:	b083      	sub	sp, #12
  40da02:	af00      	add	r7, sp, #0
  40da04:	6078      	str	r0, [r7, #4]
  40da06:	6039      	str	r1, [r7, #0]
		/* Test if a > b */
		return ( ( a - b - 1UL ) & 0x80000000UL ) == 0UL;
  40da08:	687a      	ldr	r2, [r7, #4]
  40da0a:	683b      	ldr	r3, [r7, #0]
  40da0c:	1ad3      	subs	r3, r2, r3
  40da0e:	3b01      	subs	r3, #1
  40da10:	43db      	mvns	r3, r3
  40da12:	0fdb      	lsrs	r3, r3, #31
  40da14:	b2db      	uxtb	r3, r3
	}
  40da16:	4618      	mov	r0, r3
  40da18:	370c      	adds	r7, #12
  40da1a:	46bd      	mov	sp, r7
  40da1c:	f85d 7b04 	ldr.w	r7, [sp], #4
  40da20:	4770      	bx	lr

0040da22 <xSequenceGreaterThanOrEqual>:
#endif /* ipconfigUSE_TCP_WIN */

/*-----------------------------------------------------------*/
static portINLINE BaseType_t xSequenceGreaterThanOrEqual( uint32_t a, uint32_t b );
static portINLINE BaseType_t xSequenceGreaterThanOrEqual( uint32_t a, uint32_t b )
{
  40da22:	b480      	push	{r7}
  40da24:	b083      	sub	sp, #12
  40da26:	af00      	add	r7, sp, #0
  40da28:	6078      	str	r0, [r7, #4]
  40da2a:	6039      	str	r1, [r7, #0]
	/* Test if a >= b */
	return ( ( a - b ) & 0x80000000UL ) == 0UL;
  40da2c:	687a      	ldr	r2, [r7, #4]
  40da2e:	683b      	ldr	r3, [r7, #0]
  40da30:	1ad3      	subs	r3, r2, r3
  40da32:	43db      	mvns	r3, r3
  40da34:	0fdb      	lsrs	r3, r3, #31
  40da36:	b2db      	uxtb	r3, r3
}
  40da38:	4618      	mov	r0, r3
  40da3a:	370c      	adds	r7, #12
  40da3c:	46bd      	mov	sp, r7
  40da3e:	f85d 7b04 	ldr.w	r7, [sp], #4
  40da42:	4770      	bx	lr

0040da44 <vListInsertFifo>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )
	static portINLINE void vListInsertFifo( List_t * const pxList, ListItem_t * const pxNewListItem );
	static portINLINE void vListInsertFifo( List_t * const pxList, ListItem_t * const pxNewListItem )
	{
  40da44:	b580      	push	{r7, lr}
  40da46:	b082      	sub	sp, #8
  40da48:	af00      	add	r7, sp, #0
  40da4a:	6078      	str	r0, [r7, #4]
  40da4c:	6039      	str	r1, [r7, #0]
		vListInsertGeneric( pxList, pxNewListItem, &pxList->xListEnd );
  40da4e:	687b      	ldr	r3, [r7, #4]
  40da50:	3308      	adds	r3, #8
  40da52:	461a      	mov	r2, r3
  40da54:	6839      	ldr	r1, [r7, #0]
  40da56:	6878      	ldr	r0, [r7, #4]
  40da58:	4b02      	ldr	r3, [pc, #8]	; (40da64 <vListInsertFifo+0x20>)
  40da5a:	4798      	blx	r3
	}
  40da5c:	bf00      	nop
  40da5e:	3708      	adds	r7, #8
  40da60:	46bd      	mov	sp, r7
  40da62:	bd80      	pop	{r7, pc}
  40da64:	0040daa9 	.word	0x0040daa9

0040da68 <vTCPTimerSet>:
#endif
/*-----------------------------------------------------------*/

static portINLINE void vTCPTimerSet( TCPTimer_t *pxTimer );
static portINLINE void vTCPTimerSet( TCPTimer_t *pxTimer )
{
  40da68:	b580      	push	{r7, lr}
  40da6a:	b082      	sub	sp, #8
  40da6c:	af00      	add	r7, sp, #0
  40da6e:	6078      	str	r0, [r7, #4]
	pxTimer->ulBorn = xTaskGetTickCount ( );
  40da70:	4b04      	ldr	r3, [pc, #16]	; (40da84 <vTCPTimerSet+0x1c>)
  40da72:	4798      	blx	r3
  40da74:	4602      	mov	r2, r0
  40da76:	687b      	ldr	r3, [r7, #4]
  40da78:	601a      	str	r2, [r3, #0]
}
  40da7a:	bf00      	nop
  40da7c:	3708      	adds	r7, #8
  40da7e:	46bd      	mov	sp, r7
  40da80:	bd80      	pop	{r7, pc}
  40da82:	bf00      	nop
  40da84:	004127d1 	.word	0x004127d1

0040da88 <ulTimerGetAge>:
/*-----------------------------------------------------------*/

static portINLINE uint32_t ulTimerGetAge( TCPTimer_t *pxTimer );
static portINLINE uint32_t ulTimerGetAge( TCPTimer_t *pxTimer )
{
  40da88:	b580      	push	{r7, lr}
  40da8a:	b082      	sub	sp, #8
  40da8c:	af00      	add	r7, sp, #0
  40da8e:	6078      	str	r0, [r7, #4]
	return ( ( xTaskGetTickCount() - pxTimer->ulBorn ) * portTICK_PERIOD_MS );
  40da90:	4b04      	ldr	r3, [pc, #16]	; (40daa4 <ulTimerGetAge+0x1c>)
  40da92:	4798      	blx	r3
  40da94:	4602      	mov	r2, r0
  40da96:	687b      	ldr	r3, [r7, #4]
  40da98:	681b      	ldr	r3, [r3, #0]
  40da9a:	1ad3      	subs	r3, r2, r3
}
  40da9c:	4618      	mov	r0, r3
  40da9e:	3708      	adds	r7, #8
  40daa0:	46bd      	mov	sp, r7
  40daa2:	bd80      	pop	{r7, pc}
  40daa4:	004127d1 	.word	0x004127d1

0040daa8 <vListInsertGeneric>:
preceded by a prototype. Later this prototype will be located in list.h? */

extern void vListInsertGeneric( List_t * const pxList, ListItem_t * const pxNewListItem, MiniListItem_t * const pxWhere );

void vListInsertGeneric( List_t * const pxList, ListItem_t * const pxNewListItem, MiniListItem_t * const pxWhere )
{
  40daa8:	b480      	push	{r7}
  40daaa:	b085      	sub	sp, #20
  40daac:	af00      	add	r7, sp, #0
  40daae:	60f8      	str	r0, [r7, #12]
  40dab0:	60b9      	str	r1, [r7, #8]
  40dab2:	607a      	str	r2, [r7, #4]
	/* Insert a new list item into pxList, it does not sort the list,
	but it puts the item just before xListEnd, so it will be the last item
	returned by listGET_HEAD_ENTRY() */
	pxNewListItem->pxNext = (struct xLIST_ITEM * configLIST_VOLATILE)pxWhere;
  40dab4:	68bb      	ldr	r3, [r7, #8]
  40dab6:	687a      	ldr	r2, [r7, #4]
  40dab8:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxWhere->pxPrevious;
  40daba:	687b      	ldr	r3, [r7, #4]
  40dabc:	689a      	ldr	r2, [r3, #8]
  40dabe:	68bb      	ldr	r3, [r7, #8]
  40dac0:	609a      	str	r2, [r3, #8]
	pxWhere->pxPrevious->pxNext = pxNewListItem;
  40dac2:	687b      	ldr	r3, [r7, #4]
  40dac4:	689b      	ldr	r3, [r3, #8]
  40dac6:	68ba      	ldr	r2, [r7, #8]
  40dac8:	605a      	str	r2, [r3, #4]
	pxWhere->pxPrevious = pxNewListItem;
  40daca:	687b      	ldr	r3, [r7, #4]
  40dacc:	68ba      	ldr	r2, [r7, #8]
  40dace:	609a      	str	r2, [r3, #8]

	/* Remember which list the item is in. */
	listLIST_ITEM_CONTAINER( pxNewListItem ) = ( void * ) pxList;
  40dad0:	68bb      	ldr	r3, [r7, #8]
  40dad2:	68fa      	ldr	r2, [r7, #12]
  40dad4:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
  40dad6:	68fb      	ldr	r3, [r7, #12]
  40dad8:	681b      	ldr	r3, [r3, #0]
  40dada:	1c5a      	adds	r2, r3, #1
  40dadc:	68fb      	ldr	r3, [r7, #12]
  40dade:	601a      	str	r2, [r3, #0]
}
  40dae0:	bf00      	nop
  40dae2:	3714      	adds	r7, #20
  40dae4:	46bd      	mov	sp, r7
  40dae6:	f85d 7b04 	ldr.w	r7, [sp], #4
  40daea:	4770      	bx	lr

0040daec <prvCreateSectors>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	static BaseType_t prvCreateSectors( void )
	{
  40daec:	b580      	push	{r7, lr}
  40daee:	b082      	sub	sp, #8
  40daf0:	af00      	add	r7, sp, #0
	BaseType_t xIndex, xReturn;

		/* Allocate space for 'xTCPSegments' and store them in 'xSegmentList'. */

		vListInitialise( &xSegmentList );
  40daf2:	4827      	ldr	r0, [pc, #156]	; (40db90 <prvCreateSectors+0xa4>)
  40daf4:	4b27      	ldr	r3, [pc, #156]	; (40db94 <prvCreateSectors+0xa8>)
  40daf6:	4798      	blx	r3
		xTCPSegments = ( TCPSegment_t * ) pvPortMallocLarge( ipconfigTCP_WIN_SEG_COUNT * sizeof( xTCPSegments[ 0 ] ) );
  40daf8:	f44f 5070 	mov.w	r0, #15360	; 0x3c00
  40dafc:	4b26      	ldr	r3, [pc, #152]	; (40db98 <prvCreateSectors+0xac>)
  40dafe:	4798      	blx	r3
  40db00:	4602      	mov	r2, r0
  40db02:	4b26      	ldr	r3, [pc, #152]	; (40db9c <prvCreateSectors+0xb0>)
  40db04:	601a      	str	r2, [r3, #0]

		if( xTCPSegments == NULL )
  40db06:	4b25      	ldr	r3, [pc, #148]	; (40db9c <prvCreateSectors+0xb0>)
  40db08:	681b      	ldr	r3, [r3, #0]
  40db0a:	2b00      	cmp	r3, #0
  40db0c:	d107      	bne.n	40db1e <prvCreateSectors+0x32>
		{
			FreeRTOS_debug_printf( ( "prvCreateSectors: malloc %lu failed\n",
  40db0e:	f44f 5170 	mov.w	r1, #15360	; 0x3c00
  40db12:	4823      	ldr	r0, [pc, #140]	; (40dba0 <prvCreateSectors+0xb4>)
  40db14:	4b23      	ldr	r3, [pc, #140]	; (40dba4 <prvCreateSectors+0xb8>)
  40db16:	4798      	blx	r3
				ipconfigTCP_WIN_SEG_COUNT * sizeof( xTCPSegments[ 0 ] ) ) );

			xReturn = pdFAIL;
  40db18:	2300      	movs	r3, #0
  40db1a:	603b      	str	r3, [r7, #0]
  40db1c:	e032      	b.n	40db84 <prvCreateSectors+0x98>
		}
		else
		{
			/* Clear the allocated space. */
			memset( xTCPSegments, '\0', ipconfigTCP_WIN_SEG_COUNT * sizeof( xTCPSegments[ 0 ] ) );
  40db1e:	4b1f      	ldr	r3, [pc, #124]	; (40db9c <prvCreateSectors+0xb0>)
  40db20:	681b      	ldr	r3, [r3, #0]
  40db22:	f44f 5270 	mov.w	r2, #15360	; 0x3c00
  40db26:	2100      	movs	r1, #0
  40db28:	4618      	mov	r0, r3
  40db2a:	4b1f      	ldr	r3, [pc, #124]	; (40dba8 <prvCreateSectors+0xbc>)
  40db2c:	4798      	blx	r3

			for( xIndex = 0; xIndex < ipconfigTCP_WIN_SEG_COUNT; xIndex++ )
  40db2e:	2300      	movs	r3, #0
  40db30:	607b      	str	r3, [r7, #4]
  40db32:	e022      	b.n	40db7a <prvCreateSectors+0x8e>
			{
				/* Could call vListInitialiseItem here but all data has been
				nulled already.  Set the owner to a segment descriptor. */
				listSET_LIST_ITEM_OWNER( &( xTCPSegments[ xIndex ].xListItem ), ( void* ) &( xTCPSegments[ xIndex ] ) );
  40db34:	4b19      	ldr	r3, [pc, #100]	; (40db9c <prvCreateSectors+0xb0>)
  40db36:	681a      	ldr	r2, [r3, #0]
  40db38:	687b      	ldr	r3, [r7, #4]
  40db3a:	019b      	lsls	r3, r3, #6
  40db3c:	4413      	add	r3, r2
  40db3e:	4a17      	ldr	r2, [pc, #92]	; (40db9c <prvCreateSectors+0xb0>)
  40db40:	6811      	ldr	r1, [r2, #0]
  40db42:	687a      	ldr	r2, [r7, #4]
  40db44:	0192      	lsls	r2, r2, #6
  40db46:	440a      	add	r2, r1
  40db48:	639a      	str	r2, [r3, #56]	; 0x38
				listSET_LIST_ITEM_OWNER( &( xTCPSegments[ xIndex ].xQueueItem ), ( void* ) &( xTCPSegments[ xIndex ] ) );
  40db4a:	4b14      	ldr	r3, [pc, #80]	; (40db9c <prvCreateSectors+0xb0>)
  40db4c:	681a      	ldr	r2, [r3, #0]
  40db4e:	687b      	ldr	r3, [r7, #4]
  40db50:	019b      	lsls	r3, r3, #6
  40db52:	4413      	add	r3, r2
  40db54:	4a11      	ldr	r2, [pc, #68]	; (40db9c <prvCreateSectors+0xb0>)
  40db56:	6811      	ldr	r1, [r2, #0]
  40db58:	687a      	ldr	r2, [r7, #4]
  40db5a:	0192      	lsls	r2, r2, #6
  40db5c:	440a      	add	r2, r1
  40db5e:	625a      	str	r2, [r3, #36]	; 0x24

				/* And add it to the pool of available segments */
				vListInsertFifo( &xSegmentList, &( xTCPSegments[xIndex].xListItem ) );
  40db60:	4b0e      	ldr	r3, [pc, #56]	; (40db9c <prvCreateSectors+0xb0>)
  40db62:	681a      	ldr	r2, [r3, #0]
  40db64:	687b      	ldr	r3, [r7, #4]
  40db66:	019b      	lsls	r3, r3, #6
  40db68:	4413      	add	r3, r2
  40db6a:	332c      	adds	r3, #44	; 0x2c
  40db6c:	4619      	mov	r1, r3
  40db6e:	4808      	ldr	r0, [pc, #32]	; (40db90 <prvCreateSectors+0xa4>)
  40db70:	4b0e      	ldr	r3, [pc, #56]	; (40dbac <prvCreateSectors+0xc0>)
  40db72:	4798      	blx	r3
			for( xIndex = 0; xIndex < ipconfigTCP_WIN_SEG_COUNT; xIndex++ )
  40db74:	687b      	ldr	r3, [r7, #4]
  40db76:	3301      	adds	r3, #1
  40db78:	607b      	str	r3, [r7, #4]
  40db7a:	687b      	ldr	r3, [r7, #4]
  40db7c:	2bef      	cmp	r3, #239	; 0xef
  40db7e:	ddd9      	ble.n	40db34 <prvCreateSectors+0x48>
			}

			xReturn = pdPASS;
  40db80:	2301      	movs	r3, #1
  40db82:	603b      	str	r3, [r7, #0]
		}

		return xReturn;
  40db84:	683b      	ldr	r3, [r7, #0]
	}
  40db86:	4618      	mov	r0, r3
  40db88:	3708      	adds	r7, #8
  40db8a:	46bd      	mov	sp, r7
  40db8c:	bd80      	pop	{r7, pc}
  40db8e:	bf00      	nop
  40db90:	20006d4c 	.word	0x20006d4c
  40db94:	00410ce1 	.word	0x00410ce1
  40db98:	004111e5 	.word	0x004111e5
  40db9c:	20006d48 	.word	0x20006d48
  40dba0:	0041d888 	.word	0x0041d888
  40dba4:	00416c7d 	.word	0x00416c7d
  40dba8:	00416f01 	.word	0x00416f01
  40dbac:	0040da45 	.word	0x0040da45

0040dbb0 <xTCPWindowRxFind>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	static TCPSegment_t *xTCPWindowRxFind( TCPWindow_t *pxWindow, uint32_t ulSequenceNumber )
	{
  40dbb0:	b480      	push	{r7}
  40dbb2:	b087      	sub	sp, #28
  40dbb4:	af00      	add	r7, sp, #0
  40dbb6:	6078      	str	r0, [r7, #4]
  40dbb8:	6039      	str	r1, [r7, #0]
	const ListItem_t *pxIterator;
	const MiniListItem_t* pxEnd;
	TCPSegment_t *pxSegment, *pxReturn = NULL;
  40dbba:	2300      	movs	r3, #0
  40dbbc:	613b      	str	r3, [r7, #16]

		/* Find a segment with a given sequence number in the list of received
		segments. */

		pxEnd = ( const MiniListItem_t* )listGET_END_MARKER( &pxWindow->xRxSegments );
  40dbbe:	687b      	ldr	r3, [r7, #4]
  40dbc0:	33ac      	adds	r3, #172	; 0xac
  40dbc2:	60fb      	str	r3, [r7, #12]

		for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
  40dbc4:	68fb      	ldr	r3, [r7, #12]
  40dbc6:	685b      	ldr	r3, [r3, #4]
  40dbc8:	617b      	str	r3, [r7, #20]
  40dbca:	e00d      	b.n	40dbe8 <xTCPWindowRxFind+0x38>
			 pxIterator != ( const ListItem_t * ) pxEnd;
			 pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxIterator ) )
		{
			pxSegment = ( TCPSegment_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
  40dbcc:	697b      	ldr	r3, [r7, #20]
  40dbce:	68db      	ldr	r3, [r3, #12]
  40dbd0:	60bb      	str	r3, [r7, #8]

			if( pxSegment->ulSequenceNumber == ulSequenceNumber )
  40dbd2:	68bb      	ldr	r3, [r7, #8]
  40dbd4:	681a      	ldr	r2, [r3, #0]
  40dbd6:	683b      	ldr	r3, [r7, #0]
  40dbd8:	429a      	cmp	r2, r3
  40dbda:	d102      	bne.n	40dbe2 <xTCPWindowRxFind+0x32>
			{
				pxReturn = pxSegment;
  40dbdc:	68bb      	ldr	r3, [r7, #8]
  40dbde:	613b      	str	r3, [r7, #16]
				break;
  40dbe0:	e006      	b.n	40dbf0 <xTCPWindowRxFind+0x40>
			 pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxIterator ) )
  40dbe2:	697b      	ldr	r3, [r7, #20]
  40dbe4:	685b      	ldr	r3, [r3, #4]
  40dbe6:	617b      	str	r3, [r7, #20]
		for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
  40dbe8:	697a      	ldr	r2, [r7, #20]
  40dbea:	68fb      	ldr	r3, [r7, #12]
  40dbec:	429a      	cmp	r2, r3
  40dbee:	d1ed      	bne.n	40dbcc <xTCPWindowRxFind+0x1c>
			}
		}

		return pxReturn;
  40dbf0:	693b      	ldr	r3, [r7, #16]
	}
  40dbf2:	4618      	mov	r0, r3
  40dbf4:	371c      	adds	r7, #28
  40dbf6:	46bd      	mov	sp, r7
  40dbf8:	f85d 7b04 	ldr.w	r7, [sp], #4
  40dbfc:	4770      	bx	lr
	...

0040dc00 <xTCPWindowNew>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	static TCPSegment_t *xTCPWindowNew( TCPWindow_t *pxWindow, uint32_t ulSequenceNumber, int32_t lCount, BaseType_t xIsForRx )
	{
  40dc00:	b580      	push	{r7, lr}
  40dc02:	b088      	sub	sp, #32
  40dc04:	af00      	add	r7, sp, #0
  40dc06:	60f8      	str	r0, [r7, #12]
  40dc08:	60b9      	str	r1, [r7, #8]
  40dc0a:	607a      	str	r2, [r7, #4]
  40dc0c:	603b      	str	r3, [r7, #0]
	TCPSegment_t *pxSegment;
	ListItem_t * pxItem;

		/* Allocate a new segment.  The socket will borrow all segments from a
		common pool: 'xSegmentList', which is a list of 'TCPSegment_t' */
		if( listLIST_IS_EMPTY( &xSegmentList ) != pdFALSE )
  40dc0e:	4b32      	ldr	r3, [pc, #200]	; (40dcd8 <xTCPWindowNew+0xd8>)
  40dc10:	681b      	ldr	r3, [r3, #0]
  40dc12:	2b00      	cmp	r3, #0
  40dc14:	d10c      	bne.n	40dc30 <xTCPWindowNew+0x30>
		{
			/* If the TCP-stack runs out of segments, you might consider
			increasing 'ipconfigTCP_WIN_SEG_COUNT'. */
			FreeRTOS_debug_printf( ( "xTCPWindow%cxNew: Error: all segments occupied\n", xIsForRx ? 'R' : 'T' ) );
  40dc16:	683b      	ldr	r3, [r7, #0]
  40dc18:	2b00      	cmp	r3, #0
  40dc1a:	d001      	beq.n	40dc20 <xTCPWindowNew+0x20>
  40dc1c:	2352      	movs	r3, #82	; 0x52
  40dc1e:	e000      	b.n	40dc22 <xTCPWindowNew+0x22>
  40dc20:	2354      	movs	r3, #84	; 0x54
  40dc22:	4619      	mov	r1, r3
  40dc24:	482d      	ldr	r0, [pc, #180]	; (40dcdc <xTCPWindowNew+0xdc>)
  40dc26:	4b2e      	ldr	r3, [pc, #184]	; (40dce0 <xTCPWindowNew+0xe0>)
  40dc28:	4798      	blx	r3
			pxSegment = NULL;
  40dc2a:	2300      	movs	r3, #0
  40dc2c:	61fb      	str	r3, [r7, #28]
  40dc2e:	e04d      	b.n	40dccc <xTCPWindowNew+0xcc>
		}
		else
		{
			/* Pop the item at the head of the list.  Semaphore protection is
			not required as only the IP task will call these functions.  */
			pxItem = ( ListItem_t * ) listGET_HEAD_ENTRY( &xSegmentList );
  40dc30:	4b29      	ldr	r3, [pc, #164]	; (40dcd8 <xTCPWindowNew+0xd8>)
  40dc32:	68db      	ldr	r3, [r3, #12]
  40dc34:	61bb      	str	r3, [r7, #24]
			pxSegment = ( TCPSegment_t * ) listGET_LIST_ITEM_OWNER( pxItem );
  40dc36:	69bb      	ldr	r3, [r7, #24]
  40dc38:	68db      	ldr	r3, [r3, #12]
  40dc3a:	61fb      	str	r3, [r7, #28]

			configASSERT( pxItem != NULL );
  40dc3c:	69bb      	ldr	r3, [r7, #24]
  40dc3e:	2b00      	cmp	r3, #0
  40dc40:	d105      	bne.n	40dc4e <xTCPWindowNew+0x4e>
  40dc42:	f240 128f 	movw	r2, #399	; 0x18f
  40dc46:	4927      	ldr	r1, [pc, #156]	; (40dce4 <xTCPWindowNew+0xe4>)
  40dc48:	4827      	ldr	r0, [pc, #156]	; (40dce8 <xTCPWindowNew+0xe8>)
  40dc4a:	4b25      	ldr	r3, [pc, #148]	; (40dce0 <xTCPWindowNew+0xe0>)
  40dc4c:	4798      	blx	r3
			configASSERT( pxSegment != NULL );
  40dc4e:	69fb      	ldr	r3, [r7, #28]
  40dc50:	2b00      	cmp	r3, #0
  40dc52:	d105      	bne.n	40dc60 <xTCPWindowNew+0x60>
  40dc54:	f44f 72c8 	mov.w	r2, #400	; 0x190
  40dc58:	4922      	ldr	r1, [pc, #136]	; (40dce4 <xTCPWindowNew+0xe4>)
  40dc5a:	4823      	ldr	r0, [pc, #140]	; (40dce8 <xTCPWindowNew+0xe8>)
  40dc5c:	4b20      	ldr	r3, [pc, #128]	; (40dce0 <xTCPWindowNew+0xe0>)
  40dc5e:	4798      	blx	r3

			/* Remove the item from xSegmentList. */
			uxListRemove( pxItem );
  40dc60:	69b8      	ldr	r0, [r7, #24]
  40dc62:	4b22      	ldr	r3, [pc, #136]	; (40dcec <xTCPWindowNew+0xec>)
  40dc64:	4798      	blx	r3

			/* Add it to either the connections' Rx or Tx queue. */
			vListInsertFifo( xIsForRx ? &pxWindow->xRxSegments : &pxWindow->xTxSegments, pxItem );
  40dc66:	683b      	ldr	r3, [r7, #0]
  40dc68:	2b00      	cmp	r3, #0
  40dc6a:	d002      	beq.n	40dc72 <xTCPWindowNew+0x72>
  40dc6c:	68fb      	ldr	r3, [r7, #12]
  40dc6e:	33a4      	adds	r3, #164	; 0xa4
  40dc70:	e001      	b.n	40dc76 <xTCPWindowNew+0x76>
  40dc72:	68fb      	ldr	r3, [r7, #12]
  40dc74:	3390      	adds	r3, #144	; 0x90
  40dc76:	69b9      	ldr	r1, [r7, #24]
  40dc78:	4618      	mov	r0, r3
  40dc7a:	4b1d      	ldr	r3, [pc, #116]	; (40dcf0 <xTCPWindowNew+0xf0>)
  40dc7c:	4798      	blx	r3

			/* And set the segment's timer to zero */
			vTCPTimerSet( &pxSegment->xTransmitTimer );
  40dc7e:	69fb      	ldr	r3, [r7, #28]
  40dc80:	3310      	adds	r3, #16
  40dc82:	4618      	mov	r0, r3
  40dc84:	4b1b      	ldr	r3, [pc, #108]	; (40dcf4 <xTCPWindowNew+0xf4>)
  40dc86:	4798      	blx	r3

			pxSegment->u.ulFlags = 0;
  40dc88:	69fb      	ldr	r3, [r7, #28]
  40dc8a:	2200      	movs	r2, #0
  40dc8c:	615a      	str	r2, [r3, #20]
			pxSegment->u.bits.bIsForRx = ( xIsForRx != 0 );
  40dc8e:	683b      	ldr	r3, [r7, #0]
  40dc90:	2b00      	cmp	r3, #0
  40dc92:	bf14      	ite	ne
  40dc94:	2301      	movne	r3, #1
  40dc96:	2300      	moveq	r3, #0
  40dc98:	b2d9      	uxtb	r1, r3
  40dc9a:	69fa      	ldr	r2, [r7, #28]
  40dc9c:	7d93      	ldrb	r3, [r2, #22]
  40dc9e:	f361 0382 	bfi	r3, r1, #2, #1
  40dca2:	7593      	strb	r3, [r2, #22]
			pxSegment->lMaxLength = lCount;
  40dca4:	69fb      	ldr	r3, [r7, #28]
  40dca6:	687a      	ldr	r2, [r7, #4]
  40dca8:	605a      	str	r2, [r3, #4]
			pxSegment->lDataLength = lCount;
  40dcaa:	69fb      	ldr	r3, [r7, #28]
  40dcac:	687a      	ldr	r2, [r7, #4]
  40dcae:	609a      	str	r2, [r3, #8]
			pxSegment->ulSequenceNumber = ulSequenceNumber;
  40dcb0:	69fb      	ldr	r3, [r7, #28]
  40dcb2:	68ba      	ldr	r2, [r7, #8]
  40dcb4:	601a      	str	r2, [r3, #0]
			#if( ipconfigHAS_DEBUG_PRINTF != 0 )
			{
			static UBaseType_t xLowestLength = ipconfigTCP_WIN_SEG_COUNT;
			UBaseType_t xLength = listCURRENT_LIST_LENGTH( &xSegmentList );
  40dcb6:	4b08      	ldr	r3, [pc, #32]	; (40dcd8 <xTCPWindowNew+0xd8>)
  40dcb8:	681b      	ldr	r3, [r3, #0]
  40dcba:	617b      	str	r3, [r7, #20]

				if( xLowestLength > xLength )
  40dcbc:	4b0e      	ldr	r3, [pc, #56]	; (40dcf8 <xTCPWindowNew+0xf8>)
  40dcbe:	681a      	ldr	r2, [r3, #0]
  40dcc0:	697b      	ldr	r3, [r7, #20]
  40dcc2:	429a      	cmp	r2, r3
  40dcc4:	d902      	bls.n	40dccc <xTCPWindowNew+0xcc>
				{
					xLowestLength = xLength;
  40dcc6:	4a0c      	ldr	r2, [pc, #48]	; (40dcf8 <xTCPWindowNew+0xf8>)
  40dcc8:	697b      	ldr	r3, [r7, #20]
  40dcca:	6013      	str	r3, [r2, #0]
				}
			}
			#endif /* ipconfigHAS_DEBUG_PRINTF */
		}

		return pxSegment;
  40dccc:	69fb      	ldr	r3, [r7, #28]
	}
  40dcce:	4618      	mov	r0, r3
  40dcd0:	3720      	adds	r7, #32
  40dcd2:	46bd      	mov	sp, r7
  40dcd4:	bd80      	pop	{r7, pc}
  40dcd6:	bf00      	nop
  40dcd8:	20006d4c 	.word	0x20006d4c
  40dcdc:	0041d8b0 	.word	0x0041d8b0
  40dce0:	00416c7d 	.word	0x00416c7d
  40dce4:	0041d8e0 	.word	0x0041d8e0
  40dce8:	0041d93c 	.word	0x0041d93c
  40dcec:	00410df5 	.word	0x00410df5
  40dcf0:	0040da45 	.word	0x0040da45
  40dcf4:	0040da69 	.word	0x0040da69
  40dcf8:	20000104 	.word	0x20000104

0040dcfc <xTCPWindowRxEmpty>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	BaseType_t xTCPWindowRxEmpty( TCPWindow_t *pxWindow )
	{
  40dcfc:	b580      	push	{r7, lr}
  40dcfe:	b084      	sub	sp, #16
  40dd00:	af00      	add	r7, sp, #0
  40dd02:	6078      	str	r0, [r7, #4]
		/* When the peer has a close request (FIN flag), the driver will check
		if there are missing packets in the Rx-queue.  It will accept the
		closure of the connection if both conditions are true:
		  - the Rx-queue is empty
		  - the highest Rx sequence number has been ACK'ed */
		if( listLIST_IS_EMPTY( ( &pxWindow->xRxSegments ) ) == pdFALSE )
  40dd04:	687b      	ldr	r3, [r7, #4]
  40dd06:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
  40dd0a:	2b00      	cmp	r3, #0
  40dd0c:	d002      	beq.n	40dd14 <xTCPWindowRxEmpty+0x18>
		{
			/* Rx data has been stored while earlier packets were missing. */
			xReturn = pdFALSE;
  40dd0e:	2300      	movs	r3, #0
  40dd10:	60fb      	str	r3, [r7, #12]
  40dd12:	e01d      	b.n	40dd50 <xTCPWindowRxEmpty+0x54>
		}
		else if( xSequenceGreaterThanOrEqual( pxWindow->rx.ulCurrentSequenceNumber, pxWindow->rx.ulHighestSequenceNumber ) != pdFALSE )
  40dd14:	687b      	ldr	r3, [r7, #4]
  40dd16:	691a      	ldr	r2, [r3, #16]
  40dd18:	687b      	ldr	r3, [r7, #4]
  40dd1a:	699b      	ldr	r3, [r3, #24]
  40dd1c:	4619      	mov	r1, r3
  40dd1e:	4610      	mov	r0, r2
  40dd20:	4b0e      	ldr	r3, [pc, #56]	; (40dd5c <xTCPWindowRxEmpty+0x60>)
  40dd22:	4798      	blx	r3
  40dd24:	4603      	mov	r3, r0
  40dd26:	2b00      	cmp	r3, #0
  40dd28:	d002      	beq.n	40dd30 <xTCPWindowRxEmpty+0x34>
		{
			/* No Rx packets are being stored and the highest sequence number
			that has been received has been ACKed. */
			xReturn = pdTRUE;
  40dd2a:	2301      	movs	r3, #1
  40dd2c:	60fb      	str	r3, [r7, #12]
  40dd2e:	e00f      	b.n	40dd50 <xTCPWindowRxEmpty+0x54>
		}
		else
		{
			FreeRTOS_debug_printf( ( "xTCPWindowRxEmpty: cur %lu highest %lu (empty)\n",
  40dd30:	687b      	ldr	r3, [r7, #4]
  40dd32:	691a      	ldr	r2, [r3, #16]
  40dd34:	687b      	ldr	r3, [r7, #4]
  40dd36:	68db      	ldr	r3, [r3, #12]
  40dd38:	1ad1      	subs	r1, r2, r3
  40dd3a:	687b      	ldr	r3, [r7, #4]
  40dd3c:	699a      	ldr	r2, [r3, #24]
  40dd3e:	687b      	ldr	r3, [r7, #4]
  40dd40:	68db      	ldr	r3, [r3, #12]
  40dd42:	1ad3      	subs	r3, r2, r3
  40dd44:	461a      	mov	r2, r3
  40dd46:	4806      	ldr	r0, [pc, #24]	; (40dd60 <xTCPWindowRxEmpty+0x64>)
  40dd48:	4b06      	ldr	r3, [pc, #24]	; (40dd64 <xTCPWindowRxEmpty+0x68>)
  40dd4a:	4798      	blx	r3
				( pxWindow->rx.ulCurrentSequenceNumber - pxWindow->rx.ulFirstSequenceNumber ),
				( pxWindow->rx.ulHighestSequenceNumber - pxWindow->rx.ulFirstSequenceNumber ) ) );
			xReturn = pdFALSE;
  40dd4c:	2300      	movs	r3, #0
  40dd4e:	60fb      	str	r3, [r7, #12]
		}

		return xReturn;
  40dd50:	68fb      	ldr	r3, [r7, #12]
	}
  40dd52:	4618      	mov	r0, r3
  40dd54:	3710      	adds	r7, #16
  40dd56:	46bd      	mov	sp, r7
  40dd58:	bd80      	pop	{r7, pc}
  40dd5a:	bf00      	nop
  40dd5c:	0040da23 	.word	0x0040da23
  40dd60:	0041d94c 	.word	0x0041d94c
  40dd64:	00416c7d 	.word	0x00416c7d

0040dd68 <xTCPWindowGetHead>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	static TCPSegment_t *xTCPWindowGetHead( List_t *pxList )
	{
  40dd68:	b580      	push	{r7, lr}
  40dd6a:	b084      	sub	sp, #16
  40dd6c:	af00      	add	r7, sp, #0
  40dd6e:	6078      	str	r0, [r7, #4]
	TCPSegment_t *pxSegment;
	ListItem_t * pxItem;

		/* Detaches and returns the head of a queue. */
		if( listLIST_IS_EMPTY( pxList ) != pdFALSE )
  40dd70:	687b      	ldr	r3, [r7, #4]
  40dd72:	681b      	ldr	r3, [r3, #0]
  40dd74:	2b00      	cmp	r3, #0
  40dd76:	d102      	bne.n	40dd7e <xTCPWindowGetHead+0x16>
		{
			pxSegment = NULL;
  40dd78:	2300      	movs	r3, #0
  40dd7a:	60fb      	str	r3, [r7, #12]
  40dd7c:	e008      	b.n	40dd90 <xTCPWindowGetHead+0x28>
		}
		else
		{
			pxItem = ( ListItem_t * ) listGET_HEAD_ENTRY( pxList );
  40dd7e:	687b      	ldr	r3, [r7, #4]
  40dd80:	68db      	ldr	r3, [r3, #12]
  40dd82:	60bb      	str	r3, [r7, #8]
			pxSegment = ( TCPSegment_t * ) listGET_LIST_ITEM_OWNER( pxItem );
  40dd84:	68bb      	ldr	r3, [r7, #8]
  40dd86:	68db      	ldr	r3, [r3, #12]
  40dd88:	60fb      	str	r3, [r7, #12]

			uxListRemove( pxItem );
  40dd8a:	68b8      	ldr	r0, [r7, #8]
  40dd8c:	4b03      	ldr	r3, [pc, #12]	; (40dd9c <xTCPWindowGetHead+0x34>)
  40dd8e:	4798      	blx	r3
		}

		return pxSegment;
  40dd90:	68fb      	ldr	r3, [r7, #12]
	}
  40dd92:	4618      	mov	r0, r3
  40dd94:	3710      	adds	r7, #16
  40dd96:	46bd      	mov	sp, r7
  40dd98:	bd80      	pop	{r7, pc}
  40dd9a:	bf00      	nop
  40dd9c:	00410df5 	.word	0x00410df5

0040dda0 <xTCPWindowPeekHead>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	static TCPSegment_t *xTCPWindowPeekHead( List_t *pxList )
	{
  40dda0:	b480      	push	{r7}
  40dda2:	b085      	sub	sp, #20
  40dda4:	af00      	add	r7, sp, #0
  40dda6:	6078      	str	r0, [r7, #4]
	ListItem_t *pxItem;
	TCPSegment_t *pxReturn;

		/* Returns the head of a queue but it won't be detached. */
		if( listLIST_IS_EMPTY( pxList ) != pdFALSE )
  40dda8:	687b      	ldr	r3, [r7, #4]
  40ddaa:	681b      	ldr	r3, [r3, #0]
  40ddac:	2b00      	cmp	r3, #0
  40ddae:	d102      	bne.n	40ddb6 <xTCPWindowPeekHead+0x16>
		{
			pxReturn = NULL;
  40ddb0:	2300      	movs	r3, #0
  40ddb2:	60fb      	str	r3, [r7, #12]
  40ddb4:	e005      	b.n	40ddc2 <xTCPWindowPeekHead+0x22>
		}
		else
		{
			pxItem = ( ListItem_t * ) listGET_HEAD_ENTRY( pxList );
  40ddb6:	687b      	ldr	r3, [r7, #4]
  40ddb8:	68db      	ldr	r3, [r3, #12]
  40ddba:	60bb      	str	r3, [r7, #8]
			pxReturn = ( TCPSegment_t * ) listGET_LIST_ITEM_OWNER( pxItem );
  40ddbc:	68bb      	ldr	r3, [r7, #8]
  40ddbe:	68db      	ldr	r3, [r3, #12]
  40ddc0:	60fb      	str	r3, [r7, #12]
		}

		return pxReturn;
  40ddc2:	68fb      	ldr	r3, [r7, #12]
	}
  40ddc4:	4618      	mov	r0, r3
  40ddc6:	3714      	adds	r7, #20
  40ddc8:	46bd      	mov	sp, r7
  40ddca:	f85d 7b04 	ldr.w	r7, [sp], #4
  40ddce:	4770      	bx	lr

0040ddd0 <vTCPWindowFree>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	static void vTCPWindowFree( TCPSegment_t *pxSegment )
	{
  40ddd0:	b580      	push	{r7, lr}
  40ddd2:	b082      	sub	sp, #8
  40ddd4:	af00      	add	r7, sp, #0
  40ddd6:	6078      	str	r0, [r7, #4]
		/*  Free entry pxSegment because it's not used any more.  The ownership
		will be passed back to the segment pool.

		Unlink it from one of the queues, if any. */
		if( listLIST_ITEM_CONTAINER( &( pxSegment->xQueueItem ) ) != NULL )
  40ddd8:	687b      	ldr	r3, [r7, #4]
  40ddda:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  40dddc:	2b00      	cmp	r3, #0
  40ddde:	d004      	beq.n	40ddea <vTCPWindowFree+0x1a>
		{
			uxListRemove( &( pxSegment->xQueueItem ) );
  40dde0:	687b      	ldr	r3, [r7, #4]
  40dde2:	3318      	adds	r3, #24
  40dde4:	4618      	mov	r0, r3
  40dde6:	4b0f      	ldr	r3, [pc, #60]	; (40de24 <vTCPWindowFree+0x54>)
  40dde8:	4798      	blx	r3
		}

		pxSegment->ulSequenceNumber = 0u;
  40ddea:	687b      	ldr	r3, [r7, #4]
  40ddec:	2200      	movs	r2, #0
  40ddee:	601a      	str	r2, [r3, #0]
		pxSegment->lDataLength = 0l;
  40ddf0:	687b      	ldr	r3, [r7, #4]
  40ddf2:	2200      	movs	r2, #0
  40ddf4:	609a      	str	r2, [r3, #8]
		pxSegment->u.ulFlags = 0u;
  40ddf6:	687b      	ldr	r3, [r7, #4]
  40ddf8:	2200      	movs	r2, #0
  40ddfa:	615a      	str	r2, [r3, #20]

		/* Take it out of xRxSegments/xTxSegments */
		if( listLIST_ITEM_CONTAINER( &( pxSegment->xListItem ) ) != NULL )
  40ddfc:	687b      	ldr	r3, [r7, #4]
  40ddfe:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  40de00:	2b00      	cmp	r3, #0
  40de02:	d004      	beq.n	40de0e <vTCPWindowFree+0x3e>
		{
			uxListRemove( &( pxSegment->xListItem ) );
  40de04:	687b      	ldr	r3, [r7, #4]
  40de06:	332c      	adds	r3, #44	; 0x2c
  40de08:	4618      	mov	r0, r3
  40de0a:	4b06      	ldr	r3, [pc, #24]	; (40de24 <vTCPWindowFree+0x54>)
  40de0c:	4798      	blx	r3
		}

		/* Return it to xSegmentList */
		vListInsertFifo( &xSegmentList, &( pxSegment->xListItem ) );
  40de0e:	687b      	ldr	r3, [r7, #4]
  40de10:	332c      	adds	r3, #44	; 0x2c
  40de12:	4619      	mov	r1, r3
  40de14:	4804      	ldr	r0, [pc, #16]	; (40de28 <vTCPWindowFree+0x58>)
  40de16:	4b05      	ldr	r3, [pc, #20]	; (40de2c <vTCPWindowFree+0x5c>)
  40de18:	4798      	blx	r3
	}
  40de1a:	bf00      	nop
  40de1c:	3708      	adds	r7, #8
  40de1e:	46bd      	mov	sp, r7
  40de20:	bd80      	pop	{r7, pc}
  40de22:	bf00      	nop
  40de24:	00410df5 	.word	0x00410df5
  40de28:	20006d4c 	.word	0x20006d4c
  40de2c:	0040da45 	.word	0x0040da45

0040de30 <vTCPWindowDestroy>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	void vTCPWindowDestroy( TCPWindow_t *pxWindow )
	{
  40de30:	b580      	push	{r7, lr}
  40de32:	b086      	sub	sp, #24
  40de34:	af00      	add	r7, sp, #0
  40de36:	6078      	str	r0, [r7, #4]

		/*  Destroy a window.  A TCP window doesn't serve any more.  Return all
		owned segments to the pool.  In order to save code, it will make 2 rounds,
		one to remove the segments from xRxSegments, and a second round to clear
		xTxSegments*/
		for( xRound = 0; xRound < 2; xRound++ )
  40de38:	2300      	movs	r3, #0
  40de3a:	613b      	str	r3, [r7, #16]
  40de3c:	e022      	b.n	40de84 <vTCPWindowDestroy+0x54>
		{
			if( xRound != 0 )
  40de3e:	693b      	ldr	r3, [r7, #16]
  40de40:	2b00      	cmp	r3, #0
  40de42:	d003      	beq.n	40de4c <vTCPWindowDestroy+0x1c>
			{
				pxSegments = &( pxWindow->xRxSegments );
  40de44:	687b      	ldr	r3, [r7, #4]
  40de46:	33a4      	adds	r3, #164	; 0xa4
  40de48:	617b      	str	r3, [r7, #20]
  40de4a:	e002      	b.n	40de52 <vTCPWindowDestroy+0x22>
			}
			else
			{
				pxSegments = &( pxWindow->xTxSegments );
  40de4c:	687b      	ldr	r3, [r7, #4]
  40de4e:	3390      	adds	r3, #144	; 0x90
  40de50:	617b      	str	r3, [r7, #20]
			}

			if( listLIST_IS_INITIALISED( pxSegments ) != pdFALSE )
  40de52:	697b      	ldr	r3, [r7, #20]
  40de54:	689b      	ldr	r3, [r3, #8]
  40de56:	f1b3 3fff 	cmp.w	r3, #4294967295
  40de5a:	d101      	bne.n	40de60 <vTCPWindowDestroy+0x30>
  40de5c:	2301      	movs	r3, #1
  40de5e:	e000      	b.n	40de62 <vTCPWindowDestroy+0x32>
  40de60:	2300      	movs	r3, #0
  40de62:	2b00      	cmp	r3, #0
  40de64:	d00b      	beq.n	40de7e <vTCPWindowDestroy+0x4e>
			{
				while( listCURRENT_LIST_LENGTH( pxSegments ) > 0U )
  40de66:	e006      	b.n	40de76 <vTCPWindowDestroy+0x46>
				{
					pxSegment = ( TCPSegment_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxSegments );
  40de68:	697b      	ldr	r3, [r7, #20]
  40de6a:	68db      	ldr	r3, [r3, #12]
  40de6c:	68db      	ldr	r3, [r3, #12]
  40de6e:	60fb      	str	r3, [r7, #12]
					vTCPWindowFree( pxSegment );
  40de70:	68f8      	ldr	r0, [r7, #12]
  40de72:	4b08      	ldr	r3, [pc, #32]	; (40de94 <vTCPWindowDestroy+0x64>)
  40de74:	4798      	blx	r3
				while( listCURRENT_LIST_LENGTH( pxSegments ) > 0U )
  40de76:	697b      	ldr	r3, [r7, #20]
  40de78:	681b      	ldr	r3, [r3, #0]
  40de7a:	2b00      	cmp	r3, #0
  40de7c:	d1f4      	bne.n	40de68 <vTCPWindowDestroy+0x38>
		for( xRound = 0; xRound < 2; xRound++ )
  40de7e:	693b      	ldr	r3, [r7, #16]
  40de80:	3301      	adds	r3, #1
  40de82:	613b      	str	r3, [r7, #16]
  40de84:	693b      	ldr	r3, [r7, #16]
  40de86:	2b01      	cmp	r3, #1
  40de88:	ddd9      	ble.n	40de3e <vTCPWindowDestroy+0xe>
				}
			}
		}
	}
  40de8a:	bf00      	nop
  40de8c:	3718      	adds	r7, #24
  40de8e:	46bd      	mov	sp, r7
  40de90:	bd80      	pop	{r7, pc}
  40de92:	bf00      	nop
  40de94:	0040ddd1 	.word	0x0040ddd1

0040de98 <vTCPWindowCreate>:
#endif /* ipconfigUSE_TCP_WIN == 1 */
/*-----------------------------------------------------------*/

void vTCPWindowCreate( TCPWindow_t *pxWindow, uint32_t ulRxWindowLength,
	uint32_t ulTxWindowLength, uint32_t ulAckNumber, uint32_t ulSequenceNumber, uint32_t ulMSS )
{
  40de98:	b590      	push	{r4, r7, lr}
  40de9a:	b085      	sub	sp, #20
  40de9c:	af00      	add	r7, sp, #0
  40de9e:	60f8      	str	r0, [r7, #12]
  40dea0:	60b9      	str	r1, [r7, #8]
  40dea2:	607a      	str	r2, [r7, #4]
  40dea4:	603b      	str	r3, [r7, #0]
	/* Create and initialize a window. */

	#if( ipconfigUSE_TCP_WIN == 1 )
	{
		if( xTCPSegments == NULL )
  40dea6:	4b1c      	ldr	r3, [pc, #112]	; (40df18 <vTCPWindowCreate+0x80>)
  40dea8:	681b      	ldr	r3, [r3, #0]
  40deaa:	2b00      	cmp	r3, #0
  40deac:	d101      	bne.n	40deb2 <vTCPWindowCreate+0x1a>
		{
			prvCreateSectors();
  40deae:	4b1b      	ldr	r3, [pc, #108]	; (40df1c <vTCPWindowCreate+0x84>)
  40deb0:	4798      	blx	r3
		}

		vListInitialise( &pxWindow->xTxSegments );
  40deb2:	68fb      	ldr	r3, [r7, #12]
  40deb4:	3390      	adds	r3, #144	; 0x90
  40deb6:	4618      	mov	r0, r3
  40deb8:	4b19      	ldr	r3, [pc, #100]	; (40df20 <vTCPWindowCreate+0x88>)
  40deba:	4798      	blx	r3
		vListInitialise( &pxWindow->xRxSegments );
  40debc:	68fb      	ldr	r3, [r7, #12]
  40debe:	33a4      	adds	r3, #164	; 0xa4
  40dec0:	4618      	mov	r0, r3
  40dec2:	4b17      	ldr	r3, [pc, #92]	; (40df20 <vTCPWindowCreate+0x88>)
  40dec4:	4798      	blx	r3

		vListInitialise( &pxWindow->xPriorityQueue );			/* Priority queue: segments which must be sent immediately */
  40dec6:	68fb      	ldr	r3, [r7, #12]
  40dec8:	3340      	adds	r3, #64	; 0x40
  40deca:	4618      	mov	r0, r3
  40decc:	4b14      	ldr	r3, [pc, #80]	; (40df20 <vTCPWindowCreate+0x88>)
  40dece:	4798      	blx	r3
		vListInitialise( &pxWindow->xTxQueue   );			/* Transmit queue: segments queued for transmission */
  40ded0:	68fb      	ldr	r3, [r7, #12]
  40ded2:	3354      	adds	r3, #84	; 0x54
  40ded4:	4618      	mov	r0, r3
  40ded6:	4b12      	ldr	r3, [pc, #72]	; (40df20 <vTCPWindowCreate+0x88>)
  40ded8:	4798      	blx	r3
		vListInitialise( &pxWindow->xWaitQueue );			/* Waiting queue:  outstanding segments */
  40deda:	68fb      	ldr	r3, [r7, #12]
  40dedc:	3368      	adds	r3, #104	; 0x68
  40dede:	4618      	mov	r0, r3
  40dee0:	4b0f      	ldr	r3, [pc, #60]	; (40df20 <vTCPWindowCreate+0x88>)
  40dee2:	4798      	blx	r3
	}
	#endif /* ipconfigUSE_TCP_WIN == 1 */

	if( xTCPWindowLoggingLevel != 0 )
  40dee4:	4b0f      	ldr	r3, [pc, #60]	; (40df24 <vTCPWindowCreate+0x8c>)
  40dee6:	681b      	ldr	r3, [r3, #0]
  40dee8:	2b00      	cmp	r3, #0
  40deea:	d004      	beq.n	40def6 <vTCPWindowCreate+0x5e>
	{
		FreeRTOS_debug_printf( ( "vTCPWindowCreate: for WinLen = Rx/Tx: %lu/%lu\n",
  40deec:	687a      	ldr	r2, [r7, #4]
  40deee:	68b9      	ldr	r1, [r7, #8]
  40def0:	480d      	ldr	r0, [pc, #52]	; (40df28 <vTCPWindowCreate+0x90>)
  40def2:	4b0e      	ldr	r3, [pc, #56]	; (40df2c <vTCPWindowCreate+0x94>)
  40def4:	4798      	blx	r3
			ulRxWindowLength, ulTxWindowLength ) );
	}

	pxWindow->xSize.ulRxWindowLength = ulRxWindowLength;
  40def6:	68fb      	ldr	r3, [r7, #12]
  40def8:	68ba      	ldr	r2, [r7, #8]
  40defa:	605a      	str	r2, [r3, #4]
	pxWindow->xSize.ulTxWindowLength = ulTxWindowLength;
  40defc:	68fb      	ldr	r3, [r7, #12]
  40defe:	687a      	ldr	r2, [r7, #4]
  40df00:	609a      	str	r2, [r3, #8]

	vTCPWindowInit( pxWindow, ulAckNumber, ulSequenceNumber, ulMSS );
  40df02:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40df04:	6a3a      	ldr	r2, [r7, #32]
  40df06:	6839      	ldr	r1, [r7, #0]
  40df08:	68f8      	ldr	r0, [r7, #12]
  40df0a:	4c09      	ldr	r4, [pc, #36]	; (40df30 <vTCPWindowCreate+0x98>)
  40df0c:	47a0      	blx	r4
}
  40df0e:	bf00      	nop
  40df10:	3714      	adds	r7, #20
  40df12:	46bd      	mov	sp, r7
  40df14:	bd90      	pop	{r4, r7, pc}
  40df16:	bf00      	nop
  40df18:	20006d48 	.word	0x20006d48
  40df1c:	0040daed 	.word	0x0040daed
  40df20:	00410ce1 	.word	0x00410ce1
  40df24:	20006d60 	.word	0x20006d60
  40df28:	0041d97c 	.word	0x0041d97c
  40df2c:	00416c7d 	.word	0x00416c7d
  40df30:	0040df35 	.word	0x0040df35

0040df34 <vTCPWindowInit>:
/*-----------------------------------------------------------*/

void vTCPWindowInit( TCPWindow_t *pxWindow, uint32_t ulAckNumber, uint32_t ulSequenceNumber, uint32_t ulMSS )
{
  40df34:	b480      	push	{r7}
  40df36:	b087      	sub	sp, #28
  40df38:	af00      	add	r7, sp, #0
  40df3a:	60f8      	str	r0, [r7, #12]
  40df3c:	60b9      	str	r1, [r7, #8]
  40df3e:	607a      	str	r2, [r7, #4]
  40df40:	603b      	str	r3, [r7, #0]
const int32_t l500ms = 500;
  40df42:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
  40df46:	617b      	str	r3, [r7, #20]

	pxWindow->u.ulFlags = 0ul;
  40df48:	68fb      	ldr	r3, [r7, #12]
  40df4a:	2200      	movs	r2, #0
  40df4c:	601a      	str	r2, [r3, #0]
	pxWindow->u.bits.bHasInit = pdTRUE_UNSIGNED;
  40df4e:	68fa      	ldr	r2, [r7, #12]
  40df50:	7813      	ldrb	r3, [r2, #0]
  40df52:	f043 0301 	orr.w	r3, r3, #1
  40df56:	7013      	strb	r3, [r2, #0]

	if( ulMSS != 0ul )
  40df58:	683b      	ldr	r3, [r7, #0]
  40df5a:	2b00      	cmp	r3, #0
  40df5c:	d024      	beq.n	40dfa8 <vTCPWindowInit+0x74>
	{
		if( pxWindow->usMSSInit != 0u )
  40df5e:	68fb      	ldr	r3, [r7, #12]
  40df60:	f8b3 30be 	ldrh.w	r3, [r3, #190]	; 0xbe
  40df64:	2b00      	cmp	r3, #0
  40df66:	d004      	beq.n	40df72 <vTCPWindowInit+0x3e>
		{
			pxWindow->usMSSInit = ( uint16_t ) ulMSS;
  40df68:	683b      	ldr	r3, [r7, #0]
  40df6a:	b29a      	uxth	r2, r3
  40df6c:	68fb      	ldr	r3, [r7, #12]
  40df6e:	f8a3 20be 	strh.w	r2, [r3, #190]	; 0xbe
		}

		if( ( ulMSS < ( uint32_t ) pxWindow->usMSS ) || ( pxWindow->usMSS == 0u ) )
  40df72:	68fb      	ldr	r3, [r7, #12]
  40df74:	f8b3 30bc 	ldrh.w	r3, [r3, #188]	; 0xbc
  40df78:	461a      	mov	r2, r3
  40df7a:	683b      	ldr	r3, [r7, #0]
  40df7c:	429a      	cmp	r2, r3
  40df7e:	d804      	bhi.n	40df8a <vTCPWindowInit+0x56>
  40df80:	68fb      	ldr	r3, [r7, #12]
  40df82:	f8b3 30bc 	ldrh.w	r3, [r3, #188]	; 0xbc
  40df86:	2b00      	cmp	r3, #0
  40df88:	d10e      	bne.n	40dfa8 <vTCPWindowInit+0x74>
		{
			pxWindow->xSize.ulRxWindowLength = ( pxWindow->xSize.ulRxWindowLength / ulMSS ) * ulMSS;
  40df8a:	68fb      	ldr	r3, [r7, #12]
  40df8c:	685a      	ldr	r2, [r3, #4]
  40df8e:	683b      	ldr	r3, [r7, #0]
  40df90:	fbb2 f3f3 	udiv	r3, r2, r3
  40df94:	683a      	ldr	r2, [r7, #0]
  40df96:	fb02 f203 	mul.w	r2, r2, r3
  40df9a:	68fb      	ldr	r3, [r7, #12]
  40df9c:	605a      	str	r2, [r3, #4]
			pxWindow->usMSS = ( uint16_t ) ulMSS;
  40df9e:	683b      	ldr	r3, [r7, #0]
  40dfa0:	b29a      	uxth	r2, r3
  40dfa2:	68fb      	ldr	r3, [r7, #12]
  40dfa4:	f8a3 20bc 	strh.w	r2, [r3, #188]	; 0xbc
		pxWindow->xTxSegment.lMaxLength = ( int32_t ) pxWindow->usMSS;
	}
	#endif /* ipconfigUSE_TCP_WIN == 1 */

	/*Start with a timeout of 2 * 500 ms (1 sec). */
	pxWindow->lSRTT = l500ms;
  40dfa8:	68fb      	ldr	r3, [r7, #12]
  40dfaa:	697a      	ldr	r2, [r7, #20]
  40dfac:	639a      	str	r2, [r3, #56]	; 0x38

	/* Just for logging, to print relative sequence numbers. */
	pxWindow->rx.ulFirstSequenceNumber = ulAckNumber;
  40dfae:	68fb      	ldr	r3, [r7, #12]
  40dfb0:	68ba      	ldr	r2, [r7, #8]
  40dfb2:	60da      	str	r2, [r3, #12]

	/* The segment asked for in the next transmission. */
	pxWindow->rx.ulCurrentSequenceNumber = ulAckNumber;
  40dfb4:	68fb      	ldr	r3, [r7, #12]
  40dfb6:	68ba      	ldr	r2, [r7, #8]
  40dfb8:	611a      	str	r2, [r3, #16]

	/* The right-hand side of the receive window. */
	pxWindow->rx.ulHighestSequenceNumber = ulAckNumber;
  40dfba:	68fb      	ldr	r3, [r7, #12]
  40dfbc:	68ba      	ldr	r2, [r7, #8]
  40dfbe:	619a      	str	r2, [r3, #24]

	pxWindow->tx.ulFirstSequenceNumber = ulSequenceNumber;
  40dfc0:	68fb      	ldr	r3, [r7, #12]
  40dfc2:	687a      	ldr	r2, [r7, #4]
  40dfc4:	61da      	str	r2, [r3, #28]

	/* The segment asked for in next transmission. */
	pxWindow->tx.ulCurrentSequenceNumber = ulSequenceNumber;
  40dfc6:	68fb      	ldr	r3, [r7, #12]
  40dfc8:	687a      	ldr	r2, [r7, #4]
  40dfca:	621a      	str	r2, [r3, #32]

	/* The sequence number given to the next outgoing byte to be added is
	maintained by lTCPWindowTxAdd(). */
	pxWindow->ulNextTxSequenceNumber = ulSequenceNumber;
  40dfcc:	68fb      	ldr	r3, [r7, #12]
  40dfce:	687a      	ldr	r2, [r7, #4]
  40dfd0:	635a      	str	r2, [r3, #52]	; 0x34

	/* The right-hand side of the transmit window. */
	pxWindow->tx.ulHighestSequenceNumber = ulSequenceNumber;
  40dfd2:	68fb      	ldr	r3, [r7, #12]
  40dfd4:	687a      	ldr	r2, [r7, #4]
  40dfd6:	629a      	str	r2, [r3, #40]	; 0x28
	pxWindow->ulOurSequenceNumber = ulSequenceNumber;
  40dfd8:	68fb      	ldr	r3, [r7, #12]
  40dfda:	687a      	ldr	r2, [r7, #4]
  40dfdc:	62da      	str	r2, [r3, #44]	; 0x2c
}
  40dfde:	bf00      	nop
  40dfe0:	371c      	adds	r7, #28
  40dfe2:	46bd      	mov	sp, r7
  40dfe4:	f85d 7b04 	ldr.w	r7, [sp], #4
  40dfe8:	4770      	bx	lr
	...

0040dfec <xTCPWindowRxConfirm>:
 *=============================================================================*/

#if( ipconfigUSE_TCP_WIN == 1 )

	static TCPSegment_t *xTCPWindowRxConfirm( TCPWindow_t *pxWindow, uint32_t ulSequenceNumber, uint32_t ulLength )
	{
  40dfec:	b5f0      	push	{r4, r5, r6, r7, lr}
  40dfee:	b08f      	sub	sp, #60	; 0x3c
  40dff0:	af04      	add	r7, sp, #16
  40dff2:	60f8      	str	r0, [r7, #12]
  40dff4:	60b9      	str	r1, [r7, #8]
  40dff6:	607a      	str	r2, [r7, #4]
	TCPSegment_t *pxBest = NULL;
  40dff8:	2300      	movs	r3, #0
  40dffa:	627b      	str	r3, [r7, #36]	; 0x24
	const ListItem_t *pxIterator;
	uint32_t ulNextSequenceNumber = ulSequenceNumber + ulLength;
  40dffc:	68ba      	ldr	r2, [r7, #8]
  40dffe:	687b      	ldr	r3, [r7, #4]
  40e000:	4413      	add	r3, r2
  40e002:	61fb      	str	r3, [r7, #28]
	const MiniListItem_t* pxEnd = ( const MiniListItem_t* ) listGET_END_MARKER( &pxWindow->xRxSegments );
  40e004:	68fb      	ldr	r3, [r7, #12]
  40e006:	33ac      	adds	r3, #172	; 0xac
  40e008:	61bb      	str	r3, [r7, #24]
		and (ulSequenceNumber+ulLength).  Normally none will be found, because
		the next RX segment should have a sequence number equal to
		'(ulSequenceNumber+ulLength)'. */

		/* Iterate through all RX segments that are stored: */
		for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
  40e00a:	69bb      	ldr	r3, [r7, #24]
  40e00c:	685b      	ldr	r3, [r3, #4]
  40e00e:	623b      	str	r3, [r7, #32]
  40e010:	e027      	b.n	40e062 <xTCPWindowRxConfirm+0x76>
			 pxIterator != ( const ListItem_t * ) pxEnd;
			 pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxIterator ) )
		{
			pxSegment = ( TCPSegment_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
  40e012:	6a3b      	ldr	r3, [r7, #32]
  40e014:	68db      	ldr	r3, [r3, #12]
  40e016:	617b      	str	r3, [r7, #20]
			/* And see if there is a segment for which:
			'ulSequenceNumber' <= 'pxSegment->ulSequenceNumber' < 'ulNextSequenceNumber'
			If there are more matching segments, the one with the lowest sequence number
			shall be taken */
			if( ( xSequenceGreaterThanOrEqual( pxSegment->ulSequenceNumber, ulSequenceNumber ) != 0 ) &&
  40e018:	697b      	ldr	r3, [r7, #20]
  40e01a:	681b      	ldr	r3, [r3, #0]
  40e01c:	68b9      	ldr	r1, [r7, #8]
  40e01e:	4618      	mov	r0, r3
  40e020:	4b2e      	ldr	r3, [pc, #184]	; (40e0dc <xTCPWindowRxConfirm+0xf0>)
  40e022:	4798      	blx	r3
  40e024:	4603      	mov	r3, r0
  40e026:	2b00      	cmp	r3, #0
  40e028:	d018      	beq.n	40e05c <xTCPWindowRxConfirm+0x70>
				( xSequenceLessThan( pxSegment->ulSequenceNumber, ulNextSequenceNumber ) != 0 ) )
  40e02a:	697b      	ldr	r3, [r7, #20]
  40e02c:	681b      	ldr	r3, [r3, #0]
  40e02e:	69f9      	ldr	r1, [r7, #28]
  40e030:	4618      	mov	r0, r3
  40e032:	4b2b      	ldr	r3, [pc, #172]	; (40e0e0 <xTCPWindowRxConfirm+0xf4>)
  40e034:	4798      	blx	r3
  40e036:	4603      	mov	r3, r0
			if( ( xSequenceGreaterThanOrEqual( pxSegment->ulSequenceNumber, ulSequenceNumber ) != 0 ) &&
  40e038:	2b00      	cmp	r3, #0
  40e03a:	d00f      	beq.n	40e05c <xTCPWindowRxConfirm+0x70>
			{
				if( ( pxBest == NULL ) || ( xSequenceLessThan( pxSegment->ulSequenceNumber, pxBest->ulSequenceNumber ) != 0 ) )
  40e03c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40e03e:	2b00      	cmp	r3, #0
  40e040:	d00a      	beq.n	40e058 <xTCPWindowRxConfirm+0x6c>
  40e042:	697b      	ldr	r3, [r7, #20]
  40e044:	681a      	ldr	r2, [r3, #0]
  40e046:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40e048:	681b      	ldr	r3, [r3, #0]
  40e04a:	4619      	mov	r1, r3
  40e04c:	4610      	mov	r0, r2
  40e04e:	4b24      	ldr	r3, [pc, #144]	; (40e0e0 <xTCPWindowRxConfirm+0xf4>)
  40e050:	4798      	blx	r3
  40e052:	4603      	mov	r3, r0
  40e054:	2b00      	cmp	r3, #0
  40e056:	d001      	beq.n	40e05c <xTCPWindowRxConfirm+0x70>
				{
					pxBest = pxSegment;
  40e058:	697b      	ldr	r3, [r7, #20]
  40e05a:	627b      	str	r3, [r7, #36]	; 0x24
			 pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxIterator ) )
  40e05c:	6a3b      	ldr	r3, [r7, #32]
  40e05e:	685b      	ldr	r3, [r3, #4]
  40e060:	623b      	str	r3, [r7, #32]
		for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
  40e062:	6a3a      	ldr	r2, [r7, #32]
  40e064:	69bb      	ldr	r3, [r7, #24]
  40e066:	429a      	cmp	r2, r3
  40e068:	d1d3      	bne.n	40e012 <xTCPWindowRxConfirm+0x26>
				}
			}
		}

		if( ( pxBest != NULL ) &&
  40e06a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40e06c:	2b00      	cmp	r3, #0
  40e06e:	d030      	beq.n	40e0d2 <xTCPWindowRxConfirm+0xe6>
			( ( pxBest->ulSequenceNumber != ulSequenceNumber ) || ( pxBest->lDataLength != ( int32_t ) ulLength ) ) )
  40e070:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40e072:	681a      	ldr	r2, [r3, #0]
		if( ( pxBest != NULL ) &&
  40e074:	68bb      	ldr	r3, [r7, #8]
  40e076:	429a      	cmp	r2, r3
  40e078:	d104      	bne.n	40e084 <xTCPWindowRxConfirm+0x98>
			( ( pxBest->ulSequenceNumber != ulSequenceNumber ) || ( pxBest->lDataLength != ( int32_t ) ulLength ) ) )
  40e07a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40e07c:	689a      	ldr	r2, [r3, #8]
  40e07e:	687b      	ldr	r3, [r7, #4]
  40e080:	429a      	cmp	r2, r3
  40e082:	d026      	beq.n	40e0d2 <xTCPWindowRxConfirm+0xe6>
		{
			FreeRTOS_flush_logging();
			FreeRTOS_debug_printf( ( "xTCPWindowRxConfirm[%u]: search %lu (+%ld=%lu) found %lu (+%ld=%lu)\n",
  40e084:	68fb      	ldr	r3, [r7, #12]
  40e086:	f8b3 30ba 	ldrh.w	r3, [r3, #186]	; 0xba
  40e08a:	461e      	mov	r6, r3
  40e08c:	68fb      	ldr	r3, [r7, #12]
  40e08e:	68db      	ldr	r3, [r3, #12]
  40e090:	68ba      	ldr	r2, [r7, #8]
  40e092:	1ad5      	subs	r5, r2, r3
  40e094:	68ba      	ldr	r2, [r7, #8]
  40e096:	687b      	ldr	r3, [r7, #4]
  40e098:	441a      	add	r2, r3
  40e09a:	68fb      	ldr	r3, [r7, #12]
  40e09c:	68db      	ldr	r3, [r3, #12]
  40e09e:	1ad3      	subs	r3, r2, r3
  40e0a0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  40e0a2:	6811      	ldr	r1, [r2, #0]
  40e0a4:	68fa      	ldr	r2, [r7, #12]
  40e0a6:	68d2      	ldr	r2, [r2, #12]
  40e0a8:	1a8a      	subs	r2, r1, r2
  40e0aa:	6a79      	ldr	r1, [r7, #36]	; 0x24
  40e0ac:	6889      	ldr	r1, [r1, #8]
  40e0ae:	6a78      	ldr	r0, [r7, #36]	; 0x24
  40e0b0:	6800      	ldr	r0, [r0, #0]
  40e0b2:	6a7c      	ldr	r4, [r7, #36]	; 0x24
  40e0b4:	68a4      	ldr	r4, [r4, #8]
  40e0b6:	4404      	add	r4, r0
  40e0b8:	68f8      	ldr	r0, [r7, #12]
  40e0ba:	68c0      	ldr	r0, [r0, #12]
  40e0bc:	1a20      	subs	r0, r4, r0
  40e0be:	9003      	str	r0, [sp, #12]
  40e0c0:	9102      	str	r1, [sp, #8]
  40e0c2:	9201      	str	r2, [sp, #4]
  40e0c4:	9300      	str	r3, [sp, #0]
  40e0c6:	687b      	ldr	r3, [r7, #4]
  40e0c8:	462a      	mov	r2, r5
  40e0ca:	4631      	mov	r1, r6
  40e0cc:	4805      	ldr	r0, [pc, #20]	; (40e0e4 <xTCPWindowRxConfirm+0xf8>)
  40e0ce:	4c06      	ldr	r4, [pc, #24]	; (40e0e8 <xTCPWindowRxConfirm+0xfc>)
  40e0d0:	47a0      	blx	r4
				pxBest->ulSequenceNumber - pxWindow->rx.ulFirstSequenceNumber,
				pxBest->lDataLength,
				pxBest->ulSequenceNumber + ( ( uint32_t ) pxBest->lDataLength ) - pxWindow->rx.ulFirstSequenceNumber ) );
		}

		return pxBest;
  40e0d2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
	}
  40e0d4:	4618      	mov	r0, r3
  40e0d6:	372c      	adds	r7, #44	; 0x2c
  40e0d8:	46bd      	mov	sp, r7
  40e0da:	bdf0      	pop	{r4, r5, r6, r7, pc}
  40e0dc:	0040da23 	.word	0x0040da23
  40e0e0:	0040d9db 	.word	0x0040d9db
  40e0e4:	0041d9ac 	.word	0x0041d9ac
  40e0e8:	00416c7d 	.word	0x00416c7d

0040e0ec <lTCPWindowRxCheck>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	int32_t lTCPWindowRxCheck( TCPWindow_t *pxWindow, uint32_t ulSequenceNumber, uint32_t ulLength, uint32_t ulSpace )
	{
  40e0ec:	b5f0      	push	{r4, r5, r6, r7, lr}
  40e0ee:	b08f      	sub	sp, #60	; 0x3c
  40e0f0:	af04      	add	r7, sp, #16
  40e0f2:	60f8      	str	r0, [r7, #12]
  40e0f4:	60b9      	str	r1, [r7, #8]
  40e0f6:	607a      	str	r2, [r7, #4]
  40e0f8:	603b      	str	r3, [r7, #0]
		or there is not enough space.

		As a side-effect, pxWindow->ulUserDataLength will get set to non-zero,
		if more Rx data may be passed to the user after this packet. */

		ulCurrentSequenceNumber = pxWindow->rx.ulCurrentSequenceNumber;
  40e0fa:	68fb      	ldr	r3, [r7, #12]
  40e0fc:	691b      	ldr	r3, [r3, #16]
  40e0fe:	627b      	str	r3, [r7, #36]	; 0x24

		/* For Selective Ack (SACK), used when out-of-sequence data come in. */
		pxWindow->ucOptionLength = 0u;
  40e100:	68fb      	ldr	r3, [r7, #12]
  40e102:	2200      	movs	r2, #0
  40e104:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

		/* Non-zero if TCP-windows contains data which must be popped. */
		pxWindow->ulUserDataLength = 0ul;
  40e108:	68fb      	ldr	r3, [r7, #12]
  40e10a:	2200      	movs	r2, #0
  40e10c:	631a      	str	r2, [r3, #48]	; 0x30

		if( ulCurrentSequenceNumber == ulSequenceNumber )
  40e10e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  40e110:	68bb      	ldr	r3, [r7, #8]
  40e112:	429a      	cmp	r2, r3
  40e114:	d169      	bne.n	40e1ea <lTCPWindowRxCheck+0xfe>
		{
			/* This is the packet with the lowest sequence number we're waiting
			for.  It can be passed directly to the rx stream. */
			if( ulLength > ulSpace )
  40e116:	687a      	ldr	r2, [r7, #4]
  40e118:	683b      	ldr	r3, [r7, #0]
  40e11a:	429a      	cmp	r2, r3
  40e11c:	d908      	bls.n	40e130 <lTCPWindowRxCheck+0x44>
			{
				FreeRTOS_debug_printf( ( "lTCPWindowRxCheck: Refuse %lu bytes, due to lack of space (%lu)\n", ulLength, ulSpace ) );
  40e11e:	683a      	ldr	r2, [r7, #0]
  40e120:	6879      	ldr	r1, [r7, #4]
  40e122:	4894      	ldr	r0, [pc, #592]	; (40e374 <lTCPWindowRxCheck+0x288>)
  40e124:	4b94      	ldr	r3, [pc, #592]	; (40e378 <lTCPWindowRxCheck+0x28c>)
  40e126:	4798      	blx	r3
				lReturn = -1;
  40e128:	f04f 33ff 	mov.w	r3, #4294967295
  40e12c:	61fb      	str	r3, [r7, #28]
  40e12e:	e11c      	b.n	40e36a <lTCPWindowRxCheck+0x27e>
			}
			else
			{
				ulCurrentSequenceNumber += ulLength;
  40e130:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  40e132:	687b      	ldr	r3, [r7, #4]
  40e134:	4413      	add	r3, r2
  40e136:	627b      	str	r3, [r7, #36]	; 0x24

				if( listCURRENT_LIST_LENGTH( &( pxWindow->xRxSegments ) ) != 0 )
  40e138:	68fb      	ldr	r3, [r7, #12]
  40e13a:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
  40e13e:	2b00      	cmp	r3, #0
  40e140:	d04d      	beq.n	40e1de <lTCPWindowRxCheck+0xf2>
				{
					ulSavedSequenceNumber = ulCurrentSequenceNumber;
  40e142:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40e144:	61bb      	str	r3, [r7, #24]
                    If the server is forced to retransmit packets several time in a row it might send a batch of concatenated packet for speed.
                    So we cannot rely on the packets between ulSequenceNumber and ulSequenceNumber + ulLength to be sequential and it is better to just
                    clean them out. */
                    do
                    {
                        pxFound = xTCPWindowRxConfirm( pxWindow, ulSequenceNumber, ulLength );
  40e146:	687a      	ldr	r2, [r7, #4]
  40e148:	68b9      	ldr	r1, [r7, #8]
  40e14a:	68f8      	ldr	r0, [r7, #12]
  40e14c:	4b8b      	ldr	r3, [pc, #556]	; (40e37c <lTCPWindowRxCheck+0x290>)
  40e14e:	4798      	blx	r3
  40e150:	6178      	str	r0, [r7, #20]

                        if ( pxFound != NULL )
  40e152:	697b      	ldr	r3, [r7, #20]
  40e154:	2b00      	cmp	r3, #0
  40e156:	d002      	beq.n	40e15e <lTCPWindowRxCheck+0x72>
                        {
                            /* Remove it because it will be passed to user directly. */
                            vTCPWindowFree( pxFound );
  40e158:	6978      	ldr	r0, [r7, #20]
  40e15a:	4b89      	ldr	r3, [pc, #548]	; (40e380 <lTCPWindowRxCheck+0x294>)
  40e15c:	4798      	blx	r3
                        }
                    } while ( pxFound );
  40e15e:	697b      	ldr	r3, [r7, #20]
  40e160:	2b00      	cmp	r3, #0
  40e162:	d1f0      	bne.n	40e146 <lTCPWindowRxCheck+0x5a>

					/*  Check for following segments that are already in the
					queue and increment ulCurrentSequenceNumber. */
					while( ( pxFound = xTCPWindowRxFind( pxWindow, ulCurrentSequenceNumber ) ) != NULL )
  40e164:	e008      	b.n	40e178 <lTCPWindowRxCheck+0x8c>
					{
						ulCurrentSequenceNumber += ( uint32_t ) pxFound->lDataLength;
  40e166:	697b      	ldr	r3, [r7, #20]
  40e168:	689b      	ldr	r3, [r3, #8]
  40e16a:	461a      	mov	r2, r3
  40e16c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40e16e:	4413      	add	r3, r2
  40e170:	627b      	str	r3, [r7, #36]	; 0x24

						/* As all packet below this one have been passed to the
						user it can be discarded. */
						vTCPWindowFree( pxFound );
  40e172:	6978      	ldr	r0, [r7, #20]
  40e174:	4b82      	ldr	r3, [pc, #520]	; (40e380 <lTCPWindowRxCheck+0x294>)
  40e176:	4798      	blx	r3
					while( ( pxFound = xTCPWindowRxFind( pxWindow, ulCurrentSequenceNumber ) ) != NULL )
  40e178:	6a79      	ldr	r1, [r7, #36]	; 0x24
  40e17a:	68f8      	ldr	r0, [r7, #12]
  40e17c:	4b81      	ldr	r3, [pc, #516]	; (40e384 <lTCPWindowRxCheck+0x298>)
  40e17e:	4798      	blx	r3
  40e180:	6178      	str	r0, [r7, #20]
  40e182:	697b      	ldr	r3, [r7, #20]
  40e184:	2b00      	cmp	r3, #0
  40e186:	d1ee      	bne.n	40e166 <lTCPWindowRxCheck+0x7a>
					}

					if( ulSavedSequenceNumber != ulCurrentSequenceNumber )
  40e188:	69ba      	ldr	r2, [r7, #24]
  40e18a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40e18c:	429a      	cmp	r2, r3
  40e18e:	d026      	beq.n	40e1de <lTCPWindowRxCheck+0xf2>
					{
						/*  After the current data-package, there is more data
						to be popped. */
						pxWindow->ulUserDataLength = ulCurrentSequenceNumber - ulSavedSequenceNumber;
  40e190:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  40e192:	69bb      	ldr	r3, [r7, #24]
  40e194:	1ad2      	subs	r2, r2, r3
  40e196:	68fb      	ldr	r3, [r7, #12]
  40e198:	631a      	str	r2, [r3, #48]	; 0x30

						if( xTCPWindowLoggingLevel >= 1 )
  40e19a:	4b7b      	ldr	r3, [pc, #492]	; (40e388 <lTCPWindowRxCheck+0x29c>)
  40e19c:	681b      	ldr	r3, [r3, #0]
  40e19e:	2b00      	cmp	r3, #0
  40e1a0:	dd1d      	ble.n	40e1de <lTCPWindowRxCheck+0xf2>
						{
							FreeRTOS_debug_printf( ( "lTCPWindowRxCheck[%d,%d]: retran %lu (Found %lu bytes at %lu cnt %ld)\n",
  40e1a2:	68fb      	ldr	r3, [r7, #12]
  40e1a4:	f8b3 30ba 	ldrh.w	r3, [r3, #186]	; 0xba
  40e1a8:	461c      	mov	r4, r3
  40e1aa:	68fb      	ldr	r3, [r7, #12]
  40e1ac:	f8b3 30b8 	ldrh.w	r3, [r3, #184]	; 0xb8
  40e1b0:	461d      	mov	r5, r3
  40e1b2:	68fb      	ldr	r3, [r7, #12]
  40e1b4:	68db      	ldr	r3, [r3, #12]
  40e1b6:	68ba      	ldr	r2, [r7, #8]
  40e1b8:	1ad0      	subs	r0, r2, r3
  40e1ba:	68fb      	ldr	r3, [r7, #12]
  40e1bc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  40e1be:	68fa      	ldr	r2, [r7, #12]
  40e1c0:	68d2      	ldr	r2, [r2, #12]
  40e1c2:	69b9      	ldr	r1, [r7, #24]
  40e1c4:	1a8a      	subs	r2, r1, r2
  40e1c6:	68f9      	ldr	r1, [r7, #12]
  40e1c8:	f8d1 10a4 	ldr.w	r1, [r1, #164]	; 0xa4
  40e1cc:	9102      	str	r1, [sp, #8]
  40e1ce:	9201      	str	r2, [sp, #4]
  40e1d0:	9300      	str	r3, [sp, #0]
  40e1d2:	4603      	mov	r3, r0
  40e1d4:	462a      	mov	r2, r5
  40e1d6:	4621      	mov	r1, r4
  40e1d8:	486c      	ldr	r0, [pc, #432]	; (40e38c <lTCPWindowRxCheck+0x2a0>)
  40e1da:	4c67      	ldr	r4, [pc, #412]	; (40e378 <lTCPWindowRxCheck+0x28c>)
  40e1dc:	47a0      	blx	r4
								listCURRENT_LIST_LENGTH( &pxWindow->xRxSegments ) ) );
						}
					}
				}

				pxWindow->rx.ulCurrentSequenceNumber = ulCurrentSequenceNumber;
  40e1de:	68fb      	ldr	r3, [r7, #12]
  40e1e0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  40e1e2:	611a      	str	r2, [r3, #16]

				/* Packet was expected, may be passed directly to the socket
				buffer or application.  Store the packet at offset 0. */
				lReturn = 0;
  40e1e4:	2300      	movs	r3, #0
  40e1e6:	61fb      	str	r3, [r7, #28]
  40e1e8:	e0bf      	b.n	40e36a <lTCPWindowRxCheck+0x27e>
			}
		}
		else if( ulCurrentSequenceNumber == ( ulSequenceNumber + 1UL ) )
  40e1ea:	68bb      	ldr	r3, [r7, #8]
  40e1ec:	1c5a      	adds	r2, r3, #1
  40e1ee:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40e1f0:	429a      	cmp	r2, r3
  40e1f2:	d103      	bne.n	40e1fc <lTCPWindowRxCheck+0x110>
		{
			/* Looks like a TCP keep-alive message.  Do not accept/store Rx data
			ulUserDataLength = 0. Not packet out-of-sync.  Just reply to it. */
			lReturn = -1;
  40e1f4:	f04f 33ff 	mov.w	r3, #4294967295
  40e1f8:	61fb      	str	r3, [r7, #28]
  40e1fa:	e0b6      	b.n	40e36a <lTCPWindowRxCheck+0x27e>
			/* The packet is not the one expected.  See if it falls within the Rx
			window so it can be stored. */

			/*  An "out-of-sequence" segment was received, must have missed one.
			Prepare a SACK (Selective ACK). */
			ulLast = ulSequenceNumber + ulLength;
  40e1fc:	68ba      	ldr	r2, [r7, #8]
  40e1fe:	687b      	ldr	r3, [r7, #4]
  40e200:	4413      	add	r3, r2
  40e202:	623b      	str	r3, [r7, #32]
			lDistance = ( int32_t ) ( ulLast - ulCurrentSequenceNumber );
  40e204:	6a3a      	ldr	r2, [r7, #32]
  40e206:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40e208:	1ad3      	subs	r3, r2, r3
  40e20a:	613b      	str	r3, [r7, #16]

			if( lDistance <= 0 )
  40e20c:	693b      	ldr	r3, [r7, #16]
  40e20e:	2b00      	cmp	r3, #0
  40e210:	dc03      	bgt.n	40e21a <lTCPWindowRxCheck+0x12e>
			{
				/* An earlier has been received, must be a retransmission of a
				packet that has been accepted already.  No need to send out a
				Selective ACK (SACK). */
				lReturn = -1;
  40e212:	f04f 33ff 	mov.w	r3, #4294967295
  40e216:	61fb      	str	r3, [r7, #28]
  40e218:	e0a7      	b.n	40e36a <lTCPWindowRxCheck+0x27e>
			}
			else if( lDistance > ( int32_t ) ulSpace )
  40e21a:	683b      	ldr	r3, [r7, #0]
  40e21c:	693a      	ldr	r2, [r7, #16]
  40e21e:	429a      	cmp	r2, r3
  40e220:	dd0f      	ble.n	40e242 <lTCPWindowRxCheck+0x156>
			{
				/* The new segment is ahead of rx.ulCurrentSequenceNumber.  The
				sequence number of this packet is too far ahead, ignore it. */
				FreeRTOS_debug_printf( ( "lTCPWindowRxCheck: Refuse %lu+%lu bytes, due to lack of space (%lu)\n", lDistance, ulLength, ulSpace ) );
  40e222:	683b      	ldr	r3, [r7, #0]
  40e224:	687a      	ldr	r2, [r7, #4]
  40e226:	6939      	ldr	r1, [r7, #16]
  40e228:	4859      	ldr	r0, [pc, #356]	; (40e390 <lTCPWindowRxCheck+0x2a4>)
  40e22a:	4c53      	ldr	r4, [pc, #332]	; (40e378 <lTCPWindowRxCheck+0x28c>)
  40e22c:	47a0      	blx	r4
				lReturn = -1;
  40e22e:	f04f 33ff 	mov.w	r3, #4294967295
  40e232:	61fb      	str	r3, [r7, #28]
  40e234:	e099      	b.n	40e36a <lTCPWindowRxCheck+0x27e>
				 * This is useful because subsequent packets will be SACK'd with
				 * single one message
				 */
				while( ( pxFound = xTCPWindowRxFind( pxWindow, ulLast ) ) != NULL )
				{
					ulLast += ( uint32_t ) pxFound->lDataLength;
  40e236:	697b      	ldr	r3, [r7, #20]
  40e238:	689b      	ldr	r3, [r3, #8]
  40e23a:	461a      	mov	r2, r3
  40e23c:	6a3b      	ldr	r3, [r7, #32]
  40e23e:	4413      	add	r3, r2
  40e240:	623b      	str	r3, [r7, #32]
				while( ( pxFound = xTCPWindowRxFind( pxWindow, ulLast ) ) != NULL )
  40e242:	6a39      	ldr	r1, [r7, #32]
  40e244:	68f8      	ldr	r0, [r7, #12]
  40e246:	4b4f      	ldr	r3, [pc, #316]	; (40e384 <lTCPWindowRxCheck+0x298>)
  40e248:	4798      	blx	r3
  40e24a:	6178      	str	r0, [r7, #20]
  40e24c:	697b      	ldr	r3, [r7, #20]
  40e24e:	2b00      	cmp	r3, #0
  40e250:	d1f1      	bne.n	40e236 <lTCPWindowRxCheck+0x14a>
				}

				if( xTCPWindowLoggingLevel >= 1 )
  40e252:	4b4d      	ldr	r3, [pc, #308]	; (40e388 <lTCPWindowRxCheck+0x29c>)
  40e254:	681b      	ldr	r3, [r3, #0]
  40e256:	2b00      	cmp	r3, #0
  40e258:	dd20      	ble.n	40e29c <lTCPWindowRxCheck+0x1b0>
				{
					FreeRTOS_debug_printf( ( "lTCPWindowRxCheck[%d,%d]: seqnr %lu exp %lu (dist %ld) SACK to %lu\n",
  40e25a:	68fb      	ldr	r3, [r7, #12]
  40e25c:	f8b3 30ba 	ldrh.w	r3, [r3, #186]	; 0xba
  40e260:	461d      	mov	r5, r3
  40e262:	68fb      	ldr	r3, [r7, #12]
  40e264:	f8b3 30b8 	ldrh.w	r3, [r3, #184]	; 0xb8
  40e268:	461e      	mov	r6, r3
  40e26a:	68fb      	ldr	r3, [r7, #12]
  40e26c:	68db      	ldr	r3, [r3, #12]
  40e26e:	68ba      	ldr	r2, [r7, #8]
  40e270:	1ad0      	subs	r0, r2, r3
  40e272:	68fb      	ldr	r3, [r7, #12]
  40e274:	68db      	ldr	r3, [r3, #12]
  40e276:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  40e278:	1ad3      	subs	r3, r2, r3
  40e27a:	68b9      	ldr	r1, [r7, #8]
  40e27c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  40e27e:	1a8a      	subs	r2, r1, r2
  40e280:	4614      	mov	r4, r2
  40e282:	68fa      	ldr	r2, [r7, #12]
  40e284:	68d2      	ldr	r2, [r2, #12]
  40e286:	6a39      	ldr	r1, [r7, #32]
  40e288:	1a8a      	subs	r2, r1, r2
  40e28a:	9202      	str	r2, [sp, #8]
  40e28c:	9401      	str	r4, [sp, #4]
  40e28e:	9300      	str	r3, [sp, #0]
  40e290:	4603      	mov	r3, r0
  40e292:	4632      	mov	r2, r6
  40e294:	4629      	mov	r1, r5
  40e296:	483f      	ldr	r0, [pc, #252]	; (40e394 <lTCPWindowRxCheck+0x2a8>)
  40e298:	4c37      	ldr	r4, [pc, #220]	; (40e378 <lTCPWindowRxCheck+0x28c>)
  40e29a:	47a0      	blx	r4
						ulLast - pxWindow->rx.ulFirstSequenceNumber ) );
				}

				/* Now prepare the SACK message.
				Code OPTION_CODE_SINGLE_SACK already in network byte order. */
				pxWindow->ulOptionsData[0] = OPTION_CODE_SINGLE_SACK;
  40e29c:	68fb      	ldr	r3, [r7, #12]
  40e29e:	4a3e      	ldr	r2, [pc, #248]	; (40e398 <lTCPWindowRxCheck+0x2ac>)
  40e2a0:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

				/* First sequence number that we received. */
				pxWindow->ulOptionsData[1] = FreeRTOS_htonl( ulSequenceNumber );
  40e2a4:	68bb      	ldr	r3, [r7, #8]
  40e2a6:	061a      	lsls	r2, r3, #24
  40e2a8:	68bb      	ldr	r3, [r7, #8]
  40e2aa:	021b      	lsls	r3, r3, #8
  40e2ac:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
  40e2b0:	431a      	orrs	r2, r3
  40e2b2:	68bb      	ldr	r3, [r7, #8]
  40e2b4:	0a1b      	lsrs	r3, r3, #8
  40e2b6:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
  40e2ba:	431a      	orrs	r2, r3
  40e2bc:	68bb      	ldr	r3, [r7, #8]
  40e2be:	0e1b      	lsrs	r3, r3, #24
  40e2c0:	431a      	orrs	r2, r3
  40e2c2:	68fb      	ldr	r3, [r7, #12]
  40e2c4:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

				/* Last + 1 */
				pxWindow->ulOptionsData[2] = FreeRTOS_htonl( ulLast );
  40e2c8:	6a3b      	ldr	r3, [r7, #32]
  40e2ca:	061a      	lsls	r2, r3, #24
  40e2cc:	6a3b      	ldr	r3, [r7, #32]
  40e2ce:	021b      	lsls	r3, r3, #8
  40e2d0:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
  40e2d4:	431a      	orrs	r2, r3
  40e2d6:	6a3b      	ldr	r3, [r7, #32]
  40e2d8:	0a1b      	lsrs	r3, r3, #8
  40e2da:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
  40e2de:	431a      	orrs	r2, r3
  40e2e0:	6a3b      	ldr	r3, [r7, #32]
  40e2e2:	0e1b      	lsrs	r3, r3, #24
  40e2e4:	431a      	orrs	r2, r3
  40e2e6:	68fb      	ldr	r3, [r7, #12]
  40e2e8:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

				/* Which make 12 (3*4) option bytes. */
				pxWindow->ucOptionLength = 3 * sizeof( pxWindow->ulOptionsData[ 0 ] );
  40e2ec:	68fb      	ldr	r3, [r7, #12]
  40e2ee:	220c      	movs	r2, #12
  40e2f0:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

				pxFound = xTCPWindowRxFind( pxWindow, ulSequenceNumber );
  40e2f4:	68b9      	ldr	r1, [r7, #8]
  40e2f6:	68f8      	ldr	r0, [r7, #12]
  40e2f8:	4b22      	ldr	r3, [pc, #136]	; (40e384 <lTCPWindowRxCheck+0x298>)
  40e2fa:	4798      	blx	r3
  40e2fc:	6178      	str	r0, [r7, #20]

				if( pxFound != NULL )
  40e2fe:	697b      	ldr	r3, [r7, #20]
  40e300:	2b00      	cmp	r3, #0
  40e302:	d003      	beq.n	40e30c <lTCPWindowRxCheck+0x220>
				{
					/* This out-of-sequence packet has been received for a
					second time.  It is already stored but do send a SACK
					again. */
					lReturn = -1;
  40e304:	f04f 33ff 	mov.w	r3, #4294967295
  40e308:	61fb      	str	r3, [r7, #28]
  40e30a:	e02e      	b.n	40e36a <lTCPWindowRxCheck+0x27e>
				}
				else
				{
					pxFound = xTCPWindowRxNew( pxWindow, ulSequenceNumber, ( int32_t ) ulLength );
  40e30c:	687a      	ldr	r2, [r7, #4]
  40e30e:	2301      	movs	r3, #1
  40e310:	68b9      	ldr	r1, [r7, #8]
  40e312:	68f8      	ldr	r0, [r7, #12]
  40e314:	4c21      	ldr	r4, [pc, #132]	; (40e39c <lTCPWindowRxCheck+0x2b0>)
  40e316:	47a0      	blx	r4
  40e318:	6178      	str	r0, [r7, #20]

					if( pxFound == NULL )
  40e31a:	697b      	ldr	r3, [r7, #20]
  40e31c:	2b00      	cmp	r3, #0
  40e31e:	d107      	bne.n	40e330 <lTCPWindowRxCheck+0x244>
					{
						/* Can not send a SACK, because the segment cannot be
						stored. */
						pxWindow->ucOptionLength = 0u;
  40e320:	68fb      	ldr	r3, [r7, #12]
  40e322:	2200      	movs	r2, #0
  40e324:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

						/* Needs to be stored but there is no segment
						available. */
						lReturn = -1;
  40e328:	f04f 33ff 	mov.w	r3, #4294967295
  40e32c:	61fb      	str	r3, [r7, #28]
  40e32e:	e01c      	b.n	40e36a <lTCPWindowRxCheck+0x27e>
					}
					else
					{
						if( xTCPWindowLoggingLevel != 0 )
  40e330:	4b15      	ldr	r3, [pc, #84]	; (40e388 <lTCPWindowRxCheck+0x29c>)
  40e332:	681b      	ldr	r3, [r3, #0]
  40e334:	2b00      	cmp	r3, #0
  40e336:	d014      	beq.n	40e362 <lTCPWindowRxCheck+0x276>
						{
							FreeRTOS_debug_printf( ( "lTCPWindowRxCheck[%u,%u]: seqnr %lu (cnt %lu)\n",
  40e338:	68fb      	ldr	r3, [r7, #12]
  40e33a:	f8b3 30ba 	ldrh.w	r3, [r3, #186]	; 0xba
  40e33e:	4619      	mov	r1, r3
  40e340:	68fb      	ldr	r3, [r7, #12]
  40e342:	f8b3 30b8 	ldrh.w	r3, [r3, #184]	; 0xb8
  40e346:	4618      	mov	r0, r3
  40e348:	68fb      	ldr	r3, [r7, #12]
  40e34a:	68db      	ldr	r3, [r3, #12]
  40e34c:	68ba      	ldr	r2, [r7, #8]
  40e34e:	1ad2      	subs	r2, r2, r3
  40e350:	68fb      	ldr	r3, [r7, #12]
  40e352:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
  40e356:	9300      	str	r3, [sp, #0]
  40e358:	4613      	mov	r3, r2
  40e35a:	4602      	mov	r2, r0
  40e35c:	4810      	ldr	r0, [pc, #64]	; (40e3a0 <lTCPWindowRxCheck+0x2b4>)
  40e35e:	4c06      	ldr	r4, [pc, #24]	; (40e378 <lTCPWindowRxCheck+0x28c>)
  40e360:	47a0      	blx	r4
							FreeRTOS_flush_logging( );
						}

						/* Return a positive value.  The packet may be accepted
						and stored but an earlier packet is still missing. */
						lReturn = ( int32_t ) ( ulSequenceNumber - ulCurrentSequenceNumber );
  40e362:	68ba      	ldr	r2, [r7, #8]
  40e364:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40e366:	1ad3      	subs	r3, r2, r3
  40e368:	61fb      	str	r3, [r7, #28]
					}
				}
			}
		}

		return lReturn;
  40e36a:	69fb      	ldr	r3, [r7, #28]
	}
  40e36c:	4618      	mov	r0, r3
  40e36e:	372c      	adds	r7, #44	; 0x2c
  40e370:	46bd      	mov	sp, r7
  40e372:	bdf0      	pop	{r4, r5, r6, r7, pc}
  40e374:	0041d9f4 	.word	0x0041d9f4
  40e378:	00416c7d 	.word	0x00416c7d
  40e37c:	0040dfed 	.word	0x0040dfed
  40e380:	0040ddd1 	.word	0x0040ddd1
  40e384:	0040dbb1 	.word	0x0040dbb1
  40e388:	20006d60 	.word	0x20006d60
  40e38c:	0041da38 	.word	0x0041da38
  40e390:	0041da80 	.word	0x0041da80
  40e394:	0041dac8 	.word	0x0041dac8
  40e398:	0a050101 	.word	0x0a050101
  40e39c:	0040dc01 	.word	0x0040dc01
  40e3a0:	0041db0c 	.word	0x0041db0c

0040e3a4 <lTCPIncrementTxPosition>:
 *=============================================================================*/

#if( ipconfigUSE_TCP_WIN == 1 )

	static int32_t lTCPIncrementTxPosition( int32_t lPosition, int32_t lMax, int32_t lCount )
	{
  40e3a4:	b480      	push	{r7}
  40e3a6:	b085      	sub	sp, #20
  40e3a8:	af00      	add	r7, sp, #0
  40e3aa:	60f8      	str	r0, [r7, #12]
  40e3ac:	60b9      	str	r1, [r7, #8]
  40e3ae:	607a      	str	r2, [r7, #4]
		/* +TCP stores data in circular buffers.  Calculate the next position to
		store. */
		lPosition += lCount;
  40e3b0:	68fa      	ldr	r2, [r7, #12]
  40e3b2:	687b      	ldr	r3, [r7, #4]
  40e3b4:	4413      	add	r3, r2
  40e3b6:	60fb      	str	r3, [r7, #12]
		if( lPosition >= lMax )
  40e3b8:	68fa      	ldr	r2, [r7, #12]
  40e3ba:	68bb      	ldr	r3, [r7, #8]
  40e3bc:	429a      	cmp	r2, r3
  40e3be:	db03      	blt.n	40e3c8 <lTCPIncrementTxPosition+0x24>
		{
			lPosition -= lMax;
  40e3c0:	68fa      	ldr	r2, [r7, #12]
  40e3c2:	68bb      	ldr	r3, [r7, #8]
  40e3c4:	1ad3      	subs	r3, r2, r3
  40e3c6:	60fb      	str	r3, [r7, #12]
		}

		return lPosition;
  40e3c8:	68fb      	ldr	r3, [r7, #12]
	}
  40e3ca:	4618      	mov	r0, r3
  40e3cc:	3714      	adds	r7, #20
  40e3ce:	46bd      	mov	sp, r7
  40e3d0:	f85d 7b04 	ldr.w	r7, [sp], #4
  40e3d4:	4770      	bx	lr
	...

0040e3d8 <lTCPWindowTxAdd>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	int32_t lTCPWindowTxAdd( TCPWindow_t *pxWindow, uint32_t ulLength, int32_t lPosition, int32_t lMax )
	{
  40e3d8:	b590      	push	{r4, r7, lr}
  40e3da:	b08b      	sub	sp, #44	; 0x2c
  40e3dc:	af02      	add	r7, sp, #8
  40e3de:	60f8      	str	r0, [r7, #12]
  40e3e0:	60b9      	str	r1, [r7, #8]
  40e3e2:	607a      	str	r2, [r7, #4]
  40e3e4:	603b      	str	r3, [r7, #0]
	int32_t lBytesLeft = ( int32_t ) ulLength, lToWrite;
  40e3e6:	68bb      	ldr	r3, [r7, #8]
  40e3e8:	61fb      	str	r3, [r7, #28]
	int32_t lDone = 0;
  40e3ea:	2300      	movs	r3, #0
  40e3ec:	61bb      	str	r3, [r7, #24]
	TCPSegment_t *pxSegment = pxWindow->pxHeadSegment;
  40e3ee:	68fb      	ldr	r3, [r7, #12]
  40e3f0:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
  40e3f2:	617b      	str	r3, [r7, #20]

		/* Puts a message in the Tx-window (after buffer size has been
		verified). */
		if( pxSegment != NULL )
  40e3f4:	697b      	ldr	r3, [r7, #20]
  40e3f6:	2b00      	cmp	r3, #0
  40e3f8:	f000 80d6 	beq.w	40e5a8 <lTCPWindowTxAdd+0x1d0>
		{
			if( pxSegment->lDataLength < pxSegment->lMaxLength )
  40e3fc:	697b      	ldr	r3, [r7, #20]
  40e3fe:	689a      	ldr	r2, [r3, #8]
  40e400:	697b      	ldr	r3, [r7, #20]
  40e402:	685b      	ldr	r3, [r3, #4]
  40e404:	429a      	cmp	r2, r3
  40e406:	f280 80cf 	bge.w	40e5a8 <lTCPWindowTxAdd+0x1d0>
			{
				if( ( pxSegment->u.bits.bOutstanding == pdFALSE_UNSIGNED ) && ( pxSegment->lDataLength != 0 ) )
  40e40a:	697b      	ldr	r3, [r7, #20]
  40e40c:	7d9b      	ldrb	r3, [r3, #22]
  40e40e:	f003 0301 	and.w	r3, r3, #1
  40e412:	b2db      	uxtb	r3, r3
  40e414:	2b00      	cmp	r3, #0
  40e416:	f040 80c7 	bne.w	40e5a8 <lTCPWindowTxAdd+0x1d0>
  40e41a:	697b      	ldr	r3, [r7, #20]
  40e41c:	689b      	ldr	r3, [r3, #8]
  40e41e:	2b00      	cmp	r3, #0
  40e420:	f000 80c2 	beq.w	40e5a8 <lTCPWindowTxAdd+0x1d0>
				{
					/* Adding data to a segment that was already in the TX queue.  It
					will be filled-up to a maximum of MSS (maximum segment size). */
					lToWrite = FreeRTOS_min_int32( lBytesLeft, pxSegment->lMaxLength - pxSegment->lDataLength );
  40e424:	697b      	ldr	r3, [r7, #20]
  40e426:	685a      	ldr	r2, [r3, #4]
  40e428:	697b      	ldr	r3, [r7, #20]
  40e42a:	689b      	ldr	r3, [r3, #8]
  40e42c:	1ad3      	subs	r3, r2, r3
  40e42e:	4619      	mov	r1, r3
  40e430:	69f8      	ldr	r0, [r7, #28]
  40e432:	4b62      	ldr	r3, [pc, #392]	; (40e5bc <lTCPWindowTxAdd+0x1e4>)
  40e434:	4798      	blx	r3
  40e436:	6138      	str	r0, [r7, #16]

					pxSegment->lDataLength += lToWrite;
  40e438:	697b      	ldr	r3, [r7, #20]
  40e43a:	689a      	ldr	r2, [r3, #8]
  40e43c:	693b      	ldr	r3, [r7, #16]
  40e43e:	441a      	add	r2, r3
  40e440:	697b      	ldr	r3, [r7, #20]
  40e442:	609a      	str	r2, [r3, #8]

					if( pxSegment->lDataLength >= pxSegment->lMaxLength )
  40e444:	697b      	ldr	r3, [r7, #20]
  40e446:	689a      	ldr	r2, [r3, #8]
  40e448:	697b      	ldr	r3, [r7, #20]
  40e44a:	685b      	ldr	r3, [r3, #4]
  40e44c:	429a      	cmp	r2, r3
  40e44e:	db02      	blt.n	40e456 <lTCPWindowTxAdd+0x7e>
					{
						/* This segment is full, don't add more bytes. */
						pxWindow->pxHeadSegment = NULL;
  40e450:	68fb      	ldr	r3, [r7, #12]
  40e452:	2200      	movs	r2, #0
  40e454:	67da      	str	r2, [r3, #124]	; 0x7c
					}

					lBytesLeft -= lToWrite;
  40e456:	69fa      	ldr	r2, [r7, #28]
  40e458:	693b      	ldr	r3, [r7, #16]
  40e45a:	1ad3      	subs	r3, r2, r3
  40e45c:	61fb      	str	r3, [r7, #28]

					/* ulNextTxSequenceNumber is the sequence number of the next byte to
					be stored for transmission. */
					pxWindow->ulNextTxSequenceNumber += ( uint32_t ) lToWrite;
  40e45e:	68fb      	ldr	r3, [r7, #12]
  40e460:	6b5a      	ldr	r2, [r3, #52]	; 0x34
  40e462:	693b      	ldr	r3, [r7, #16]
  40e464:	441a      	add	r2, r3
  40e466:	68fb      	ldr	r3, [r7, #12]
  40e468:	635a      	str	r2, [r3, #52]	; 0x34

					/* Increased the return value. */
					lDone += lToWrite;
  40e46a:	69ba      	ldr	r2, [r7, #24]
  40e46c:	693b      	ldr	r3, [r7, #16]
  40e46e:	4413      	add	r3, r2
  40e470:	61bb      	str	r3, [r7, #24]

					/* Some detailed logging, for those who're interested. */
					if( ( xTCPWindowLoggingLevel >= 2 ) && ( ipconfigTCP_MAY_LOG_PORT( pxWindow->usOurPortNumber ) != 0 ) )
  40e472:	4b53      	ldr	r3, [pc, #332]	; (40e5c0 <lTCPWindowTxAdd+0x1e8>)
  40e474:	681b      	ldr	r3, [r3, #0]
  40e476:	2b01      	cmp	r3, #1
  40e478:	dd1a      	ble.n	40e4b0 <lTCPWindowTxAdd+0xd8>
  40e47a:	68fb      	ldr	r3, [r7, #12]
  40e47c:	f8b3 30b8 	ldrh.w	r3, [r3, #184]	; 0xb8
  40e480:	2b17      	cmp	r3, #23
  40e482:	d015      	beq.n	40e4b0 <lTCPWindowTxAdd+0xd8>
					{
						FreeRTOS_debug_printf( ( "lTCPWindowTxAdd: Add %4lu bytes for seqNr %lu len %4lu (nxt %lu) pos %lu\n",
  40e484:	697b      	ldr	r3, [r7, #20]
  40e486:	681a      	ldr	r2, [r3, #0]
  40e488:	68fb      	ldr	r3, [r7, #12]
  40e48a:	69db      	ldr	r3, [r3, #28]
  40e48c:	1ad1      	subs	r1, r2, r3
  40e48e:	697b      	ldr	r3, [r7, #20]
  40e490:	6898      	ldr	r0, [r3, #8]
  40e492:	68fb      	ldr	r3, [r7, #12]
  40e494:	6b5a      	ldr	r2, [r3, #52]	; 0x34
  40e496:	68fb      	ldr	r3, [r7, #12]
  40e498:	69db      	ldr	r3, [r3, #28]
  40e49a:	1ad3      	subs	r3, r2, r3
  40e49c:	697a      	ldr	r2, [r7, #20]
  40e49e:	68d2      	ldr	r2, [r2, #12]
  40e4a0:	9201      	str	r2, [sp, #4]
  40e4a2:	9300      	str	r3, [sp, #0]
  40e4a4:	4603      	mov	r3, r0
  40e4a6:	460a      	mov	r2, r1
  40e4a8:	68b9      	ldr	r1, [r7, #8]
  40e4aa:	4846      	ldr	r0, [pc, #280]	; (40e5c4 <lTCPWindowTxAdd+0x1ec>)
  40e4ac:	4c46      	ldr	r4, [pc, #280]	; (40e5c8 <lTCPWindowTxAdd+0x1f0>)
  40e4ae:	47a0      	blx	r4
						FreeRTOS_flush_logging( );
					}

					/* Calculate the next position in the circular data buffer, knowing
					its maximum length 'lMax'. */
					lPosition = lTCPIncrementTxPosition( lPosition, lMax, lToWrite );
  40e4b0:	693a      	ldr	r2, [r7, #16]
  40e4b2:	6839      	ldr	r1, [r7, #0]
  40e4b4:	6878      	ldr	r0, [r7, #4]
  40e4b6:	4b45      	ldr	r3, [pc, #276]	; (40e5cc <lTCPWindowTxAdd+0x1f4>)
  40e4b8:	4798      	blx	r3
  40e4ba:	6078      	str	r0, [r7, #4]
				}
			}
		}

		while( lBytesLeft > 0 )
  40e4bc:	e074      	b.n	40e5a8 <lTCPWindowTxAdd+0x1d0>
		{
			/* The current transmission segment is full, create new segments as
			needed. */
			pxSegment = xTCPWindowTxNew( pxWindow, pxWindow->ulNextTxSequenceNumber, pxWindow->usMSS );
  40e4be:	68fb      	ldr	r3, [r7, #12]
  40e4c0:	6b59      	ldr	r1, [r3, #52]	; 0x34
  40e4c2:	68fb      	ldr	r3, [r7, #12]
  40e4c4:	f8b3 30bc 	ldrh.w	r3, [r3, #188]	; 0xbc
  40e4c8:	461a      	mov	r2, r3
  40e4ca:	2300      	movs	r3, #0
  40e4cc:	68f8      	ldr	r0, [r7, #12]
  40e4ce:	4c40      	ldr	r4, [pc, #256]	; (40e5d0 <lTCPWindowTxAdd+0x1f8>)
  40e4d0:	47a0      	blx	r4
  40e4d2:	6178      	str	r0, [r7, #20]

			if( pxSegment != NULL )
  40e4d4:	697b      	ldr	r3, [r7, #20]
  40e4d6:	2b00      	cmp	r3, #0
  40e4d8:	d05e      	beq.n	40e598 <lTCPWindowTxAdd+0x1c0>
			{
				/* Store as many as needed, but no more than the maximum
				(MSS). */
				lToWrite = FreeRTOS_min_int32( lBytesLeft, pxSegment->lMaxLength );
  40e4da:	697b      	ldr	r3, [r7, #20]
  40e4dc:	685b      	ldr	r3, [r3, #4]
  40e4de:	4619      	mov	r1, r3
  40e4e0:	69f8      	ldr	r0, [r7, #28]
  40e4e2:	4b36      	ldr	r3, [pc, #216]	; (40e5bc <lTCPWindowTxAdd+0x1e4>)
  40e4e4:	4798      	blx	r3
  40e4e6:	6138      	str	r0, [r7, #16]

				pxSegment->lDataLength = lToWrite;
  40e4e8:	697b      	ldr	r3, [r7, #20]
  40e4ea:	693a      	ldr	r2, [r7, #16]
  40e4ec:	609a      	str	r2, [r3, #8]
				pxSegment->lStreamPos = lPosition;
  40e4ee:	697b      	ldr	r3, [r7, #20]
  40e4f0:	687a      	ldr	r2, [r7, #4]
  40e4f2:	60da      	str	r2, [r3, #12]
				lBytesLeft -= lToWrite;
  40e4f4:	69fa      	ldr	r2, [r7, #28]
  40e4f6:	693b      	ldr	r3, [r7, #16]
  40e4f8:	1ad3      	subs	r3, r2, r3
  40e4fa:	61fb      	str	r3, [r7, #28]
				lPosition = lTCPIncrementTxPosition( lPosition, lMax, lToWrite );
  40e4fc:	693a      	ldr	r2, [r7, #16]
  40e4fe:	6839      	ldr	r1, [r7, #0]
  40e500:	6878      	ldr	r0, [r7, #4]
  40e502:	4b32      	ldr	r3, [pc, #200]	; (40e5cc <lTCPWindowTxAdd+0x1f4>)
  40e504:	4798      	blx	r3
  40e506:	6078      	str	r0, [r7, #4]
				pxWindow->ulNextTxSequenceNumber += ( uint32_t ) lToWrite;
  40e508:	68fb      	ldr	r3, [r7, #12]
  40e50a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
  40e50c:	693b      	ldr	r3, [r7, #16]
  40e50e:	441a      	add	r2, r3
  40e510:	68fb      	ldr	r3, [r7, #12]
  40e512:	635a      	str	r2, [r3, #52]	; 0x34
				lDone += lToWrite;
  40e514:	69ba      	ldr	r2, [r7, #24]
  40e516:	693b      	ldr	r3, [r7, #16]
  40e518:	4413      	add	r3, r2
  40e51a:	61bb      	str	r3, [r7, #24]

				/* Link this segment in the Tx-Queue. */
				vListInsertFifo( &( pxWindow->xTxQueue ), &( pxSegment->xQueueItem ) );
  40e51c:	68fb      	ldr	r3, [r7, #12]
  40e51e:	f103 0254 	add.w	r2, r3, #84	; 0x54
  40e522:	697b      	ldr	r3, [r7, #20]
  40e524:	3318      	adds	r3, #24
  40e526:	4619      	mov	r1, r3
  40e528:	4610      	mov	r0, r2
  40e52a:	4b2a      	ldr	r3, [pc, #168]	; (40e5d4 <lTCPWindowTxAdd+0x1fc>)
  40e52c:	4798      	blx	r3

				/* Let 'pxHeadSegment' point to this segment if there is still
				space. */
				if( pxSegment->lDataLength < pxSegment->lMaxLength )
  40e52e:	697b      	ldr	r3, [r7, #20]
  40e530:	689a      	ldr	r2, [r3, #8]
  40e532:	697b      	ldr	r3, [r7, #20]
  40e534:	685b      	ldr	r3, [r3, #4]
  40e536:	429a      	cmp	r2, r3
  40e538:	da03      	bge.n	40e542 <lTCPWindowTxAdd+0x16a>
				{
					pxWindow->pxHeadSegment = pxSegment;
  40e53a:	68fb      	ldr	r3, [r7, #12]
  40e53c:	697a      	ldr	r2, [r7, #20]
  40e53e:	67da      	str	r2, [r3, #124]	; 0x7c
  40e540:	e002      	b.n	40e548 <lTCPWindowTxAdd+0x170>
				}
				else
				{
					pxWindow->pxHeadSegment = NULL;
  40e542:	68fb      	ldr	r3, [r7, #12]
  40e544:	2200      	movs	r2, #0
  40e546:	67da      	str	r2, [r3, #124]	; 0x7c
				}

				if( ipconfigTCP_MAY_LOG_PORT( pxWindow->usOurPortNumber ) != 0 )
  40e548:	68fb      	ldr	r3, [r7, #12]
  40e54a:	f8b3 30b8 	ldrh.w	r3, [r3, #184]	; 0xb8
  40e54e:	2b17      	cmp	r3, #23
  40e550:	d02a      	beq.n	40e5a8 <lTCPWindowTxAdd+0x1d0>
				{
					if( ( xTCPWindowLoggingLevel >= 3 ) ||
  40e552:	4b1b      	ldr	r3, [pc, #108]	; (40e5c0 <lTCPWindowTxAdd+0x1e8>)
  40e554:	681b      	ldr	r3, [r3, #0]
  40e556:	2b02      	cmp	r3, #2
  40e558:	dc07      	bgt.n	40e56a <lTCPWindowTxAdd+0x192>
						( ( xTCPWindowLoggingLevel >= 2 ) && ( pxWindow->pxHeadSegment != NULL ) ) )
  40e55a:	4b19      	ldr	r3, [pc, #100]	; (40e5c0 <lTCPWindowTxAdd+0x1e8>)
  40e55c:	681b      	ldr	r3, [r3, #0]
					if( ( xTCPWindowLoggingLevel >= 3 ) ||
  40e55e:	2b01      	cmp	r3, #1
  40e560:	dd22      	ble.n	40e5a8 <lTCPWindowTxAdd+0x1d0>
						( ( xTCPWindowLoggingLevel >= 2 ) && ( pxWindow->pxHeadSegment != NULL ) ) )
  40e562:	68fb      	ldr	r3, [r7, #12]
  40e564:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
  40e566:	2b00      	cmp	r3, #0
  40e568:	d01e      	beq.n	40e5a8 <lTCPWindowTxAdd+0x1d0>
					{
						FreeRTOS_debug_printf( ( "lTCPWindowTxAdd: New %4ld bytes for seqNr %lu len %4lu (nxt %lu) pos %lu\n",
  40e56a:	697b      	ldr	r3, [r7, #20]
  40e56c:	681a      	ldr	r2, [r3, #0]
  40e56e:	68fb      	ldr	r3, [r7, #12]
  40e570:	69db      	ldr	r3, [r3, #28]
  40e572:	1ad1      	subs	r1, r2, r3
  40e574:	697b      	ldr	r3, [r7, #20]
  40e576:	6898      	ldr	r0, [r3, #8]
  40e578:	68fb      	ldr	r3, [r7, #12]
  40e57a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
  40e57c:	68fb      	ldr	r3, [r7, #12]
  40e57e:	69db      	ldr	r3, [r3, #28]
  40e580:	1ad3      	subs	r3, r2, r3
  40e582:	697a      	ldr	r2, [r7, #20]
  40e584:	68d2      	ldr	r2, [r2, #12]
  40e586:	9201      	str	r2, [sp, #4]
  40e588:	9300      	str	r3, [sp, #0]
  40e58a:	4603      	mov	r3, r0
  40e58c:	460a      	mov	r2, r1
  40e58e:	68b9      	ldr	r1, [r7, #8]
  40e590:	4811      	ldr	r0, [pc, #68]	; (40e5d8 <lTCPWindowTxAdd+0x200>)
  40e592:	4c0d      	ldr	r4, [pc, #52]	; (40e5c8 <lTCPWindowTxAdd+0x1f0>)
  40e594:	47a0      	blx	r4
  40e596:	e007      	b.n	40e5a8 <lTCPWindowTxAdd+0x1d0>
			}
			else
			{
				/* A sever situation: running out of segments for transmission.
				No more data can be sent at the moment. */
				if( lDone != 0 )
  40e598:	69bb      	ldr	r3, [r7, #24]
  40e59a:	2b00      	cmp	r3, #0
  40e59c:	d008      	beq.n	40e5b0 <lTCPWindowTxAdd+0x1d8>
				{
					FreeRTOS_debug_printf( ( "lTCPWindowTxAdd: Sorry all buffers full (cancel %ld bytes)\n", lBytesLeft ) );
  40e59e:	69f9      	ldr	r1, [r7, #28]
  40e5a0:	480e      	ldr	r0, [pc, #56]	; (40e5dc <lTCPWindowTxAdd+0x204>)
  40e5a2:	4b09      	ldr	r3, [pc, #36]	; (40e5c8 <lTCPWindowTxAdd+0x1f0>)
  40e5a4:	4798      	blx	r3
				}
				break;
  40e5a6:	e003      	b.n	40e5b0 <lTCPWindowTxAdd+0x1d8>
		while( lBytesLeft > 0 )
  40e5a8:	69fb      	ldr	r3, [r7, #28]
  40e5aa:	2b00      	cmp	r3, #0
  40e5ac:	dc87      	bgt.n	40e4be <lTCPWindowTxAdd+0xe6>
  40e5ae:	e000      	b.n	40e5b2 <lTCPWindowTxAdd+0x1da>
				break;
  40e5b0:	bf00      	nop
			}
		}

		return lDone;
  40e5b2:	69bb      	ldr	r3, [r7, #24]
	}
  40e5b4:	4618      	mov	r0, r3
  40e5b6:	3724      	adds	r7, #36	; 0x24
  40e5b8:	46bd      	mov	sp, r7
  40e5ba:	bd90      	pop	{r4, r7, pc}
  40e5bc:	0040d979 	.word	0x0040d979
  40e5c0:	20006d60 	.word	0x20006d60
  40e5c4:	0041db3c 	.word	0x0041db3c
  40e5c8:	00416c7d 	.word	0x00416c7d
  40e5cc:	0040e3a5 	.word	0x0040e3a5
  40e5d0:	0040dc01 	.word	0x0040dc01
  40e5d4:	0040da45 	.word	0x0040da45
  40e5d8:	0041db88 	.word	0x0041db88
  40e5dc:	0041dbd4 	.word	0x0041dbd4

0040e5e0 <xTCPWindowTxDone>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	BaseType_t xTCPWindowTxDone( TCPWindow_t *pxWindow )
	{
  40e5e0:	b480      	push	{r7}
  40e5e2:	b083      	sub	sp, #12
  40e5e4:	af00      	add	r7, sp, #0
  40e5e6:	6078      	str	r0, [r7, #4]
		return listLIST_IS_EMPTY( ( &pxWindow->xTxSegments) );
  40e5e8:	687b      	ldr	r3, [r7, #4]
  40e5ea:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
  40e5ee:	2b00      	cmp	r3, #0
  40e5f0:	d101      	bne.n	40e5f6 <xTCPWindowTxDone+0x16>
  40e5f2:	2301      	movs	r3, #1
  40e5f4:	e000      	b.n	40e5f8 <xTCPWindowTxDone+0x18>
  40e5f6:	2300      	movs	r3, #0
	}
  40e5f8:	4618      	mov	r0, r3
  40e5fa:	370c      	adds	r7, #12
  40e5fc:	46bd      	mov	sp, r7
  40e5fe:	f85d 7b04 	ldr.w	r7, [sp], #4
  40e602:	4770      	bx	lr

0040e604 <prvTCPWindowTxHasSpace>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	static BaseType_t prvTCPWindowTxHasSpace( TCPWindow_t *pxWindow, uint32_t ulWindowSize )
	{
  40e604:	b580      	push	{r7, lr}
  40e606:	b086      	sub	sp, #24
  40e608:	af00      	add	r7, sp, #0
  40e60a:	6078      	str	r0, [r7, #4]
  40e60c:	6039      	str	r1, [r7, #0]
	TCPSegment_t *pxSegment;

		/* This function will look if there is new transmission data.  It will
		return true if there is data to be sent. */

		pxSegment = xTCPWindowPeekHead( &( pxWindow->xTxQueue ) );
  40e60e:	687b      	ldr	r3, [r7, #4]
  40e610:	3354      	adds	r3, #84	; 0x54
  40e612:	4618      	mov	r0, r3
  40e614:	4b1e      	ldr	r3, [pc, #120]	; (40e690 <prvTCPWindowTxHasSpace+0x8c>)
  40e616:	4798      	blx	r3
  40e618:	60f8      	str	r0, [r7, #12]

		if( pxSegment == NULL )
  40e61a:	68fb      	ldr	r3, [r7, #12]
  40e61c:	2b00      	cmp	r3, #0
  40e61e:	d102      	bne.n	40e626 <prvTCPWindowTxHasSpace+0x22>
		{
			xHasSpace = pdFALSE;
  40e620:	2300      	movs	r3, #0
  40e622:	613b      	str	r3, [r7, #16]
  40e624:	e02f      	b.n	40e686 <prvTCPWindowTxHasSpace+0x82>
		}
		else
		{
			/* How much data is outstanding, i.e. how much data has been sent
			but not yet acknowledged ? */
			if( pxWindow->tx.ulHighestSequenceNumber >= pxWindow->tx.ulCurrentSequenceNumber )
  40e626:	687b      	ldr	r3, [r7, #4]
  40e628:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  40e62a:	687b      	ldr	r3, [r7, #4]
  40e62c:	6a1b      	ldr	r3, [r3, #32]
  40e62e:	429a      	cmp	r2, r3
  40e630:	d306      	bcc.n	40e640 <prvTCPWindowTxHasSpace+0x3c>
			{
				ulTxOutstanding = pxWindow->tx.ulHighestSequenceNumber - pxWindow->tx.ulCurrentSequenceNumber;
  40e632:	687b      	ldr	r3, [r7, #4]
  40e634:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  40e636:	687b      	ldr	r3, [r7, #4]
  40e638:	6a1b      	ldr	r3, [r3, #32]
  40e63a:	1ad3      	subs	r3, r2, r3
  40e63c:	617b      	str	r3, [r7, #20]
  40e63e:	e001      	b.n	40e644 <prvTCPWindowTxHasSpace+0x40>
			}
			else
			{
				ulTxOutstanding = 0UL;
  40e640:	2300      	movs	r3, #0
  40e642:	617b      	str	r3, [r7, #20]
			}

			/* Subtract this from the peer's space. */
			ulWindowSize -= FreeRTOS_min_uint32( ulWindowSize, ulTxOutstanding );
  40e644:	6979      	ldr	r1, [r7, #20]
  40e646:	6838      	ldr	r0, [r7, #0]
  40e648:	4b12      	ldr	r3, [pc, #72]	; (40e694 <prvTCPWindowTxHasSpace+0x90>)
  40e64a:	4798      	blx	r3
  40e64c:	4602      	mov	r2, r0
  40e64e:	683b      	ldr	r3, [r7, #0]
  40e650:	1a9b      	subs	r3, r3, r2
  40e652:	603b      	str	r3, [r7, #0]

			/* See if the next segment may be sent. */
			if( ulWindowSize >= ( uint32_t ) pxSegment->lDataLength )
  40e654:	68fb      	ldr	r3, [r7, #12]
  40e656:	689b      	ldr	r3, [r3, #8]
  40e658:	461a      	mov	r2, r3
  40e65a:	683b      	ldr	r3, [r7, #0]
  40e65c:	429a      	cmp	r2, r3
  40e65e:	d802      	bhi.n	40e666 <prvTCPWindowTxHasSpace+0x62>
			{
				xHasSpace = pdTRUE;
  40e660:	2301      	movs	r3, #1
  40e662:	613b      	str	r3, [r7, #16]
  40e664:	e001      	b.n	40e66a <prvTCPWindowTxHasSpace+0x66>
			}
			else
			{
				xHasSpace = pdFALSE;
  40e666:	2300      	movs	r3, #0
  40e668:	613b      	str	r3, [r7, #16]

			/* If 'xHasSpace', it looks like the peer has at least space for 1
			more new segment of size MSS.  xSize.ulTxWindowLength is the self-imposed
			limitation of the transmission window (in case of many resends it
			may be decreased). */
			if( ( ulTxOutstanding != 0UL ) && ( pxWindow->xSize.ulTxWindowLength < ulTxOutstanding + ( ( uint32_t ) pxSegment->lDataLength ) ) )
  40e66a:	697b      	ldr	r3, [r7, #20]
  40e66c:	2b00      	cmp	r3, #0
  40e66e:	d00a      	beq.n	40e686 <prvTCPWindowTxHasSpace+0x82>
  40e670:	687b      	ldr	r3, [r7, #4]
  40e672:	689a      	ldr	r2, [r3, #8]
  40e674:	68fb      	ldr	r3, [r7, #12]
  40e676:	689b      	ldr	r3, [r3, #8]
  40e678:	4619      	mov	r1, r3
  40e67a:	697b      	ldr	r3, [r7, #20]
  40e67c:	440b      	add	r3, r1
  40e67e:	429a      	cmp	r2, r3
  40e680:	d201      	bcs.n	40e686 <prvTCPWindowTxHasSpace+0x82>
			{
				xHasSpace = pdFALSE;
  40e682:	2300      	movs	r3, #0
  40e684:	613b      	str	r3, [r7, #16]
			}
		}

		return xHasSpace;
  40e686:	693b      	ldr	r3, [r7, #16]
	}
  40e688:	4618      	mov	r0, r3
  40e68a:	3718      	adds	r7, #24
  40e68c:	46bd      	mov	sp, r7
  40e68e:	bd80      	pop	{r7, pc}
  40e690:	0040dda1 	.word	0x0040dda1
  40e694:	0040d999 	.word	0x0040d999

0040e698 <xTCPWindowTxHasData>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	BaseType_t xTCPWindowTxHasData( TCPWindow_t *pxWindow, uint32_t ulWindowSize, TickType_t *pulDelay )
	{
  40e698:	b580      	push	{r7, lr}
  40e69a:	b088      	sub	sp, #32
  40e69c:	af00      	add	r7, sp, #0
  40e69e:	60f8      	str	r0, [r7, #12]
  40e6a0:	60b9      	str	r1, [r7, #8]
  40e6a2:	607a      	str	r2, [r7, #4]
	TCPSegment_t *pxSegment;
	BaseType_t xReturn;
	TickType_t ulAge, ulMaxAge;

		*pulDelay = 0u;
  40e6a4:	687b      	ldr	r3, [r7, #4]
  40e6a6:	2200      	movs	r2, #0
  40e6a8:	601a      	str	r2, [r3, #0]

		if( listLIST_IS_EMPTY( &pxWindow->xPriorityQueue ) == pdFALSE )
  40e6aa:	68fb      	ldr	r3, [r7, #12]
  40e6ac:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  40e6ae:	2b00      	cmp	r3, #0
  40e6b0:	d002      	beq.n	40e6b8 <xTCPWindowTxHasData+0x20>
		{
			/* No need to look at retransmissions or new transmission as long as
			there are priority segments.  *pulDelay equals zero, meaning it must
			be sent out immediately. */
			xReturn = pdTRUE;
  40e6b2:	2301      	movs	r3, #1
  40e6b4:	61fb      	str	r3, [r7, #28]
  40e6b6:	e04a      	b.n	40e74e <xTCPWindowTxHasData+0xb6>
		}
		else
		{
			pxSegment = xTCPWindowPeekHead( &( pxWindow->xWaitQueue ) );
  40e6b8:	68fb      	ldr	r3, [r7, #12]
  40e6ba:	3368      	adds	r3, #104	; 0x68
  40e6bc:	4618      	mov	r0, r3
  40e6be:	4b26      	ldr	r3, [pc, #152]	; (40e758 <xTCPWindowTxHasData+0xc0>)
  40e6c0:	4798      	blx	r3
  40e6c2:	61b8      	str	r0, [r7, #24]

			if( pxSegment != NULL )
  40e6c4:	69bb      	ldr	r3, [r7, #24]
  40e6c6:	2b00      	cmp	r3, #0
  40e6c8:	d019      	beq.n	40e6fe <xTCPWindowTxHasData+0x66>
			{
				/* There is an outstanding segment, see if it is time to resend
				it. */
				ulAge = ulTimerGetAge( &pxSegment->xTransmitTimer );
  40e6ca:	69bb      	ldr	r3, [r7, #24]
  40e6cc:	3310      	adds	r3, #16
  40e6ce:	4618      	mov	r0, r3
  40e6d0:	4b22      	ldr	r3, [pc, #136]	; (40e75c <xTCPWindowTxHasData+0xc4>)
  40e6d2:	4798      	blx	r3
  40e6d4:	6178      	str	r0, [r7, #20]

				/* After a packet has been sent for the first time, it will wait
				'1 * lSRTT' ms for an ACK. A second time it will wait '2 * lSRTT' ms,
				each time doubling the time-out */
				ulMaxAge = ( 1u << pxSegment->u.bits.ucTransmitCount ) * ( ( uint32_t ) pxWindow->lSRTT );
  40e6d6:	68fb      	ldr	r3, [r7, #12]
  40e6d8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  40e6da:	461a      	mov	r2, r3
  40e6dc:	69bb      	ldr	r3, [r7, #24]
  40e6de:	7d1b      	ldrb	r3, [r3, #20]
  40e6e0:	fa02 f303 	lsl.w	r3, r2, r3
  40e6e4:	613b      	str	r3, [r7, #16]

				if( ulMaxAge > ulAge )
  40e6e6:	693a      	ldr	r2, [r7, #16]
  40e6e8:	697b      	ldr	r3, [r7, #20]
  40e6ea:	429a      	cmp	r2, r3
  40e6ec:	d904      	bls.n	40e6f8 <xTCPWindowTxHasData+0x60>
				{
					/* A segment must be sent after this amount of msecs */
					*pulDelay = ulMaxAge - ulAge;
  40e6ee:	693a      	ldr	r2, [r7, #16]
  40e6f0:	697b      	ldr	r3, [r7, #20]
  40e6f2:	1ad2      	subs	r2, r2, r3
  40e6f4:	687b      	ldr	r3, [r7, #4]
  40e6f6:	601a      	str	r2, [r3, #0]
				}

				xReturn = pdTRUE;
  40e6f8:	2301      	movs	r3, #1
  40e6fa:	61fb      	str	r3, [r7, #28]
  40e6fc:	e027      	b.n	40e74e <xTCPWindowTxHasData+0xb6>
			}
			else
			{
				/* No priority segment, no outstanding data, see if there is new
				transmission data. */
				pxSegment = xTCPWindowPeekHead( &pxWindow->xTxQueue );
  40e6fe:	68fb      	ldr	r3, [r7, #12]
  40e700:	3354      	adds	r3, #84	; 0x54
  40e702:	4618      	mov	r0, r3
  40e704:	4b14      	ldr	r3, [pc, #80]	; (40e758 <xTCPWindowTxHasData+0xc0>)
  40e706:	4798      	blx	r3
  40e708:	61b8      	str	r0, [r7, #24]

				/* See if it fits in the peer's reception window. */
				if( pxSegment == NULL )
  40e70a:	69bb      	ldr	r3, [r7, #24]
  40e70c:	2b00      	cmp	r3, #0
  40e70e:	d102      	bne.n	40e716 <xTCPWindowTxHasData+0x7e>
				{
					xReturn = pdFALSE;
  40e710:	2300      	movs	r3, #0
  40e712:	61fb      	str	r3, [r7, #28]
  40e714:	e01b      	b.n	40e74e <xTCPWindowTxHasData+0xb6>
				}
				else if( prvTCPWindowTxHasSpace( pxWindow, ulWindowSize ) == pdFALSE )
  40e716:	68b9      	ldr	r1, [r7, #8]
  40e718:	68f8      	ldr	r0, [r7, #12]
  40e71a:	4b11      	ldr	r3, [pc, #68]	; (40e760 <xTCPWindowTxHasData+0xc8>)
  40e71c:	4798      	blx	r3
  40e71e:	4603      	mov	r3, r0
  40e720:	2b00      	cmp	r3, #0
  40e722:	d102      	bne.n	40e72a <xTCPWindowTxHasData+0x92>
				{
					/* Too many outstanding messages. */
					xReturn = pdFALSE;
  40e724:	2300      	movs	r3, #0
  40e726:	61fb      	str	r3, [r7, #28]
  40e728:	e011      	b.n	40e74e <xTCPWindowTxHasData+0xb6>
				}
				else if( ( pxWindow->u.bits.bSendFullSize != pdFALSE_UNSIGNED ) && ( pxSegment->lDataLength < pxSegment->lMaxLength ) )
  40e72a:	68fb      	ldr	r3, [r7, #12]
  40e72c:	781b      	ldrb	r3, [r3, #0]
  40e72e:	f003 0302 	and.w	r3, r3, #2
  40e732:	b2db      	uxtb	r3, r3
  40e734:	2b00      	cmp	r3, #0
  40e736:	d008      	beq.n	40e74a <xTCPWindowTxHasData+0xb2>
  40e738:	69bb      	ldr	r3, [r7, #24]
  40e73a:	689a      	ldr	r2, [r3, #8]
  40e73c:	69bb      	ldr	r3, [r7, #24]
  40e73e:	685b      	ldr	r3, [r3, #4]
  40e740:	429a      	cmp	r2, r3
  40e742:	da02      	bge.n	40e74a <xTCPWindowTxHasData+0xb2>
				{
					/* 'bSendFullSize' is a special optimisation.  If true, the
					driver will only sent completely filled packets (of MSS
					bytes). */
					xReturn = pdFALSE;
  40e744:	2300      	movs	r3, #0
  40e746:	61fb      	str	r3, [r7, #28]
  40e748:	e001      	b.n	40e74e <xTCPWindowTxHasData+0xb6>
				}
				else
				{
					xReturn = pdTRUE;
  40e74a:	2301      	movs	r3, #1
  40e74c:	61fb      	str	r3, [r7, #28]
				}
			}
		}

		return xReturn;
  40e74e:	69fb      	ldr	r3, [r7, #28]
	}
  40e750:	4618      	mov	r0, r3
  40e752:	3720      	adds	r7, #32
  40e754:	46bd      	mov	sp, r7
  40e756:	bd80      	pop	{r7, pc}
  40e758:	0040dda1 	.word	0x0040dda1
  40e75c:	0040da89 	.word	0x0040da89
  40e760:	0040e605 	.word	0x0040e605

0040e764 <ulTCPWindowTxGet>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	uint32_t ulTCPWindowTxGet( TCPWindow_t *pxWindow, uint32_t ulWindowSize, int32_t *plPosition )
	{
  40e764:	b590      	push	{r4, r7, lr}
  40e766:	b08b      	sub	sp, #44	; 0x2c
  40e768:	af02      	add	r7, sp, #8
  40e76a:	60f8      	str	r0, [r7, #12]
  40e76c:	60b9      	str	r1, [r7, #8]
  40e76e:	607a      	str	r2, [r7, #4]
	TCPSegment_t *pxSegment;
	uint32_t ulMaxTime;
	uint32_t ulReturn  = ~0UL;
  40e770:	f04f 33ff 	mov.w	r3, #4294967295
  40e774:	61bb      	str	r3, [r7, #24]

		/* Fetches data to be sent-out now.

		Priority messages: segments with a resend need no check current sliding
		window size. */
		pxSegment = xTCPWindowGetHead( &( pxWindow->xPriorityQueue ) );
  40e776:	68fb      	ldr	r3, [r7, #12]
  40e778:	3340      	adds	r3, #64	; 0x40
  40e77a:	4618      	mov	r0, r3
  40e77c:	4b97      	ldr	r3, [pc, #604]	; (40e9dc <ulTCPWindowTxGet+0x278>)
  40e77e:	4798      	blx	r3
  40e780:	61f8      	str	r0, [r7, #28]
		pxWindow->ulOurSequenceNumber = pxWindow->tx.ulHighestSequenceNumber;
  40e782:	68fb      	ldr	r3, [r7, #12]
  40e784:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  40e786:	68fb      	ldr	r3, [r7, #12]
  40e788:	62da      	str	r2, [r3, #44]	; 0x2c

		if( pxSegment == NULL )
  40e78a:	69fb      	ldr	r3, [r7, #28]
  40e78c:	2b00      	cmp	r3, #0
  40e78e:	f040 80ad 	bne.w	40e8ec <ulTCPWindowTxGet+0x188>
		{
			/* Waiting messages: outstanding messages with a running timer
			neither check peer's reception window size because these packets
			have been sent earlier. */
			pxSegment = xTCPWindowPeekHead( &( pxWindow->xWaitQueue ) );
  40e792:	68fb      	ldr	r3, [r7, #12]
  40e794:	3368      	adds	r3, #104	; 0x68
  40e796:	4618      	mov	r0, r3
  40e798:	4b91      	ldr	r3, [pc, #580]	; (40e9e0 <ulTCPWindowTxGet+0x27c>)
  40e79a:	4798      	blx	r3
  40e79c:	61f8      	str	r0, [r7, #28]

			if( pxSegment != NULL )
  40e79e:	69fb      	ldr	r3, [r7, #28]
  40e7a0:	2b00      	cmp	r3, #0
  40e7a2:	d03e      	beq.n	40e822 <ulTCPWindowTxGet+0xbe>
			{
				/* Do check the timing. */
				ulMaxTime = ( 1u << pxSegment->u.bits.ucTransmitCount ) * ( ( uint32_t ) pxWindow->lSRTT );
  40e7a4:	68fb      	ldr	r3, [r7, #12]
  40e7a6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  40e7a8:	461a      	mov	r2, r3
  40e7aa:	69fb      	ldr	r3, [r7, #28]
  40e7ac:	7d1b      	ldrb	r3, [r3, #20]
  40e7ae:	fa02 f303 	lsl.w	r3, r2, r3
  40e7b2:	617b      	str	r3, [r7, #20]

				if( ulTimerGetAge( &pxSegment->xTransmitTimer ) > ulMaxTime )
  40e7b4:	69fb      	ldr	r3, [r7, #28]
  40e7b6:	3310      	adds	r3, #16
  40e7b8:	4618      	mov	r0, r3
  40e7ba:	4b8a      	ldr	r3, [pc, #552]	; (40e9e4 <ulTCPWindowTxGet+0x280>)
  40e7bc:	4798      	blx	r3
  40e7be:	4602      	mov	r2, r0
  40e7c0:	697b      	ldr	r3, [r7, #20]
  40e7c2:	429a      	cmp	r2, r3
  40e7c4:	d92b      	bls.n	40e81e <ulTCPWindowTxGet+0xba>
				{
					/* A normal (non-fast) retransmission.  Move it from the
					head of the waiting queue. */
					pxSegment = xTCPWindowGetHead( &( pxWindow->xWaitQueue ) );
  40e7c6:	68fb      	ldr	r3, [r7, #12]
  40e7c8:	3368      	adds	r3, #104	; 0x68
  40e7ca:	4618      	mov	r0, r3
  40e7cc:	4b83      	ldr	r3, [pc, #524]	; (40e9dc <ulTCPWindowTxGet+0x278>)
  40e7ce:	4798      	blx	r3
  40e7d0:	61f8      	str	r0, [r7, #28]
					pxSegment->u.bits.ucDupAckCount = pdFALSE_UNSIGNED;
  40e7d2:	69fb      	ldr	r3, [r7, #28]
  40e7d4:	2200      	movs	r2, #0
  40e7d6:	755a      	strb	r2, [r3, #21]

					/* Some detailed logging. */
					if( ( xTCPWindowLoggingLevel != 0 ) && ( ipconfigTCP_MAY_LOG_PORT( pxWindow->usOurPortNumber ) != 0 ) )
  40e7d8:	4b83      	ldr	r3, [pc, #524]	; (40e9e8 <ulTCPWindowTxGet+0x284>)
  40e7da:	681b      	ldr	r3, [r3, #0]
  40e7dc:	2b00      	cmp	r3, #0
  40e7de:	d020      	beq.n	40e822 <ulTCPWindowTxGet+0xbe>
  40e7e0:	68fb      	ldr	r3, [r7, #12]
  40e7e2:	f8b3 30b8 	ldrh.w	r3, [r3, #184]	; 0xb8
  40e7e6:	2b17      	cmp	r3, #23
  40e7e8:	d01b      	beq.n	40e822 <ulTCPWindowTxGet+0xbe>
					{
						FreeRTOS_debug_printf( ( "ulTCPWindowTxGet[%u,%u]: WaitQueue %ld bytes for sequence number %lu (%lX)\n",
  40e7ea:	68fb      	ldr	r3, [r7, #12]
  40e7ec:	f8b3 30ba 	ldrh.w	r3, [r3, #186]	; 0xba
  40e7f0:	4618      	mov	r0, r3
  40e7f2:	68fb      	ldr	r3, [r7, #12]
  40e7f4:	f8b3 30b8 	ldrh.w	r3, [r3, #184]	; 0xb8
  40e7f8:	461c      	mov	r4, r3
  40e7fa:	69fb      	ldr	r3, [r7, #28]
  40e7fc:	6899      	ldr	r1, [r3, #8]
  40e7fe:	69fb      	ldr	r3, [r7, #28]
  40e800:	681a      	ldr	r2, [r3, #0]
  40e802:	68fb      	ldr	r3, [r7, #12]
  40e804:	69db      	ldr	r3, [r3, #28]
  40e806:	1ad3      	subs	r3, r2, r3
  40e808:	69fa      	ldr	r2, [r7, #28]
  40e80a:	6812      	ldr	r2, [r2, #0]
  40e80c:	9201      	str	r2, [sp, #4]
  40e80e:	9300      	str	r3, [sp, #0]
  40e810:	460b      	mov	r3, r1
  40e812:	4622      	mov	r2, r4
  40e814:	4601      	mov	r1, r0
  40e816:	4875      	ldr	r0, [pc, #468]	; (40e9ec <ulTCPWindowTxGet+0x288>)
  40e818:	4c75      	ldr	r4, [pc, #468]	; (40e9f0 <ulTCPWindowTxGet+0x28c>)
  40e81a:	47a0      	blx	r4
  40e81c:	e001      	b.n	40e822 <ulTCPWindowTxGet+0xbe>
						FreeRTOS_flush_logging( );
					}
				}
				else
				{
					pxSegment = NULL;
  40e81e:	2300      	movs	r3, #0
  40e820:	61fb      	str	r3, [r7, #28]
				}
			}

			if( pxSegment == NULL )
  40e822:	69fb      	ldr	r3, [r7, #28]
  40e824:	2b00      	cmp	r3, #0
  40e826:	d17d      	bne.n	40e924 <ulTCPWindowTxGet+0x1c0>
			{
				/* New messages: sent-out for the first time.  Check current
				sliding window size of peer. */
				pxSegment = xTCPWindowPeekHead( &( pxWindow->xTxQueue ) );
  40e828:	68fb      	ldr	r3, [r7, #12]
  40e82a:	3354      	adds	r3, #84	; 0x54
  40e82c:	4618      	mov	r0, r3
  40e82e:	4b6c      	ldr	r3, [pc, #432]	; (40e9e0 <ulTCPWindowTxGet+0x27c>)
  40e830:	4798      	blx	r3
  40e832:	61f8      	str	r0, [r7, #28]

				if( pxSegment == NULL )
  40e834:	69fb      	ldr	r3, [r7, #28]
  40e836:	2b00      	cmp	r3, #0
  40e838:	d102      	bne.n	40e840 <ulTCPWindowTxGet+0xdc>
				{
					/* No segments queued. */
					ulReturn = 0UL;
  40e83a:	2300      	movs	r3, #0
  40e83c:	61bb      	str	r3, [r7, #24]
  40e83e:	e071      	b.n	40e924 <ulTCPWindowTxGet+0x1c0>
				}
				else if( ( pxWindow->u.bits.bSendFullSize != pdFALSE_UNSIGNED ) && ( pxSegment->lDataLength < pxSegment->lMaxLength ) )
  40e840:	68fb      	ldr	r3, [r7, #12]
  40e842:	781b      	ldrb	r3, [r3, #0]
  40e844:	f003 0302 	and.w	r3, r3, #2
  40e848:	b2db      	uxtb	r3, r3
  40e84a:	2b00      	cmp	r3, #0
  40e84c:	d008      	beq.n	40e860 <ulTCPWindowTxGet+0xfc>
  40e84e:	69fb      	ldr	r3, [r7, #28]
  40e850:	689a      	ldr	r2, [r3, #8]
  40e852:	69fb      	ldr	r3, [r7, #28]
  40e854:	685b      	ldr	r3, [r3, #4]
  40e856:	429a      	cmp	r2, r3
  40e858:	da02      	bge.n	40e860 <ulTCPWindowTxGet+0xfc>
				{
					/* A segment has been queued but the driver waits until it
					has a full size of MSS. */
					ulReturn = 0;
  40e85a:	2300      	movs	r3, #0
  40e85c:	61bb      	str	r3, [r7, #24]
  40e85e:	e061      	b.n	40e924 <ulTCPWindowTxGet+0x1c0>
				}
				else if( prvTCPWindowTxHasSpace( pxWindow, ulWindowSize ) == pdFALSE )
  40e860:	68b9      	ldr	r1, [r7, #8]
  40e862:	68f8      	ldr	r0, [r7, #12]
  40e864:	4b63      	ldr	r3, [pc, #396]	; (40e9f4 <ulTCPWindowTxGet+0x290>)
  40e866:	4798      	blx	r3
  40e868:	4603      	mov	r3, r0
  40e86a:	2b00      	cmp	r3, #0
  40e86c:	d102      	bne.n	40e874 <ulTCPWindowTxGet+0x110>
				{
					/* Peer has no more space at this moment. */
					ulReturn = 0;
  40e86e:	2300      	movs	r3, #0
  40e870:	61bb      	str	r3, [r7, #24]
  40e872:	e057      	b.n	40e924 <ulTCPWindowTxGet+0x1c0>
				}
				else
				{
					/* Move it out of the Tx queue. */
					pxSegment = xTCPWindowGetHead( &( pxWindow->xTxQueue ) );
  40e874:	68fb      	ldr	r3, [r7, #12]
  40e876:	3354      	adds	r3, #84	; 0x54
  40e878:	4618      	mov	r0, r3
  40e87a:	4b58      	ldr	r3, [pc, #352]	; (40e9dc <ulTCPWindowTxGet+0x278>)
  40e87c:	4798      	blx	r3
  40e87e:	61f8      	str	r0, [r7, #28]

					/* Don't let pxHeadSegment point to this segment any more,
					so no more data will be added. */
					if( pxWindow->pxHeadSegment == pxSegment )
  40e880:	68fb      	ldr	r3, [r7, #12]
  40e882:	6fda      	ldr	r2, [r3, #124]	; 0x7c
  40e884:	69fb      	ldr	r3, [r7, #28]
  40e886:	429a      	cmp	r2, r3
  40e888:	d102      	bne.n	40e890 <ulTCPWindowTxGet+0x12c>
					{
						pxWindow->pxHeadSegment = NULL;
  40e88a:	68fb      	ldr	r3, [r7, #12]
  40e88c:	2200      	movs	r2, #0
  40e88e:	67da      	str	r2, [r3, #124]	; 0x7c
					}

					/* pxWindow->tx.highest registers the highest sequence
					number in our transmission window. */
					pxWindow->tx.ulHighestSequenceNumber = pxSegment->ulSequenceNumber + ( ( uint32_t ) pxSegment->lDataLength );
  40e890:	69fb      	ldr	r3, [r7, #28]
  40e892:	681b      	ldr	r3, [r3, #0]
  40e894:	69fa      	ldr	r2, [r7, #28]
  40e896:	6892      	ldr	r2, [r2, #8]
  40e898:	441a      	add	r2, r3
  40e89a:	68fb      	ldr	r3, [r7, #12]
  40e89c:	629a      	str	r2, [r3, #40]	; 0x28

					/* ...and more detailed logging */
					if( ( xTCPWindowLoggingLevel >= 2 ) && ( ipconfigTCP_MAY_LOG_PORT( pxWindow->usOurPortNumber ) != pdFALSE ) )
  40e89e:	4b52      	ldr	r3, [pc, #328]	; (40e9e8 <ulTCPWindowTxGet+0x284>)
  40e8a0:	681b      	ldr	r3, [r3, #0]
  40e8a2:	2b01      	cmp	r3, #1
  40e8a4:	dd3e      	ble.n	40e924 <ulTCPWindowTxGet+0x1c0>
  40e8a6:	68fb      	ldr	r3, [r7, #12]
  40e8a8:	f8b3 30b8 	ldrh.w	r3, [r3, #184]	; 0xb8
  40e8ac:	2b17      	cmp	r3, #23
  40e8ae:	d001      	beq.n	40e8b4 <ulTCPWindowTxGet+0x150>
  40e8b0:	2301      	movs	r3, #1
  40e8b2:	e000      	b.n	40e8b6 <ulTCPWindowTxGet+0x152>
  40e8b4:	2300      	movs	r3, #0
  40e8b6:	2b00      	cmp	r3, #0
  40e8b8:	d034      	beq.n	40e924 <ulTCPWindowTxGet+0x1c0>
					{
						FreeRTOS_debug_printf( ( "ulTCPWindowTxGet[%u,%u]: XmitQueue %ld bytes for sequence number %lu (ws %lu)\n",
  40e8ba:	68fb      	ldr	r3, [r7, #12]
  40e8bc:	f8b3 30ba 	ldrh.w	r3, [r3, #186]	; 0xba
  40e8c0:	4618      	mov	r0, r3
  40e8c2:	68fb      	ldr	r3, [r7, #12]
  40e8c4:	f8b3 30b8 	ldrh.w	r3, [r3, #184]	; 0xb8
  40e8c8:	461c      	mov	r4, r3
  40e8ca:	69fb      	ldr	r3, [r7, #28]
  40e8cc:	6899      	ldr	r1, [r3, #8]
  40e8ce:	69fb      	ldr	r3, [r7, #28]
  40e8d0:	681a      	ldr	r2, [r3, #0]
  40e8d2:	68fb      	ldr	r3, [r7, #12]
  40e8d4:	69db      	ldr	r3, [r3, #28]
  40e8d6:	1ad3      	subs	r3, r2, r3
  40e8d8:	68ba      	ldr	r2, [r7, #8]
  40e8da:	9201      	str	r2, [sp, #4]
  40e8dc:	9300      	str	r3, [sp, #0]
  40e8de:	460b      	mov	r3, r1
  40e8e0:	4622      	mov	r2, r4
  40e8e2:	4601      	mov	r1, r0
  40e8e4:	4844      	ldr	r0, [pc, #272]	; (40e9f8 <ulTCPWindowTxGet+0x294>)
  40e8e6:	4c42      	ldr	r4, [pc, #264]	; (40e9f0 <ulTCPWindowTxGet+0x28c>)
  40e8e8:	47a0      	blx	r4
  40e8ea:	e01b      	b.n	40e924 <ulTCPWindowTxGet+0x1c0>
		}
		else
		{
			/* There is a priority segment. It doesn't need any checking for
			space or timeouts. */
			if( xTCPWindowLoggingLevel != 0 )
  40e8ec:	4b3e      	ldr	r3, [pc, #248]	; (40e9e8 <ulTCPWindowTxGet+0x284>)
  40e8ee:	681b      	ldr	r3, [r3, #0]
  40e8f0:	2b00      	cmp	r3, #0
  40e8f2:	d017      	beq.n	40e924 <ulTCPWindowTxGet+0x1c0>
			{
				FreeRTOS_debug_printf( ( "ulTCPWindowTxGet[%u,%u]: PrioQueue %ld bytes for sequence number %lu (ws %lu)\n",
  40e8f4:	68fb      	ldr	r3, [r7, #12]
  40e8f6:	f8b3 30ba 	ldrh.w	r3, [r3, #186]	; 0xba
  40e8fa:	4618      	mov	r0, r3
  40e8fc:	68fb      	ldr	r3, [r7, #12]
  40e8fe:	f8b3 30b8 	ldrh.w	r3, [r3, #184]	; 0xb8
  40e902:	461c      	mov	r4, r3
  40e904:	69fb      	ldr	r3, [r7, #28]
  40e906:	6899      	ldr	r1, [r3, #8]
  40e908:	69fb      	ldr	r3, [r7, #28]
  40e90a:	681a      	ldr	r2, [r3, #0]
  40e90c:	68fb      	ldr	r3, [r7, #12]
  40e90e:	69db      	ldr	r3, [r3, #28]
  40e910:	1ad3      	subs	r3, r2, r3
  40e912:	68ba      	ldr	r2, [r7, #8]
  40e914:	9201      	str	r2, [sp, #4]
  40e916:	9300      	str	r3, [sp, #0]
  40e918:	460b      	mov	r3, r1
  40e91a:	4622      	mov	r2, r4
  40e91c:	4601      	mov	r1, r0
  40e91e:	4837      	ldr	r0, [pc, #220]	; (40e9fc <ulTCPWindowTxGet+0x298>)
  40e920:	4c33      	ldr	r4, [pc, #204]	; (40e9f0 <ulTCPWindowTxGet+0x28c>)
  40e922:	47a0      	blx	r4
				FreeRTOS_flush_logging( );
			}
		}

		/* See if it has already been determined to return 0. */
		if( ulReturn != 0UL )
  40e924:	69bb      	ldr	r3, [r7, #24]
  40e926:	2b00      	cmp	r3, #0
  40e928:	d053      	beq.n	40e9d2 <ulTCPWindowTxGet+0x26e>
		{
			configASSERT( listLIST_ITEM_CONTAINER( &(pxSegment->xQueueItem ) ) == NULL );
  40e92a:	69fb      	ldr	r3, [r7, #28]
  40e92c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  40e92e:	2b00      	cmp	r3, #0
  40e930:	d005      	beq.n	40e93e <ulTCPWindowTxGet+0x1da>
  40e932:	f240 5276 	movw	r2, #1398	; 0x576
  40e936:	4932      	ldr	r1, [pc, #200]	; (40ea00 <ulTCPWindowTxGet+0x29c>)
  40e938:	4832      	ldr	r0, [pc, #200]	; (40ea04 <ulTCPWindowTxGet+0x2a0>)
  40e93a:	4b2d      	ldr	r3, [pc, #180]	; (40e9f0 <ulTCPWindowTxGet+0x28c>)
  40e93c:	4798      	blx	r3

			/* Now that the segment will be transmitted, add it to the tail of
			the waiting queue. */
			vListInsertFifo( &pxWindow->xWaitQueue, &pxSegment->xQueueItem );
  40e93e:	68fb      	ldr	r3, [r7, #12]
  40e940:	f103 0268 	add.w	r2, r3, #104	; 0x68
  40e944:	69fb      	ldr	r3, [r7, #28]
  40e946:	3318      	adds	r3, #24
  40e948:	4619      	mov	r1, r3
  40e94a:	4610      	mov	r0, r2
  40e94c:	4b2e      	ldr	r3, [pc, #184]	; (40ea08 <ulTCPWindowTxGet+0x2a4>)
  40e94e:	4798      	blx	r3

			/* And mark it as outstanding. */
			pxSegment->u.bits.bOutstanding = pdTRUE_UNSIGNED;
  40e950:	69fa      	ldr	r2, [r7, #28]
  40e952:	7d93      	ldrb	r3, [r2, #22]
  40e954:	f043 0301 	orr.w	r3, r3, #1
  40e958:	7593      	strb	r3, [r2, #22]

			/* Administer the transmit count, needed for fast
			retransmissions. */
			( pxSegment->u.bits.ucTransmitCount )++;
  40e95a:	69fb      	ldr	r3, [r7, #28]
  40e95c:	7d1b      	ldrb	r3, [r3, #20]
  40e95e:	3301      	adds	r3, #1
  40e960:	b2da      	uxtb	r2, r3
  40e962:	69fb      	ldr	r3, [r7, #28]
  40e964:	751a      	strb	r2, [r3, #20]

			/* If there have been several retransmissions (4), decrease the
			size of the transmission window to at most 2 times MSS. */
			if( pxSegment->u.bits.ucTransmitCount == MAX_TRANSMIT_COUNT_USING_LARGE_WINDOW )
  40e966:	69fb      	ldr	r3, [r7, #28]
  40e968:	7d1b      	ldrb	r3, [r3, #20]
  40e96a:	2b04      	cmp	r3, #4
  40e96c:	d121      	bne.n	40e9b2 <ulTCPWindowTxGet+0x24e>
			{
				if( pxWindow->xSize.ulTxWindowLength > ( 2U * pxWindow->usMSS ) )
  40e96e:	68fb      	ldr	r3, [r7, #12]
  40e970:	689a      	ldr	r2, [r3, #8]
  40e972:	68fb      	ldr	r3, [r7, #12]
  40e974:	f8b3 30bc 	ldrh.w	r3, [r3, #188]	; 0xbc
  40e978:	005b      	lsls	r3, r3, #1
  40e97a:	429a      	cmp	r2, r3
  40e97c:	d919      	bls.n	40e9b2 <ulTCPWindowTxGet+0x24e>
				{
					FreeRTOS_debug_printf( ( "ulTCPWindowTxGet[%u - %d]: Change Tx window: %lu -> %u\n",
  40e97e:	68fb      	ldr	r3, [r7, #12]
  40e980:	f8b3 30ba 	ldrh.w	r3, [r3, #186]	; 0xba
  40e984:	4619      	mov	r1, r3
  40e986:	68fb      	ldr	r3, [r7, #12]
  40e988:	f8b3 30b8 	ldrh.w	r3, [r3, #184]	; 0xb8
  40e98c:	4618      	mov	r0, r3
  40e98e:	68fb      	ldr	r3, [r7, #12]
  40e990:	689a      	ldr	r2, [r3, #8]
  40e992:	68fb      	ldr	r3, [r7, #12]
  40e994:	f8b3 30bc 	ldrh.w	r3, [r3, #188]	; 0xbc
  40e998:	005b      	lsls	r3, r3, #1
  40e99a:	9300      	str	r3, [sp, #0]
  40e99c:	4613      	mov	r3, r2
  40e99e:	4602      	mov	r2, r0
  40e9a0:	481a      	ldr	r0, [pc, #104]	; (40ea0c <ulTCPWindowTxGet+0x2a8>)
  40e9a2:	4c13      	ldr	r4, [pc, #76]	; (40e9f0 <ulTCPWindowTxGet+0x28c>)
  40e9a4:	47a0      	blx	r4
						pxWindow->usPeerPortNumber, pxWindow->usOurPortNumber,
						pxWindow->xSize.ulTxWindowLength, 2 * pxWindow->usMSS ) );
					pxWindow->xSize.ulTxWindowLength = ( 2UL * pxWindow->usMSS );
  40e9a6:	68fb      	ldr	r3, [r7, #12]
  40e9a8:	f8b3 30bc 	ldrh.w	r3, [r3, #188]	; 0xbc
  40e9ac:	005a      	lsls	r2, r3, #1
  40e9ae:	68fb      	ldr	r3, [r7, #12]
  40e9b0:	609a      	str	r2, [r3, #8]
				}
			}

			/* Clear the transmit timer. */
			vTCPTimerSet( &( pxSegment->xTransmitTimer ) );
  40e9b2:	69fb      	ldr	r3, [r7, #28]
  40e9b4:	3310      	adds	r3, #16
  40e9b6:	4618      	mov	r0, r3
  40e9b8:	4b15      	ldr	r3, [pc, #84]	; (40ea10 <ulTCPWindowTxGet+0x2ac>)
  40e9ba:	4798      	blx	r3

			pxWindow->ulOurSequenceNumber = pxSegment->ulSequenceNumber;
  40e9bc:	69fb      	ldr	r3, [r7, #28]
  40e9be:	681a      	ldr	r2, [r3, #0]
  40e9c0:	68fb      	ldr	r3, [r7, #12]
  40e9c2:	62da      	str	r2, [r3, #44]	; 0x2c

			/* Inform the caller where to find the data within the queue. */
			*plPosition = pxSegment->lStreamPos;
  40e9c4:	69fb      	ldr	r3, [r7, #28]
  40e9c6:	68da      	ldr	r2, [r3, #12]
  40e9c8:	687b      	ldr	r3, [r7, #4]
  40e9ca:	601a      	str	r2, [r3, #0]

			/* And return the length of the data segment */
			ulReturn = ( uint32_t ) pxSegment->lDataLength;
  40e9cc:	69fb      	ldr	r3, [r7, #28]
  40e9ce:	689b      	ldr	r3, [r3, #8]
  40e9d0:	61bb      	str	r3, [r7, #24]
		}

		return ulReturn;
  40e9d2:	69bb      	ldr	r3, [r7, #24]
	}
  40e9d4:	4618      	mov	r0, r3
  40e9d6:	3724      	adds	r7, #36	; 0x24
  40e9d8:	46bd      	mov	sp, r7
  40e9da:	bd90      	pop	{r4, r7, pc}
  40e9dc:	0040dd69 	.word	0x0040dd69
  40e9e0:	0040dda1 	.word	0x0040dda1
  40e9e4:	0040da89 	.word	0x0040da89
  40e9e8:	20006d60 	.word	0x20006d60
  40e9ec:	0041dc10 	.word	0x0041dc10
  40e9f0:	00416c7d 	.word	0x00416c7d
  40e9f4:	0040e605 	.word	0x0040e605
  40e9f8:	0041dc5c 	.word	0x0041dc5c
  40e9fc:	0041dcac 	.word	0x0041dcac
  40ea00:	0041d8e0 	.word	0x0041d8e0
  40ea04:	0041d93c 	.word	0x0041d93c
  40ea08:	0040da45 	.word	0x0040da45
  40ea0c:	0041dcfc 	.word	0x0041dcfc
  40ea10:	0040da69 	.word	0x0040da69

0040ea14 <prvTCPWindowTxCheckAck>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	static uint32_t prvTCPWindowTxCheckAck( TCPWindow_t *pxWindow, uint32_t ulFirst, uint32_t ulLast )
	{
  40ea14:	b5b0      	push	{r4, r5, r7, lr}
  40ea16:	b092      	sub	sp, #72	; 0x48
  40ea18:	af04      	add	r7, sp, #16
  40ea1a:	60f8      	str	r0, [r7, #12]
  40ea1c:	60b9      	str	r1, [r7, #8]
  40ea1e:	607a      	str	r2, [r7, #4]
	uint32_t ulBytesConfirmed = 0u;
  40ea20:	2300      	movs	r3, #0
  40ea22:	637b      	str	r3, [r7, #52]	; 0x34
	uint32_t ulSequenceNumber = ulFirst, ulDataLength;
  40ea24:	68bb      	ldr	r3, [r7, #8]
  40ea26:	633b      	str	r3, [r7, #48]	; 0x30
	const ListItem_t *pxIterator;
	const MiniListItem_t *pxEnd = ( const MiniListItem_t* )listGET_END_MARKER( &pxWindow->xTxSegments );
  40ea28:	68fb      	ldr	r3, [r7, #12]
  40ea2a:	3398      	adds	r3, #152	; 0x98
  40ea2c:	627b      	str	r3, [r7, #36]	; 0x24

		 A Smoothed RTT will increase quickly, but it is conservative when
		 becoming smaller. */

		for(
				pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
  40ea2e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40ea30:	685b      	ldr	r3, [r3, #4]
  40ea32:	62fb      	str	r3, [r7, #44]	; 0x2c
		for(
  40ea34:	e0d6      	b.n	40ebe4 <prvTCPWindowTxCheckAck+0x1d0>
				( pxIterator != ( const ListItem_t * ) pxEnd ) && ( xSequenceLessThan( ulSequenceNumber, ulLast ) != 0 );
			)
		{
			xDoUnlink = pdFALSE;
  40ea36:	2300      	movs	r3, #0
  40ea38:	62bb      	str	r3, [r7, #40]	; 0x28
			pxSegment = ( TCPSegment_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
  40ea3a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40ea3c:	68db      	ldr	r3, [r3, #12]
  40ea3e:	623b      	str	r3, [r7, #32]

			/* Move to the next item because the current item might get
			removed. */
			pxIterator = ( const ListItem_t * ) listGET_NEXT( pxIterator );
  40ea40:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40ea42:	685b      	ldr	r3, [r3, #4]
  40ea44:	62fb      	str	r3, [r7, #44]	; 0x2c

			/* Continue if this segment does not fall within the ACK'd range. */
			if( xSequenceGreaterThan( ulSequenceNumber, pxSegment->ulSequenceNumber ) != pdFALSE )
  40ea46:	6a3b      	ldr	r3, [r7, #32]
  40ea48:	681b      	ldr	r3, [r3, #0]
  40ea4a:	4619      	mov	r1, r3
  40ea4c:	6b38      	ldr	r0, [r7, #48]	; 0x30
  40ea4e:	4b6f      	ldr	r3, [pc, #444]	; (40ec0c <prvTCPWindowTxCheckAck+0x1f8>)
  40ea50:	4798      	blx	r3
  40ea52:	4603      	mov	r3, r0
  40ea54:	2b00      	cmp	r3, #0
  40ea56:	d000      	beq.n	40ea5a <prvTCPWindowTxCheckAck+0x46>
			{
				continue;
  40ea58:	e0c4      	b.n	40ebe4 <prvTCPWindowTxCheckAck+0x1d0>
			}

			/* Is it ready? */
			if( ulSequenceNumber != pxSegment->ulSequenceNumber )
  40ea5a:	6a3b      	ldr	r3, [r7, #32]
  40ea5c:	681a      	ldr	r2, [r3, #0]
  40ea5e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  40ea60:	429a      	cmp	r2, r3
  40ea62:	f040 80cc 	bne.w	40ebfe <prvTCPWindowTxCheckAck+0x1ea>
			{
				break;
			}

			ulDataLength = ( uint32_t ) pxSegment->lDataLength;
  40ea66:	6a3b      	ldr	r3, [r7, #32]
  40ea68:	689b      	ldr	r3, [r3, #8]
  40ea6a:	61fb      	str	r3, [r7, #28]

			if( pxSegment->u.bits.bAcked == pdFALSE_UNSIGNED )
  40ea6c:	6a3b      	ldr	r3, [r7, #32]
  40ea6e:	7d9b      	ldrb	r3, [r3, #22]
  40ea70:	f003 0302 	and.w	r3, r3, #2
  40ea74:	b2db      	uxtb	r3, r3
  40ea76:	2b00      	cmp	r3, #0
  40ea78:	d171      	bne.n	40eb5e <prvTCPWindowTxCheckAck+0x14a>
			{
				if( xSequenceGreaterThan( pxSegment->ulSequenceNumber + ( uint32_t )ulDataLength, ulLast ) != pdFALSE )
  40ea7a:	6a3b      	ldr	r3, [r7, #32]
  40ea7c:	681a      	ldr	r2, [r3, #0]
  40ea7e:	69fb      	ldr	r3, [r7, #28]
  40ea80:	4413      	add	r3, r2
  40ea82:	6879      	ldr	r1, [r7, #4]
  40ea84:	4618      	mov	r0, r3
  40ea86:	4b61      	ldr	r3, [pc, #388]	; (40ec0c <prvTCPWindowTxCheckAck+0x1f8>)
  40ea88:	4798      	blx	r3
  40ea8a:	4603      	mov	r3, r0
  40ea8c:	2b00      	cmp	r3, #0
  40ea8e:	d023      	beq.n	40ead8 <prvTCPWindowTxCheckAck+0xc4>

					  AAAAAAA BBBBBBB << acked
					  aaaaaaa aaaa    << sent */
					#if( ipconfigHAS_DEBUG_PRINTF != 0 )
					{
						uint32_t ulFirstSeq = pxSegment->ulSequenceNumber - pxWindow->tx.ulFirstSequenceNumber;
  40ea90:	6a3b      	ldr	r3, [r7, #32]
  40ea92:	681a      	ldr	r2, [r3, #0]
  40ea94:	68fb      	ldr	r3, [r7, #12]
  40ea96:	69db      	ldr	r3, [r3, #28]
  40ea98:	1ad3      	subs	r3, r2, r3
  40ea9a:	617b      	str	r3, [r7, #20]
						FreeRTOS_debug_printf( ( "prvTCPWindowTxCheckAck[%u.%u]: %lu - %lu Partial sequence number %lu - %lu\n",
  40ea9c:	68fb      	ldr	r3, [r7, #12]
  40ea9e:	f8b3 30ba 	ldrh.w	r3, [r3, #186]	; 0xba
  40eaa2:	461c      	mov	r4, r3
  40eaa4:	68fb      	ldr	r3, [r7, #12]
  40eaa6:	f8b3 30b8 	ldrh.w	r3, [r3, #184]	; 0xb8
  40eaaa:	461d      	mov	r5, r3
  40eaac:	68fb      	ldr	r3, [r7, #12]
  40eaae:	69db      	ldr	r3, [r3, #28]
  40eab0:	697a      	ldr	r2, [r7, #20]
  40eab2:	1ad0      	subs	r0, r2, r3
  40eab4:	68fb      	ldr	r3, [r7, #12]
  40eab6:	69db      	ldr	r3, [r3, #28]
  40eab8:	687a      	ldr	r2, [r7, #4]
  40eaba:	1ad3      	subs	r3, r2, r3
  40eabc:	6979      	ldr	r1, [r7, #20]
  40eabe:	69fa      	ldr	r2, [r7, #28]
  40eac0:	440a      	add	r2, r1
  40eac2:	9202      	str	r2, [sp, #8]
  40eac4:	697a      	ldr	r2, [r7, #20]
  40eac6:	9201      	str	r2, [sp, #4]
  40eac8:	9300      	str	r3, [sp, #0]
  40eaca:	4603      	mov	r3, r0
  40eacc:	462a      	mov	r2, r5
  40eace:	4621      	mov	r1, r4
  40ead0:	484f      	ldr	r0, [pc, #316]	; (40ec10 <prvTCPWindowTxCheckAck+0x1fc>)
  40ead2:	4c50      	ldr	r4, [pc, #320]	; (40ec14 <prvTCPWindowTxCheckAck+0x200>)
  40ead4:	47a0      	blx	r4
							ulFirstSeq - pxWindow->tx.ulFirstSequenceNumber,
							ulLast - pxWindow->tx.ulFirstSequenceNumber,
							ulFirstSeq, ulFirstSeq + ulDataLength ) );
					}
					#endif /* ipconfigHAS_DEBUG_PRINTF */
					break;
  40ead6:	e093      	b.n	40ec00 <prvTCPWindowTxCheckAck+0x1ec>
				}

				/* This segment is fully ACK'd, set the flag. */
				pxSegment->u.bits.bAcked = pdTRUE_UNSIGNED;
  40ead8:	6a3a      	ldr	r2, [r7, #32]
  40eada:	7d93      	ldrb	r3, [r2, #22]
  40eadc:	f043 0302 	orr.w	r3, r3, #2
  40eae0:	7593      	strb	r3, [r2, #22]

				/* Calculate the RTT only if the segment was sent-out for the
				first time and if this is the last ACK'd segment in a range. */
				if( ( pxSegment->u.bits.ucTransmitCount == 1 ) && ( ( pxSegment->ulSequenceNumber + ulDataLength ) == ulLast ) )
  40eae2:	6a3b      	ldr	r3, [r7, #32]
  40eae4:	7d1b      	ldrb	r3, [r3, #20]
  40eae6:	2b01      	cmp	r3, #1
  40eae8:	d137      	bne.n	40eb5a <prvTCPWindowTxCheckAck+0x146>
  40eaea:	6a3b      	ldr	r3, [r7, #32]
  40eaec:	681a      	ldr	r2, [r3, #0]
  40eaee:	69fb      	ldr	r3, [r7, #28]
  40eaf0:	441a      	add	r2, r3
  40eaf2:	687b      	ldr	r3, [r7, #4]
  40eaf4:	429a      	cmp	r2, r3
  40eaf6:	d130      	bne.n	40eb5a <prvTCPWindowTxCheckAck+0x146>
				{
					int32_t mS = ( int32_t ) ulTimerGetAge( &( pxSegment->xTransmitTimer ) );
  40eaf8:	6a3b      	ldr	r3, [r7, #32]
  40eafa:	3310      	adds	r3, #16
  40eafc:	4618      	mov	r0, r3
  40eafe:	4b46      	ldr	r3, [pc, #280]	; (40ec18 <prvTCPWindowTxCheckAck+0x204>)
  40eb00:	4798      	blx	r3
  40eb02:	4603      	mov	r3, r0
  40eb04:	61bb      	str	r3, [r7, #24]

					if( pxWindow->lSRTT >= mS )
  40eb06:	68fb      	ldr	r3, [r7, #12]
  40eb08:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  40eb0a:	69bb      	ldr	r3, [r7, #24]
  40eb0c:	429a      	cmp	r2, r3
  40eb0e:	db0e      	blt.n	40eb2e <prvTCPWindowTxCheckAck+0x11a>
					{
						/* RTT becomes smaller: adapt slowly. */
						pxWindow->lSRTT = ( ( winSRTT_DECREMENT_NEW * mS ) + ( winSRTT_DECREMENT_CURRENT * pxWindow->lSRTT ) ) / ( winSRTT_DECREMENT_NEW + winSRTT_DECREMENT_CURRENT );
  40eb10:	68fb      	ldr	r3, [r7, #12]
  40eb12:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  40eb14:	4613      	mov	r3, r2
  40eb16:	00db      	lsls	r3, r3, #3
  40eb18:	1a9a      	subs	r2, r3, r2
  40eb1a:	69bb      	ldr	r3, [r7, #24]
  40eb1c:	4413      	add	r3, r2
  40eb1e:	2b00      	cmp	r3, #0
  40eb20:	da00      	bge.n	40eb24 <prvTCPWindowTxCheckAck+0x110>
  40eb22:	3307      	adds	r3, #7
  40eb24:	10db      	asrs	r3, r3, #3
  40eb26:	461a      	mov	r2, r3
  40eb28:	68fb      	ldr	r3, [r7, #12]
  40eb2a:	639a      	str	r2, [r3, #56]	; 0x38
  40eb2c:	e00e      	b.n	40eb4c <prvTCPWindowTxCheckAck+0x138>
					}
					else
					{
						/* RTT becomes larger: adapt quicker */
						pxWindow->lSRTT = ( ( winSRTT_INCREMENT_NEW * mS ) + ( winSRTT_INCREMENT_CURRENT * pxWindow->lSRTT ) ) / ( winSRTT_INCREMENT_NEW + winSRTT_INCREMENT_CURRENT );
  40eb2e:	68fb      	ldr	r3, [r7, #12]
  40eb30:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  40eb32:	4613      	mov	r3, r2
  40eb34:	005b      	lsls	r3, r3, #1
  40eb36:	441a      	add	r2, r3
  40eb38:	69bb      	ldr	r3, [r7, #24]
  40eb3a:	4413      	add	r3, r2
  40eb3c:	005b      	lsls	r3, r3, #1
  40eb3e:	2b00      	cmp	r3, #0
  40eb40:	da00      	bge.n	40eb44 <prvTCPWindowTxCheckAck+0x130>
  40eb42:	3307      	adds	r3, #7
  40eb44:	10db      	asrs	r3, r3, #3
  40eb46:	461a      	mov	r2, r3
  40eb48:	68fb      	ldr	r3, [r7, #12]
  40eb4a:	639a      	str	r2, [r3, #56]	; 0x38
					}

					/* Cap to the minimum of 50ms. */
					if( pxWindow->lSRTT < winSRTT_CAP_mS )
  40eb4c:	68fb      	ldr	r3, [r7, #12]
  40eb4e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  40eb50:	2b31      	cmp	r3, #49	; 0x31
  40eb52:	dc02      	bgt.n	40eb5a <prvTCPWindowTxCheckAck+0x146>
					{
						pxWindow->lSRTT = winSRTT_CAP_mS;
  40eb54:	68fb      	ldr	r3, [r7, #12]
  40eb56:	2232      	movs	r2, #50	; 0x32
  40eb58:	639a      	str	r2, [r3, #56]	; 0x38
					}
				}

				/* Unlink it from the 3 queues, but do not destroy it (yet). */
				xDoUnlink = pdTRUE;
  40eb5a:	2301      	movs	r3, #1
  40eb5c:	62bb      	str	r3, [r7, #40]	; 0x28
			}

			/* pxSegment->u.bits.bAcked is now true.  Is it located at the left
			side of the transmission queue?  If so, it may be freed. */
			if( ulSequenceNumber == pxWindow->tx.ulCurrentSequenceNumber )
  40eb5e:	68fb      	ldr	r3, [r7, #12]
  40eb60:	6a1a      	ldr	r2, [r3, #32]
  40eb62:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  40eb64:	429a      	cmp	r2, r3
  40eb66:	d12d      	bne.n	40ebc4 <prvTCPWindowTxCheckAck+0x1b0>
			{
				if( ( xTCPWindowLoggingLevel >= 2 ) && ( ipconfigTCP_MAY_LOG_PORT( pxWindow->usOurPortNumber ) != pdFALSE ) )
  40eb68:	4b2c      	ldr	r3, [pc, #176]	; (40ec1c <prvTCPWindowTxCheckAck+0x208>)
  40eb6a:	681b      	ldr	r3, [r3, #0]
  40eb6c:	2b01      	cmp	r3, #1
  40eb6e:	dd1a      	ble.n	40eba6 <prvTCPWindowTxCheckAck+0x192>
  40eb70:	68fb      	ldr	r3, [r7, #12]
  40eb72:	f8b3 30b8 	ldrh.w	r3, [r3, #184]	; 0xb8
  40eb76:	2b17      	cmp	r3, #23
  40eb78:	d001      	beq.n	40eb7e <prvTCPWindowTxCheckAck+0x16a>
  40eb7a:	2301      	movs	r3, #1
  40eb7c:	e000      	b.n	40eb80 <prvTCPWindowTxCheckAck+0x16c>
  40eb7e:	2300      	movs	r3, #0
  40eb80:	2b00      	cmp	r3, #0
  40eb82:	d010      	beq.n	40eba6 <prvTCPWindowTxCheckAck+0x192>
				{
					FreeRTOS_debug_printf( ( "prvTCPWindowTxCheckAck: %lu - %lu Ready sequence number %lu\n",
  40eb84:	68fb      	ldr	r3, [r7, #12]
  40eb86:	69db      	ldr	r3, [r3, #28]
  40eb88:	68ba      	ldr	r2, [r7, #8]
  40eb8a:	1ad1      	subs	r1, r2, r3
  40eb8c:	68fb      	ldr	r3, [r7, #12]
  40eb8e:	69db      	ldr	r3, [r3, #28]
  40eb90:	687a      	ldr	r2, [r7, #4]
  40eb92:	1ad0      	subs	r0, r2, r3
  40eb94:	6a3b      	ldr	r3, [r7, #32]
  40eb96:	681a      	ldr	r2, [r3, #0]
  40eb98:	68fb      	ldr	r3, [r7, #12]
  40eb9a:	69db      	ldr	r3, [r3, #28]
  40eb9c:	1ad3      	subs	r3, r2, r3
  40eb9e:	4602      	mov	r2, r0
  40eba0:	481f      	ldr	r0, [pc, #124]	; (40ec20 <prvTCPWindowTxCheckAck+0x20c>)
  40eba2:	4c1c      	ldr	r4, [pc, #112]	; (40ec14 <prvTCPWindowTxCheckAck+0x200>)
  40eba4:	47a0      	blx	r4
						ulLast - pxWindow->tx.ulFirstSequenceNumber,
						pxSegment->ulSequenceNumber - pxWindow->tx.ulFirstSequenceNumber ) );
				}

				/* Increase the left-hand value of the transmission window. */
				pxWindow->tx.ulCurrentSequenceNumber += ulDataLength;
  40eba6:	68fb      	ldr	r3, [r7, #12]
  40eba8:	6a1a      	ldr	r2, [r3, #32]
  40ebaa:	69fb      	ldr	r3, [r7, #28]
  40ebac:	441a      	add	r2, r3
  40ebae:	68fb      	ldr	r3, [r7, #12]
  40ebb0:	621a      	str	r2, [r3, #32]

				/* This function will return the number of bytes that the tail
				of txStream may be advanced. */
				ulBytesConfirmed += ulDataLength;
  40ebb2:	6b7a      	ldr	r2, [r7, #52]	; 0x34
  40ebb4:	69fb      	ldr	r3, [r7, #28]
  40ebb6:	4413      	add	r3, r2
  40ebb8:	637b      	str	r3, [r7, #52]	; 0x34

				/* All segments below tx.ulCurrentSequenceNumber may be freed. */
				vTCPWindowFree( pxSegment );
  40ebba:	6a38      	ldr	r0, [r7, #32]
  40ebbc:	4b19      	ldr	r3, [pc, #100]	; (40ec24 <prvTCPWindowTxCheckAck+0x210>)
  40ebbe:	4798      	blx	r3

				/* No need to unlink it any more. */
				xDoUnlink = pdFALSE;
  40ebc0:	2300      	movs	r3, #0
  40ebc2:	62bb      	str	r3, [r7, #40]	; 0x28
			}

			if( ( xDoUnlink != pdFALSE ) && ( listLIST_ITEM_CONTAINER( &( pxSegment->xQueueItem ) ) != NULL ) )
  40ebc4:	6abb      	ldr	r3, [r7, #40]	; 0x28
  40ebc6:	2b00      	cmp	r3, #0
  40ebc8:	d008      	beq.n	40ebdc <prvTCPWindowTxCheckAck+0x1c8>
  40ebca:	6a3b      	ldr	r3, [r7, #32]
  40ebcc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  40ebce:	2b00      	cmp	r3, #0
  40ebd0:	d004      	beq.n	40ebdc <prvTCPWindowTxCheckAck+0x1c8>
			{
				/* Remove item from its queues. */
				uxListRemove( &pxSegment->xQueueItem );
  40ebd2:	6a3b      	ldr	r3, [r7, #32]
  40ebd4:	3318      	adds	r3, #24
  40ebd6:	4618      	mov	r0, r3
  40ebd8:	4b13      	ldr	r3, [pc, #76]	; (40ec28 <prvTCPWindowTxCheckAck+0x214>)
  40ebda:	4798      	blx	r3
			}

			ulSequenceNumber += ulDataLength;
  40ebdc:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  40ebde:	69fb      	ldr	r3, [r7, #28]
  40ebe0:	4413      	add	r3, r2
  40ebe2:	633b      	str	r3, [r7, #48]	; 0x30
		for(
  40ebe4:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  40ebe6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40ebe8:	429a      	cmp	r2, r3
  40ebea:	d009      	beq.n	40ec00 <prvTCPWindowTxCheckAck+0x1ec>
				( pxIterator != ( const ListItem_t * ) pxEnd ) && ( xSequenceLessThan( ulSequenceNumber, ulLast ) != 0 );
  40ebec:	6879      	ldr	r1, [r7, #4]
  40ebee:	6b38      	ldr	r0, [r7, #48]	; 0x30
  40ebf0:	4b0e      	ldr	r3, [pc, #56]	; (40ec2c <prvTCPWindowTxCheckAck+0x218>)
  40ebf2:	4798      	blx	r3
  40ebf4:	4603      	mov	r3, r0
  40ebf6:	2b00      	cmp	r3, #0
  40ebf8:	f47f af1d 	bne.w	40ea36 <prvTCPWindowTxCheckAck+0x22>
  40ebfc:	e000      	b.n	40ec00 <prvTCPWindowTxCheckAck+0x1ec>
				break;
  40ebfe:	bf00      	nop
		}

		return ulBytesConfirmed;
  40ec00:	6b7b      	ldr	r3, [r7, #52]	; 0x34
	}
  40ec02:	4618      	mov	r0, r3
  40ec04:	3738      	adds	r7, #56	; 0x38
  40ec06:	46bd      	mov	sp, r7
  40ec08:	bdb0      	pop	{r4, r5, r7, pc}
  40ec0a:	bf00      	nop
  40ec0c:	0040d9ff 	.word	0x0040d9ff
  40ec10:	0041dd34 	.word	0x0041dd34
  40ec14:	00416c7d 	.word	0x00416c7d
  40ec18:	0040da89 	.word	0x0040da89
  40ec1c:	20006d60 	.word	0x20006d60
  40ec20:	0041dd80 	.word	0x0041dd80
  40ec24:	0040ddd1 	.word	0x0040ddd1
  40ec28:	00410df5 	.word	0x00410df5
  40ec2c:	0040d9db 	.word	0x0040d9db

0040ec30 <prvTCPWindowFastRetransmit>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	static uint32_t prvTCPWindowFastRetransmit( TCPWindow_t *pxWindow, uint32_t ulFirst )
	{
  40ec30:	b580      	push	{r7, lr}
  40ec32:	b086      	sub	sp, #24
  40ec34:	af00      	add	r7, sp, #0
  40ec36:	6078      	str	r0, [r7, #4]
  40ec38:	6039      	str	r1, [r7, #0]
	const ListItem_t *pxIterator;
	const MiniListItem_t* pxEnd;
	TCPSegment_t *pxSegment;
	uint32_t ulCount = 0UL;
  40ec3a:	2300      	movs	r3, #0
  40ec3c:	613b      	str	r3, [r7, #16]

		/* A higher Tx block has been acknowledged.  Now iterate through the
		 xWaitQueue to find a possible condition for a FAST retransmission. */

		pxEnd = ( const MiniListItem_t* ) listGET_END_MARKER( &( pxWindow->xWaitQueue ) );
  40ec3e:	687b      	ldr	r3, [r7, #4]
  40ec40:	3370      	adds	r3, #112	; 0x70
  40ec42:	60fb      	str	r3, [r7, #12]

		for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
  40ec44:	68fb      	ldr	r3, [r7, #12]
  40ec46:	685b      	ldr	r3, [r3, #4]
  40ec48:	617b      	str	r3, [r7, #20]
  40ec4a:	e04e      	b.n	40ecea <prvTCPWindowFastRetransmit+0xba>
			 pxIterator != ( const ListItem_t * ) pxEnd; )
		{
			/* Get the owner, which is a TCP segment. */
			pxSegment = ( TCPSegment_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
  40ec4c:	697b      	ldr	r3, [r7, #20]
  40ec4e:	68db      	ldr	r3, [r3, #12]
  40ec50:	60bb      	str	r3, [r7, #8]

			/* Hop to the next item before the current gets unlinked. */
			pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxIterator );
  40ec52:	697b      	ldr	r3, [r7, #20]
  40ec54:	685b      	ldr	r3, [r3, #4]
  40ec56:	617b      	str	r3, [r7, #20]

			/* Fast retransmission:
			When 3 packets with a higher sequence number have been acknowledged
			by the peer, it is very unlikely a current packet will ever arrive.
			It will be retransmitted far before the RTO. */
			if( ( pxSegment->u.bits.bAcked == pdFALSE_UNSIGNED ) &&
  40ec58:	68bb      	ldr	r3, [r7, #8]
  40ec5a:	7d9b      	ldrb	r3, [r3, #22]
  40ec5c:	f003 0302 	and.w	r3, r3, #2
  40ec60:	b2db      	uxtb	r3, r3
  40ec62:	2b00      	cmp	r3, #0
  40ec64:	d141      	bne.n	40ecea <prvTCPWindowFastRetransmit+0xba>
				( xSequenceLessThan( pxSegment->ulSequenceNumber, ulFirst ) != pdFALSE ) &&
  40ec66:	68bb      	ldr	r3, [r7, #8]
  40ec68:	681b      	ldr	r3, [r3, #0]
  40ec6a:	6839      	ldr	r1, [r7, #0]
  40ec6c:	4618      	mov	r0, r3
  40ec6e:	4b23      	ldr	r3, [pc, #140]	; (40ecfc <prvTCPWindowFastRetransmit+0xcc>)
  40ec70:	4798      	blx	r3
  40ec72:	4603      	mov	r3, r0
			if( ( pxSegment->u.bits.bAcked == pdFALSE_UNSIGNED ) &&
  40ec74:	2b00      	cmp	r3, #0
  40ec76:	d038      	beq.n	40ecea <prvTCPWindowFastRetransmit+0xba>
				( ++( pxSegment->u.bits.ucDupAckCount ) == DUPLICATE_ACKS_BEFORE_FAST_RETRANSMIT ) )
  40ec78:	68bb      	ldr	r3, [r7, #8]
  40ec7a:	7d5b      	ldrb	r3, [r3, #21]
  40ec7c:	3301      	adds	r3, #1
  40ec7e:	b2da      	uxtb	r2, r3
				( xSequenceLessThan( pxSegment->ulSequenceNumber, ulFirst ) != pdFALSE ) &&
  40ec80:	68bb      	ldr	r3, [r7, #8]
  40ec82:	755a      	strb	r2, [r3, #21]
				( ++( pxSegment->u.bits.ucDupAckCount ) == DUPLICATE_ACKS_BEFORE_FAST_RETRANSMIT ) )
  40ec84:	68bb      	ldr	r3, [r7, #8]
  40ec86:	7d5b      	ldrb	r3, [r3, #21]
				( xSequenceLessThan( pxSegment->ulSequenceNumber, ulFirst ) != pdFALSE ) &&
  40ec88:	2b03      	cmp	r3, #3
  40ec8a:	d12e      	bne.n	40ecea <prvTCPWindowFastRetransmit+0xba>
			{
				pxSegment->u.bits.ucTransmitCount = pdFALSE_UNSIGNED;
  40ec8c:	68bb      	ldr	r3, [r7, #8]
  40ec8e:	2200      	movs	r2, #0
  40ec90:	751a      	strb	r2, [r3, #20]

				/* Not clearing 'ucDupAckCount' yet as more SACK's might come in
				which might lead to a second fast rexmit. */
				if( ( xTCPWindowLoggingLevel >= 0 ) && ( ipconfigTCP_MAY_LOG_PORT( pxWindow->usOurPortNumber ) != pdFALSE ) )
  40ec92:	4b1b      	ldr	r3, [pc, #108]	; (40ed00 <prvTCPWindowFastRetransmit+0xd0>)
  40ec94:	681b      	ldr	r3, [r3, #0]
  40ec96:	2b00      	cmp	r3, #0
  40ec98:	db16      	blt.n	40ecc8 <prvTCPWindowFastRetransmit+0x98>
  40ec9a:	687b      	ldr	r3, [r7, #4]
  40ec9c:	f8b3 30b8 	ldrh.w	r3, [r3, #184]	; 0xb8
  40eca0:	2b17      	cmp	r3, #23
  40eca2:	d001      	beq.n	40eca8 <prvTCPWindowFastRetransmit+0x78>
  40eca4:	2301      	movs	r3, #1
  40eca6:	e000      	b.n	40ecaa <prvTCPWindowFastRetransmit+0x7a>
  40eca8:	2300      	movs	r3, #0
  40ecaa:	2b00      	cmp	r3, #0
  40ecac:	d00c      	beq.n	40ecc8 <prvTCPWindowFastRetransmit+0x98>
				{
					FreeRTOS_debug_printf( ( "prvTCPWindowFastRetransmit: Requeue sequence number %lu < %lu\n",
  40ecae:	68bb      	ldr	r3, [r7, #8]
  40ecb0:	681a      	ldr	r2, [r3, #0]
  40ecb2:	687b      	ldr	r3, [r7, #4]
  40ecb4:	69db      	ldr	r3, [r3, #28]
  40ecb6:	1ad1      	subs	r1, r2, r3
  40ecb8:	687b      	ldr	r3, [r7, #4]
  40ecba:	69db      	ldr	r3, [r3, #28]
  40ecbc:	683a      	ldr	r2, [r7, #0]
  40ecbe:	1ad3      	subs	r3, r2, r3
  40ecc0:	461a      	mov	r2, r3
  40ecc2:	4810      	ldr	r0, [pc, #64]	; (40ed04 <prvTCPWindowFastRetransmit+0xd4>)
  40ecc4:	4b10      	ldr	r3, [pc, #64]	; (40ed08 <prvTCPWindowFastRetransmit+0xd8>)
  40ecc6:	4798      	blx	r3
						ulFirst - pxWindow->tx.ulFirstSequenceNumber ) );
					FreeRTOS_flush_logging( );
				}

				/* Remove it from xWaitQueue. */
				uxListRemove( &pxSegment->xQueueItem );
  40ecc8:	68bb      	ldr	r3, [r7, #8]
  40ecca:	3318      	adds	r3, #24
  40eccc:	4618      	mov	r0, r3
  40ecce:	4b0f      	ldr	r3, [pc, #60]	; (40ed0c <prvTCPWindowFastRetransmit+0xdc>)
  40ecd0:	4798      	blx	r3

				/* Add this segment to the priority queue so it gets
				retransmitted immediately. */
				vListInsertFifo( &( pxWindow->xPriorityQueue ), &( pxSegment->xQueueItem ) );
  40ecd2:	687b      	ldr	r3, [r7, #4]
  40ecd4:	f103 0240 	add.w	r2, r3, #64	; 0x40
  40ecd8:	68bb      	ldr	r3, [r7, #8]
  40ecda:	3318      	adds	r3, #24
  40ecdc:	4619      	mov	r1, r3
  40ecde:	4610      	mov	r0, r2
  40ece0:	4b0b      	ldr	r3, [pc, #44]	; (40ed10 <prvTCPWindowFastRetransmit+0xe0>)
  40ece2:	4798      	blx	r3
				ulCount++;
  40ece4:	693b      	ldr	r3, [r7, #16]
  40ece6:	3301      	adds	r3, #1
  40ece8:	613b      	str	r3, [r7, #16]
		for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
  40ecea:	697a      	ldr	r2, [r7, #20]
  40ecec:	68fb      	ldr	r3, [r7, #12]
  40ecee:	429a      	cmp	r2, r3
  40ecf0:	d1ac      	bne.n	40ec4c <prvTCPWindowFastRetransmit+0x1c>
			}
		}

		return ulCount;
  40ecf2:	693b      	ldr	r3, [r7, #16]
	}
  40ecf4:	4618      	mov	r0, r3
  40ecf6:	3718      	adds	r7, #24
  40ecf8:	46bd      	mov	sp, r7
  40ecfa:	bd80      	pop	{r7, pc}
  40ecfc:	0040d9db 	.word	0x0040d9db
  40ed00:	20006d60 	.word	0x20006d60
  40ed04:	0041ddc0 	.word	0x0041ddc0
  40ed08:	00416c7d 	.word	0x00416c7d
  40ed0c:	00410df5 	.word	0x00410df5
  40ed10:	0040da45 	.word	0x0040da45

0040ed14 <ulTCPWindowTxAck>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	uint32_t ulTCPWindowTxAck( TCPWindow_t *pxWindow, uint32_t ulSequenceNumber )
	{
  40ed14:	b580      	push	{r7, lr}
  40ed16:	b084      	sub	sp, #16
  40ed18:	af00      	add	r7, sp, #0
  40ed1a:	6078      	str	r0, [r7, #4]
  40ed1c:	6039      	str	r1, [r7, #0]
	uint32_t ulFirstSequence, ulReturn;

		/* Receive a normal ACK. */

		ulFirstSequence = pxWindow->tx.ulCurrentSequenceNumber;
  40ed1e:	687b      	ldr	r3, [r7, #4]
  40ed20:	6a1b      	ldr	r3, [r3, #32]
  40ed22:	60bb      	str	r3, [r7, #8]

		if( xSequenceLessThanOrEqual( ulSequenceNumber, ulFirstSequence ) != pdFALSE )
  40ed24:	68b9      	ldr	r1, [r7, #8]
  40ed26:	6838      	ldr	r0, [r7, #0]
  40ed28:	4b09      	ldr	r3, [pc, #36]	; (40ed50 <ulTCPWindowTxAck+0x3c>)
  40ed2a:	4798      	blx	r3
  40ed2c:	4603      	mov	r3, r0
  40ed2e:	2b00      	cmp	r3, #0
  40ed30:	d002      	beq.n	40ed38 <ulTCPWindowTxAck+0x24>
		{
			ulReturn = 0UL;
  40ed32:	2300      	movs	r3, #0
  40ed34:	60fb      	str	r3, [r7, #12]
  40ed36:	e005      	b.n	40ed44 <ulTCPWindowTxAck+0x30>
		}
		else
		{
			ulReturn = prvTCPWindowTxCheckAck( pxWindow, ulFirstSequence, ulSequenceNumber );
  40ed38:	683a      	ldr	r2, [r7, #0]
  40ed3a:	68b9      	ldr	r1, [r7, #8]
  40ed3c:	6878      	ldr	r0, [r7, #4]
  40ed3e:	4b05      	ldr	r3, [pc, #20]	; (40ed54 <ulTCPWindowTxAck+0x40>)
  40ed40:	4798      	blx	r3
  40ed42:	60f8      	str	r0, [r7, #12]
		}

		return ulReturn;
  40ed44:	68fb      	ldr	r3, [r7, #12]
	}
  40ed46:	4618      	mov	r0, r3
  40ed48:	3710      	adds	r7, #16
  40ed4a:	46bd      	mov	sp, r7
  40ed4c:	bd80      	pop	{r7, pc}
  40ed4e:	bf00      	nop
  40ed50:	0040d9b9 	.word	0x0040d9b9
  40ed54:	0040ea15 	.word	0x0040ea15

0040ed58 <ulTCPWindowTxSack>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	uint32_t ulTCPWindowTxSack( TCPWindow_t *pxWindow, uint32_t ulFirst, uint32_t ulLast )
	{
  40ed58:	b5b0      	push	{r4, r5, r7, lr}
  40ed5a:	b088      	sub	sp, #32
  40ed5c:	af02      	add	r7, sp, #8
  40ed5e:	60f8      	str	r0, [r7, #12]
  40ed60:	60b9      	str	r1, [r7, #8]
  40ed62:	607a      	str	r2, [r7, #4]
	uint32_t ulAckCount = 0UL;
  40ed64:	2300      	movs	r3, #0
  40ed66:	617b      	str	r3, [r7, #20]
	uint32_t ulCurrentSequenceNumber = pxWindow->tx.ulCurrentSequenceNumber;
  40ed68:	68fb      	ldr	r3, [r7, #12]
  40ed6a:	6a1b      	ldr	r3, [r3, #32]
  40ed6c:	613b      	str	r3, [r7, #16]

		/* Receive a SACK option. */
		ulAckCount = prvTCPWindowTxCheckAck( pxWindow, ulFirst, ulLast );
  40ed6e:	687a      	ldr	r2, [r7, #4]
  40ed70:	68b9      	ldr	r1, [r7, #8]
  40ed72:	68f8      	ldr	r0, [r7, #12]
  40ed74:	4b19      	ldr	r3, [pc, #100]	; (40eddc <ulTCPWindowTxSack+0x84>)
  40ed76:	4798      	blx	r3
  40ed78:	6178      	str	r0, [r7, #20]
		prvTCPWindowFastRetransmit( pxWindow, ulFirst );
  40ed7a:	68b9      	ldr	r1, [r7, #8]
  40ed7c:	68f8      	ldr	r0, [r7, #12]
  40ed7e:	4b18      	ldr	r3, [pc, #96]	; (40ede0 <ulTCPWindowTxSack+0x88>)
  40ed80:	4798      	blx	r3

		if( ( xTCPWindowLoggingLevel >= 1 ) && ( xSequenceGreaterThan( ulFirst, ulCurrentSequenceNumber ) != pdFALSE ) )
  40ed82:	4b18      	ldr	r3, [pc, #96]	; (40ede4 <ulTCPWindowTxSack+0x8c>)
  40ed84:	681b      	ldr	r3, [r3, #0]
  40ed86:	2b00      	cmp	r3, #0
  40ed88:	dd23      	ble.n	40edd2 <ulTCPWindowTxSack+0x7a>
  40ed8a:	6939      	ldr	r1, [r7, #16]
  40ed8c:	68b8      	ldr	r0, [r7, #8]
  40ed8e:	4b16      	ldr	r3, [pc, #88]	; (40ede8 <ulTCPWindowTxSack+0x90>)
  40ed90:	4798      	blx	r3
  40ed92:	4603      	mov	r3, r0
  40ed94:	2b00      	cmp	r3, #0
  40ed96:	d01c      	beq.n	40edd2 <ulTCPWindowTxSack+0x7a>
		{
			FreeRTOS_debug_printf( ( "ulTCPWindowTxSack[%u,%u]: from %lu to %lu (ack = %lu)\n",
  40ed98:	68fb      	ldr	r3, [r7, #12]
  40ed9a:	f8b3 30ba 	ldrh.w	r3, [r3, #186]	; 0xba
  40ed9e:	461c      	mov	r4, r3
  40eda0:	68fb      	ldr	r3, [r7, #12]
  40eda2:	f8b3 30b8 	ldrh.w	r3, [r3, #184]	; 0xb8
  40eda6:	461d      	mov	r5, r3
  40eda8:	68fb      	ldr	r3, [r7, #12]
  40edaa:	69db      	ldr	r3, [r3, #28]
  40edac:	68ba      	ldr	r2, [r7, #8]
  40edae:	1ad0      	subs	r0, r2, r3
  40edb0:	68fb      	ldr	r3, [r7, #12]
  40edb2:	69db      	ldr	r3, [r3, #28]
  40edb4:	687a      	ldr	r2, [r7, #4]
  40edb6:	1ad3      	subs	r3, r2, r3
  40edb8:	68fa      	ldr	r2, [r7, #12]
  40edba:	6a11      	ldr	r1, [r2, #32]
  40edbc:	68fa      	ldr	r2, [r7, #12]
  40edbe:	69d2      	ldr	r2, [r2, #28]
  40edc0:	1a8a      	subs	r2, r1, r2
  40edc2:	9201      	str	r2, [sp, #4]
  40edc4:	9300      	str	r3, [sp, #0]
  40edc6:	4603      	mov	r3, r0
  40edc8:	462a      	mov	r2, r5
  40edca:	4621      	mov	r1, r4
  40edcc:	4807      	ldr	r0, [pc, #28]	; (40edec <ulTCPWindowTxSack+0x94>)
  40edce:	4c08      	ldr	r4, [pc, #32]	; (40edf0 <ulTCPWindowTxSack+0x98>)
  40edd0:	47a0      	blx	r4
				ulLast - pxWindow->tx.ulFirstSequenceNumber,
				pxWindow->tx.ulCurrentSequenceNumber - pxWindow->tx.ulFirstSequenceNumber ) );
			FreeRTOS_flush_logging( );
		}

		return ulAckCount;
  40edd2:	697b      	ldr	r3, [r7, #20]
	}
  40edd4:	4618      	mov	r0, r3
  40edd6:	3718      	adds	r7, #24
  40edd8:	46bd      	mov	sp, r7
  40edda:	bdb0      	pop	{r4, r5, r7, pc}
  40eddc:	0040ea15 	.word	0x0040ea15
  40ede0:	0040ec31 	.word	0x0040ec31
  40ede4:	20006d60 	.word	0x20006d60
  40ede8:	0040d9ff 	.word	0x0040d9ff
  40edec:	0041de00 	.word	0x0041de00
  40edf0:	00416c7d 	.word	0x00416c7d

0040edf4 <vProcessGeneratedUDPPacket>:
	}
};
/*-----------------------------------------------------------*/

void vProcessGeneratedUDPPacket( NetworkBufferDescriptor_t * const pxNetworkBuffer )
{
  40edf4:	b5b0      	push	{r4, r5, r7, lr}
  40edf6:	b08a      	sub	sp, #40	; 0x28
  40edf8:	af00      	add	r7, sp, #0
  40edfa:	6078      	str	r0, [r7, #4]
UDPPacket_t *pxUDPPacket;
IPHeader_t *pxIPHeader;
eARPLookupResult_t eReturned;
uint32_t ulIPAddress = pxNetworkBuffer->ulIPAddress;
  40edfc:	687b      	ldr	r3, [r7, #4]
  40edfe:	695b      	ldr	r3, [r3, #20]
  40ee00:	60bb      	str	r3, [r7, #8]
size_t uxPayloadSize;

	/* Map the UDP packet onto the start of the frame. */
	pxUDPPacket = ( UDPPacket_t * ) pxNetworkBuffer->pucEthernetBuffer;
  40ee02:	687b      	ldr	r3, [r7, #4]
  40ee04:	699b      	ldr	r3, [r3, #24]
  40ee06:	623b      	str	r3, [r7, #32]
		uxPayloadSize = pxNetworkBuffer->xDataLength - sizeof( ICMPPacket_t );
	}
	else
#endif
	{
		uxPayloadSize = pxNetworkBuffer->xDataLength - sizeof( UDPPacket_t );
  40ee08:	687b      	ldr	r3, [r7, #4]
  40ee0a:	69db      	ldr	r3, [r3, #28]
  40ee0c:	3b2a      	subs	r3, #42	; 0x2a
  40ee0e:	61fb      	str	r3, [r7, #28]
	}

	/* Determine the ARP cache status for the requested IP address. */
	eReturned = eARPGetCacheEntry( &( ulIPAddress ), &( pxUDPPacket->xEthernetHeader.xDestinationAddress ) );
  40ee10:	6a3a      	ldr	r2, [r7, #32]
  40ee12:	f107 0308 	add.w	r3, r7, #8
  40ee16:	4611      	mov	r1, r2
  40ee18:	4618      	mov	r0, r3
  40ee1a:	4b5f      	ldr	r3, [pc, #380]	; (40ef98 <vProcessGeneratedUDPPacket+0x1a4>)
  40ee1c:	4798      	blx	r3
  40ee1e:	4603      	mov	r3, r0
  40ee20:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

	if( eReturned != eCantSendPacket )
  40ee24:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
  40ee28:	2b02      	cmp	r3, #2
  40ee2a:	f000 80a4 	beq.w	40ef76 <vProcessGeneratedUDPPacket+0x182>
	{
		if( eReturned == eARPCacheHit )
  40ee2e:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
  40ee32:	2b01      	cmp	r3, #1
  40ee34:	f040 808c 	bne.w	40ef50 <vProcessGeneratedUDPPacket+0x15c>
				uint8_t ucSocketOptions;
			#endif
			iptraceSENDING_UDP_PACKET( pxNetworkBuffer->ulIPAddress );

			/* Create short cuts to the data within the packet. */
			pxIPHeader = &( pxUDPPacket->xIPHeader );
  40ee38:	6a3b      	ldr	r3, [r7, #32]
  40ee3a:	330e      	adds	r3, #14
  40ee3c:	61bb      	str	r3, [r7, #24]
			if( pxNetworkBuffer->usPort != ipPACKET_CONTAINS_ICMP_DATA )
		#endif /* ipconfigSUPPORT_OUTGOING_PINGS */
			{
			UDPHeader_t *pxUDPHeader;

				pxUDPHeader = &( pxUDPPacket->xUDPHeader );
  40ee3e:	6a3b      	ldr	r3, [r7, #32]
  40ee40:	3322      	adds	r3, #34	; 0x22
  40ee42:	617b      	str	r3, [r7, #20]

				pxUDPHeader->usDestinationPort = pxNetworkBuffer->usPort;
  40ee44:	687b      	ldr	r3, [r7, #4]
  40ee46:	8c1a      	ldrh	r2, [r3, #32]
  40ee48:	697b      	ldr	r3, [r7, #20]
  40ee4a:	805a      	strh	r2, [r3, #2]
				pxUDPHeader->usSourcePort = pxNetworkBuffer->usBoundPort;
  40ee4c:	687b      	ldr	r3, [r7, #4]
  40ee4e:	8c5a      	ldrh	r2, [r3, #34]	; 0x22
  40ee50:	697b      	ldr	r3, [r7, #20]
  40ee52:	801a      	strh	r2, [r3, #0]
				pxUDPHeader->usLength = ( uint16_t ) ( uxPayloadSize + sizeof( UDPHeader_t ) );
  40ee54:	69fb      	ldr	r3, [r7, #28]
  40ee56:	b29b      	uxth	r3, r3
  40ee58:	3308      	adds	r3, #8
  40ee5a:	b29a      	uxth	r2, r3
  40ee5c:	697b      	ldr	r3, [r7, #20]
  40ee5e:	809a      	strh	r2, [r3, #4]
				pxUDPHeader->usLength = FreeRTOS_htons( pxUDPHeader->usLength );
  40ee60:	697b      	ldr	r3, [r7, #20]
  40ee62:	889b      	ldrh	r3, [r3, #4]
  40ee64:	b29b      	uxth	r3, r3
  40ee66:	021b      	lsls	r3, r3, #8
  40ee68:	b21a      	sxth	r2, r3
  40ee6a:	697b      	ldr	r3, [r7, #20]
  40ee6c:	889b      	ldrh	r3, [r3, #4]
  40ee6e:	b29b      	uxth	r3, r3
  40ee70:	0a1b      	lsrs	r3, r3, #8
  40ee72:	b29b      	uxth	r3, r3
  40ee74:	b21b      	sxth	r3, r3
  40ee76:	4313      	orrs	r3, r2
  40ee78:	b21b      	sxth	r3, r3
  40ee7a:	b29a      	uxth	r2, r3
  40ee7c:	697b      	ldr	r3, [r7, #20]
  40ee7e:	809a      	strh	r2, [r3, #4]
				pxUDPHeader->usChecksum = 0u;
  40ee80:	697b      	ldr	r3, [r7, #20]
  40ee82:	2200      	movs	r2, #0
  40ee84:	719a      	strb	r2, [r3, #6]
  40ee86:	2200      	movs	r2, #0
  40ee88:	71da      	strb	r2, [r3, #7]
			and
				xIPHeader.usHeaderChecksum
			*/
			/* Save options now, as they will be overwritten by memcpy */
			#if( ipconfigDRIVER_INCLUDED_TX_IP_CHECKSUM == 0 )
				ucSocketOptions = pxNetworkBuffer->pucEthernetBuffer[ ipSOCKET_OPTIONS_OFFSET ];
  40ee8a:	687b      	ldr	r3, [r7, #4]
  40ee8c:	699b      	ldr	r3, [r3, #24]
  40ee8e:	799b      	ldrb	r3, [r3, #6]
  40ee90:	74fb      	strb	r3, [r7, #19]
			#endif
			/*
			 * Offset the memcpy by the size of a MAC address to start at the packet's
			 * Ethernet header 'source' MAC address; the preceding 'destination' should not be altered.
			 */
			char *pxUdpSrcAddrOffset = ( char *) pxUDPPacket + sizeof( MACAddress_t );
  40ee92:	6a3b      	ldr	r3, [r7, #32]
  40ee94:	3306      	adds	r3, #6
  40ee96:	60fb      	str	r3, [r7, #12]
			memcpy( pxUdpSrcAddrOffset, xDefaultPartUDPPacketHeader.ucBytes, sizeof( xDefaultPartUDPPacketHeader ) );
  40ee98:	68fb      	ldr	r3, [r7, #12]
  40ee9a:	4a40      	ldr	r2, [pc, #256]	; (40ef9c <vProcessGeneratedUDPPacket+0x1a8>)
  40ee9c:	461d      	mov	r5, r3
  40ee9e:	4614      	mov	r4, r2
  40eea0:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  40eea2:	6028      	str	r0, [r5, #0]
  40eea4:	6069      	str	r1, [r5, #4]
  40eea6:	60aa      	str	r2, [r5, #8]
  40eea8:	60eb      	str	r3, [r5, #12]
  40eeaa:	cc03      	ldmia	r4!, {r0, r1}
  40eeac:	6128      	str	r0, [r5, #16]
  40eeae:	6169      	str	r1, [r5, #20]
				pxIPHeader->usLength = ( uint16_t ) ( uxPayloadSize + sizeof( IPHeader_t ) + sizeof( ICMPHeader_t ) );
			}
			else
		#endif /* ipconfigSUPPORT_OUTGOING_PINGS */
			{
				pxIPHeader->usLength = ( uint16_t ) ( uxPayloadSize + sizeof( IPHeader_t ) + sizeof( UDPHeader_t ) );
  40eeb0:	69fb      	ldr	r3, [r7, #28]
  40eeb2:	b29b      	uxth	r3, r3
  40eeb4:	331c      	adds	r3, #28
  40eeb6:	b29a      	uxth	r2, r3
  40eeb8:	69bb      	ldr	r3, [r7, #24]
  40eeba:	805a      	strh	r2, [r3, #2]
			}

			pxIPHeader->usLength = FreeRTOS_htons( pxIPHeader->usLength );
  40eebc:	69bb      	ldr	r3, [r7, #24]
  40eebe:	885b      	ldrh	r3, [r3, #2]
  40eec0:	b29b      	uxth	r3, r3
  40eec2:	021b      	lsls	r3, r3, #8
  40eec4:	b21a      	sxth	r2, r3
  40eec6:	69bb      	ldr	r3, [r7, #24]
  40eec8:	885b      	ldrh	r3, [r3, #2]
  40eeca:	b29b      	uxth	r3, r3
  40eecc:	0a1b      	lsrs	r3, r3, #8
  40eece:	b29b      	uxth	r3, r3
  40eed0:	b21b      	sxth	r3, r3
  40eed2:	4313      	orrs	r3, r2
  40eed4:	b21b      	sxth	r3, r3
  40eed6:	b29a      	uxth	r2, r3
  40eed8:	69bb      	ldr	r3, [r7, #24]
  40eeda:	805a      	strh	r2, [r3, #2]
			/* HT:endian: changed back to network endian */
			pxIPHeader->ulDestinationIPAddress = pxNetworkBuffer->ulIPAddress;
  40eedc:	687b      	ldr	r3, [r7, #4]
  40eede:	695a      	ldr	r2, [r3, #20]
  40eee0:	69bb      	ldr	r3, [r7, #24]
  40eee2:	611a      	str	r2, [r3, #16]
			}
			#endif

			#if( ipconfigDRIVER_INCLUDED_TX_IP_CHECKSUM == 0 )
			{
				pxIPHeader->usHeaderChecksum = 0u;
  40eee4:	69bb      	ldr	r3, [r7, #24]
  40eee6:	2200      	movs	r2, #0
  40eee8:	729a      	strb	r2, [r3, #10]
  40eeea:	2200      	movs	r2, #0
  40eeec:	72da      	strb	r2, [r3, #11]
				pxIPHeader->usHeaderChecksum = usGenerateChecksum( 0UL, ( uint8_t * ) &( pxIPHeader->ucVersionHeaderLength ), ipSIZE_OF_IPv4_HEADER );
  40eeee:	69bb      	ldr	r3, [r7, #24]
  40eef0:	2214      	movs	r2, #20
  40eef2:	4619      	mov	r1, r3
  40eef4:	2000      	movs	r0, #0
  40eef6:	4b2a      	ldr	r3, [pc, #168]	; (40efa0 <vProcessGeneratedUDPPacket+0x1ac>)
  40eef8:	4798      	blx	r3
  40eefa:	4603      	mov	r3, r0
  40eefc:	461a      	mov	r2, r3
  40eefe:	69bb      	ldr	r3, [r7, #24]
  40ef00:	815a      	strh	r2, [r3, #10]
				pxIPHeader->usHeaderChecksum = ~FreeRTOS_htons( pxIPHeader->usHeaderChecksum );
  40ef02:	69bb      	ldr	r3, [r7, #24]
  40ef04:	895b      	ldrh	r3, [r3, #10]
  40ef06:	b29b      	uxth	r3, r3
  40ef08:	021b      	lsls	r3, r3, #8
  40ef0a:	b21a      	sxth	r2, r3
  40ef0c:	69bb      	ldr	r3, [r7, #24]
  40ef0e:	895b      	ldrh	r3, [r3, #10]
  40ef10:	b29b      	uxth	r3, r3
  40ef12:	0a1b      	lsrs	r3, r3, #8
  40ef14:	b29b      	uxth	r3, r3
  40ef16:	b21b      	sxth	r3, r3
  40ef18:	4313      	orrs	r3, r2
  40ef1a:	b21b      	sxth	r3, r3
  40ef1c:	b29b      	uxth	r3, r3
  40ef1e:	43db      	mvns	r3, r3
  40ef20:	b29a      	uxth	r2, r3
  40ef22:	69bb      	ldr	r3, [r7, #24]
  40ef24:	815a      	strh	r2, [r3, #10]

				if( ( ucSocketOptions & ( uint8_t ) FREERTOS_SO_UDPCKSUM_OUT ) != 0u )
  40ef26:	7cfb      	ldrb	r3, [r7, #19]
  40ef28:	f003 0302 	and.w	r3, r3, #2
  40ef2c:	2b00      	cmp	r3, #0
  40ef2e:	d007      	beq.n	40ef40 <vProcessGeneratedUDPPacket+0x14c>
				{
					usGenerateProtocolChecksum( (uint8_t*)pxUDPPacket, pxNetworkBuffer->xDataLength, pdTRUE );
  40ef30:	687b      	ldr	r3, [r7, #4]
  40ef32:	69db      	ldr	r3, [r3, #28]
  40ef34:	2201      	movs	r2, #1
  40ef36:	4619      	mov	r1, r3
  40ef38:	6a38      	ldr	r0, [r7, #32]
  40ef3a:	4b1a      	ldr	r3, [pc, #104]	; (40efa4 <vProcessGeneratedUDPPacket+0x1b0>)
  40ef3c:	4798      	blx	r3
  40ef3e:	e01a      	b.n	40ef76 <vProcessGeneratedUDPPacket+0x182>
				}
				else
				{
					pxUDPPacket->xUDPHeader.usChecksum = 0u;
  40ef40:	6a3b      	ldr	r3, [r7, #32]
  40ef42:	2200      	movs	r2, #0
  40ef44:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
  40ef48:	2200      	movs	r2, #0
  40ef4a:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
  40ef4e:	e012      	b.n	40ef76 <vProcessGeneratedUDPPacket+0x182>
				}
			}
			#endif
		}
		else if( eReturned == eARPCacheMiss )
  40ef50:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
  40ef54:	2b00      	cmp	r3, #0
  40ef56:	d10b      	bne.n	40ef70 <vProcessGeneratedUDPPacket+0x17c>
		{
			/* Add an entry to the ARP table with a null hardware address.
			This allows the ARP timer to know that an ARP reply is
			outstanding, and perform retransmissions if necessary. */
			vARPRefreshCacheEntry( NULL, ulIPAddress );
  40ef58:	68bb      	ldr	r3, [r7, #8]
  40ef5a:	4619      	mov	r1, r3
  40ef5c:	2000      	movs	r0, #0
  40ef5e:	4b12      	ldr	r3, [pc, #72]	; (40efa8 <vProcessGeneratedUDPPacket+0x1b4>)
  40ef60:	4798      	blx	r3

			/* Generate an ARP for the required IP address. */
			iptracePACKET_DROPPED_TO_GENERATE_ARP( pxNetworkBuffer->ulIPAddress );
			pxNetworkBuffer->ulIPAddress = ulIPAddress;
  40ef62:	68ba      	ldr	r2, [r7, #8]
  40ef64:	687b      	ldr	r3, [r7, #4]
  40ef66:	615a      	str	r2, [r3, #20]
			vARPGenerateRequestPacket( pxNetworkBuffer );
  40ef68:	6878      	ldr	r0, [r7, #4]
  40ef6a:	4b10      	ldr	r3, [pc, #64]	; (40efac <vProcessGeneratedUDPPacket+0x1b8>)
  40ef6c:	4798      	blx	r3
  40ef6e:	e002      	b.n	40ef76 <vProcessGeneratedUDPPacket+0x182>
		}
		else
		{
			/* The lookup indicated that an ARP request has already been
			sent out for the queried IP address. */
			eReturned = eCantSendPacket;
  40ef70:	2302      	movs	r3, #2
  40ef72:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
		}
	}

	if( eReturned != eCantSendPacket )
  40ef76:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
  40ef7a:	2b02      	cmp	r3, #2
  40ef7c:	d004      	beq.n	40ef88 <vProcessGeneratedUDPPacket+0x194>
				pxNetworkBuffer->xDataLength = ( size_t ) ipconfigETHERNET_MINIMUM_PACKET_BYTES;
			}
		}
		#endif

		xNetworkInterfaceOutput( pxNetworkBuffer, pdTRUE );
  40ef7e:	2101      	movs	r1, #1
  40ef80:	6878      	ldr	r0, [r7, #4]
  40ef82:	4b0b      	ldr	r3, [pc, #44]	; (40efb0 <vProcessGeneratedUDPPacket+0x1bc>)
  40ef84:	4798      	blx	r3
	{
		/* The packet can't be sent (DHCP not completed?).  Just drop the
		packet. */
		vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
	}
}
  40ef86:	e002      	b.n	40ef8e <vProcessGeneratedUDPPacket+0x19a>
		vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
  40ef88:	6878      	ldr	r0, [r7, #4]
  40ef8a:	4b0a      	ldr	r3, [pc, #40]	; (40efb4 <vProcessGeneratedUDPPacket+0x1c0>)
  40ef8c:	4798      	blx	r3
}
  40ef8e:	bf00      	nop
  40ef90:	3728      	adds	r7, #40	; 0x28
  40ef92:	46bd      	mov	sp, r7
  40ef94:	bdb0      	pop	{r4, r5, r7, pc}
  40ef96:	bf00      	nop
  40ef98:	00407359 	.word	0x00407359
  40ef9c:	20000108 	.word	0x20000108
  40efa0:	004085c5 	.word	0x004085c5
  40efa4:	004082e5 	.word	0x004082e5
  40efa8:	00407159 	.word	0x00407159
  40efac:	00407639 	.word	0x00407639
  40efb0:	004102dd 	.word	0x004102dd
  40efb4:	0040f2ed 	.word	0x0040f2ed

0040efb8 <xProcessReceivedUDPPacket>:
/*-----------------------------------------------------------*/

BaseType_t xProcessReceivedUDPPacket( NetworkBufferDescriptor_t *pxNetworkBuffer, uint16_t usPort )
{
  40efb8:	b580      	push	{r7, lr}
  40efba:	b086      	sub	sp, #24
  40efbc:	af00      	add	r7, sp, #0
  40efbe:	6078      	str	r0, [r7, #4]
  40efc0:	460b      	mov	r3, r1
  40efc2:	807b      	strh	r3, [r7, #2]
BaseType_t xReturn = pdPASS;
  40efc4:	2301      	movs	r3, #1
  40efc6:	617b      	str	r3, [r7, #20]
FreeRTOS_Socket_t *pxSocket;
configASSERT(pxNetworkBuffer);
  40efc8:	687b      	ldr	r3, [r7, #4]
  40efca:	2b00      	cmp	r3, #0
  40efcc:	d104      	bne.n	40efd8 <xProcessReceivedUDPPacket+0x20>
  40efce:	22fd      	movs	r2, #253	; 0xfd
  40efd0:	492c      	ldr	r1, [pc, #176]	; (40f084 <xProcessReceivedUDPPacket+0xcc>)
  40efd2:	482d      	ldr	r0, [pc, #180]	; (40f088 <xProcessReceivedUDPPacket+0xd0>)
  40efd4:	4b2d      	ldr	r3, [pc, #180]	; (40f08c <xProcessReceivedUDPPacket+0xd4>)
  40efd6:	4798      	blx	r3
configASSERT(pxNetworkBuffer->pucEthernetBuffer);
  40efd8:	687b      	ldr	r3, [r7, #4]
  40efda:	699b      	ldr	r3, [r3, #24]
  40efdc:	2b00      	cmp	r3, #0
  40efde:	d104      	bne.n	40efea <xProcessReceivedUDPPacket+0x32>
  40efe0:	22fe      	movs	r2, #254	; 0xfe
  40efe2:	4928      	ldr	r1, [pc, #160]	; (40f084 <xProcessReceivedUDPPacket+0xcc>)
  40efe4:	4828      	ldr	r0, [pc, #160]	; (40f088 <xProcessReceivedUDPPacket+0xd0>)
  40efe6:	4b29      	ldr	r3, [pc, #164]	; (40f08c <xProcessReceivedUDPPacket+0xd4>)
  40efe8:	4798      	blx	r3


UDPPacket_t *pxUDPPacket = (UDPPacket_t *) pxNetworkBuffer->pucEthernetBuffer;
  40efea:	687b      	ldr	r3, [r7, #4]
  40efec:	699b      	ldr	r3, [r3, #24]
  40efee:	613b      	str	r3, [r7, #16]

	/* Caller must check for minimum packet size. */
	pxSocket = pxUDPSocketLookup( usPort );
  40eff0:	887b      	ldrh	r3, [r7, #2]
  40eff2:	4618      	mov	r0, r3
  40eff4:	4b26      	ldr	r3, [pc, #152]	; (40f090 <xProcessReceivedUDPPacket+0xd8>)
  40eff6:	4798      	blx	r3
  40eff8:	60f8      	str	r0, [r7, #12]

	if( pxSocket )
  40effa:	68fb      	ldr	r3, [r7, #12]
  40effc:	2b00      	cmp	r3, #0
  40effe:	d039      	beq.n	40f074 <xProcessReceivedUDPPacket+0xbc>
	{

		/* When refreshing the ARP cache with received UDP packets we must be
		careful;  hundreds of broadcast messages may pass and if we're not
		handling them, no use to fill the ARP cache with those IP addresses. */
		vARPRefreshCacheEntry( &( pxUDPPacket->xEthernetHeader.xSourceAddress ), pxUDPPacket->xIPHeader.ulSourceIPAddress );
  40f000:	693b      	ldr	r3, [r7, #16]
  40f002:	1d9a      	adds	r2, r3, #6
  40f004:	693b      	ldr	r3, [r7, #16]
  40f006:	f8d3 301a 	ldr.w	r3, [r3, #26]
  40f00a:	4619      	mov	r1, r3
  40f00c:	4610      	mov	r0, r2
  40f00e:	4b21      	ldr	r3, [pc, #132]	; (40f094 <xProcessReceivedUDPPacket+0xdc>)
  40f010:	4798      	blx	r3
				}
			}
		}
		#endif

		if( xReturn == pdPASS )
  40f012:	697b      	ldr	r3, [r7, #20]
  40f014:	2b01      	cmp	r3, #1
  40f016:	d12f      	bne.n	40f078 <xProcessReceivedUDPPacket+0xc0>
		{
			vTaskSuspendAll();
  40f018:	4b1f      	ldr	r3, [pc, #124]	; (40f098 <xProcessReceivedUDPPacket+0xe0>)
  40f01a:	4798      	blx	r3
			{
				if( xReturn == pdPASS )
  40f01c:	697b      	ldr	r3, [r7, #20]
  40f01e:	2b01      	cmp	r3, #1
  40f020:	d10a      	bne.n	40f038 <xProcessReceivedUDPPacket+0x80>
				{
					taskENTER_CRITICAL();
  40f022:	4b1e      	ldr	r3, [pc, #120]	; (40f09c <xProcessReceivedUDPPacket+0xe4>)
  40f024:	4798      	blx	r3
					{
						/* Add the network packet to the list of packets to be
						processed by the socket. */
						vListInsertEnd( &( pxSocket->u.xUDP.xWaitingPacketsList ), &( pxNetworkBuffer->xBufferListItem ) );
  40f026:	68fb      	ldr	r3, [r7, #12]
  40f028:	3338      	adds	r3, #56	; 0x38
  40f02a:	687a      	ldr	r2, [r7, #4]
  40f02c:	4611      	mov	r1, r2
  40f02e:	4618      	mov	r0, r3
  40f030:	4b1b      	ldr	r3, [pc, #108]	; (40f0a0 <xProcessReceivedUDPPacket+0xe8>)
  40f032:	4798      	blx	r3
					}
					taskEXIT_CRITICAL();
  40f034:	4b1b      	ldr	r3, [pc, #108]	; (40f0a4 <xProcessReceivedUDPPacket+0xec>)
  40f036:	4798      	blx	r3
				}
			}
			xTaskResumeAll();
  40f038:	4b1b      	ldr	r3, [pc, #108]	; (40f0a8 <xProcessReceivedUDPPacket+0xf0>)
  40f03a:	4798      	blx	r3

			/* Set the socket's receive event */
			if( pxSocket->xEventGroup != NULL )
  40f03c:	68fb      	ldr	r3, [r7, #12]
  40f03e:	685b      	ldr	r3, [r3, #4]
  40f040:	2b00      	cmp	r3, #0
  40f042:	d005      	beq.n	40f050 <xProcessReceivedUDPPacket+0x98>
			{
				xEventGroupSetBits( pxSocket->xEventGroup, eSOCKET_RECEIVE );
  40f044:	68fb      	ldr	r3, [r7, #12]
  40f046:	685b      	ldr	r3, [r3, #4]
  40f048:	2101      	movs	r1, #1
  40f04a:	4618      	mov	r0, r3
  40f04c:	4b17      	ldr	r3, [pc, #92]	; (40f0ac <xProcessReceivedUDPPacket+0xf4>)
  40f04e:	4798      	blx	r3
			}

			#if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
			{
				if( ( pxSocket->pxSocketSet != NULL ) && ( ( pxSocket->xSelectBits & eSELECT_READ ) != 0 ) )
  40f050:	68fb      	ldr	r3, [r7, #12]
  40f052:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  40f054:	2b00      	cmp	r3, #0
  40f056:	d00f      	beq.n	40f078 <xProcessReceivedUDPPacket+0xc0>
  40f058:	68fb      	ldr	r3, [r7, #12]
  40f05a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  40f05c:	f003 0301 	and.w	r3, r3, #1
  40f060:	2b00      	cmp	r3, #0
  40f062:	d009      	beq.n	40f078 <xProcessReceivedUDPPacket+0xc0>
				{
					xEventGroupSetBits( pxSocket->pxSocketSet->xSelectGroup, eSELECT_READ );
  40f064:	68fb      	ldr	r3, [r7, #12]
  40f066:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  40f068:	681b      	ldr	r3, [r3, #0]
  40f06a:	2101      	movs	r1, #1
  40f06c:	4618      	mov	r0, r3
  40f06e:	4b0f      	ldr	r3, [pc, #60]	; (40f0ac <xProcessReceivedUDPPacket+0xf4>)
  40f070:	4798      	blx	r3
  40f072:	e001      	b.n	40f078 <xProcessReceivedUDPPacket+0xc0>
				xReturn = ( BaseType_t )ulNBNSHandlePacket( pxNetworkBuffer );
			}
			else
		#endif /* ipconfigUSE_NBNS */
		{
			xReturn = pdFAIL;
  40f074:	2300      	movs	r3, #0
  40f076:	617b      	str	r3, [r7, #20]
		}
	}

	return xReturn;
  40f078:	697b      	ldr	r3, [r7, #20]
}
  40f07a:	4618      	mov	r0, r3
  40f07c:	3718      	adds	r7, #24
  40f07e:	46bd      	mov	sp, r7
  40f080:	bd80      	pop	{r7, pc}
  40f082:	bf00      	nop
  40f084:	0041de38 	.word	0x0041de38
  40f088:	0041de90 	.word	0x0041de90
  40f08c:	00416c7d 	.word	0x00416c7d
  40f090:	004094d1 	.word	0x004094d1
  40f094:	00407159 	.word	0x00407159
  40f098:	0041267d 	.word	0x0041267d
  40f09c:	0041103d 	.word	0x0041103d
  40f0a0:	00410d3b 	.word	0x00410d3b
  40f0a4:	00411099 	.word	0x00411099
  40f0a8:	00412699 	.word	0x00412699
  40f0ac:	00410b0d 	.word	0x00410b0d

0040f0b0 <xNetworkBuffersInitialise>:
static SemaphoreHandle_t xNetworkBufferSemaphore = NULL;

/*-----------------------------------------------------------*/

BaseType_t xNetworkBuffersInitialise( void )
{
  40f0b0:	b580      	push	{r7, lr}
  40f0b2:	b082      	sub	sp, #8
  40f0b4:	af00      	add	r7, sp, #0
BaseType_t xReturn, x;

	/* Only initialise the buffers and their associated kernel objects if they
	have not been initialised before. */
	if( xNetworkBufferSemaphore == NULL )
  40f0b6:	4b32      	ldr	r3, [pc, #200]	; (40f180 <xNetworkBuffersInitialise+0xd0>)
  40f0b8:	681b      	ldr	r3, [r3, #0]
  40f0ba:	2b00      	cmp	r3, #0
  40f0bc:	d151      	bne.n	40f162 <xNetworkBuffersInitialise+0xb2>
	{
		xNetworkBufferSemaphore = xSemaphoreCreateCounting( ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS, ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS );
  40f0be:	213c      	movs	r1, #60	; 0x3c
  40f0c0:	203c      	movs	r0, #60	; 0x3c
  40f0c2:	4b30      	ldr	r3, [pc, #192]	; (40f184 <xNetworkBuffersInitialise+0xd4>)
  40f0c4:	4798      	blx	r3
  40f0c6:	4602      	mov	r2, r0
  40f0c8:	4b2d      	ldr	r3, [pc, #180]	; (40f180 <xNetworkBuffersInitialise+0xd0>)
  40f0ca:	601a      	str	r2, [r3, #0]
		configASSERT( xNetworkBufferSemaphore );
  40f0cc:	4b2c      	ldr	r3, [pc, #176]	; (40f180 <xNetworkBuffersInitialise+0xd0>)
  40f0ce:	681b      	ldr	r3, [r3, #0]
  40f0d0:	2b00      	cmp	r3, #0
  40f0d2:	d104      	bne.n	40f0de <xNetworkBuffersInitialise+0x2e>
  40f0d4:	2269      	movs	r2, #105	; 0x69
  40f0d6:	492c      	ldr	r1, [pc, #176]	; (40f188 <xNetworkBuffersInitialise+0xd8>)
  40f0d8:	482c      	ldr	r0, [pc, #176]	; (40f18c <xNetworkBuffersInitialise+0xdc>)
  40f0da:	4b2d      	ldr	r3, [pc, #180]	; (40f190 <xNetworkBuffersInitialise+0xe0>)
  40f0dc:	4798      	blx	r3

		if( xNetworkBufferSemaphore != NULL )
  40f0de:	4b28      	ldr	r3, [pc, #160]	; (40f180 <xNetworkBuffersInitialise+0xd0>)
  40f0e0:	681b      	ldr	r3, [r3, #0]
  40f0e2:	2b00      	cmp	r3, #0
  40f0e4:	d03d      	beq.n	40f162 <xNetworkBuffersInitialise+0xb2>
				vTraceSetQueueName( xNetworkEventQueue, "IPStackEvent" );
				vTraceSetQueueName( xNetworkBufferSemaphore, "NetworkBufferCount" );
			}
			#endif /*  ipconfigINCLUDE_EXAMPLE_FREERTOS_PLUS_TRACE_CALLS == 1 */

			vListInitialise( &xFreeBuffersList );
  40f0e6:	482b      	ldr	r0, [pc, #172]	; (40f194 <xNetworkBuffersInitialise+0xe4>)
  40f0e8:	4b2b      	ldr	r3, [pc, #172]	; (40f198 <xNetworkBuffersInitialise+0xe8>)
  40f0ea:	4798      	blx	r3

			/* Initialise all the network buffers.  No storage is allocated to
			the buffers yet. */
			for( x = 0; x < ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS; x++ )
  40f0ec:	2300      	movs	r3, #0
  40f0ee:	603b      	str	r3, [r7, #0]
  40f0f0:	e031      	b.n	40f156 <xNetworkBuffersInitialise+0xa6>
			{
				/* Initialise and set the owner of the buffer list items. */
				xNetworkBufferDescriptors[ x ].pucEthernetBuffer = NULL;
  40f0f2:	492a      	ldr	r1, [pc, #168]	; (40f19c <xNetworkBuffersInitialise+0xec>)
  40f0f4:	683a      	ldr	r2, [r7, #0]
  40f0f6:	4613      	mov	r3, r2
  40f0f8:	009b      	lsls	r3, r3, #2
  40f0fa:	4413      	add	r3, r2
  40f0fc:	00db      	lsls	r3, r3, #3
  40f0fe:	440b      	add	r3, r1
  40f100:	3318      	adds	r3, #24
  40f102:	2200      	movs	r2, #0
  40f104:	601a      	str	r2, [r3, #0]
				vListInitialiseItem( &( xNetworkBufferDescriptors[ x ].xBufferListItem ) );
  40f106:	683a      	ldr	r2, [r7, #0]
  40f108:	4613      	mov	r3, r2
  40f10a:	009b      	lsls	r3, r3, #2
  40f10c:	4413      	add	r3, r2
  40f10e:	00db      	lsls	r3, r3, #3
  40f110:	4a22      	ldr	r2, [pc, #136]	; (40f19c <xNetworkBuffersInitialise+0xec>)
  40f112:	4413      	add	r3, r2
  40f114:	4618      	mov	r0, r3
  40f116:	4b22      	ldr	r3, [pc, #136]	; (40f1a0 <xNetworkBuffersInitialise+0xf0>)
  40f118:	4798      	blx	r3
				listSET_LIST_ITEM_OWNER( &( xNetworkBufferDescriptors[ x ].xBufferListItem ), &xNetworkBufferDescriptors[ x ] );
  40f11a:	683a      	ldr	r2, [r7, #0]
  40f11c:	4613      	mov	r3, r2
  40f11e:	009b      	lsls	r3, r3, #2
  40f120:	4413      	add	r3, r2
  40f122:	00db      	lsls	r3, r3, #3
  40f124:	4a1d      	ldr	r2, [pc, #116]	; (40f19c <xNetworkBuffersInitialise+0xec>)
  40f126:	1899      	adds	r1, r3, r2
  40f128:	481c      	ldr	r0, [pc, #112]	; (40f19c <xNetworkBuffersInitialise+0xec>)
  40f12a:	683a      	ldr	r2, [r7, #0]
  40f12c:	4613      	mov	r3, r2
  40f12e:	009b      	lsls	r3, r3, #2
  40f130:	4413      	add	r3, r2
  40f132:	00db      	lsls	r3, r3, #3
  40f134:	4403      	add	r3, r0
  40f136:	330c      	adds	r3, #12
  40f138:	6019      	str	r1, [r3, #0]

				/* Currently, all buffers are available for use. */
				vListInsert( &xFreeBuffersList, &( xNetworkBufferDescriptors[ x ].xBufferListItem ) );
  40f13a:	683a      	ldr	r2, [r7, #0]
  40f13c:	4613      	mov	r3, r2
  40f13e:	009b      	lsls	r3, r3, #2
  40f140:	4413      	add	r3, r2
  40f142:	00db      	lsls	r3, r3, #3
  40f144:	4a15      	ldr	r2, [pc, #84]	; (40f19c <xNetworkBuffersInitialise+0xec>)
  40f146:	4413      	add	r3, r2
  40f148:	4619      	mov	r1, r3
  40f14a:	4812      	ldr	r0, [pc, #72]	; (40f194 <xNetworkBuffersInitialise+0xe4>)
  40f14c:	4b15      	ldr	r3, [pc, #84]	; (40f1a4 <xNetworkBuffersInitialise+0xf4>)
  40f14e:	4798      	blx	r3
			for( x = 0; x < ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS; x++ )
  40f150:	683b      	ldr	r3, [r7, #0]
  40f152:	3301      	adds	r3, #1
  40f154:	603b      	str	r3, [r7, #0]
  40f156:	683b      	ldr	r3, [r7, #0]
  40f158:	2b3b      	cmp	r3, #59	; 0x3b
  40f15a:	ddca      	ble.n	40f0f2 <xNetworkBuffersInitialise+0x42>
			}

			uxMinimumFreeNetworkBuffers = ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS;
  40f15c:	4b12      	ldr	r3, [pc, #72]	; (40f1a8 <xNetworkBuffersInitialise+0xf8>)
  40f15e:	223c      	movs	r2, #60	; 0x3c
  40f160:	601a      	str	r2, [r3, #0]
		}
	}

	if( xNetworkBufferSemaphore == NULL )
  40f162:	4b07      	ldr	r3, [pc, #28]	; (40f180 <xNetworkBuffersInitialise+0xd0>)
  40f164:	681b      	ldr	r3, [r3, #0]
  40f166:	2b00      	cmp	r3, #0
  40f168:	d102      	bne.n	40f170 <xNetworkBuffersInitialise+0xc0>
	{
		xReturn = pdFAIL;
  40f16a:	2300      	movs	r3, #0
  40f16c:	607b      	str	r3, [r7, #4]
  40f16e:	e001      	b.n	40f174 <xNetworkBuffersInitialise+0xc4>
	}
	else
	{
		xReturn = pdPASS;
  40f170:	2301      	movs	r3, #1
  40f172:	607b      	str	r3, [r7, #4]
	}

	return xReturn;
  40f174:	687b      	ldr	r3, [r7, #4]
}
  40f176:	4618      	mov	r0, r3
  40f178:	3708      	adds	r7, #8
  40f17a:	46bd      	mov	sp, r7
  40f17c:	bd80      	pop	{r7, pc}
  40f17e:	bf00      	nop
  40f180:	200076dc 	.word	0x200076dc
  40f184:	004117cd 	.word	0x004117cd
  40f188:	0041dea4 	.word	0x0041dea4
  40f18c:	0041df1c 	.word	0x0041df1c
  40f190:	00416c7d 	.word	0x00416c7d
  40f194:	20006d64 	.word	0x20006d64
  40f198:	00410ce1 	.word	0x00410ce1
  40f19c:	20006d7c 	.word	0x20006d7c
  40f1a0:	00410d21 	.word	0x00410d21
  40f1a4:	00410d83 	.word	0x00410d83
  40f1a8:	20006d78 	.word	0x20006d78

0040f1ac <vReleaseNetworkBuffer>:
	return pucEthernetBuffer;
}
/*-----------------------------------------------------------*/

void vReleaseNetworkBuffer( uint8_t *pucEthernetBuffer )
{
  40f1ac:	b580      	push	{r7, lr}
  40f1ae:	b082      	sub	sp, #8
  40f1b0:	af00      	add	r7, sp, #0
  40f1b2:	6078      	str	r0, [r7, #4]
	/* There is space before the Ethernet buffer in which a pointer to the
	network buffer that references this Ethernet buffer is stored.  Remove the
	space before freeing the buffer. */
	if( pucEthernetBuffer != NULL )
  40f1b4:	687b      	ldr	r3, [r7, #4]
  40f1b6:	2b00      	cmp	r3, #0
  40f1b8:	d005      	beq.n	40f1c6 <vReleaseNetworkBuffer+0x1a>
	{
		pucEthernetBuffer -= ipBUFFER_PADDING;
  40f1ba:	687b      	ldr	r3, [r7, #4]
  40f1bc:	3b0a      	subs	r3, #10
  40f1be:	607b      	str	r3, [r7, #4]
		vPortFree( ( void * ) pucEthernetBuffer );
  40f1c0:	6878      	ldr	r0, [r7, #4]
  40f1c2:	4b03      	ldr	r3, [pc, #12]	; (40f1d0 <vReleaseNetworkBuffer+0x24>)
  40f1c4:	4798      	blx	r3
	}
}
  40f1c6:	bf00      	nop
  40f1c8:	3708      	adds	r7, #8
  40f1ca:	46bd      	mov	sp, r7
  40f1cc:	bd80      	pop	{r7, pc}
  40f1ce:	bf00      	nop
  40f1d0:	004113a1 	.word	0x004113a1

0040f1d4 <pxGetNetworkBufferWithDescriptor>:
/*-----------------------------------------------------------*/

NetworkBufferDescriptor_t *pxGetNetworkBufferWithDescriptor( size_t xRequestedSizeBytes, TickType_t xBlockTimeTicks )
{
  40f1d4:	b580      	push	{r7, lr}
  40f1d6:	b084      	sub	sp, #16
  40f1d8:	af00      	add	r7, sp, #0
  40f1da:	6078      	str	r0, [r7, #4]
  40f1dc:	6039      	str	r1, [r7, #0]
NetworkBufferDescriptor_t *pxReturn = NULL;
  40f1de:	2300      	movs	r3, #0
  40f1e0:	60fb      	str	r3, [r7, #12]
size_t uxCount;

	if( xNetworkBufferSemaphore != NULL )
  40f1e2:	4b36      	ldr	r3, [pc, #216]	; (40f2bc <pxGetNetworkBufferWithDescriptor+0xe8>)
  40f1e4:	681b      	ldr	r3, [r3, #0]
  40f1e6:	2b00      	cmp	r3, #0
  40f1e8:	d062      	beq.n	40f2b0 <pxGetNetworkBufferWithDescriptor+0xdc>
	{
		if( ( xRequestedSizeBytes != 0u ) && ( xRequestedSizeBytes < ( size_t ) baMINIMAL_BUFFER_SIZE ) )
  40f1ea:	687b      	ldr	r3, [r7, #4]
  40f1ec:	2b00      	cmp	r3, #0
  40f1ee:	d004      	beq.n	40f1fa <pxGetNetworkBufferWithDescriptor+0x26>
  40f1f0:	687b      	ldr	r3, [r7, #4]
  40f1f2:	2b45      	cmp	r3, #69	; 0x45
  40f1f4:	d801      	bhi.n	40f1fa <pxGetNetworkBufferWithDescriptor+0x26>
		{
			/* ARP packets can replace application packets, so the storage must be
			at least large enough to hold an ARP. */
			xRequestedSizeBytes = baMINIMAL_BUFFER_SIZE;
  40f1f6:	2346      	movs	r3, #70	; 0x46
  40f1f8:	607b      	str	r3, [r7, #4]
		}

		/* Add 2 bytes to xRequestedSizeBytes and round up xRequestedSizeBytes
		to the nearest multiple of N bytes, where N equals 'sizeof( size_t )'. */
		xRequestedSizeBytes += 2u;
  40f1fa:	687b      	ldr	r3, [r7, #4]
  40f1fc:	3302      	adds	r3, #2
  40f1fe:	607b      	str	r3, [r7, #4]
		if( ( xRequestedSizeBytes & ( sizeof( size_t ) - 1u ) ) != 0u )
  40f200:	687b      	ldr	r3, [r7, #4]
  40f202:	f003 0303 	and.w	r3, r3, #3
  40f206:	2b00      	cmp	r3, #0
  40f208:	d004      	beq.n	40f214 <pxGetNetworkBufferWithDescriptor+0x40>
		{
			xRequestedSizeBytes = ( xRequestedSizeBytes | ( sizeof( size_t ) - 1u ) ) + 1u;
  40f20a:	687b      	ldr	r3, [r7, #4]
  40f20c:	f043 0303 	orr.w	r3, r3, #3
  40f210:	3301      	adds	r3, #1
  40f212:	607b      	str	r3, [r7, #4]
		}

		/* If there is a semaphore available, there is a network buffer available. */
		if( xSemaphoreTake( xNetworkBufferSemaphore, xBlockTimeTicks ) == pdPASS )
  40f214:	4b29      	ldr	r3, [pc, #164]	; (40f2bc <pxGetNetworkBufferWithDescriptor+0xe8>)
  40f216:	681b      	ldr	r3, [r3, #0]
  40f218:	6839      	ldr	r1, [r7, #0]
  40f21a:	4618      	mov	r0, r3
  40f21c:	4b28      	ldr	r3, [pc, #160]	; (40f2c0 <pxGetNetworkBufferWithDescriptor+0xec>)
  40f21e:	4798      	blx	r3
  40f220:	4603      	mov	r3, r0
  40f222:	2b01      	cmp	r3, #1
  40f224:	d144      	bne.n	40f2b0 <pxGetNetworkBufferWithDescriptor+0xdc>
		{
			/* Protect the structure as it is accessed from tasks and interrupts. */
			taskENTER_CRITICAL();
  40f226:	4b27      	ldr	r3, [pc, #156]	; (40f2c4 <pxGetNetworkBufferWithDescriptor+0xf0>)
  40f228:	4798      	blx	r3
			{
				pxReturn = ( NetworkBufferDescriptor_t * ) listGET_OWNER_OF_HEAD_ENTRY( &xFreeBuffersList );
  40f22a:	4b27      	ldr	r3, [pc, #156]	; (40f2c8 <pxGetNetworkBufferWithDescriptor+0xf4>)
  40f22c:	68db      	ldr	r3, [r3, #12]
  40f22e:	68db      	ldr	r3, [r3, #12]
  40f230:	60fb      	str	r3, [r7, #12]
				uxListRemove( &( pxReturn->xBufferListItem ) );
  40f232:	68fb      	ldr	r3, [r7, #12]
  40f234:	4618      	mov	r0, r3
  40f236:	4b25      	ldr	r3, [pc, #148]	; (40f2cc <pxGetNetworkBufferWithDescriptor+0xf8>)
  40f238:	4798      	blx	r3
			}
			taskEXIT_CRITICAL();
  40f23a:	4b25      	ldr	r3, [pc, #148]	; (40f2d0 <pxGetNetworkBufferWithDescriptor+0xfc>)
  40f23c:	4798      	blx	r3

			/* Reading UBaseType_t, no critical section needed. */
			uxCount = listCURRENT_LIST_LENGTH( &xFreeBuffersList );
  40f23e:	4b22      	ldr	r3, [pc, #136]	; (40f2c8 <pxGetNetworkBufferWithDescriptor+0xf4>)
  40f240:	681b      	ldr	r3, [r3, #0]
  40f242:	60bb      	str	r3, [r7, #8]

			if( uxMinimumFreeNetworkBuffers > uxCount )
  40f244:	4b23      	ldr	r3, [pc, #140]	; (40f2d4 <pxGetNetworkBufferWithDescriptor+0x100>)
  40f246:	681a      	ldr	r2, [r3, #0]
  40f248:	68bb      	ldr	r3, [r7, #8]
  40f24a:	429a      	cmp	r2, r3
  40f24c:	d902      	bls.n	40f254 <pxGetNetworkBufferWithDescriptor+0x80>
			{
				uxMinimumFreeNetworkBuffers = uxCount;
  40f24e:	4a21      	ldr	r2, [pc, #132]	; (40f2d4 <pxGetNetworkBufferWithDescriptor+0x100>)
  40f250:	68bb      	ldr	r3, [r7, #8]
  40f252:	6013      	str	r3, [r2, #0]
			}

			/* Allocate storage of exactly the requested size to the buffer. */
			configASSERT( pxReturn->pucEthernetBuffer == NULL );
  40f254:	68fb      	ldr	r3, [r7, #12]
  40f256:	699b      	ldr	r3, [r3, #24]
  40f258:	2b00      	cmp	r3, #0
  40f25a:	d004      	beq.n	40f266 <pxGetNetworkBufferWithDescriptor+0x92>
  40f25c:	22fa      	movs	r2, #250	; 0xfa
  40f25e:	491e      	ldr	r1, [pc, #120]	; (40f2d8 <pxGetNetworkBufferWithDescriptor+0x104>)
  40f260:	481e      	ldr	r0, [pc, #120]	; (40f2dc <pxGetNetworkBufferWithDescriptor+0x108>)
  40f262:	4b1f      	ldr	r3, [pc, #124]	; (40f2e0 <pxGetNetworkBufferWithDescriptor+0x10c>)
  40f264:	4798      	blx	r3
			if( xRequestedSizeBytes > 0 )
  40f266:	687b      	ldr	r3, [r7, #4]
  40f268:	2b00      	cmp	r3, #0
  40f26a:	d021      	beq.n	40f2b0 <pxGetNetworkBufferWithDescriptor+0xdc>
			{
				/* Extra space is obtained so a pointer to the network buffer can
				be stored at the beginning of the buffer. */
				pxReturn->pucEthernetBuffer = ( uint8_t * ) pvPortMalloc( xRequestedSizeBytes + ipBUFFER_PADDING );
  40f26c:	687b      	ldr	r3, [r7, #4]
  40f26e:	330a      	adds	r3, #10
  40f270:	4618      	mov	r0, r3
  40f272:	4b1c      	ldr	r3, [pc, #112]	; (40f2e4 <pxGetNetworkBufferWithDescriptor+0x110>)
  40f274:	4798      	blx	r3
  40f276:	4602      	mov	r2, r0
  40f278:	68fb      	ldr	r3, [r7, #12]
  40f27a:	619a      	str	r2, [r3, #24]

				if( pxReturn->pucEthernetBuffer == NULL )
  40f27c:	68fb      	ldr	r3, [r7, #12]
  40f27e:	699b      	ldr	r3, [r3, #24]
  40f280:	2b00      	cmp	r3, #0
  40f282:	d105      	bne.n	40f290 <pxGetNetworkBufferWithDescriptor+0xbc>
				{
					/* The attempt to allocate storage for the buffer payload failed,
					so the network buffer structure cannot be used and must be
					released. */
					vReleaseNetworkBufferAndDescriptor( pxReturn );
  40f284:	68f8      	ldr	r0, [r7, #12]
  40f286:	4b18      	ldr	r3, [pc, #96]	; (40f2e8 <pxGetNetworkBufferWithDescriptor+0x114>)
  40f288:	4798      	blx	r3
					pxReturn = NULL;
  40f28a:	2300      	movs	r3, #0
  40f28c:	60fb      	str	r3, [r7, #12]
  40f28e:	e00f      	b.n	40f2b0 <pxGetNetworkBufferWithDescriptor+0xdc>
				{
					/* Store a pointer to the network buffer structure in the
					buffer storage area, then move the buffer pointer on past the
					stored pointer so the pointer value is not overwritten by the
					application when the buffer is used. */
					*( ( NetworkBufferDescriptor_t ** ) ( pxReturn->pucEthernetBuffer ) ) = pxReturn;
  40f290:	68fb      	ldr	r3, [r7, #12]
  40f292:	699b      	ldr	r3, [r3, #24]
  40f294:	68fa      	ldr	r2, [r7, #12]
  40f296:	601a      	str	r2, [r3, #0]
					pxReturn->pucEthernetBuffer += ipBUFFER_PADDING;
  40f298:	68fb      	ldr	r3, [r7, #12]
  40f29a:	699b      	ldr	r3, [r3, #24]
  40f29c:	f103 020a 	add.w	r2, r3, #10
  40f2a0:	68fb      	ldr	r3, [r7, #12]
  40f2a2:	619a      	str	r2, [r3, #24]

					/* Store the actual size of the allocated buffer, which may be
					greater than the original requested size. */
					pxReturn->xDataLength = xRequestedSizeBytes;
  40f2a4:	68fb      	ldr	r3, [r7, #12]
  40f2a6:	687a      	ldr	r2, [r7, #4]
  40f2a8:	61da      	str	r2, [r3, #28]

					#if( ipconfigUSE_LINKED_RX_MESSAGES != 0 )
					{
						/* make sure the buffer is not linked */
						pxReturn->pxNextBuffer = NULL;
  40f2aa:	68fb      	ldr	r3, [r7, #12]
  40f2ac:	2200      	movs	r2, #0
  40f2ae:	625a      	str	r2, [r3, #36]	; 0x24
	else
	{
		iptraceNETWORK_BUFFER_OBTAINED( pxReturn );
	}

	return pxReturn;
  40f2b0:	68fb      	ldr	r3, [r7, #12]
}
  40f2b2:	4618      	mov	r0, r3
  40f2b4:	3710      	adds	r7, #16
  40f2b6:	46bd      	mov	sp, r7
  40f2b8:	bd80      	pop	{r7, pc}
  40f2ba:	bf00      	nop
  40f2bc:	200076dc 	.word	0x200076dc
  40f2c0:	00411db1 	.word	0x00411db1
  40f2c4:	0041103d 	.word	0x0041103d
  40f2c8:	20006d64 	.word	0x20006d64
  40f2cc:	00410df5 	.word	0x00410df5
  40f2d0:	00411099 	.word	0x00411099
  40f2d4:	20006d78 	.word	0x20006d78
  40f2d8:	0041dea4 	.word	0x0041dea4
  40f2dc:	0041df1c 	.word	0x0041df1c
  40f2e0:	00416c7d 	.word	0x00416c7d
  40f2e4:	004111e5 	.word	0x004111e5
  40f2e8:	0040f2ed 	.word	0x0040f2ed

0040f2ec <vReleaseNetworkBufferAndDescriptor>:
/*-----------------------------------------------------------*/

void vReleaseNetworkBufferAndDescriptor( NetworkBufferDescriptor_t * const pxNetworkBuffer )
{
  40f2ec:	b590      	push	{r4, r7, lr}
  40f2ee:	b085      	sub	sp, #20
  40f2f0:	af00      	add	r7, sp, #0
  40f2f2:	6078      	str	r0, [r7, #4]
	/* Ensure the buffer is returned to the list of free buffers before the
	counting semaphore is 'given' to say a buffer is available.  Release the
	storage allocated to the buffer payload.  THIS FILE SHOULD NOT BE USED
	IF THE PROJECT INCLUDES A MEMORY ALLOCATOR THAT WILL FRAGMENT THE HEAP
	MEMORY.  For example, heap_2 must not be used, heap_4 can be used. */
	vReleaseNetworkBuffer( pxNetworkBuffer->pucEthernetBuffer );
  40f2f4:	687b      	ldr	r3, [r7, #4]
  40f2f6:	699b      	ldr	r3, [r3, #24]
  40f2f8:	4618      	mov	r0, r3
  40f2fa:	4b14      	ldr	r3, [pc, #80]	; (40f34c <vReleaseNetworkBufferAndDescriptor+0x60>)
  40f2fc:	4798      	blx	r3
	pxNetworkBuffer->pucEthernetBuffer = NULL;
  40f2fe:	687b      	ldr	r3, [r7, #4]
  40f300:	2200      	movs	r2, #0
  40f302:	619a      	str	r2, [r3, #24]

	taskENTER_CRITICAL();
  40f304:	4b12      	ldr	r3, [pc, #72]	; (40f350 <vReleaseNetworkBufferAndDescriptor+0x64>)
  40f306:	4798      	blx	r3
	{
		xListItemAlreadyInFreeList = listIS_CONTAINED_WITHIN( &xFreeBuffersList, &( pxNetworkBuffer->xBufferListItem ) );
  40f308:	687b      	ldr	r3, [r7, #4]
  40f30a:	691b      	ldr	r3, [r3, #16]
  40f30c:	4a11      	ldr	r2, [pc, #68]	; (40f354 <vReleaseNetworkBufferAndDescriptor+0x68>)
  40f30e:	4293      	cmp	r3, r2
  40f310:	d101      	bne.n	40f316 <vReleaseNetworkBufferAndDescriptor+0x2a>
  40f312:	2301      	movs	r3, #1
  40f314:	e000      	b.n	40f318 <vReleaseNetworkBufferAndDescriptor+0x2c>
  40f316:	2300      	movs	r3, #0
  40f318:	60fb      	str	r3, [r7, #12]

		if( xListItemAlreadyInFreeList == pdFALSE )
  40f31a:	68fb      	ldr	r3, [r7, #12]
  40f31c:	2b00      	cmp	r3, #0
  40f31e:	d104      	bne.n	40f32a <vReleaseNetworkBufferAndDescriptor+0x3e>
		{
			vListInsertEnd( &xFreeBuffersList, &( pxNetworkBuffer->xBufferListItem ) );
  40f320:	687b      	ldr	r3, [r7, #4]
  40f322:	4619      	mov	r1, r3
  40f324:	480b      	ldr	r0, [pc, #44]	; (40f354 <vReleaseNetworkBufferAndDescriptor+0x68>)
  40f326:	4b0c      	ldr	r3, [pc, #48]	; (40f358 <vReleaseNetworkBufferAndDescriptor+0x6c>)
  40f328:	4798      	blx	r3
		}
	}
	taskEXIT_CRITICAL();
  40f32a:	4b0c      	ldr	r3, [pc, #48]	; (40f35c <vReleaseNetworkBufferAndDescriptor+0x70>)
  40f32c:	4798      	blx	r3

	/*
	 * Update the network state machine, unless the program fails to release its 'xNetworkBufferSemaphore'.
	 * The program should only try to release its semaphore if 'xListItemAlreadyInFreeList' is false.
	 */
	if( xListItemAlreadyInFreeList == pdFALSE )
  40f32e:	68fb      	ldr	r3, [r7, #12]
  40f330:	2b00      	cmp	r3, #0
  40f332:	d106      	bne.n	40f342 <vReleaseNetworkBufferAndDescriptor+0x56>
	{
		if ( xSemaphoreGive( xNetworkBufferSemaphore ) == pdTRUE )
  40f334:	4b0a      	ldr	r3, [pc, #40]	; (40f360 <vReleaseNetworkBufferAndDescriptor+0x74>)
  40f336:	6818      	ldr	r0, [r3, #0]
  40f338:	2300      	movs	r3, #0
  40f33a:	2200      	movs	r2, #0
  40f33c:	2100      	movs	r1, #0
  40f33e:	4c09      	ldr	r4, [pc, #36]	; (40f364 <vReleaseNetworkBufferAndDescriptor+0x78>)
  40f340:	47a0      	blx	r4
	}
	else
	{
		iptraceNETWORK_BUFFER_RELEASED( pxNetworkBuffer );
	}
}
  40f342:	bf00      	nop
  40f344:	3714      	adds	r7, #20
  40f346:	46bd      	mov	sp, r7
  40f348:	bd90      	pop	{r4, r7, pc}
  40f34a:	bf00      	nop
  40f34c:	0040f1ad 	.word	0x0040f1ad
  40f350:	0041103d 	.word	0x0041103d
  40f354:	20006d64 	.word	0x20006d64
  40f358:	00410d3b 	.word	0x00410d3b
  40f35c:	00411099 	.word	0x00411099
  40f360:	200076dc 	.word	0x200076dc
  40f364:	00411831 	.word	0x00411831

0040f368 <uxGetNumberOfFreeNetworkBuffers>:

/*
 * Returns the number of free network buffers
 */
UBaseType_t uxGetNumberOfFreeNetworkBuffers( void )
{
  40f368:	b480      	push	{r7}
  40f36a:	af00      	add	r7, sp, #0
	return listCURRENT_LIST_LENGTH( &xFreeBuffersList );
  40f36c:	4b03      	ldr	r3, [pc, #12]	; (40f37c <uxGetNumberOfFreeNetworkBuffers+0x14>)
  40f36e:	681b      	ldr	r3, [r3, #0]
}
  40f370:	4618      	mov	r0, r3
  40f372:	46bd      	mov	sp, r7
  40f374:	f85d 7b04 	ldr.w	r7, [sp], #4
  40f378:	4770      	bx	lr
  40f37a:	bf00      	nop
  40f37c:	20006d64 	.word	0x20006d64

0040f380 <uxGetMinimumFreeNetworkBuffers>:
/*-----------------------------------------------------------*/

UBaseType_t uxGetMinimumFreeNetworkBuffers( void )
{
  40f380:	b480      	push	{r7}
  40f382:	af00      	add	r7, sp, #0
	return uxMinimumFreeNetworkBuffers;
  40f384:	4b03      	ldr	r3, [pc, #12]	; (40f394 <uxGetMinimumFreeNetworkBuffers+0x14>)
  40f386:	681b      	ldr	r3, [r3, #0]
}
  40f388:	4618      	mov	r0, r3
  40f38a:	46bd      	mov	sp, r7
  40f38c:	f85d 7b04 	ldr.w	r7, [sp], #4
  40f390:	4770      	bx	lr
  40f392:	bf00      	nop
  40f394:	20006d78 	.word	0x20006d78

0040f398 <gmac_network_control>:
{
  40f398:	b480      	push	{r7}
  40f39a:	b083      	sub	sp, #12
  40f39c:	af00      	add	r7, sp, #0
  40f39e:	6078      	str	r0, [r7, #4]
  40f3a0:	6039      	str	r1, [r7, #0]
	p_gmac->GMAC_NCR = ul_ncr;
  40f3a2:	687b      	ldr	r3, [r7, #4]
  40f3a4:	683a      	ldr	r2, [r7, #0]
  40f3a6:	601a      	str	r2, [r3, #0]
}
  40f3a8:	bf00      	nop
  40f3aa:	370c      	adds	r7, #12
  40f3ac:	46bd      	mov	sp, r7
  40f3ae:	f85d 7b04 	ldr.w	r7, [sp], #4
  40f3b2:	4770      	bx	lr

0040f3b4 <gmac_enable_receive>:
{
  40f3b4:	b480      	push	{r7}
  40f3b6:	b083      	sub	sp, #12
  40f3b8:	af00      	add	r7, sp, #0
  40f3ba:	6078      	str	r0, [r7, #4]
  40f3bc:	460b      	mov	r3, r1
  40f3be:	70fb      	strb	r3, [r7, #3]
	if (uc_enable) {
  40f3c0:	78fb      	ldrb	r3, [r7, #3]
  40f3c2:	2b00      	cmp	r3, #0
  40f3c4:	d006      	beq.n	40f3d4 <gmac_enable_receive+0x20>
		p_gmac->GMAC_NCR |= GMAC_NCR_RXEN;
  40f3c6:	687b      	ldr	r3, [r7, #4]
  40f3c8:	681b      	ldr	r3, [r3, #0]
  40f3ca:	f043 0204 	orr.w	r2, r3, #4
  40f3ce:	687b      	ldr	r3, [r7, #4]
  40f3d0:	601a      	str	r2, [r3, #0]
}
  40f3d2:	e005      	b.n	40f3e0 <gmac_enable_receive+0x2c>
		p_gmac->GMAC_NCR &= ~GMAC_NCR_RXEN;
  40f3d4:	687b      	ldr	r3, [r7, #4]
  40f3d6:	681b      	ldr	r3, [r3, #0]
  40f3d8:	f023 0204 	bic.w	r2, r3, #4
  40f3dc:	687b      	ldr	r3, [r7, #4]
  40f3de:	601a      	str	r2, [r3, #0]
}
  40f3e0:	bf00      	nop
  40f3e2:	370c      	adds	r7, #12
  40f3e4:	46bd      	mov	sp, r7
  40f3e6:	f85d 7b04 	ldr.w	r7, [sp], #4
  40f3ea:	4770      	bx	lr

0040f3ec <gmac_enable_transmit>:
{
  40f3ec:	b480      	push	{r7}
  40f3ee:	b083      	sub	sp, #12
  40f3f0:	af00      	add	r7, sp, #0
  40f3f2:	6078      	str	r0, [r7, #4]
  40f3f4:	460b      	mov	r3, r1
  40f3f6:	70fb      	strb	r3, [r7, #3]
	if (uc_enable) {
  40f3f8:	78fb      	ldrb	r3, [r7, #3]
  40f3fa:	2b00      	cmp	r3, #0
  40f3fc:	d006      	beq.n	40f40c <gmac_enable_transmit+0x20>
		p_gmac->GMAC_NCR |= GMAC_NCR_TXEN;
  40f3fe:	687b      	ldr	r3, [r7, #4]
  40f400:	681b      	ldr	r3, [r3, #0]
  40f402:	f043 0208 	orr.w	r2, r3, #8
  40f406:	687b      	ldr	r3, [r7, #4]
  40f408:	601a      	str	r2, [r3, #0]
}
  40f40a:	e005      	b.n	40f418 <gmac_enable_transmit+0x2c>
		p_gmac->GMAC_NCR &= ~GMAC_NCR_TXEN;
  40f40c:	687b      	ldr	r3, [r7, #4]
  40f40e:	681b      	ldr	r3, [r3, #0]
  40f410:	f023 0208 	bic.w	r2, r3, #8
  40f414:	687b      	ldr	r3, [r7, #4]
  40f416:	601a      	str	r2, [r3, #0]
}
  40f418:	bf00      	nop
  40f41a:	370c      	adds	r7, #12
  40f41c:	46bd      	mov	sp, r7
  40f41e:	f85d 7b04 	ldr.w	r7, [sp], #4
  40f422:	4770      	bx	lr

0040f424 <gmac_clear_statistics>:
{
  40f424:	b480      	push	{r7}
  40f426:	b083      	sub	sp, #12
  40f428:	af00      	add	r7, sp, #0
  40f42a:	6078      	str	r0, [r7, #4]
	p_gmac->GMAC_NCR |= GMAC_NCR_CLRSTAT;
  40f42c:	687b      	ldr	r3, [r7, #4]
  40f42e:	681b      	ldr	r3, [r3, #0]
  40f430:	f043 0220 	orr.w	r2, r3, #32
  40f434:	687b      	ldr	r3, [r7, #4]
  40f436:	601a      	str	r2, [r3, #0]
}
  40f438:	bf00      	nop
  40f43a:	370c      	adds	r7, #12
  40f43c:	46bd      	mov	sp, r7
  40f43e:	f85d 7b04 	ldr.w	r7, [sp], #4
  40f442:	4770      	bx	lr

0040f444 <gmac_enable_statistics_write>:
{
  40f444:	b480      	push	{r7}
  40f446:	b083      	sub	sp, #12
  40f448:	af00      	add	r7, sp, #0
  40f44a:	6078      	str	r0, [r7, #4]
  40f44c:	460b      	mov	r3, r1
  40f44e:	70fb      	strb	r3, [r7, #3]
	if (uc_enable) {
  40f450:	78fb      	ldrb	r3, [r7, #3]
  40f452:	2b00      	cmp	r3, #0
  40f454:	d006      	beq.n	40f464 <gmac_enable_statistics_write+0x20>
		p_gmac->GMAC_NCR |= GMAC_NCR_WESTAT;
  40f456:	687b      	ldr	r3, [r7, #4]
  40f458:	681b      	ldr	r3, [r3, #0]
  40f45a:	f043 0280 	orr.w	r2, r3, #128	; 0x80
  40f45e:	687b      	ldr	r3, [r7, #4]
  40f460:	601a      	str	r2, [r3, #0]
}
  40f462:	e005      	b.n	40f470 <gmac_enable_statistics_write+0x2c>
		p_gmac->GMAC_NCR &= ~GMAC_NCR_WESTAT;
  40f464:	687b      	ldr	r3, [r7, #4]
  40f466:	681b      	ldr	r3, [r3, #0]
  40f468:	f023 0280 	bic.w	r2, r3, #128	; 0x80
  40f46c:	687b      	ldr	r3, [r7, #4]
  40f46e:	601a      	str	r2, [r3, #0]
}
  40f470:	bf00      	nop
  40f472:	370c      	adds	r7, #12
  40f474:	46bd      	mov	sp, r7
  40f476:	f85d 7b04 	ldr.w	r7, [sp], #4
  40f47a:	4770      	bx	lr

0040f47c <gmac_start_transmission>:
{
  40f47c:	b480      	push	{r7}
  40f47e:	b083      	sub	sp, #12
  40f480:	af00      	add	r7, sp, #0
  40f482:	6078      	str	r0, [r7, #4]
  __ASM volatile ("dsb");
  40f484:	f3bf 8f4f 	dsb	sy
	p_gmac->GMAC_NCR |= GMAC_NCR_TSTART;
  40f488:	687b      	ldr	r3, [r7, #4]
  40f48a:	681b      	ldr	r3, [r3, #0]
  40f48c:	f443 7200 	orr.w	r2, r3, #512	; 0x200
  40f490:	687b      	ldr	r3, [r7, #4]
  40f492:	601a      	str	r2, [r3, #0]
}
  40f494:	bf00      	nop
  40f496:	370c      	adds	r7, #12
  40f498:	46bd      	mov	sp, r7
  40f49a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40f49e:	4770      	bx	lr

0040f4a0 <gmac_set_config>:
{
  40f4a0:	b480      	push	{r7}
  40f4a2:	b083      	sub	sp, #12
  40f4a4:	af00      	add	r7, sp, #0
  40f4a6:	6078      	str	r0, [r7, #4]
  40f4a8:	6039      	str	r1, [r7, #0]
	p_gmac->GMAC_NCFGR = ul_cfg;
  40f4aa:	687b      	ldr	r3, [r7, #4]
  40f4ac:	683a      	ldr	r2, [r7, #0]
  40f4ae:	605a      	str	r2, [r3, #4]
}
  40f4b0:	bf00      	nop
  40f4b2:	370c      	adds	r7, #12
  40f4b4:	46bd      	mov	sp, r7
  40f4b6:	f85d 7b04 	ldr.w	r7, [sp], #4
  40f4ba:	4770      	bx	lr

0040f4bc <gmac_get_config>:
{
  40f4bc:	b480      	push	{r7}
  40f4be:	b083      	sub	sp, #12
  40f4c0:	af00      	add	r7, sp, #0
  40f4c2:	6078      	str	r0, [r7, #4]
	return p_gmac->GMAC_NCFGR;
  40f4c4:	687b      	ldr	r3, [r7, #4]
  40f4c6:	685b      	ldr	r3, [r3, #4]
}
  40f4c8:	4618      	mov	r0, r3
  40f4ca:	370c      	adds	r7, #12
  40f4cc:	46bd      	mov	sp, r7
  40f4ce:	f85d 7b04 	ldr.w	r7, [sp], #4
  40f4d2:	4770      	bx	lr

0040f4d4 <gmac_set_dma>:
{
  40f4d4:	b480      	push	{r7}
  40f4d6:	b083      	sub	sp, #12
  40f4d8:	af00      	add	r7, sp, #0
  40f4da:	6078      	str	r0, [r7, #4]
  40f4dc:	6039      	str	r1, [r7, #0]
	p_gmac->GMAC_DCFGR = ul_cfg;
  40f4de:	687b      	ldr	r3, [r7, #4]
  40f4e0:	683a      	ldr	r2, [r7, #0]
  40f4e2:	611a      	str	r2, [r3, #16]
}
  40f4e4:	bf00      	nop
  40f4e6:	370c      	adds	r7, #12
  40f4e8:	46bd      	mov	sp, r7
  40f4ea:	f85d 7b04 	ldr.w	r7, [sp], #4
  40f4ee:	4770      	bx	lr

0040f4f0 <gmac_get_dma>:
{
  40f4f0:	b480      	push	{r7}
  40f4f2:	b083      	sub	sp, #12
  40f4f4:	af00      	add	r7, sp, #0
  40f4f6:	6078      	str	r0, [r7, #4]
	return p_gmac->GMAC_DCFGR;
  40f4f8:	687b      	ldr	r3, [r7, #4]
  40f4fa:	691b      	ldr	r3, [r3, #16]
}
  40f4fc:	4618      	mov	r0, r3
  40f4fe:	370c      	adds	r7, #12
  40f500:	46bd      	mov	sp, r7
  40f502:	f85d 7b04 	ldr.w	r7, [sp], #4
  40f506:	4770      	bx	lr

0040f508 <gmac_enable_copy_all>:
{
  40f508:	b480      	push	{r7}
  40f50a:	b083      	sub	sp, #12
  40f50c:	af00      	add	r7, sp, #0
  40f50e:	6078      	str	r0, [r7, #4]
  40f510:	460b      	mov	r3, r1
  40f512:	70fb      	strb	r3, [r7, #3]
	if (uc_enable) {
  40f514:	78fb      	ldrb	r3, [r7, #3]
  40f516:	2b00      	cmp	r3, #0
  40f518:	d006      	beq.n	40f528 <gmac_enable_copy_all+0x20>
		p_gmac->GMAC_NCFGR |= GMAC_NCFGR_CAF;
  40f51a:	687b      	ldr	r3, [r7, #4]
  40f51c:	685b      	ldr	r3, [r3, #4]
  40f51e:	f043 0210 	orr.w	r2, r3, #16
  40f522:	687b      	ldr	r3, [r7, #4]
  40f524:	605a      	str	r2, [r3, #4]
}
  40f526:	e005      	b.n	40f534 <gmac_enable_copy_all+0x2c>
		p_gmac->GMAC_NCFGR &= ~GMAC_NCFGR_CAF;
  40f528:	687b      	ldr	r3, [r7, #4]
  40f52a:	685b      	ldr	r3, [r3, #4]
  40f52c:	f023 0210 	bic.w	r2, r3, #16
  40f530:	687b      	ldr	r3, [r7, #4]
  40f532:	605a      	str	r2, [r3, #4]
}
  40f534:	bf00      	nop
  40f536:	370c      	adds	r7, #12
  40f538:	46bd      	mov	sp, r7
  40f53a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40f53e:	4770      	bx	lr

0040f540 <gmac_disable_broadcast>:
{
  40f540:	b480      	push	{r7}
  40f542:	b083      	sub	sp, #12
  40f544:	af00      	add	r7, sp, #0
  40f546:	6078      	str	r0, [r7, #4]
  40f548:	460b      	mov	r3, r1
  40f54a:	70fb      	strb	r3, [r7, #3]
	if (uc_enable) {
  40f54c:	78fb      	ldrb	r3, [r7, #3]
  40f54e:	2b00      	cmp	r3, #0
  40f550:	d006      	beq.n	40f560 <gmac_disable_broadcast+0x20>
		p_gmac->GMAC_NCFGR |= GMAC_NCFGR_NBC;
  40f552:	687b      	ldr	r3, [r7, #4]
  40f554:	685b      	ldr	r3, [r3, #4]
  40f556:	f043 0220 	orr.w	r2, r3, #32
  40f55a:	687b      	ldr	r3, [r7, #4]
  40f55c:	605a      	str	r2, [r3, #4]
}
  40f55e:	e005      	b.n	40f56c <gmac_disable_broadcast+0x2c>
		p_gmac->GMAC_NCFGR &= ~GMAC_NCFGR_NBC;
  40f560:	687b      	ldr	r3, [r7, #4]
  40f562:	685b      	ldr	r3, [r3, #4]
  40f564:	f023 0220 	bic.w	r2, r3, #32
  40f568:	687b      	ldr	r3, [r7, #4]
  40f56a:	605a      	str	r2, [r3, #4]
}
  40f56c:	bf00      	nop
  40f56e:	370c      	adds	r7, #12
  40f570:	46bd      	mov	sp, r7
  40f572:	f85d 7b04 	ldr.w	r7, [sp], #4
  40f576:	4770      	bx	lr

0040f578 <gmac_get_tx_status>:
{
  40f578:	b480      	push	{r7}
  40f57a:	b083      	sub	sp, #12
  40f57c:	af00      	add	r7, sp, #0
  40f57e:	6078      	str	r0, [r7, #4]
	return p_gmac->GMAC_TSR;
  40f580:	687b      	ldr	r3, [r7, #4]
  40f582:	695b      	ldr	r3, [r3, #20]
}
  40f584:	4618      	mov	r0, r3
  40f586:	370c      	adds	r7, #12
  40f588:	46bd      	mov	sp, r7
  40f58a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40f58e:	4770      	bx	lr

0040f590 <gmac_clear_tx_status>:
{
  40f590:	b480      	push	{r7}
  40f592:	b083      	sub	sp, #12
  40f594:	af00      	add	r7, sp, #0
  40f596:	6078      	str	r0, [r7, #4]
  40f598:	6039      	str	r1, [r7, #0]
	p_gmac->GMAC_TSR = ul_status;
  40f59a:	687b      	ldr	r3, [r7, #4]
  40f59c:	683a      	ldr	r2, [r7, #0]
  40f59e:	615a      	str	r2, [r3, #20]
}
  40f5a0:	bf00      	nop
  40f5a2:	370c      	adds	r7, #12
  40f5a4:	46bd      	mov	sp, r7
  40f5a6:	f85d 7b04 	ldr.w	r7, [sp], #4
  40f5aa:	4770      	bx	lr

0040f5ac <gmac_get_rx_status>:
{
  40f5ac:	b480      	push	{r7}
  40f5ae:	b083      	sub	sp, #12
  40f5b0:	af00      	add	r7, sp, #0
  40f5b2:	6078      	str	r0, [r7, #4]
	return p_gmac->GMAC_RSR;
  40f5b4:	687b      	ldr	r3, [r7, #4]
  40f5b6:	6a1b      	ldr	r3, [r3, #32]
}
  40f5b8:	4618      	mov	r0, r3
  40f5ba:	370c      	adds	r7, #12
  40f5bc:	46bd      	mov	sp, r7
  40f5be:	f85d 7b04 	ldr.w	r7, [sp], #4
  40f5c2:	4770      	bx	lr

0040f5c4 <gmac_clear_rx_status>:
{
  40f5c4:	b480      	push	{r7}
  40f5c6:	b083      	sub	sp, #12
  40f5c8:	af00      	add	r7, sp, #0
  40f5ca:	6078      	str	r0, [r7, #4]
  40f5cc:	6039      	str	r1, [r7, #0]
	p_gmac->GMAC_RSR = ul_status;
  40f5ce:	687b      	ldr	r3, [r7, #4]
  40f5d0:	683a      	ldr	r2, [r7, #0]
  40f5d2:	621a      	str	r2, [r3, #32]
}
  40f5d4:	bf00      	nop
  40f5d6:	370c      	adds	r7, #12
  40f5d8:	46bd      	mov	sp, r7
  40f5da:	f85d 7b04 	ldr.w	r7, [sp], #4
  40f5de:	4770      	bx	lr

0040f5e0 <gmac_set_rx_queue>:
{
  40f5e0:	b480      	push	{r7}
  40f5e2:	b083      	sub	sp, #12
  40f5e4:	af00      	add	r7, sp, #0
  40f5e6:	6078      	str	r0, [r7, #4]
  40f5e8:	6039      	str	r1, [r7, #0]
	p_gmac->GMAC_RBQB = GMAC_RBQB_ADDR_Msk & ul_addr;
  40f5ea:	683b      	ldr	r3, [r7, #0]
  40f5ec:	f023 0203 	bic.w	r2, r3, #3
  40f5f0:	687b      	ldr	r3, [r7, #4]
  40f5f2:	619a      	str	r2, [r3, #24]
}
  40f5f4:	bf00      	nop
  40f5f6:	370c      	adds	r7, #12
  40f5f8:	46bd      	mov	sp, r7
  40f5fa:	f85d 7b04 	ldr.w	r7, [sp], #4
  40f5fe:	4770      	bx	lr

0040f600 <gmac_set_tx_queue>:
{
  40f600:	b480      	push	{r7}
  40f602:	b083      	sub	sp, #12
  40f604:	af00      	add	r7, sp, #0
  40f606:	6078      	str	r0, [r7, #4]
  40f608:	6039      	str	r1, [r7, #0]
	p_gmac->GMAC_TBQB = GMAC_TBQB_ADDR_Msk & ul_addr;
  40f60a:	683b      	ldr	r3, [r7, #0]
  40f60c:	f023 0203 	bic.w	r2, r3, #3
  40f610:	687b      	ldr	r3, [r7, #4]
  40f612:	61da      	str	r2, [r3, #28]
}
  40f614:	bf00      	nop
  40f616:	370c      	adds	r7, #12
  40f618:	46bd      	mov	sp, r7
  40f61a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40f61e:	4770      	bx	lr

0040f620 <gmac_enable_interrupt>:
{
  40f620:	b480      	push	{r7}
  40f622:	b083      	sub	sp, #12
  40f624:	af00      	add	r7, sp, #0
  40f626:	6078      	str	r0, [r7, #4]
  40f628:	6039      	str	r1, [r7, #0]
	p_gmac->GMAC_IER = ul_source;
  40f62a:	687b      	ldr	r3, [r7, #4]
  40f62c:	683a      	ldr	r2, [r7, #0]
  40f62e:	629a      	str	r2, [r3, #40]	; 0x28
}
  40f630:	bf00      	nop
  40f632:	370c      	adds	r7, #12
  40f634:	46bd      	mov	sp, r7
  40f636:	f85d 7b04 	ldr.w	r7, [sp], #4
  40f63a:	4770      	bx	lr

0040f63c <gmac_disable_interrupt>:
{
  40f63c:	b480      	push	{r7}
  40f63e:	b083      	sub	sp, #12
  40f640:	af00      	add	r7, sp, #0
  40f642:	6078      	str	r0, [r7, #4]
  40f644:	6039      	str	r1, [r7, #0]
	p_gmac->GMAC_IDR = ul_source;
  40f646:	687b      	ldr	r3, [r7, #4]
  40f648:	683a      	ldr	r2, [r7, #0]
  40f64a:	62da      	str	r2, [r3, #44]	; 0x2c
}
  40f64c:	bf00      	nop
  40f64e:	370c      	adds	r7, #12
  40f650:	46bd      	mov	sp, r7
  40f652:	f85d 7b04 	ldr.w	r7, [sp], #4
  40f656:	4770      	bx	lr

0040f658 <gmac_get_interrupt_status>:
{
  40f658:	b480      	push	{r7}
  40f65a:	b083      	sub	sp, #12
  40f65c:	af00      	add	r7, sp, #0
  40f65e:	6078      	str	r0, [r7, #4]
	return p_gmac->GMAC_ISR;
  40f660:	687b      	ldr	r3, [r7, #4]
  40f662:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
  40f664:	4618      	mov	r0, r3
  40f666:	370c      	adds	r7, #12
  40f668:	46bd      	mov	sp, r7
  40f66a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40f66e:	4770      	bx	lr

0040f670 <gmac_set_address>:
{
  40f670:	b480      	push	{r7}
  40f672:	b085      	sub	sp, #20
  40f674:	af00      	add	r7, sp, #0
  40f676:	60f8      	str	r0, [r7, #12]
  40f678:	460b      	mov	r3, r1
  40f67a:	607a      	str	r2, [r7, #4]
  40f67c:	72fb      	strb	r3, [r7, #11]
	p_gmac->GMAC_SA[uc_index].GMAC_SAB = (p_mac_addr[3] << 24)
  40f67e:	7afa      	ldrb	r2, [r7, #11]
  40f680:	687b      	ldr	r3, [r7, #4]
  40f682:	3303      	adds	r3, #3
  40f684:	781b      	ldrb	r3, [r3, #0]
  40f686:	0619      	lsls	r1, r3, #24
			| (p_mac_addr[2] << 16)
  40f688:	687b      	ldr	r3, [r7, #4]
  40f68a:	3302      	adds	r3, #2
  40f68c:	781b      	ldrb	r3, [r3, #0]
  40f68e:	041b      	lsls	r3, r3, #16
  40f690:	4319      	orrs	r1, r3
			| (p_mac_addr[1] << 8)
  40f692:	687b      	ldr	r3, [r7, #4]
  40f694:	3301      	adds	r3, #1
  40f696:	781b      	ldrb	r3, [r3, #0]
  40f698:	021b      	lsls	r3, r3, #8
  40f69a:	430b      	orrs	r3, r1
			| (p_mac_addr[0]);
  40f69c:	6879      	ldr	r1, [r7, #4]
  40f69e:	7809      	ldrb	r1, [r1, #0]
  40f6a0:	430b      	orrs	r3, r1
  40f6a2:	4619      	mov	r1, r3
	p_gmac->GMAC_SA[uc_index].GMAC_SAB = (p_mac_addr[3] << 24)
  40f6a4:	68fb      	ldr	r3, [r7, #12]
  40f6a6:	3211      	adds	r2, #17
  40f6a8:	f843 1032 	str.w	r1, [r3, r2, lsl #3]
	p_gmac->GMAC_SA[uc_index].GMAC_SAT = (p_mac_addr[5] << 8)
  40f6ac:	7afb      	ldrb	r3, [r7, #11]
  40f6ae:	687a      	ldr	r2, [r7, #4]
  40f6b0:	3205      	adds	r2, #5
  40f6b2:	7812      	ldrb	r2, [r2, #0]
  40f6b4:	0212      	lsls	r2, r2, #8
			| (p_mac_addr[4]);
  40f6b6:	6879      	ldr	r1, [r7, #4]
  40f6b8:	3104      	adds	r1, #4
  40f6ba:	7809      	ldrb	r1, [r1, #0]
  40f6bc:	430a      	orrs	r2, r1
  40f6be:	4611      	mov	r1, r2
	p_gmac->GMAC_SA[uc_index].GMAC_SAT = (p_mac_addr[5] << 8)
  40f6c0:	68fa      	ldr	r2, [r7, #12]
  40f6c2:	3311      	adds	r3, #17
  40f6c4:	00db      	lsls	r3, r3, #3
  40f6c6:	4413      	add	r3, r2
  40f6c8:	6059      	str	r1, [r3, #4]
}
  40f6ca:	bf00      	nop
  40f6cc:	3714      	adds	r7, #20
  40f6ce:	46bd      	mov	sp, r7
  40f6d0:	f85d 7b04 	ldr.w	r7, [sp], #4
  40f6d4:	4770      	bx	lr

0040f6d6 <circ_inc32>:
/** Clear circular buffer */
#define CIRC_CLEAR( head, tail )			do { ( head ) = 0; ( tail ) = 0; } while( 0 )

/** Increment head or tail */
static __inline void circ_inc32( int32_t *lHeadOrTail, uint32_t ulSize )
{
  40f6d6:	b480      	push	{r7}
  40f6d8:	b083      	sub	sp, #12
  40f6da:	af00      	add	r7, sp, #0
  40f6dc:	6078      	str	r0, [r7, #4]
  40f6de:	6039      	str	r1, [r7, #0]
	( *lHeadOrTail ) ++;
  40f6e0:	687b      	ldr	r3, [r7, #4]
  40f6e2:	681b      	ldr	r3, [r3, #0]
  40f6e4:	1c5a      	adds	r2, r3, #1
  40f6e6:	687b      	ldr	r3, [r7, #4]
  40f6e8:	601a      	str	r2, [r3, #0]
    if( ( *lHeadOrTail ) >= ( int32_t )ulSize )
  40f6ea:	687b      	ldr	r3, [r7, #4]
  40f6ec:	681a      	ldr	r2, [r3, #0]
  40f6ee:	683b      	ldr	r3, [r7, #0]
  40f6f0:	429a      	cmp	r2, r3
  40f6f2:	db02      	blt.n	40f6fa <circ_inc32+0x24>
	{
		( *lHeadOrTail ) = 0;
  40f6f4:	687b      	ldr	r3, [r7, #4]
  40f6f6:	2200      	movs	r2, #0
  40f6f8:	601a      	str	r2, [r3, #0]
	}
}
  40f6fa:	bf00      	nop
  40f6fc:	370c      	adds	r7, #12
  40f6fe:	46bd      	mov	sp, r7
  40f700:	f85d 7b04 	ldr.w	r7, [sp], #4
  40f704:	4770      	bx	lr
	...

0040f708 <gmac_reset_tx_mem>:
 *
 * \param p_dev Pointer to GMAC driver instance.
 *
 */
static void gmac_reset_tx_mem(gmac_device_t* p_dev)
{
  40f708:	b580      	push	{r7, lr}
  40f70a:	b088      	sub	sp, #32
  40f70c:	af00      	add	r7, sp, #0
  40f70e:	6078      	str	r0, [r7, #4]
	Gmac *p_hw = p_dev->p_hw;
  40f710:	687b      	ldr	r3, [r7, #4]
  40f712:	681b      	ldr	r3, [r3, #0]
  40f714:	61bb      	str	r3, [r7, #24]
	uint8_t *p_tx_buff = p_dev->p_tx_buffer;
  40f716:	687b      	ldr	r3, [r7, #4]
  40f718:	685b      	ldr	r3, [r3, #4]
  40f71a:	617b      	str	r3, [r7, #20]
	gmac_tx_descriptor_t *p_td = p_dev->p_tx_dscr;
  40f71c:	687b      	ldr	r3, [r7, #4]
  40f71e:	691b      	ldr	r3, [r3, #16]
  40f720:	613b      	str	r3, [r7, #16]

	uint32_t ul_index;
	uint32_t ul_address;

	/* Disable TX */
	gmac_enable_transmit(p_hw, 0);
  40f722:	2100      	movs	r1, #0
  40f724:	69b8      	ldr	r0, [r7, #24]
  40f726:	4b1e      	ldr	r3, [pc, #120]	; (40f7a0 <gmac_reset_tx_mem+0x98>)
  40f728:	4798      	blx	r3

	/* Set up the TX descriptors */
	CIRC_CLEAR(p_dev->l_tx_head, p_dev->l_tx_tail);
  40f72a:	687b      	ldr	r3, [r7, #4]
  40f72c:	2200      	movs	r2, #0
  40f72e:	629a      	str	r2, [r3, #40]	; 0x28
  40f730:	687b      	ldr	r3, [r7, #4]
  40f732:	2200      	movs	r2, #0
  40f734:	62da      	str	r2, [r3, #44]	; 0x2c
	for( ul_index = 0; ul_index < p_dev->ul_tx_list_size; ul_index++ )
  40f736:	2300      	movs	r3, #0
  40f738:	61fb      	str	r3, [r7, #28]
  40f73a:	e017      	b.n	40f76c <gmac_reset_tx_mem+0x64>
		{
			ul_address = (uint32_t) 0u;
		}
		#else
		{
			ul_address = (uint32_t) (&(p_tx_buff[ul_index * GMAC_TX_UNITSIZE]));
  40f73c:	69fb      	ldr	r3, [r7, #28]
  40f73e:	f240 52ee 	movw	r2, #1518	; 0x5ee
  40f742:	fb02 f303 	mul.w	r3, r2, r3
  40f746:	697a      	ldr	r2, [r7, #20]
  40f748:	4413      	add	r3, r2
  40f74a:	60fb      	str	r3, [r7, #12]
		}
		#endif /* ipconfigZERO_COPY_TX_DRIVER */
		p_td[ul_index].addr = ul_address;
  40f74c:	69fb      	ldr	r3, [r7, #28]
  40f74e:	00db      	lsls	r3, r3, #3
  40f750:	693a      	ldr	r2, [r7, #16]
  40f752:	4413      	add	r3, r2
  40f754:	68fa      	ldr	r2, [r7, #12]
  40f756:	601a      	str	r2, [r3, #0]
		p_td[ul_index].status.val = GMAC_TXD_USED;
  40f758:	69fb      	ldr	r3, [r7, #28]
  40f75a:	00db      	lsls	r3, r3, #3
  40f75c:	693a      	ldr	r2, [r7, #16]
  40f75e:	4413      	add	r3, r2
  40f760:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
  40f764:	605a      	str	r2, [r3, #4]
	for( ul_index = 0; ul_index < p_dev->ul_tx_list_size; ul_index++ )
  40f766:	69fb      	ldr	r3, [r7, #28]
  40f768:	3301      	adds	r3, #1
  40f76a:	61fb      	str	r3, [r7, #28]
  40f76c:	687b      	ldr	r3, [r7, #4]
  40f76e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
  40f770:	69fb      	ldr	r3, [r7, #28]
  40f772:	429a      	cmp	r2, r3
  40f774:	d8e2      	bhi.n	40f73c <gmac_reset_tx_mem+0x34>
	}
	p_td[p_dev->ul_tx_list_size - 1].status.val =
  40f776:	687b      	ldr	r3, [r7, #4]
  40f778:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  40f77a:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
  40f77e:	3b01      	subs	r3, #1
  40f780:	00db      	lsls	r3, r3, #3
  40f782:	693a      	ldr	r2, [r7, #16]
  40f784:	4413      	add	r3, r2
  40f786:	f04f 4240 	mov.w	r2, #3221225472	; 0xc0000000
  40f78a:	605a      	str	r2, [r3, #4]
			GMAC_TXD_USED | GMAC_TXD_WRAP;

	/* Set transmit buffer queue */
	gmac_set_tx_queue(p_hw, (uint32_t) p_td);
  40f78c:	693b      	ldr	r3, [r7, #16]
  40f78e:	4619      	mov	r1, r3
  40f790:	69b8      	ldr	r0, [r7, #24]
  40f792:	4b04      	ldr	r3, [pc, #16]	; (40f7a4 <gmac_reset_tx_mem+0x9c>)
  40f794:	4798      	blx	r3
}
  40f796:	bf00      	nop
  40f798:	3720      	adds	r7, #32
  40f79a:	46bd      	mov	sp, r7
  40f79c:	bd80      	pop	{r7, pc}
  40f79e:	bf00      	nop
  40f7a0:	0040f3ed 	.word	0x0040f3ed
  40f7a4:	0040f601 	.word	0x0040f601

0040f7a8 <gmac_reset_rx_mem>:
 * \brief Disable receiver, reset registers and descriptor list.
 *
 * \param p_drv Pointer to GMAC Driver instance.
 */
static void gmac_reset_rx_mem(gmac_device_t* p_dev)
{
  40f7a8:	b580      	push	{r7, lr}
  40f7aa:	b088      	sub	sp, #32
  40f7ac:	af00      	add	r7, sp, #0
  40f7ae:	6078      	str	r0, [r7, #4]
	Gmac *p_hw = p_dev->p_hw;
  40f7b0:	687b      	ldr	r3, [r7, #4]
  40f7b2:	681b      	ldr	r3, [r3, #0]
  40f7b4:	61bb      	str	r3, [r7, #24]
	uint8_t *p_rx_buff = p_dev->p_rx_buffer;
  40f7b6:	687b      	ldr	r3, [r7, #4]
  40f7b8:	689b      	ldr	r3, [r3, #8]
  40f7ba:	617b      	str	r3, [r7, #20]
	gmac_rx_descriptor_t *pRd = p_dev->p_rx_dscr;
  40f7bc:	687b      	ldr	r3, [r7, #4]
  40f7be:	68db      	ldr	r3, [r3, #12]
  40f7c0:	613b      	str	r3, [r7, #16]

	uint32_t ul_index;
	uint32_t ul_address;

	/* Disable RX */
	gmac_enable_receive(p_hw, 0);
  40f7c2:	2100      	movs	r1, #0
  40f7c4:	69b8      	ldr	r0, [r7, #24]
  40f7c6:	4b20      	ldr	r3, [pc, #128]	; (40f848 <gmac_reset_rx_mem+0xa0>)
  40f7c8:	4798      	blx	r3

	/* Set up the RX descriptors */
	p_dev->ul_rx_idx = 0;
  40f7ca:	687b      	ldr	r3, [r7, #4]
  40f7cc:	2200      	movs	r2, #0
  40f7ce:	621a      	str	r2, [r3, #32]
	for( ul_index = 0; ul_index < p_dev->ul_rx_list_size; ul_index++ )
  40f7d0:	2300      	movs	r3, #0
  40f7d2:	61fb      	str	r3, [r7, #28]
  40f7d4:	e015      	b.n	40f802 <gmac_reset_rx_mem+0x5a>
	{
		ul_address = (uint32_t) (&(p_rx_buff[ul_index * GMAC_RX_UNITSIZE]));
  40f7d6:	69fb      	ldr	r3, [r7, #28]
  40f7d8:	01db      	lsls	r3, r3, #7
  40f7da:	697a      	ldr	r2, [r7, #20]
  40f7dc:	4413      	add	r3, r2
  40f7de:	60fb      	str	r3, [r7, #12]
		pRd[ul_index].addr.val = ul_address & GMAC_RXD_ADDR_MASK;
  40f7e0:	69fb      	ldr	r3, [r7, #28]
  40f7e2:	00db      	lsls	r3, r3, #3
  40f7e4:	693a      	ldr	r2, [r7, #16]
  40f7e6:	4413      	add	r3, r2
  40f7e8:	68fa      	ldr	r2, [r7, #12]
  40f7ea:	f022 0203 	bic.w	r2, r2, #3
  40f7ee:	601a      	str	r2, [r3, #0]
		pRd[ul_index].status.val = 0;
  40f7f0:	69fb      	ldr	r3, [r7, #28]
  40f7f2:	00db      	lsls	r3, r3, #3
  40f7f4:	693a      	ldr	r2, [r7, #16]
  40f7f6:	4413      	add	r3, r2
  40f7f8:	2200      	movs	r2, #0
  40f7fa:	605a      	str	r2, [r3, #4]
	for( ul_index = 0; ul_index < p_dev->ul_rx_list_size; ul_index++ )
  40f7fc:	69fb      	ldr	r3, [r7, #28]
  40f7fe:	3301      	adds	r3, #1
  40f800:	61fb      	str	r3, [r7, #28]
  40f802:	687b      	ldr	r3, [r7, #4]
  40f804:	69da      	ldr	r2, [r3, #28]
  40f806:	69fb      	ldr	r3, [r7, #28]
  40f808:	429a      	cmp	r2, r3
  40f80a:	d8e4      	bhi.n	40f7d6 <gmac_reset_rx_mem+0x2e>
	}
	pRd[p_dev->ul_rx_list_size - 1].addr.val |= GMAC_RXD_WRAP;
  40f80c:	687b      	ldr	r3, [r7, #4]
  40f80e:	69db      	ldr	r3, [r3, #28]
  40f810:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
  40f814:	3b01      	subs	r3, #1
  40f816:	00db      	lsls	r3, r3, #3
  40f818:	693a      	ldr	r2, [r7, #16]
  40f81a:	441a      	add	r2, r3
  40f81c:	687b      	ldr	r3, [r7, #4]
  40f81e:	69db      	ldr	r3, [r3, #28]
  40f820:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
  40f824:	3b01      	subs	r3, #1
  40f826:	00db      	lsls	r3, r3, #3
  40f828:	6939      	ldr	r1, [r7, #16]
  40f82a:	440b      	add	r3, r1
  40f82c:	681b      	ldr	r3, [r3, #0]
  40f82e:	f043 0302 	orr.w	r3, r3, #2
  40f832:	6013      	str	r3, [r2, #0]

	/* Set receive buffer queue */
	gmac_set_rx_queue(p_hw, (uint32_t) pRd);
  40f834:	693b      	ldr	r3, [r7, #16]
  40f836:	4619      	mov	r1, r3
  40f838:	69b8      	ldr	r0, [r7, #24]
  40f83a:	4b04      	ldr	r3, [pc, #16]	; (40f84c <gmac_reset_rx_mem+0xa4>)
  40f83c:	4798      	blx	r3
}
  40f83e:	bf00      	nop
  40f840:	3720      	adds	r7, #32
  40f842:	46bd      	mov	sp, r7
  40f844:	bd80      	pop	{r7, pc}
  40f846:	bf00      	nop
  40f848:	0040f3b5 	.word	0x0040f3b5
  40f84c:	0040f5e1 	.word	0x0040f5e1

0040f850 <gmac_init_mem>:
		gmac_dev_mem_t* p_dev_mm
#if( GMAC_USES_TX_CALLBACK != 0 )
		, gmac_dev_tx_cb_t* p_tx_cb
#endif
		)
{
  40f850:	b580      	push	{r7, lr}
  40f852:	b084      	sub	sp, #16
  40f854:	af00      	add	r7, sp, #0
  40f856:	60f8      	str	r0, [r7, #12]
  40f858:	60b9      	str	r1, [r7, #8]
  40f85a:	607a      	str	r2, [r7, #4]
  40f85c:	603b      	str	r3, [r7, #0]
	if (p_dev_mm->us_rx_size <= 1 || p_dev_mm->us_tx_size <= 1
  40f85e:	687b      	ldr	r3, [r7, #4]
  40f860:	689b      	ldr	r3, [r3, #8]
  40f862:	2b01      	cmp	r3, #1
  40f864:	d906      	bls.n	40f874 <gmac_init_mem+0x24>
  40f866:	687b      	ldr	r3, [r7, #4]
  40f868:	695b      	ldr	r3, [r3, #20]
  40f86a:	2b01      	cmp	r3, #1
  40f86c:	d902      	bls.n	40f874 <gmac_init_mem+0x24>
#if( GMAC_USES_TX_CALLBACK != 0 )
		|| p_tx_cb == NULL
  40f86e:	683b      	ldr	r3, [r7, #0]
  40f870:	2b00      	cmp	r3, #0
  40f872:	d101      	bne.n	40f878 <gmac_init_mem+0x28>
#endif
		) {
		return GMAC_PARAM;
  40f874:	2306      	movs	r3, #6
  40f876:	e060      	b.n	40f93a <gmac_init_mem+0xea>
	}

	/* Assign RX buffers */
	if (((uint32_t) p_dev_mm->p_rx_buffer & 0x7)
  40f878:	687b      	ldr	r3, [r7, #4]
  40f87a:	681b      	ldr	r3, [r3, #0]
  40f87c:	f003 0307 	and.w	r3, r3, #7
  40f880:	2b00      	cmp	r3, #0
  40f882:	d105      	bne.n	40f890 <gmac_init_mem+0x40>
			|| ((uint32_t) p_dev_mm->p_rx_dscr & 0x7)) {
  40f884:	687b      	ldr	r3, [r7, #4]
  40f886:	685b      	ldr	r3, [r3, #4]
  40f888:	f003 0307 	and.w	r3, r3, #7
  40f88c:	2b00      	cmp	r3, #0
  40f88e:	d004      	beq.n	40f89a <gmac_init_mem+0x4a>
		p_dev_mm->us_rx_size--;
  40f890:	687b      	ldr	r3, [r7, #4]
  40f892:	689b      	ldr	r3, [r3, #8]
  40f894:	1e5a      	subs	r2, r3, #1
  40f896:	687b      	ldr	r3, [r7, #4]
  40f898:	609a      	str	r2, [r3, #8]
	}
	p_gmac_dev->p_rx_buffer =
			(uint8_t *) ((uint32_t) p_dev_mm->p_rx_buffer & 0xFFFFFFF8);
  40f89a:	687b      	ldr	r3, [r7, #4]
  40f89c:	681b      	ldr	r3, [r3, #0]
  40f89e:	f023 0307 	bic.w	r3, r3, #7
  40f8a2:	461a      	mov	r2, r3
	p_gmac_dev->p_rx_buffer =
  40f8a4:	68bb      	ldr	r3, [r7, #8]
  40f8a6:	609a      	str	r2, [r3, #8]
	p_gmac_dev->p_rx_dscr =
			(gmac_rx_descriptor_t *) ((uint32_t) p_dev_mm->p_rx_dscr
  40f8a8:	687b      	ldr	r3, [r7, #4]
  40f8aa:	685b      	ldr	r3, [r3, #4]
			& 0xFFFFFFF8);
  40f8ac:	f023 0307 	bic.w	r3, r3, #7
			(gmac_rx_descriptor_t *) ((uint32_t) p_dev_mm->p_rx_dscr
  40f8b0:	461a      	mov	r2, r3
	p_gmac_dev->p_rx_dscr =
  40f8b2:	68bb      	ldr	r3, [r7, #8]
  40f8b4:	60da      	str	r2, [r3, #12]
	p_gmac_dev->ul_rx_list_size = p_dev_mm->us_rx_size;
  40f8b6:	687b      	ldr	r3, [r7, #4]
  40f8b8:	689a      	ldr	r2, [r3, #8]
  40f8ba:	68bb      	ldr	r3, [r7, #8]
  40f8bc:	61da      	str	r2, [r3, #28]

	/* Assign TX buffers */
	if (((uint32_t) p_dev_mm->p_tx_buffer & 0x7)
  40f8be:	687b      	ldr	r3, [r7, #4]
  40f8c0:	68db      	ldr	r3, [r3, #12]
  40f8c2:	f003 0307 	and.w	r3, r3, #7
  40f8c6:	2b00      	cmp	r3, #0
  40f8c8:	d105      	bne.n	40f8d6 <gmac_init_mem+0x86>
			|| ((uint32_t) p_dev_mm->p_tx_dscr & 0x7)) {
  40f8ca:	687b      	ldr	r3, [r7, #4]
  40f8cc:	691b      	ldr	r3, [r3, #16]
  40f8ce:	f003 0307 	and.w	r3, r3, #7
  40f8d2:	2b00      	cmp	r3, #0
  40f8d4:	d004      	beq.n	40f8e0 <gmac_init_mem+0x90>
		p_dev_mm->us_tx_size--;
  40f8d6:	687b      	ldr	r3, [r7, #4]
  40f8d8:	695b      	ldr	r3, [r3, #20]
  40f8da:	1e5a      	subs	r2, r3, #1
  40f8dc:	687b      	ldr	r3, [r7, #4]
  40f8de:	615a      	str	r2, [r3, #20]
	}
	p_gmac_dev->p_tx_buffer =
			(uint8_t *) ((uint32_t) p_dev_mm->p_tx_buffer & 0xFFFFFFF8);
  40f8e0:	687b      	ldr	r3, [r7, #4]
  40f8e2:	68db      	ldr	r3, [r3, #12]
  40f8e4:	f023 0307 	bic.w	r3, r3, #7
  40f8e8:	461a      	mov	r2, r3
	p_gmac_dev->p_tx_buffer =
  40f8ea:	68bb      	ldr	r3, [r7, #8]
  40f8ec:	605a      	str	r2, [r3, #4]
	p_gmac_dev->p_tx_dscr =
			(gmac_tx_descriptor_t *) ((uint32_t) p_dev_mm->p_tx_dscr
  40f8ee:	687b      	ldr	r3, [r7, #4]
  40f8f0:	691b      	ldr	r3, [r3, #16]
			& 0xFFFFFFF8);
  40f8f2:	f023 0307 	bic.w	r3, r3, #7
			(gmac_tx_descriptor_t *) ((uint32_t) p_dev_mm->p_tx_dscr
  40f8f6:	461a      	mov	r2, r3
	p_gmac_dev->p_tx_dscr =
  40f8f8:	68bb      	ldr	r3, [r7, #8]
  40f8fa:	611a      	str	r2, [r3, #16]
	p_gmac_dev->ul_tx_list_size = p_dev_mm->us_tx_size;
  40f8fc:	687b      	ldr	r3, [r7, #4]
  40f8fe:	695a      	ldr	r2, [r3, #20]
  40f900:	68bb      	ldr	r3, [r7, #8]
  40f902:	625a      	str	r2, [r3, #36]	; 0x24
#if( GMAC_USES_TX_CALLBACK != 0 )
	p_gmac_dev->func_tx_cb_list = p_tx_cb;
  40f904:	68bb      	ldr	r3, [r7, #8]
  40f906:	683a      	ldr	r2, [r7, #0]
  40f908:	619a      	str	r2, [r3, #24]
#endif
	/* Reset TX & RX */
	gmac_reset_rx_mem(p_gmac_dev);
  40f90a:	68b8      	ldr	r0, [r7, #8]
  40f90c:	4b0d      	ldr	r3, [pc, #52]	; (40f944 <gmac_init_mem+0xf4>)
  40f90e:	4798      	blx	r3
	gmac_reset_tx_mem(p_gmac_dev);
  40f910:	68b8      	ldr	r0, [r7, #8]
  40f912:	4b0d      	ldr	r3, [pc, #52]	; (40f948 <gmac_init_mem+0xf8>)
  40f914:	4798      	blx	r3

	/* Enable Rx and Tx, plus the statistics register */
	gmac_enable_transmit(p_gmac, true);
  40f916:	2101      	movs	r1, #1
  40f918:	68f8      	ldr	r0, [r7, #12]
  40f91a:	4b0c      	ldr	r3, [pc, #48]	; (40f94c <gmac_init_mem+0xfc>)
  40f91c:	4798      	blx	r3
	gmac_enable_receive(p_gmac, true);
  40f91e:	2101      	movs	r1, #1
  40f920:	68f8      	ldr	r0, [r7, #12]
  40f922:	4b0b      	ldr	r3, [pc, #44]	; (40f950 <gmac_init_mem+0x100>)
  40f924:	4798      	blx	r3
	gmac_enable_statistics_write(p_gmac, true);
  40f926:	2101      	movs	r1, #1
  40f928:	68f8      	ldr	r0, [r7, #12]
  40f92a:	4b0a      	ldr	r3, [pc, #40]	; (40f954 <gmac_init_mem+0x104>)
  40f92c:	4798      	blx	r3

	/* Set up the interrupts for transmission and errors */
	gmac_enable_interrupt(p_gmac,
  40f92e:	f643 41f4 	movw	r1, #15604	; 0x3cf4
  40f932:	68f8      	ldr	r0, [r7, #12]
  40f934:	4b08      	ldr	r3, [pc, #32]	; (40f958 <gmac_init_mem+0x108>)
  40f936:	4798      	blx	r3
			GMAC_IER_ROVR  | /* Enable receive overrun interrupt. */
			GMAC_IER_HRESP | /* Enable Hresp not OK interrupt. */
			GMAC_IER_PFNZ  | /* Enable pause frame received interrupt. */
			GMAC_IER_PTZ);   /* Enable pause time zero interrupt. */

	return GMAC_OK;
  40f938:	2300      	movs	r3, #0
}
  40f93a:	4618      	mov	r0, r3
  40f93c:	3710      	adds	r7, #16
  40f93e:	46bd      	mov	sp, r7
  40f940:	bd80      	pop	{r7, pc}
  40f942:	bf00      	nop
  40f944:	0040f7a9 	.word	0x0040f7a9
  40f948:	0040f709 	.word	0x0040f709
  40f94c:	0040f3ed 	.word	0x0040f3ed
  40f950:	0040f3b5 	.word	0x0040f3b5
  40f954:	0040f445 	.word	0x0040f445
  40f958:	0040f621 	.word	0x0040f621

0040f95c <gmac_dev_init>:
 * \param p_gmac_dev Pointer to the GMAC device instance.
 * \param p_opt GMAC configure options.
 */
void gmac_dev_init(Gmac* p_gmac, gmac_device_t* p_gmac_dev,
		gmac_options_t* p_opt)
{
  40f95c:	b590      	push	{r4, r7, lr}
  40f95e:	b08b      	sub	sp, #44	; 0x2c
  40f960:	af00      	add	r7, sp, #0
  40f962:	60f8      	str	r0, [r7, #12]
  40f964:	60b9      	str	r1, [r7, #8]
  40f966:	607a      	str	r2, [r7, #4]
	gmac_dev_mem_t gmac_dev_mm;

	/* Disable TX & RX and more */
	gmac_network_control(p_gmac, 0);
  40f968:	2100      	movs	r1, #0
  40f96a:	68f8      	ldr	r0, [r7, #12]
  40f96c:	4b2c      	ldr	r3, [pc, #176]	; (40fa20 <gmac_dev_init+0xc4>)
  40f96e:	4798      	blx	r3
	gmac_disable_interrupt(p_gmac, ~0u);
  40f970:	f04f 31ff 	mov.w	r1, #4294967295
  40f974:	68f8      	ldr	r0, [r7, #12]
  40f976:	4b2b      	ldr	r3, [pc, #172]	; (40fa24 <gmac_dev_init+0xc8>)
  40f978:	4798      	blx	r3


	gmac_clear_statistics(p_gmac);
  40f97a:	68f8      	ldr	r0, [r7, #12]
  40f97c:	4b2a      	ldr	r3, [pc, #168]	; (40fa28 <gmac_dev_init+0xcc>)
  40f97e:	4798      	blx	r3

	/* Clear all status bits in the receive status register. */
	gmac_clear_rx_status(p_gmac, GMAC_RSR_RXOVR | GMAC_RSR_REC | GMAC_RSR_BNA);
  40f980:	2107      	movs	r1, #7
  40f982:	68f8      	ldr	r0, [r7, #12]
  40f984:	4b29      	ldr	r3, [pc, #164]	; (40fa2c <gmac_dev_init+0xd0>)
  40f986:	4798      	blx	r3

	/* Clear all status bits in the transmit status register */
	gmac_clear_tx_status(p_gmac, GMAC_TSR_UBR | GMAC_TSR_COL | GMAC_TSR_RLE
  40f988:	2177      	movs	r1, #119	; 0x77
  40f98a:	68f8      	ldr	r0, [r7, #12]
  40f98c:	4b28      	ldr	r3, [pc, #160]	; (40fa30 <gmac_dev_init+0xd4>)
  40f98e:	4798      	blx	r3
			| GMAC_TSR_TFC | GMAC_TSR_TXCOMP | GMAC_TSR_UND);

	/* Clear interrupts */
	gmac_get_interrupt_status(p_gmac);
  40f990:	68f8      	ldr	r0, [r7, #12]
  40f992:	4b28      	ldr	r3, [pc, #160]	; (40fa34 <gmac_dev_init+0xd8>)
  40f994:	4798      	blx	r3
#endif
	/* Enable the copy of data into the buffers
	   ignore broadcasts, and not copy FCS. */

	gmac_set_configure(p_gmac,
			( gmac_get_configure(p_gmac) & ~GMAC_NCFGR_RXBUFO_Msk ) |
  40f996:	68f8      	ldr	r0, [r7, #12]
  40f998:	4b27      	ldr	r3, [pc, #156]	; (40fa38 <gmac_dev_init+0xdc>)
  40f99a:	4798      	blx	r3
  40f99c:	4603      	mov	r3, r0
			GMAC_NCFGR_RFCS |   /*  Remove FCS, frame check sequence (last 4 bytes) */
			GMAC_NCFGR_PEN |    /* Pause Enable */
			GMAC_NCFGR_RXBUFO( ETHERNET_CONF_DATA_OFFSET ) |
  40f99e:	f023 7381 	bic.w	r3, r3, #16908288	; 0x1020000
  40f9a2:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
	gmac_set_configure(p_gmac,
  40f9a6:	f043 7381 	orr.w	r3, r3, #16908288	; 0x1020000
  40f9aa:	f443 4320 	orr.w	r3, r3, #40960	; 0xa000
  40f9ae:	4619      	mov	r1, r3
  40f9b0:	68f8      	ldr	r0, [r7, #12]
  40f9b2:	4b22      	ldr	r3, [pc, #136]	; (40fa3c <gmac_dev_init+0xe0>)
  40f9b4:	4798      	blx	r3
	 * but TX checksum offloading has NOT been implemented.
	 * http://community.atmel.com/forum/sam4e-gmac-transmit-checksum-offload-enablesolved
	 */

	gmac_set_dma(p_gmac,
			gmac_get_dma(p_gmac) | GMAC_DCFGR_TXCOEN );
  40f9b6:	68f8      	ldr	r0, [r7, #12]
  40f9b8:	4b21      	ldr	r3, [pc, #132]	; (40fa40 <gmac_dev_init+0xe4>)
  40f9ba:	4798      	blx	r3
  40f9bc:	4603      	mov	r3, r0
	gmac_set_dma(p_gmac,
  40f9be:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
  40f9c2:	4619      	mov	r1, r3
  40f9c4:	68f8      	ldr	r0, [r7, #12]
  40f9c6:	4b1f      	ldr	r3, [pc, #124]	; (40fa44 <gmac_dev_init+0xe8>)
  40f9c8:	4798      	blx	r3

	gmac_enable_copy_all(p_gmac, p_opt->uc_copy_all_frame);
  40f9ca:	687b      	ldr	r3, [r7, #4]
  40f9cc:	781b      	ldrb	r3, [r3, #0]
  40f9ce:	4619      	mov	r1, r3
  40f9d0:	68f8      	ldr	r0, [r7, #12]
  40f9d2:	4b1d      	ldr	r3, [pc, #116]	; (40fa48 <gmac_dev_init+0xec>)
  40f9d4:	4798      	blx	r3
	gmac_disable_broadcast(p_gmac, p_opt->uc_no_boardcast);
  40f9d6:	687b      	ldr	r3, [r7, #4]
  40f9d8:	785b      	ldrb	r3, [r3, #1]
  40f9da:	4619      	mov	r1, r3
  40f9dc:	68f8      	ldr	r0, [r7, #12]
  40f9de:	4b1b      	ldr	r3, [pc, #108]	; (40fa4c <gmac_dev_init+0xf0>)
  40f9e0:	4798      	blx	r3

	/* Fill in GMAC device memory management */
	gmac_dev_mm.p_rx_buffer = gs_uc_rx_buffer;
  40f9e2:	4b1b      	ldr	r3, [pc, #108]	; (40fa50 <gmac_dev_init+0xf4>)
  40f9e4:	613b      	str	r3, [r7, #16]
	gmac_dev_mm.p_rx_dscr = gs_rx_desc;
  40f9e6:	4b1b      	ldr	r3, [pc, #108]	; (40fa54 <gmac_dev_init+0xf8>)
  40f9e8:	617b      	str	r3, [r7, #20]
	gmac_dev_mm.us_rx_size = GMAC_RX_BUFFERS;
  40f9ea:	2318      	movs	r3, #24
  40f9ec:	61bb      	str	r3, [r7, #24]
	{
		gmac_dev_mm.p_tx_buffer = NULL;
	}
	#else
	{
		gmac_dev_mm.p_tx_buffer = gs_uc_tx_buffer;
  40f9ee:	4b1a      	ldr	r3, [pc, #104]	; (40fa58 <gmac_dev_init+0xfc>)
  40f9f0:	61fb      	str	r3, [r7, #28]
	}
	#endif
	gmac_dev_mm.p_tx_dscr = gs_tx_desc;
  40f9f2:	4b1a      	ldr	r3, [pc, #104]	; (40fa5c <gmac_dev_init+0x100>)
  40f9f4:	623b      	str	r3, [r7, #32]
	gmac_dev_mm.us_tx_size = GMAC_TX_BUFFERS;
  40f9f6:	2308      	movs	r3, #8
  40f9f8:	627b      	str	r3, [r7, #36]	; 0x24

	gmac_init_mem(p_gmac, p_gmac_dev, &gmac_dev_mm
  40f9fa:	f107 0210 	add.w	r2, r7, #16
  40f9fe:	4b18      	ldr	r3, [pc, #96]	; (40fa60 <gmac_dev_init+0x104>)
  40fa00:	68b9      	ldr	r1, [r7, #8]
  40fa02:	68f8      	ldr	r0, [r7, #12]
  40fa04:	4c17      	ldr	r4, [pc, #92]	; (40fa64 <gmac_dev_init+0x108>)
  40fa06:	47a0      	blx	r4
#if( GMAC_USES_TX_CALLBACK != 0 )
		, gs_tx_callback
#endif
		);

	gmac_set_address(p_gmac, 0, p_opt->uc_mac_addr);
  40fa08:	687b      	ldr	r3, [r7, #4]
  40fa0a:	3302      	adds	r3, #2
  40fa0c:	461a      	mov	r2, r3
  40fa0e:	2100      	movs	r1, #0
  40fa10:	68f8      	ldr	r0, [r7, #12]
  40fa12:	4b15      	ldr	r3, [pc, #84]	; (40fa68 <gmac_dev_init+0x10c>)
  40fa14:	4798      	blx	r3
}
  40fa16:	bf00      	nop
  40fa18:	372c      	adds	r7, #44	; 0x2c
  40fa1a:	46bd      	mov	sp, r7
  40fa1c:	bd90      	pop	{r4, r7, pc}
  40fa1e:	bf00      	nop
  40fa20:	0040f399 	.word	0x0040f399
  40fa24:	0040f63d 	.word	0x0040f63d
  40fa28:	0040f425 	.word	0x0040f425
  40fa2c:	0040f5c5 	.word	0x0040f5c5
  40fa30:	0040f591 	.word	0x0040f591
  40fa34:	0040f659 	.word	0x0040f659
  40fa38:	0040f4bd 	.word	0x0040f4bd
  40fa3c:	0040f4a1 	.word	0x0040f4a1
  40fa40:	0040f4f1 	.word	0x0040f4f1
  40fa44:	0040f4d5 	.word	0x0040f4d5
  40fa48:	0040f509 	.word	0x0040f509
  40fa4c:	0040f541 	.word	0x0040f541
  40fa50:	2000a770 	.word	0x2000a770
  40fa54:	20007740 	.word	0x20007740
  40fa58:	20007800 	.word	0x20007800
  40fa5c:	200076e0 	.word	0x200076e0
  40fa60:	20007720 	.word	0x20007720
  40fa64:	0040f851 	.word	0x0040f851
  40fa68:	0040f671 	.word	0x0040f671

0040fa6c <gmac_dev_poll>:
 * Returns > 0 if a complete frame is available
 * It also it cleans up incomplete older frames
 */

static uint32_t gmac_dev_poll(gmac_device_t* p_gmac_dev)
{
  40fa6c:	b580      	push	{r7, lr}
  40fa6e:	b086      	sub	sp, #24
  40fa70:	af00      	add	r7, sp, #0
  40fa72:	6078      	str	r0, [r7, #4]
	uint32_t ulReturn = 0;
  40fa74:	2300      	movs	r3, #0
  40fa76:	617b      	str	r3, [r7, #20]
	int32_t ulIndex = p_gmac_dev->ul_rx_idx;
  40fa78:	687b      	ldr	r3, [r7, #4]
  40fa7a:	6a1b      	ldr	r3, [r3, #32]
  40fa7c:	60fb      	str	r3, [r7, #12]
	gmac_rx_descriptor_t *pxHead = &p_gmac_dev->p_rx_dscr[ulIndex];
  40fa7e:	687b      	ldr	r3, [r7, #4]
  40fa80:	68da      	ldr	r2, [r3, #12]
  40fa82:	68fb      	ldr	r3, [r7, #12]
  40fa84:	00db      	lsls	r3, r3, #3
  40fa86:	4413      	add	r3, r2
  40fa88:	613b      	str	r3, [r7, #16]

	/* Discard any incomplete frames */
	while ((pxHead->addr.val & GMAC_RXD_OWNERSHIP) &&
  40fa8a:	e017      	b.n	40fabc <gmac_dev_poll+0x50>
			(pxHead->status.val & GMAC_RXD_SOF) == 0) {
		pxHead->addr.val &= ~(GMAC_RXD_OWNERSHIP);
  40fa8c:	693b      	ldr	r3, [r7, #16]
  40fa8e:	681b      	ldr	r3, [r3, #0]
  40fa90:	f023 0201 	bic.w	r2, r3, #1
  40fa94:	693b      	ldr	r3, [r7, #16]
  40fa96:	601a      	str	r2, [r3, #0]
		circ_inc32 (&ulIndex, p_gmac_dev->ul_rx_list_size);
  40fa98:	687b      	ldr	r3, [r7, #4]
  40fa9a:	69da      	ldr	r2, [r3, #28]
  40fa9c:	f107 030c 	add.w	r3, r7, #12
  40faa0:	4611      	mov	r1, r2
  40faa2:	4618      	mov	r0, r3
  40faa4:	4b38      	ldr	r3, [pc, #224]	; (40fb88 <gmac_dev_poll+0x11c>)
  40faa6:	4798      	blx	r3
		pxHead = &p_gmac_dev->p_rx_dscr[ulIndex];
  40faa8:	687b      	ldr	r3, [r7, #4]
  40faaa:	68da      	ldr	r2, [r3, #12]
  40faac:	68fb      	ldr	r3, [r7, #12]
  40faae:	00db      	lsls	r3, r3, #3
  40fab0:	4413      	add	r3, r2
  40fab2:	613b      	str	r3, [r7, #16]
		p_gmac_dev->ul_rx_idx = ulIndex;
  40fab4:	68fb      	ldr	r3, [r7, #12]
  40fab6:	461a      	mov	r2, r3
  40fab8:	687b      	ldr	r3, [r7, #4]
  40faba:	621a      	str	r2, [r3, #32]
	while ((pxHead->addr.val & GMAC_RXD_OWNERSHIP) &&
  40fabc:	693b      	ldr	r3, [r7, #16]
  40fabe:	681b      	ldr	r3, [r3, #0]
  40fac0:	f003 0301 	and.w	r3, r3, #1
  40fac4:	2b00      	cmp	r3, #0
  40fac6:	d052      	beq.n	40fb6e <gmac_dev_poll+0x102>
			(pxHead->status.val & GMAC_RXD_SOF) == 0) {
  40fac8:	693b      	ldr	r3, [r7, #16]
  40faca:	685b      	ldr	r3, [r3, #4]
  40facc:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
	while ((pxHead->addr.val & GMAC_RXD_OWNERSHIP) &&
  40fad0:	2b00      	cmp	r3, #0
  40fad2:	d0db      	beq.n	40fa8c <gmac_dev_poll+0x20>
			gmacStats.incompCount++;
		}
		#endif
	}

	while ((pxHead->addr.val & GMAC_RXD_OWNERSHIP) != 0) {
  40fad4:	e04b      	b.n	40fb6e <gmac_dev_poll+0x102>
		if ((pxHead->status.val & GMAC_RXD_EOF) != 0) {
  40fad6:	693b      	ldr	r3, [r7, #16]
  40fad8:	685b      	ldr	r3, [r3, #4]
  40fada:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
  40fade:	2b00      	cmp	r3, #0
  40fae0:	d006      	beq.n	40faf0 <gmac_dev_poll+0x84>
			/* Here a complete frame has been seen with SOF and EOF */
			ulReturn = pxHead->status.bm.b_len; // HICS: substitui len por b_len
  40fae2:	693b      	ldr	r3, [r7, #16]
  40fae4:	889b      	ldrh	r3, [r3, #4]
  40fae6:	f3c3 030c 	ubfx	r3, r3, #0, #13
  40faea:	b29b      	uxth	r3, r3
  40faec:	617b      	str	r3, [r7, #20]
			break;
  40faee:	e046      	b.n	40fb7e <gmac_dev_poll+0x112>
		}
		circ_inc32 (&ulIndex, p_gmac_dev->ul_rx_list_size);
  40faf0:	687b      	ldr	r3, [r7, #4]
  40faf2:	69da      	ldr	r2, [r3, #28]
  40faf4:	f107 030c 	add.w	r3, r7, #12
  40faf8:	4611      	mov	r1, r2
  40fafa:	4618      	mov	r0, r3
  40fafc:	4b22      	ldr	r3, [pc, #136]	; (40fb88 <gmac_dev_poll+0x11c>)
  40fafe:	4798      	blx	r3
		pxHead = &p_gmac_dev->p_rx_dscr[ulIndex];
  40fb00:	687b      	ldr	r3, [r7, #4]
  40fb02:	68da      	ldr	r2, [r3, #12]
  40fb04:	68fb      	ldr	r3, [r7, #12]
  40fb06:	00db      	lsls	r3, r3, #3
  40fb08:	4413      	add	r3, r2
  40fb0a:	613b      	str	r3, [r7, #16]
		if ((pxHead->addr.val & GMAC_RXD_OWNERSHIP) == 0) {
  40fb0c:	693b      	ldr	r3, [r7, #16]
  40fb0e:	681b      	ldr	r3, [r3, #0]
  40fb10:	f003 0301 	and.w	r3, r3, #1
  40fb14:	2b00      	cmp	r3, #0
  40fb16:	d031      	beq.n	40fb7c <gmac_dev_poll+0x110>
			/* CPU is not the owner (yet) */
			break;
		}
		if ((pxHead->status.val & GMAC_RXD_SOF) != 0) {
  40fb18:	693b      	ldr	r3, [r7, #16]
  40fb1a:	685b      	ldr	r3, [r3, #4]
  40fb1c:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
  40fb20:	2b00      	cmp	r3, #0
  40fb22:	d024      	beq.n	40fb6e <gmac_dev_poll+0x102>
			/* Strange, we found a new Start Of Frame
			 * discard previous segments */
			int32_t ulPrev = p_gmac_dev->ul_rx_idx;
  40fb24:	687b      	ldr	r3, [r7, #4]
  40fb26:	6a1b      	ldr	r3, [r3, #32]
  40fb28:	60bb      	str	r3, [r7, #8]
			pxHead = &p_gmac_dev->p_rx_dscr[ulPrev];
  40fb2a:	687b      	ldr	r3, [r7, #4]
  40fb2c:	68da      	ldr	r2, [r3, #12]
  40fb2e:	68bb      	ldr	r3, [r7, #8]
  40fb30:	00db      	lsls	r3, r3, #3
  40fb32:	4413      	add	r3, r2
  40fb34:	613b      	str	r3, [r7, #16]
			do {
				pxHead->addr.val &= ~(GMAC_RXD_OWNERSHIP);
  40fb36:	693b      	ldr	r3, [r7, #16]
  40fb38:	681b      	ldr	r3, [r3, #0]
  40fb3a:	f023 0201 	bic.w	r2, r3, #1
  40fb3e:	693b      	ldr	r3, [r7, #16]
  40fb40:	601a      	str	r2, [r3, #0]
				circ_inc32 (&ulPrev, p_gmac_dev->ul_rx_list_size);
  40fb42:	687b      	ldr	r3, [r7, #4]
  40fb44:	69da      	ldr	r2, [r3, #28]
  40fb46:	f107 0308 	add.w	r3, r7, #8
  40fb4a:	4611      	mov	r1, r2
  40fb4c:	4618      	mov	r0, r3
  40fb4e:	4b0e      	ldr	r3, [pc, #56]	; (40fb88 <gmac_dev_poll+0x11c>)
  40fb50:	4798      	blx	r3
				pxHead = &p_gmac_dev->p_rx_dscr[ulPrev];
  40fb52:	687b      	ldr	r3, [r7, #4]
  40fb54:	68da      	ldr	r2, [r3, #12]
  40fb56:	68bb      	ldr	r3, [r7, #8]
  40fb58:	00db      	lsls	r3, r3, #3
  40fb5a:	4413      	add	r3, r2
  40fb5c:	613b      	str	r3, [r7, #16]
				#if( GMAC_STATS != 0 )
				{
					gmacStats.truncCount++;
				}
				#endif
			} while (ulPrev != ulIndex);
  40fb5e:	68ba      	ldr	r2, [r7, #8]
  40fb60:	68fb      	ldr	r3, [r7, #12]
  40fb62:	429a      	cmp	r2, r3
  40fb64:	d1e7      	bne.n	40fb36 <gmac_dev_poll+0xca>
			p_gmac_dev->ul_rx_idx = ulIndex;
  40fb66:	68fb      	ldr	r3, [r7, #12]
  40fb68:	461a      	mov	r2, r3
  40fb6a:	687b      	ldr	r3, [r7, #4]
  40fb6c:	621a      	str	r2, [r3, #32]
	while ((pxHead->addr.val & GMAC_RXD_OWNERSHIP) != 0) {
  40fb6e:	693b      	ldr	r3, [r7, #16]
  40fb70:	681b      	ldr	r3, [r3, #0]
  40fb72:	f003 0301 	and.w	r3, r3, #1
  40fb76:	2b00      	cmp	r3, #0
  40fb78:	d1ad      	bne.n	40fad6 <gmac_dev_poll+0x6a>
  40fb7a:	e000      	b.n	40fb7e <gmac_dev_poll+0x112>
			break;
  40fb7c:	bf00      	nop
		}
	}
	return ulReturn;
  40fb7e:	697b      	ldr	r3, [r7, #20]
}
  40fb80:	4618      	mov	r0, r3
  40fb82:	3718      	adds	r7, #24
  40fb84:	46bd      	mov	sp, r7
  40fb86:	bd80      	pop	{r7, pc}
  40fb88:	0040f6d7 	.word	0x0040f6d7

0040fb8c <gmac_dev_read>:
 *
 * \return GMAC_OK if receiving frame successfully, otherwise failed.
 */
uint32_t gmac_dev_read(gmac_device_t* p_gmac_dev, uint8_t* p_frame,
		uint32_t ul_frame_size, uint32_t* p_rcv_size)
{
  40fb8c:	b580      	push	{r7, lr}
  40fb8e:	b08a      	sub	sp, #40	; 0x28
  40fb90:	af00      	add	r7, sp, #0
  40fb92:	60f8      	str	r0, [r7, #12]
  40fb94:	60b9      	str	r1, [r7, #8]
  40fb96:	607a      	str	r2, [r7, #4]
  40fb98:	603b      	str	r3, [r7, #0]
	int32_t nextIdx;	/* A copy of the Rx-index 'ul_rx_idx' */
	int32_t bytesLeft = gmac_dev_poll (p_gmac_dev);
  40fb9a:	68f8      	ldr	r0, [r7, #12]
  40fb9c:	4b34      	ldr	r3, [pc, #208]	; (40fc70 <gmac_dev_read+0xe4>)
  40fb9e:	4798      	blx	r3
  40fba0:	4603      	mov	r3, r0
  40fba2:	623b      	str	r3, [r7, #32]
	gmac_rx_descriptor_t *pxHead;

	if (bytesLeft == 0 )
  40fba4:	6a3b      	ldr	r3, [r7, #32]
  40fba6:	2b00      	cmp	r3, #0
  40fba8:	d101      	bne.n	40fbae <gmac_dev_read+0x22>
	{
		return GMAC_RX_NO_DATA; // HICS substituido GMAC_RX_NULL por GMAC_RX_NO_DATA
  40fbaa:	2304      	movs	r3, #4
  40fbac:	e05b      	b.n	40fc66 <gmac_dev_read+0xda>
	}

	/* gmac_dev_poll has confirmed that there is a complete frame at
	 * the current position 'ul_rx_idx'
	 */
	nextIdx = p_gmac_dev->ul_rx_idx;
  40fbae:	68fb      	ldr	r3, [r7, #12]
  40fbb0:	6a1b      	ldr	r3, [r3, #32]
  40fbb2:	613b      	str	r3, [r7, #16]

	/* Read +2 bytes because buffers are aligned at -2 bytes */
	bytesLeft = min( bytesLeft + 2, ( int32_t )ul_frame_size );
  40fbb4:	6a3b      	ldr	r3, [r7, #32]
  40fbb6:	1c9a      	adds	r2, r3, #2
  40fbb8:	687b      	ldr	r3, [r7, #4]
  40fbba:	4293      	cmp	r3, r2
  40fbbc:	bfa8      	it	ge
  40fbbe:	4613      	movge	r3, r2
  40fbc0:	623b      	str	r3, [r7, #32]

	/* The frame will be copied in 1 or 2 memcpy's */
	if( ( p_frame != NULL ) && ( bytesLeft != 0 ) )
  40fbc2:	68bb      	ldr	r3, [r7, #8]
  40fbc4:	2b00      	cmp	r3, #0
  40fbc6:	d02c      	beq.n	40fc22 <gmac_dev_read+0x96>
  40fbc8:	6a3b      	ldr	r3, [r7, #32]
  40fbca:	2b00      	cmp	r3, #0
  40fbcc:	d029      	beq.n	40fc22 <gmac_dev_read+0x96>
	{
	const uint8_t *source;
	int32_t left;
	int32_t toCopy;

		source = p_gmac_dev->p_rx_buffer + nextIdx * GMAC_RX_UNITSIZE;
  40fbce:	68fb      	ldr	r3, [r7, #12]
  40fbd0:	689b      	ldr	r3, [r3, #8]
  40fbd2:	693a      	ldr	r2, [r7, #16]
  40fbd4:	01d2      	lsls	r2, r2, #7
  40fbd6:	4413      	add	r3, r2
  40fbd8:	61fb      	str	r3, [r7, #28]
		left = bytesLeft;
  40fbda:	6a3b      	ldr	r3, [r7, #32]
  40fbdc:	61bb      	str	r3, [r7, #24]
		toCopy = ( p_gmac_dev->ul_rx_list_size - nextIdx ) * GMAC_RX_UNITSIZE;
  40fbde:	68fb      	ldr	r3, [r7, #12]
  40fbe0:	69db      	ldr	r3, [r3, #28]
  40fbe2:	693a      	ldr	r2, [r7, #16]
  40fbe4:	1a9b      	subs	r3, r3, r2
  40fbe6:	01db      	lsls	r3, r3, #7
  40fbe8:	627b      	str	r3, [r7, #36]	; 0x24
		if(toCopy > left )
  40fbea:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  40fbec:	69bb      	ldr	r3, [r7, #24]
  40fbee:	429a      	cmp	r2, r3
  40fbf0:	dd01      	ble.n	40fbf6 <gmac_dev_read+0x6a>
		{
			toCopy = left;
  40fbf2:	69bb      	ldr	r3, [r7, #24]
  40fbf4:	627b      	str	r3, [r7, #36]	; 0x24
		}
		memcpy (p_frame, source, toCopy);
  40fbf6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40fbf8:	461a      	mov	r2, r3
  40fbfa:	69f9      	ldr	r1, [r7, #28]
  40fbfc:	68b8      	ldr	r0, [r7, #8]
  40fbfe:	4b1d      	ldr	r3, [pc, #116]	; (40fc74 <gmac_dev_read+0xe8>)
  40fc00:	4798      	blx	r3
		left -= toCopy;
  40fc02:	69ba      	ldr	r2, [r7, #24]
  40fc04:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40fc06:	1ad3      	subs	r3, r2, r3
  40fc08:	61bb      	str	r3, [r7, #24]

		if( left != 0ul )
  40fc0a:	69bb      	ldr	r3, [r7, #24]
  40fc0c:	2b00      	cmp	r3, #0
  40fc0e:	d008      	beq.n	40fc22 <gmac_dev_read+0x96>
		{
			memcpy (p_frame + toCopy, (void*)p_gmac_dev->p_rx_buffer, left);
  40fc10:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40fc12:	68ba      	ldr	r2, [r7, #8]
  40fc14:	18d0      	adds	r0, r2, r3
  40fc16:	68fb      	ldr	r3, [r7, #12]
  40fc18:	689b      	ldr	r3, [r3, #8]
  40fc1a:	69ba      	ldr	r2, [r7, #24]
  40fc1c:	4619      	mov	r1, r3
  40fc1e:	4b15      	ldr	r3, [pc, #84]	; (40fc74 <gmac_dev_read+0xe8>)
  40fc20:	4798      	blx	r3
		}
	}

	do
	{
		pxHead = &p_gmac_dev->p_rx_dscr[nextIdx];
  40fc22:	68fb      	ldr	r3, [r7, #12]
  40fc24:	68da      	ldr	r2, [r3, #12]
  40fc26:	693b      	ldr	r3, [r7, #16]
  40fc28:	00db      	lsls	r3, r3, #3
  40fc2a:	4413      	add	r3, r2
  40fc2c:	617b      	str	r3, [r7, #20]
		pxHead->addr.val &= ~(GMAC_RXD_OWNERSHIP);
  40fc2e:	697b      	ldr	r3, [r7, #20]
  40fc30:	681b      	ldr	r3, [r3, #0]
  40fc32:	f023 0201 	bic.w	r2, r3, #1
  40fc36:	697b      	ldr	r3, [r7, #20]
  40fc38:	601a      	str	r2, [r3, #0]
		circ_inc32 (&nextIdx, p_gmac_dev->ul_rx_list_size);
  40fc3a:	68fb      	ldr	r3, [r7, #12]
  40fc3c:	69da      	ldr	r2, [r3, #28]
  40fc3e:	f107 0310 	add.w	r3, r7, #16
  40fc42:	4611      	mov	r1, r2
  40fc44:	4618      	mov	r0, r3
  40fc46:	4b0c      	ldr	r3, [pc, #48]	; (40fc78 <gmac_dev_read+0xec>)
  40fc48:	4798      	blx	r3
	} while ((pxHead->status.val & GMAC_RXD_EOF) == 0);
  40fc4a:	697b      	ldr	r3, [r7, #20]
  40fc4c:	685b      	ldr	r3, [r3, #4]
  40fc4e:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
  40fc52:	2b00      	cmp	r3, #0
  40fc54:	d0e5      	beq.n	40fc22 <gmac_dev_read+0x96>

	p_gmac_dev->ul_rx_idx = nextIdx;
  40fc56:	693b      	ldr	r3, [r7, #16]
  40fc58:	461a      	mov	r2, r3
  40fc5a:	68fb      	ldr	r3, [r7, #12]
  40fc5c:	621a      	str	r2, [r3, #32]

	*p_rcv_size = bytesLeft;
  40fc5e:	6a3a      	ldr	r2, [r7, #32]
  40fc60:	683b      	ldr	r3, [r7, #0]
  40fc62:	601a      	str	r2, [r3, #0]

	return GMAC_OK;
  40fc64:	2300      	movs	r3, #0
}
  40fc66:	4618      	mov	r0, r3
  40fc68:	3728      	adds	r7, #40	; 0x28
  40fc6a:	46bd      	mov	sp, r7
  40fc6c:	bd80      	pop	{r7, pc}
  40fc6e:	bf00      	nop
  40fc70:	0040fa6d 	.word	0x0040fa6d
  40fc74:	00416d05 	.word	0x00416d05
  40fc78:	0040f6d7 	.word	0x0040f6d7

0040fc7c <gmac_dev_write>:
 *
 * \return Length sent.
 */
uint32_t gmac_dev_write(gmac_device_t* p_gmac_dev, void *p_buffer,
		uint32_t ul_size, gmac_dev_tx_cb_t func_tx_cb)
{
  40fc7c:	b580      	push	{r7, lr}
  40fc7e:	b088      	sub	sp, #32
  40fc80:	af00      	add	r7, sp, #0
  40fc82:	60f8      	str	r0, [r7, #12]
  40fc84:	60b9      	str	r1, [r7, #8]
  40fc86:	607a      	str	r2, [r7, #4]
  40fc88:	603b      	str	r3, [r7, #0]
	volatile gmac_tx_descriptor_t *p_tx_td;
#if( GMAC_USES_TX_CALLBACK != 0 )
	volatile gmac_dev_tx_cb_t *p_func_tx_cb;
#endif

	Gmac *p_hw = p_gmac_dev->p_hw;
  40fc8a:	68fb      	ldr	r3, [r7, #12]
  40fc8c:	681b      	ldr	r3, [r3, #0]
  40fc8e:	61fb      	str	r3, [r7, #28]
#if( GMAC_USES_TX_CALLBACK == 0 )
	( void )func_tx_cb;
#endif

	/* Check parameter */
	if (ul_size > GMAC_TX_UNITSIZE) {
  40fc90:	687b      	ldr	r3, [r7, #4]
  40fc92:	f240 52ee 	movw	r2, #1518	; 0x5ee
  40fc96:	4293      	cmp	r3, r2
  40fc98:	d901      	bls.n	40fc9e <gmac_dev_write+0x22>
		return GMAC_PARAM;
  40fc9a:	2306      	movs	r3, #6
  40fc9c:	e04a      	b.n	40fd34 <gmac_dev_write+0xb8>
	}

	/* Pointers to the current transmit descriptor */
	p_tx_td = &p_gmac_dev->p_tx_dscr[p_gmac_dev->l_tx_head];
  40fc9e:	68fb      	ldr	r3, [r7, #12]
  40fca0:	691a      	ldr	r2, [r3, #16]
  40fca2:	68fb      	ldr	r3, [r7, #12]
  40fca4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  40fca6:	00db      	lsls	r3, r3, #3
  40fca8:	4413      	add	r3, r2
  40fcaa:	61bb      	str	r3, [r7, #24]

	/* If no free TxTd, buffer can't be sent, schedule the wakeup callback */
//	if (CIRC_SPACE(p_gmac_dev->l_tx_head, p_gmac_dev->l_tx_tail,
//					p_gmac_dev->ul_tx_list_size) == 0)
	{
		if ((p_tx_td->status.val & GMAC_TXD_USED) == 0)
  40fcac:	69bb      	ldr	r3, [r7, #24]
  40fcae:	685b      	ldr	r3, [r3, #4]
  40fcb0:	2b00      	cmp	r3, #0
  40fcb2:	db01      	blt.n	40fcb8 <gmac_dev_write+0x3c>
			return GMAC_TX_BUSY;
  40fcb4:	2302      	movs	r3, #2
  40fcb6:	e03d      	b.n	40fd34 <gmac_dev_write+0xb8>
	}
#if( GMAC_USES_TX_CALLBACK != 0 )
	/* Pointers to the current Tx callback */
	p_func_tx_cb = &p_gmac_dev->func_tx_cb_list[p_gmac_dev->l_tx_head];
  40fcb8:	68fb      	ldr	r3, [r7, #12]
  40fcba:	699a      	ldr	r2, [r3, #24]
  40fcbc:	68fb      	ldr	r3, [r7, #12]
  40fcbe:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  40fcc0:	009b      	lsls	r3, r3, #2
  40fcc2:	4413      	add	r3, r2
  40fcc4:	617b      	str	r3, [r7, #20]
#endif

	/* Set up/copy data to transmission buffer */
	if (p_buffer && ul_size) {
  40fcc6:	68bb      	ldr	r3, [r7, #8]
  40fcc8:	2b00      	cmp	r3, #0
  40fcca:	d00f      	beq.n	40fcec <gmac_dev_write+0x70>
  40fccc:	687b      	ldr	r3, [r7, #4]
  40fcce:	2b00      	cmp	r3, #0
  40fcd0:	d00c      	beq.n	40fcec <gmac_dev_write+0x70>
			p_tx_td->addr = ( uint32_t ) p_buffer;
		}
		#else
		{
			/* Or memcopy... */
			memcpy((void *)p_tx_td->addr, p_buffer, ul_size);
  40fcd2:	69bb      	ldr	r3, [r7, #24]
  40fcd4:	681b      	ldr	r3, [r3, #0]
  40fcd6:	687a      	ldr	r2, [r7, #4]
  40fcd8:	68b9      	ldr	r1, [r7, #8]
  40fcda:	4618      	mov	r0, r3
  40fcdc:	4b17      	ldr	r3, [pc, #92]	; (40fd3c <gmac_dev_write+0xc0>)
  40fcde:	4798      	blx	r3
		}
		#endif /* ipconfigZERO_COPY_TX_DRIVER */
		//vGMACGenerateChecksum( ( uint8_t * ) p_tx_td->addr );
		vGMACGenerateChecksum( ( uint8_t * ) p_tx_td->addr, ul_size ); // HICS
  40fce0:	69bb      	ldr	r3, [r7, #24]
  40fce2:	681b      	ldr	r3, [r3, #0]
  40fce4:	6879      	ldr	r1, [r7, #4]
  40fce6:	4618      	mov	r0, r3
  40fce8:	4b15      	ldr	r3, [pc, #84]	; (40fd40 <gmac_dev_write+0xc4>)
  40fcea:	4798      	blx	r3
		
	}

#if( GMAC_USES_TX_CALLBACK != 0 )
	/* Tx callback */
	*p_func_tx_cb = func_tx_cb;
  40fcec:	697b      	ldr	r3, [r7, #20]
  40fcee:	683a      	ldr	r2, [r7, #0]
  40fcf0:	601a      	str	r2, [r3, #0]

	/* Update transmit descriptor status */

	/* The buffer size defined is the length of ethernet frame,
	   so it's always the last buffer of the frame. */
	if( p_gmac_dev->l_tx_head == ( int32_t )( p_gmac_dev->ul_tx_list_size - 1 ) )
  40fcf2:	68fb      	ldr	r3, [r7, #12]
  40fcf4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  40fcf6:	68fa      	ldr	r2, [r7, #12]
  40fcf8:	6a52      	ldr	r2, [r2, #36]	; 0x24
  40fcfa:	3a01      	subs	r2, #1
  40fcfc:	4293      	cmp	r3, r2
  40fcfe:	d107      	bne.n	40fd10 <gmac_dev_write+0x94>
	{
		/* No need to 'and' with GMAC_TXD_LEN_MASK because ul_size has been checked */
		p_tx_td->status.val =
			ul_size | GMAC_TXD_LAST | GMAC_TXD_WRAP;
  40fd00:	687b      	ldr	r3, [r7, #4]
  40fd02:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
  40fd06:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
		p_tx_td->status.val =
  40fd0a:	69ba      	ldr	r2, [r7, #24]
  40fd0c:	6053      	str	r3, [r2, #4]
  40fd0e:	e004      	b.n	40fd1a <gmac_dev_write+0x9e>
	} else {
		p_tx_td->status.val =
			ul_size | GMAC_TXD_LAST;
  40fd10:	687b      	ldr	r3, [r7, #4]
  40fd12:	f443 4200 	orr.w	r2, r3, #32768	; 0x8000
		p_tx_td->status.val =
  40fd16:	69bb      	ldr	r3, [r7, #24]
  40fd18:	605a      	str	r2, [r3, #4]
	}

	circ_inc32( &p_gmac_dev->l_tx_head, p_gmac_dev->ul_tx_list_size );
  40fd1a:	68fb      	ldr	r3, [r7, #12]
  40fd1c:	f103 0228 	add.w	r2, r3, #40	; 0x28
  40fd20:	68fb      	ldr	r3, [r7, #12]
  40fd22:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  40fd24:	4619      	mov	r1, r3
  40fd26:	4610      	mov	r0, r2
  40fd28:	4b06      	ldr	r3, [pc, #24]	; (40fd44 <gmac_dev_write+0xc8>)
  40fd2a:	4798      	blx	r3

	/* Now start to transmit if it is still not done */
	gmac_start_transmission(p_hw);
  40fd2c:	69f8      	ldr	r0, [r7, #28]
  40fd2e:	4b06      	ldr	r3, [pc, #24]	; (40fd48 <gmac_dev_write+0xcc>)
  40fd30:	4798      	blx	r3

	return GMAC_OK;
  40fd32:	2300      	movs	r3, #0
}
  40fd34:	4618      	mov	r0, r3
  40fd36:	3720      	adds	r7, #32
  40fd38:	46bd      	mov	sp, r7
  40fd3a:	bd80      	pop	{r7, pc}
  40fd3c:	00416d05 	.word	0x00416d05
  40fd40:	00410549 	.word	0x00410549
  40fd44:	0040f6d7 	.word	0x0040f6d7
  40fd48:	0040f47d 	.word	0x0040f47d

0040fd4c <gmac_dev_set_rx_callback>:
 * \param func_tx_cb  Receive callback function.
 */

void gmac_dev_set_rx_callback(gmac_device_t* p_gmac_dev,
		gmac_dev_rx_cb_t func_rx_cb)
{
  40fd4c:	b580      	push	{r7, lr}
  40fd4e:	b084      	sub	sp, #16
  40fd50:	af00      	add	r7, sp, #0
  40fd52:	6078      	str	r0, [r7, #4]
  40fd54:	6039      	str	r1, [r7, #0]
	Gmac *p_hw = p_gmac_dev->p_hw;
  40fd56:	687b      	ldr	r3, [r7, #4]
  40fd58:	681b      	ldr	r3, [r3, #0]
  40fd5a:	60fb      	str	r3, [r7, #12]

	if (func_rx_cb == NULL) {
  40fd5c:	683b      	ldr	r3, [r7, #0]
  40fd5e:	2b00      	cmp	r3, #0
  40fd60:	d107      	bne.n	40fd72 <gmac_dev_set_rx_callback+0x26>
		gmac_disable_interrupt(p_hw, GMAC_IDR_RCOMP);
  40fd62:	2102      	movs	r1, #2
  40fd64:	68f8      	ldr	r0, [r7, #12]
  40fd66:	4b08      	ldr	r3, [pc, #32]	; (40fd88 <gmac_dev_set_rx_callback+0x3c>)
  40fd68:	4798      	blx	r3
		p_gmac_dev->func_rx_cb = NULL;
  40fd6a:	687b      	ldr	r3, [r7, #4]
  40fd6c:	2200      	movs	r2, #0
  40fd6e:	615a      	str	r2, [r3, #20]
	} else {
		p_gmac_dev->func_rx_cb = func_rx_cb;
		gmac_enable_interrupt(p_hw, GMAC_IER_RCOMP);
	}
}
  40fd70:	e006      	b.n	40fd80 <gmac_dev_set_rx_callback+0x34>
		p_gmac_dev->func_rx_cb = func_rx_cb;
  40fd72:	687b      	ldr	r3, [r7, #4]
  40fd74:	683a      	ldr	r2, [r7, #0]
  40fd76:	615a      	str	r2, [r3, #20]
		gmac_enable_interrupt(p_hw, GMAC_IER_RCOMP);
  40fd78:	2102      	movs	r1, #2
  40fd7a:	68f8      	ldr	r0, [r7, #12]
  40fd7c:	4b03      	ldr	r3, [pc, #12]	; (40fd8c <gmac_dev_set_rx_callback+0x40>)
  40fd7e:	4798      	blx	r3
}
  40fd80:	bf00      	nop
  40fd82:	3710      	adds	r7, #16
  40fd84:	46bd      	mov	sp, r7
  40fd86:	bd80      	pop	{r7, pc}
  40fd88:	0040f63d 	.word	0x0040f63d
  40fd8c:	0040f621 	.word	0x0040f621

0040fd90 <gmac_handler>:
		}
	}
#endif

void gmac_handler(gmac_device_t* p_gmac_dev)
{
  40fd90:	b580      	push	{r7, lr}
  40fd92:	b08a      	sub	sp, #40	; 0x28
  40fd94:	af00      	add	r7, sp, #0
  40fd96:	6078      	str	r0, [r7, #4]
	Gmac *p_hw = p_gmac_dev->p_hw;
  40fd98:	687b      	ldr	r3, [r7, #4]
  40fd9a:	681b      	ldr	r3, [r3, #0]
  40fd9c:	61fb      	str	r3, [r7, #28]

#if( GMAC_USES_TX_CALLBACK != 0 )
	gmac_tx_descriptor_t *p_tx_td;
	gmac_dev_tx_cb_t *p_tx_cb = NULL;
  40fd9e:	2300      	movs	r3, #0
  40fda0:	627b      	str	r3, [r7, #36]	; 0x24

	/* volatile */ uint32_t ul_isr;
	/* volatile */ uint32_t ul_rsr;
	/* volatile */ uint32_t ul_tsr;

	ul_isr = gmac_get_interrupt_status(p_hw);
  40fda2:	69f8      	ldr	r0, [r7, #28]
  40fda4:	4b54      	ldr	r3, [pc, #336]	; (40fef8 <gmac_handler+0x168>)
  40fda6:	4798      	blx	r3
  40fda8:	61b8      	str	r0, [r7, #24]
	ul_rsr = gmac_get_rx_status(p_hw);
  40fdaa:	69f8      	ldr	r0, [r7, #28]
  40fdac:	4b53      	ldr	r3, [pc, #332]	; (40fefc <gmac_handler+0x16c>)
  40fdae:	4798      	blx	r3
  40fdb0:	6238      	str	r0, [r7, #32]
	ul_tsr = gmac_get_tx_status(p_hw);
  40fdb2:	69f8      	ldr	r0, [r7, #28]
  40fdb4:	4b52      	ldr	r3, [pc, #328]	; (40ff00 <gmac_handler+0x170>)
  40fdb6:	4798      	blx	r3
  40fdb8:	6178      	str	r0, [r7, #20]
		}
	}
	#endif /* GMAC_STATS != 0 */

	/* RX packet */
	if ((ul_isr & GMAC_ISR_RCOMP) || (ul_rsr & (GMAC_RSR_REC|GMAC_RSR_RXOVR|GMAC_RSR_BNA))) {
  40fdba:	69bb      	ldr	r3, [r7, #24]
  40fdbc:	f003 0302 	and.w	r3, r3, #2
  40fdc0:	2b00      	cmp	r3, #0
  40fdc2:	d104      	bne.n	40fdce <gmac_handler+0x3e>
  40fdc4:	6a3b      	ldr	r3, [r7, #32]
  40fdc6:	f003 0307 	and.w	r3, r3, #7
  40fdca:	2b00      	cmp	r3, #0
  40fdcc:	d014      	beq.n	40fdf8 <gmac_handler+0x68>
		/* Clear status */
		gmac_clear_rx_status(p_hw, ul_rsr);
  40fdce:	6a39      	ldr	r1, [r7, #32]
  40fdd0:	69f8      	ldr	r0, [r7, #28]
  40fdd2:	4b4c      	ldr	r3, [pc, #304]	; (40ff04 <gmac_handler+0x174>)
  40fdd4:	4798      	blx	r3

		if (ul_isr & GMAC_ISR_RCOMP)
  40fdd6:	69bb      	ldr	r3, [r7, #24]
  40fdd8:	f003 0302 	and.w	r3, r3, #2
  40fddc:	2b00      	cmp	r3, #0
  40fdde:	d003      	beq.n	40fde8 <gmac_handler+0x58>
			ul_rsr |= GMAC_RSR_REC;
  40fde0:	6a3b      	ldr	r3, [r7, #32]
  40fde2:	f043 0302 	orr.w	r3, r3, #2
  40fde6:	623b      	str	r3, [r7, #32]
		/* Invoke callbacks which can be useful to wake op a task */
		if (p_gmac_dev->func_rx_cb) {
  40fde8:	687b      	ldr	r3, [r7, #4]
  40fdea:	695b      	ldr	r3, [r3, #20]
  40fdec:	2b00      	cmp	r3, #0
  40fdee:	d003      	beq.n	40fdf8 <gmac_handler+0x68>
			p_gmac_dev->func_rx_cb(ul_rsr);
  40fdf0:	687b      	ldr	r3, [r7, #4]
  40fdf2:	695b      	ldr	r3, [r3, #20]
  40fdf4:	6a38      	ldr	r0, [r7, #32]
  40fdf6:	4798      	blx	r3
		}
	}

	/* TX packet */
	if ((ul_isr & GMAC_ISR_TCOMP) || (ul_tsr & (GMAC_TSR_TXCOMP|GMAC_TSR_COL|GMAC_TSR_RLE|GMAC_TSR_UND))) {
  40fdf8:	69bb      	ldr	r3, [r7, #24]
  40fdfa:	f003 0380 	and.w	r3, r3, #128	; 0x80
  40fdfe:	2b00      	cmp	r3, #0
  40fe00:	d104      	bne.n	40fe0c <gmac_handler+0x7c>
  40fe02:	697b      	ldr	r3, [r7, #20]
  40fe04:	f003 0366 	and.w	r3, r3, #102	; 0x66
  40fe08:	2b00      	cmp	r3, #0
  40fe0a:	d071      	beq.n	40fef0 <gmac_handler+0x160>

#if( GMAC_USES_TX_CALLBACK != 0 )
		ul_tx_status_flag = GMAC_TSR_TXCOMP;
  40fe0c:	2320      	movs	r3, #32
  40fe0e:	613b      	str	r3, [r7, #16]
#endif
		/* A frame transmitted */

		/* Check RLE */
		if (ul_tsr & GMAC_TSR_RLE) {
  40fe10:	697b      	ldr	r3, [r7, #20]
  40fe12:	f003 0304 	and.w	r3, r3, #4
  40fe16:	2b00      	cmp	r3, #0
  40fe18:	d01d      	beq.n	40fe56 <gmac_handler+0xc6>
			/* Status RLE & Number of discarded buffers */
#if( GMAC_USES_TX_CALLBACK != 0 )
			ul_tx_status_flag = GMAC_TSR_RLE | CIRC_CNT(p_gmac_dev->l_tx_head,
  40fe1a:	687b      	ldr	r3, [r7, #4]
  40fe1c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  40fe1e:	687b      	ldr	r3, [r7, #4]
  40fe20:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  40fe22:	1ad3      	subs	r3, r2, r3
  40fe24:	461a      	mov	r2, r3
  40fe26:	687b      	ldr	r3, [r7, #4]
  40fe28:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  40fe2a:	fbb2 f1f3 	udiv	r1, r2, r3
  40fe2e:	fb03 f301 	mul.w	r3, r3, r1
  40fe32:	1ad3      	subs	r3, r2, r3
  40fe34:	f043 0304 	orr.w	r3, r3, #4
  40fe38:	613b      	str	r3, [r7, #16]
					p_gmac_dev->l_tx_tail, p_gmac_dev->ul_tx_list_size);
			p_tx_cb = &p_gmac_dev->func_tx_cb_list[p_gmac_dev->l_tx_tail];
  40fe3a:	687b      	ldr	r3, [r7, #4]
  40fe3c:	699a      	ldr	r2, [r3, #24]
  40fe3e:	687b      	ldr	r3, [r7, #4]
  40fe40:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  40fe42:	009b      	lsls	r3, r3, #2
  40fe44:	4413      	add	r3, r2
  40fe46:	627b      	str	r3, [r7, #36]	; 0x24
#endif
			gmac_reset_tx_mem(p_gmac_dev);
  40fe48:	6878      	ldr	r0, [r7, #4]
  40fe4a:	4b2f      	ldr	r3, [pc, #188]	; (40ff08 <gmac_handler+0x178>)
  40fe4c:	4798      	blx	r3
			gmac_enable_transmit(p_hw, 1);
  40fe4e:	2101      	movs	r1, #1
  40fe50:	69f8      	ldr	r0, [r7, #28]
  40fe52:	4b2e      	ldr	r3, [pc, #184]	; (40ff0c <gmac_handler+0x17c>)
  40fe54:	4798      	blx	r3
		}
		/* Clear status */
		gmac_clear_tx_status(p_hw, ul_tsr);
  40fe56:	6979      	ldr	r1, [r7, #20]
  40fe58:	69f8      	ldr	r0, [r7, #28]
  40fe5a:	4b2d      	ldr	r3, [pc, #180]	; (40ff10 <gmac_handler+0x180>)
  40fe5c:	4798      	blx	r3

#if( GMAC_USES_TX_CALLBACK != 0 )
		if (!CIRC_EMPTY(p_gmac_dev->l_tx_head, p_gmac_dev->l_tx_tail)) {
  40fe5e:	687b      	ldr	r3, [r7, #4]
  40fe60:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  40fe62:	687b      	ldr	r3, [r7, #4]
  40fe64:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  40fe66:	429a      	cmp	r2, r3
  40fe68:	d035      	beq.n	40fed6 <gmac_handler+0x146>
			/* Check the buffers */
			do {
				p_tx_td = &p_gmac_dev->p_tx_dscr[p_gmac_dev->l_tx_tail];
  40fe6a:	687b      	ldr	r3, [r7, #4]
  40fe6c:	691a      	ldr	r2, [r3, #16]
  40fe6e:	687b      	ldr	r3, [r7, #4]
  40fe70:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  40fe72:	00db      	lsls	r3, r3, #3
  40fe74:	4413      	add	r3, r2
  40fe76:	60fb      	str	r3, [r7, #12]
				p_tx_cb = &p_gmac_dev->func_tx_cb_list[p_gmac_dev->l_tx_tail];
  40fe78:	687b      	ldr	r3, [r7, #4]
  40fe7a:	699a      	ldr	r2, [r3, #24]
  40fe7c:	687b      	ldr	r3, [r7, #4]
  40fe7e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  40fe80:	009b      	lsls	r3, r3, #2
  40fe82:	4413      	add	r3, r2
  40fe84:	627b      	str	r3, [r7, #36]	; 0x24
				/* Any error? Exit if buffer has not been sent yet */
				if ((p_tx_td->status.val & GMAC_TXD_USED) == 0) {
  40fe86:	68fb      	ldr	r3, [r7, #12]
  40fe88:	685b      	ldr	r3, [r3, #4]
  40fe8a:	2b00      	cmp	r3, #0
  40fe8c:	da22      	bge.n	40fed4 <gmac_handler+0x144>
					break;
				}

				/* Notify upper layer that a packet has been sent */
				if (*p_tx_cb) {
  40fe8e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40fe90:	681b      	ldr	r3, [r3, #0]
  40fe92:	2b00      	cmp	r3, #0
  40fe94:	d005      	beq.n	40fea2 <gmac_handler+0x112>
					//(*p_tx_cb) (ul_tx_status_flag, (void*)p_tx_td->addr);
					(*p_tx_cb) ((void*)p_tx_td->addr); // HICS: FIX PING TRAVANDO
  40fe96:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40fe98:	681b      	ldr	r3, [r3, #0]
  40fe9a:	68fa      	ldr	r2, [r7, #12]
  40fe9c:	6812      	ldr	r2, [r2, #0]
  40fe9e:	4610      	mov	r0, r2
  40fea0:	4798      	blx	r3
						p_tx_td->addr = 0ul;
					}
					#endif /* ipconfigZERO_COPY_TX_DRIVER */
				}

				circ_inc32(&p_gmac_dev->l_tx_tail, p_gmac_dev->ul_tx_list_size);
  40fea2:	687b      	ldr	r3, [r7, #4]
  40fea4:	f103 022c 	add.w	r2, r3, #44	; 0x2c
  40fea8:	687b      	ldr	r3, [r7, #4]
  40feaa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  40feac:	4619      	mov	r1, r3
  40feae:	4610      	mov	r0, r2
  40feb0:	4b18      	ldr	r3, [pc, #96]	; (40ff14 <gmac_handler+0x184>)
  40feb2:	4798      	blx	r3
			} while (CIRC_CNT(p_gmac_dev->l_tx_head, p_gmac_dev->l_tx_tail,
  40feb4:	687b      	ldr	r3, [r7, #4]
  40feb6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  40feb8:	687b      	ldr	r3, [r7, #4]
  40feba:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  40febc:	1ad3      	subs	r3, r2, r3
  40febe:	461a      	mov	r2, r3
  40fec0:	687b      	ldr	r3, [r7, #4]
  40fec2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  40fec4:	fbb2 f1f3 	udiv	r1, r2, r3
  40fec8:	fb03 f301 	mul.w	r3, r3, r1
  40fecc:	1ad3      	subs	r3, r2, r3
  40fece:	2b00      	cmp	r3, #0
  40fed0:	d1cb      	bne.n	40fe6a <gmac_handler+0xda>
  40fed2:	e000      	b.n	40fed6 <gmac_handler+0x146>
					break;
  40fed4:	bf00      	nop
							p_gmac_dev->ul_tx_list_size));
		}

		if (ul_tsr & GMAC_TSR_RLE) {
  40fed6:	697b      	ldr	r3, [r7, #20]
  40fed8:	f003 0304 	and.w	r3, r3, #4
  40fedc:	2b00      	cmp	r3, #0
  40fede:	d007      	beq.n	40fef0 <gmac_handler+0x160>
			/* Notify upper layer RLE */
			if (*p_tx_cb) {
  40fee0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40fee2:	681b      	ldr	r3, [r3, #0]
  40fee4:	2b00      	cmp	r3, #0
  40fee6:	d003      	beq.n	40fef0 <gmac_handler+0x160>
				//(*p_tx_cb) (ul_tx_status_flag, NULL);
				(*p_tx_cb) (NULL); // HICS: FIX PING TRAVANDO
  40fee8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40feea:	681b      	ldr	r3, [r3, #0]
  40feec:	2000      	movs	r0, #0
  40feee:	4798      	blx	r3
				&& p_gmac_dev->func_wakeup_cb) {
			p_gmac_dev->func_wakeup_cb();
		}
#endif
	}
}
  40fef0:	bf00      	nop
  40fef2:	3728      	adds	r7, #40	; 0x28
  40fef4:	46bd      	mov	sp, r7
  40fef6:	bd80      	pop	{r7, pc}
  40fef8:	0040f659 	.word	0x0040f659
  40fefc:	0040f5ad 	.word	0x0040f5ad
  40ff00:	0040f579 	.word	0x0040f579
  40ff04:	0040f5c5 	.word	0x0040f5c5
  40ff08:	0040f709 	.word	0x0040f709
  40ff0c:	0040f3ed 	.word	0x0040f3ed
  40ff10:	0040f591 	.word	0x0040f591
  40ff14:	0040f6d7 	.word	0x0040f6d7

0040ff18 <NVIC_EnableIRQ>:
    The function enables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  40ff18:	b480      	push	{r7}
  40ff1a:	b083      	sub	sp, #12
  40ff1c:	af00      	add	r7, sp, #0
  40ff1e:	4603      	mov	r3, r0
  40ff20:	71fb      	strb	r3, [r7, #7]
/*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
  40ff22:	4909      	ldr	r1, [pc, #36]	; (40ff48 <NVIC_EnableIRQ+0x30>)
  40ff24:	f997 3007 	ldrsb.w	r3, [r7, #7]
  40ff28:	095b      	lsrs	r3, r3, #5
  40ff2a:	79fa      	ldrb	r2, [r7, #7]
  40ff2c:	f002 021f 	and.w	r2, r2, #31
  40ff30:	2001      	movs	r0, #1
  40ff32:	fa00 f202 	lsl.w	r2, r0, r2
  40ff36:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
  40ff3a:	bf00      	nop
  40ff3c:	370c      	adds	r7, #12
  40ff3e:	46bd      	mov	sp, r7
  40ff40:	f85d 7b04 	ldr.w	r7, [sp], #4
  40ff44:	4770      	bx	lr
  40ff46:	bf00      	nop
  40ff48:	e000e100 	.word	0xe000e100

0040ff4c <NVIC_SetPriority>:

    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  40ff4c:	b480      	push	{r7}
  40ff4e:	b083      	sub	sp, #12
  40ff50:	af00      	add	r7, sp, #0
  40ff52:	4603      	mov	r3, r0
  40ff54:	6039      	str	r1, [r7, #0]
  40ff56:	71fb      	strb	r3, [r7, #7]
  if(IRQn < 0) {
  40ff58:	f997 3007 	ldrsb.w	r3, [r7, #7]
  40ff5c:	2b00      	cmp	r3, #0
  40ff5e:	da0b      	bge.n	40ff78 <NVIC_SetPriority+0x2c>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
  40ff60:	490d      	ldr	r1, [pc, #52]	; (40ff98 <NVIC_SetPriority+0x4c>)
  40ff62:	79fb      	ldrb	r3, [r7, #7]
  40ff64:	f003 030f 	and.w	r3, r3, #15
  40ff68:	3b04      	subs	r3, #4
  40ff6a:	683a      	ldr	r2, [r7, #0]
  40ff6c:	b2d2      	uxtb	r2, r2
  40ff6e:	0112      	lsls	r2, r2, #4
  40ff70:	b2d2      	uxtb	r2, r2
  40ff72:	440b      	add	r3, r1
  40ff74:	761a      	strb	r2, [r3, #24]
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
}
  40ff76:	e009      	b.n	40ff8c <NVIC_SetPriority+0x40>
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
  40ff78:	4908      	ldr	r1, [pc, #32]	; (40ff9c <NVIC_SetPriority+0x50>)
  40ff7a:	f997 3007 	ldrsb.w	r3, [r7, #7]
  40ff7e:	683a      	ldr	r2, [r7, #0]
  40ff80:	b2d2      	uxtb	r2, r2
  40ff82:	0112      	lsls	r2, r2, #4
  40ff84:	b2d2      	uxtb	r2, r2
  40ff86:	440b      	add	r3, r1
  40ff88:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
  40ff8c:	bf00      	nop
  40ff8e:	370c      	adds	r7, #12
  40ff90:	46bd      	mov	sp, r7
  40ff92:	f85d 7b04 	ldr.w	r7, [sp], #4
  40ff96:	4770      	bx	lr
  40ff98:	e000ed00 	.word	0xe000ed00
  40ff9c:	e000e100 	.word	0xe000e100

0040ffa0 <gmac_enable_management>:
{
  40ffa0:	b480      	push	{r7}
  40ffa2:	b083      	sub	sp, #12
  40ffa4:	af00      	add	r7, sp, #0
  40ffa6:	6078      	str	r0, [r7, #4]
  40ffa8:	460b      	mov	r3, r1
  40ffaa:	70fb      	strb	r3, [r7, #3]
	if (uc_enable) {
  40ffac:	78fb      	ldrb	r3, [r7, #3]
  40ffae:	2b00      	cmp	r3, #0
  40ffb0:	d006      	beq.n	40ffc0 <gmac_enable_management+0x20>
		p_gmac->GMAC_NCR |= GMAC_NCR_MPE;
  40ffb2:	687b      	ldr	r3, [r7, #4]
  40ffb4:	681b      	ldr	r3, [r3, #0]
  40ffb6:	f043 0210 	orr.w	r2, r3, #16
  40ffba:	687b      	ldr	r3, [r7, #4]
  40ffbc:	601a      	str	r2, [r3, #0]
}
  40ffbe:	e005      	b.n	40ffcc <gmac_enable_management+0x2c>
		p_gmac->GMAC_NCR &= ~GMAC_NCR_MPE;
  40ffc0:	687b      	ldr	r3, [r7, #4]
  40ffc2:	681b      	ldr	r3, [r3, #0]
  40ffc4:	f023 0210 	bic.w	r2, r3, #16
  40ffc8:	687b      	ldr	r3, [r7, #4]
  40ffca:	601a      	str	r2, [r3, #0]
}
  40ffcc:	bf00      	nop
  40ffce:	370c      	adds	r7, #12
  40ffd0:	46bd      	mov	sp, r7
  40ffd2:	f85d 7b04 	ldr.w	r7, [sp], #4
  40ffd6:	4770      	bx	lr

0040ffd8 <gmac_set_address>:
{
  40ffd8:	b480      	push	{r7}
  40ffda:	b085      	sub	sp, #20
  40ffdc:	af00      	add	r7, sp, #0
  40ffde:	60f8      	str	r0, [r7, #12]
  40ffe0:	460b      	mov	r3, r1
  40ffe2:	607a      	str	r2, [r7, #4]
  40ffe4:	72fb      	strb	r3, [r7, #11]
	p_gmac->GMAC_SA[uc_index].GMAC_SAB = (p_mac_addr[3] << 24)
  40ffe6:	7afa      	ldrb	r2, [r7, #11]
  40ffe8:	687b      	ldr	r3, [r7, #4]
  40ffea:	3303      	adds	r3, #3
  40ffec:	781b      	ldrb	r3, [r3, #0]
  40ffee:	0619      	lsls	r1, r3, #24
			| (p_mac_addr[2] << 16)
  40fff0:	687b      	ldr	r3, [r7, #4]
  40fff2:	3302      	adds	r3, #2
  40fff4:	781b      	ldrb	r3, [r3, #0]
  40fff6:	041b      	lsls	r3, r3, #16
  40fff8:	4319      	orrs	r1, r3
			| (p_mac_addr[1] << 8)
  40fffa:	687b      	ldr	r3, [r7, #4]
  40fffc:	3301      	adds	r3, #1
  40fffe:	781b      	ldrb	r3, [r3, #0]
  410000:	021b      	lsls	r3, r3, #8
  410002:	430b      	orrs	r3, r1
			| (p_mac_addr[0]);
  410004:	6879      	ldr	r1, [r7, #4]
  410006:	7809      	ldrb	r1, [r1, #0]
  410008:	430b      	orrs	r3, r1
  41000a:	4619      	mov	r1, r3
	p_gmac->GMAC_SA[uc_index].GMAC_SAB = (p_mac_addr[3] << 24)
  41000c:	68fb      	ldr	r3, [r7, #12]
  41000e:	3211      	adds	r2, #17
  410010:	f843 1032 	str.w	r1, [r3, r2, lsl #3]
	p_gmac->GMAC_SA[uc_index].GMAC_SAT = (p_mac_addr[5] << 8)
  410014:	7afb      	ldrb	r3, [r7, #11]
  410016:	687a      	ldr	r2, [r7, #4]
  410018:	3205      	adds	r2, #5
  41001a:	7812      	ldrb	r2, [r2, #0]
  41001c:	0212      	lsls	r2, r2, #8
			| (p_mac_addr[4]);
  41001e:	6879      	ldr	r1, [r7, #4]
  410020:	3104      	adds	r1, #4
  410022:	7809      	ldrb	r1, [r1, #0]
  410024:	430a      	orrs	r2, r1
  410026:	4611      	mov	r1, r2
	p_gmac->GMAC_SA[uc_index].GMAC_SAT = (p_mac_addr[5] << 8)
  410028:	68fa      	ldr	r2, [r7, #12]
  41002a:	3311      	adds	r3, #17
  41002c:	00db      	lsls	r3, r3, #3
  41002e:	4413      	add	r3, r2
  410030:	6059      	str	r1, [r3, #4]
}
  410032:	bf00      	nop
  410034:	3714      	adds	r7, #20
  410036:	46bd      	mov	sp, r7
  410038:	f85d 7b04 	ldr.w	r7, [sp], #4
  41003c:	4770      	bx	lr
	...

00410040 <osc_get_rate>:
{
  410040:	b480      	push	{r7}
  410042:	b083      	sub	sp, #12
  410044:	af00      	add	r7, sp, #0
  410046:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  410048:	687b      	ldr	r3, [r7, #4]
  41004a:	2b07      	cmp	r3, #7
  41004c:	d825      	bhi.n	41009a <osc_get_rate+0x5a>
  41004e:	a201      	add	r2, pc, #4	; (adr r2, 410054 <osc_get_rate+0x14>)
  410050:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  410054:	00410075 	.word	0x00410075
  410058:	0041007b 	.word	0x0041007b
  41005c:	00410081 	.word	0x00410081
  410060:	00410087 	.word	0x00410087
  410064:	0041008b 	.word	0x0041008b
  410068:	0041008f 	.word	0x0041008f
  41006c:	00410093 	.word	0x00410093
  410070:	00410097 	.word	0x00410097
		return OSC_SLCK_32K_RC_HZ;
  410074:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
  410078:	e010      	b.n	41009c <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_XTAL;
  41007a:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  41007e:	e00d      	b.n	41009c <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_BYPASS;
  410080:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  410084:	e00a      	b.n	41009c <osc_get_rate+0x5c>
		return OSC_MAINCK_4M_RC_HZ;
  410086:	4b08      	ldr	r3, [pc, #32]	; (4100a8 <osc_get_rate+0x68>)
  410088:	e008      	b.n	41009c <osc_get_rate+0x5c>
		return OSC_MAINCK_8M_RC_HZ;
  41008a:	4b08      	ldr	r3, [pc, #32]	; (4100ac <osc_get_rate+0x6c>)
  41008c:	e006      	b.n	41009c <osc_get_rate+0x5c>
		return OSC_MAINCK_12M_RC_HZ;
  41008e:	4b08      	ldr	r3, [pc, #32]	; (4100b0 <osc_get_rate+0x70>)
  410090:	e004      	b.n	41009c <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_XTAL;
  410092:	4b07      	ldr	r3, [pc, #28]	; (4100b0 <osc_get_rate+0x70>)
  410094:	e002      	b.n	41009c <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_BYPASS;
  410096:	4b06      	ldr	r3, [pc, #24]	; (4100b0 <osc_get_rate+0x70>)
  410098:	e000      	b.n	41009c <osc_get_rate+0x5c>
	return 0;
  41009a:	2300      	movs	r3, #0
}
  41009c:	4618      	mov	r0, r3
  41009e:	370c      	adds	r7, #12
  4100a0:	46bd      	mov	sp, r7
  4100a2:	f85d 7b04 	ldr.w	r7, [sp], #4
  4100a6:	4770      	bx	lr
  4100a8:	003d0900 	.word	0x003d0900
  4100ac:	007a1200 	.word	0x007a1200
  4100b0:	00b71b00 	.word	0x00b71b00

004100b4 <sysclk_get_main_hz>:
{
  4100b4:	b580      	push	{r7, lr}
  4100b6:	af00      	add	r7, sp, #0
		return pll_get_default_rate(0);
  4100b8:	2006      	movs	r0, #6
  4100ba:	4b03      	ldr	r3, [pc, #12]	; (4100c8 <sysclk_get_main_hz+0x14>)
  4100bc:	4798      	blx	r3
  4100be:	4603      	mov	r3, r0
  4100c0:	011b      	lsls	r3, r3, #4
}
  4100c2:	4618      	mov	r0, r3
  4100c4:	bd80      	pop	{r7, pc}
  4100c6:	bf00      	nop
  4100c8:	00410041 	.word	0x00410041

004100cc <sysclk_get_cpu_hz>:
{
  4100cc:	b580      	push	{r7, lr}
  4100ce:	af00      	add	r7, sp, #0
	return sysclk_get_main_hz() /
  4100d0:	4b02      	ldr	r3, [pc, #8]	; (4100dc <sysclk_get_cpu_hz+0x10>)
  4100d2:	4798      	blx	r3
  4100d4:	4603      	mov	r3, r0
  4100d6:	085b      	lsrs	r3, r3, #1
}
  4100d8:	4618      	mov	r0, r3
  4100da:	bd80      	pop	{r7, pc}
  4100dc:	004100b5 	.word	0x004100b5

004100e0 <GMAC_Handler>:

/*
 * GMAC interrupt handler.
 */
void GMAC_Handler(void)
{
  4100e0:	b580      	push	{r7, lr}
  4100e2:	af00      	add	r7, sp, #0
	xGMACSwitchRequired = pdFALSE;
  4100e4:	4b0b      	ldr	r3, [pc, #44]	; (410114 <GMAC_Handler+0x34>)
  4100e6:	2200      	movs	r2, #0
  4100e8:	601a      	str	r2, [r3, #0]

	/* gmac_handler() may call prvRxCallback() which may change
	the value of xGMACSwitchRequired. */
	gmac_handler( &gs_gmac_dev );
  4100ea:	480b      	ldr	r0, [pc, #44]	; (410118 <GMAC_Handler+0x38>)
  4100ec:	4b0b      	ldr	r3, [pc, #44]	; (41011c <GMAC_Handler+0x3c>)
  4100ee:	4798      	blx	r3

	if( xGMACSwitchRequired != pdFALSE )
  4100f0:	4b08      	ldr	r3, [pc, #32]	; (410114 <GMAC_Handler+0x34>)
  4100f2:	681b      	ldr	r3, [r3, #0]
  4100f4:	2b00      	cmp	r3, #0
  4100f6:	d00b      	beq.n	410110 <GMAC_Handler+0x30>
	{
		portEND_SWITCHING_ISR( xGMACSwitchRequired );
  4100f8:	4b06      	ldr	r3, [pc, #24]	; (410114 <GMAC_Handler+0x34>)
  4100fa:	681b      	ldr	r3, [r3, #0]
  4100fc:	2b00      	cmp	r3, #0
  4100fe:	d007      	beq.n	410110 <GMAC_Handler+0x30>
  410100:	4b07      	ldr	r3, [pc, #28]	; (410120 <GMAC_Handler+0x40>)
  410102:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  410106:	601a      	str	r2, [r3, #0]
  410108:	f3bf 8f4f 	dsb	sy
  41010c:	f3bf 8f6f 	isb	sy
	}
}
  410110:	bf00      	nop
  410112:	bd80      	pop	{r7, pc}
  410114:	2000b378 	.word	0x2000b378
  410118:	2000b37c 	.word	0x2000b37c
  41011c:	0040fd91 	.word	0x0040fd91
  410120:	e000ed04 	.word	0xe000ed04

00410124 <prvRxCallback>:
/*-----------------------------------------------------------*/

static void prvRxCallback( uint32_t ulStatus )
{
  410124:	b580      	push	{r7, lr}
  410126:	b082      	sub	sp, #8
  410128:	af00      	add	r7, sp, #0
  41012a:	6078      	str	r0, [r7, #4]
	if( ( ( ulStatus & GMAC_RSR_REC ) != 0 ) && ( xEMACTaskHandle != NULL ) )
  41012c:	687b      	ldr	r3, [r7, #4]
  41012e:	f003 0302 	and.w	r3, r3, #2
  410132:	2b00      	cmp	r3, #0
  410134:	d00f      	beq.n	410156 <prvRxCallback+0x32>
  410136:	4b0a      	ldr	r3, [pc, #40]	; (410160 <prvRxCallback+0x3c>)
  410138:	681b      	ldr	r3, [r3, #0]
  41013a:	2b00      	cmp	r3, #0
  41013c:	d00b      	beq.n	410156 <prvRxCallback+0x32>
	{
		/* let the prvEMACHandlerTask know that there was an RX event. */
		ulISREvents |= EMAC_IF_RX_EVENT;
  41013e:	4b09      	ldr	r3, [pc, #36]	; (410164 <prvRxCallback+0x40>)
  410140:	681b      	ldr	r3, [r3, #0]
  410142:	f043 0301 	orr.w	r3, r3, #1
  410146:	4a07      	ldr	r2, [pc, #28]	; (410164 <prvRxCallback+0x40>)
  410148:	6013      	str	r3, [r2, #0]
		/* Only an RX interrupt can wakeup prvEMACHandlerTask. */
		vTaskNotifyGiveFromISR( xEMACTaskHandle, ( BaseType_t * ) &xGMACSwitchRequired );
  41014a:	4b05      	ldr	r3, [pc, #20]	; (410160 <prvRxCallback+0x3c>)
  41014c:	681b      	ldr	r3, [r3, #0]
  41014e:	4906      	ldr	r1, [pc, #24]	; (410168 <prvRxCallback+0x44>)
  410150:	4618      	mov	r0, r3
  410152:	4b06      	ldr	r3, [pc, #24]	; (41016c <prvRxCallback+0x48>)
  410154:	4798      	blx	r3
	}
}
  410156:	bf00      	nop
  410158:	3708      	adds	r7, #8
  41015a:	46bd      	mov	sp, r7
  41015c:	bd80      	pop	{r7, pc}
  41015e:	bf00      	nop
  410160:	2000b3b0 	.word	0x2000b3b0
  410164:	2000b370 	.word	0x2000b370
  410168:	2000b378 	.word	0x2000b378
  41016c:	00413315 	.word	0x00413315

00410170 <prvTxCallback>:
/*-----------------------------------------------------------*/

//static void prvTxCallback( uint32_t ulStatus, uint8_t *puc_buffer )
static void prvTxCallback( uint8_t *puc_buffer ) // HICS: FIX PING TRAVANDO
{
  410170:	b590      	push	{r4, r7, lr}
  410172:	b083      	sub	sp, #12
  410174:	af00      	add	r7, sp, #0
  410176:	6078      	str	r0, [r7, #4]
	if( ( xTxBufferQueue != NULL ) && ( xEMACTaskHandle != NULL ) )
  410178:	4b11      	ldr	r3, [pc, #68]	; (4101c0 <prvTxCallback+0x50>)
  41017a:	681b      	ldr	r3, [r3, #0]
  41017c:	2b00      	cmp	r3, #0
  41017e:	d01b      	beq.n	4101b8 <prvTxCallback+0x48>
  410180:	4b10      	ldr	r3, [pc, #64]	; (4101c4 <prvTxCallback+0x54>)
  410182:	681b      	ldr	r3, [r3, #0]
  410184:	2b00      	cmp	r3, #0
  410186:	d017      	beq.n	4101b8 <prvTxCallback+0x48>
	{
		/* let the prvEMACHandlerTask know that there was an RX event. */
		ulISREvents |= EMAC_IF_TX_EVENT;
  410188:	4b0f      	ldr	r3, [pc, #60]	; (4101c8 <prvTxCallback+0x58>)
  41018a:	681b      	ldr	r3, [r3, #0]
  41018c:	f043 0302 	orr.w	r3, r3, #2
  410190:	4a0d      	ldr	r2, [pc, #52]	; (4101c8 <prvTxCallback+0x58>)
  410192:	6013      	str	r3, [r2, #0]

		vTaskNotifyGiveFromISR( xEMACTaskHandle, ( BaseType_t * ) &xGMACSwitchRequired );
  410194:	4b0b      	ldr	r3, [pc, #44]	; (4101c4 <prvTxCallback+0x54>)
  410196:	681b      	ldr	r3, [r3, #0]
  410198:	490c      	ldr	r1, [pc, #48]	; (4101cc <prvTxCallback+0x5c>)
  41019a:	4618      	mov	r0, r3
  41019c:	4b0c      	ldr	r3, [pc, #48]	; (4101d0 <prvTxCallback+0x60>)
  41019e:	4798      	blx	r3
		xQueueSendFromISR( xTxBufferQueue, &puc_buffer, ( BaseType_t * ) &xGMACSwitchRequired );
  4101a0:	4b07      	ldr	r3, [pc, #28]	; (4101c0 <prvTxCallback+0x50>)
  4101a2:	6818      	ldr	r0, [r3, #0]
  4101a4:	1d39      	adds	r1, r7, #4
  4101a6:	2300      	movs	r3, #0
  4101a8:	4a08      	ldr	r2, [pc, #32]	; (4101cc <prvTxCallback+0x5c>)
  4101aa:	4c0a      	ldr	r4, [pc, #40]	; (4101d4 <prvTxCallback+0x64>)
  4101ac:	47a0      	blx	r4
		tx_release_count[ 2 ]++;
  4101ae:	4b0a      	ldr	r3, [pc, #40]	; (4101d8 <prvTxCallback+0x68>)
  4101b0:	689b      	ldr	r3, [r3, #8]
  4101b2:	3301      	adds	r3, #1
  4101b4:	4a08      	ldr	r2, [pc, #32]	; (4101d8 <prvTxCallback+0x68>)
  4101b6:	6093      	str	r3, [r2, #8]
	}
}
  4101b8:	bf00      	nop
  4101ba:	370c      	adds	r7, #12
  4101bc:	46bd      	mov	sp, r7
  4101be:	bd90      	pop	{r4, r7, pc}
  4101c0:	2000b3b4 	.word	0x2000b3b4
  4101c4:	2000b3b0 	.word	0x2000b3b0
  4101c8:	2000b370 	.word	0x2000b370
  4101cc:	2000b378 	.word	0x2000b378
  4101d0:	00413315 	.word	0x00413315
  4101d4:	004119e9 	.word	0x004119e9
  4101d8:	2000b5d8 	.word	0x2000b5d8

004101dc <xNetworkInterfaceInitialise>:
/*-----------------------------------------------------------*/

BaseType_t xNetworkInterfaceInitialise( void )
{
  4101dc:	b590      	push	{r4, r7, lr}
  4101de:	b085      	sub	sp, #20
  4101e0:	af02      	add	r7, sp, #8
const TickType_t x5_Seconds = 5000UL;
  4101e2:	f241 3388 	movw	r3, #5000	; 0x1388
  4101e6:	607b      	str	r3, [r7, #4]

	if( xEMACTaskHandle == NULL )
  4101e8:	4b2d      	ldr	r3, [pc, #180]	; (4102a0 <xNetworkInterfaceInitialise+0xc4>)
  4101ea:	681b      	ldr	r3, [r3, #0]
  4101ec:	2b00      	cmp	r3, #0
  4101ee:	d121      	bne.n	410234 <xNetworkInterfaceInitialise+0x58>
	{
		prvGMACInit();
  4101f0:	4b2c      	ldr	r3, [pc, #176]	; (4102a4 <xNetworkInterfaceInitialise+0xc8>)
  4101f2:	4798      	blx	r3

		/* Wait at most 5 seconds for a Link Status in the PHY. */
		xGMACWaitLS( pdMS_TO_TICKS( x5_Seconds ) );
  4101f4:	687b      	ldr	r3, [r7, #4]
  4101f6:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
  4101fa:	fb02 f303 	mul.w	r3, r2, r3
  4101fe:	4a2a      	ldr	r2, [pc, #168]	; (4102a8 <xNetworkInterfaceInitialise+0xcc>)
  410200:	fba2 2303 	umull	r2, r3, r2, r3
  410204:	099b      	lsrs	r3, r3, #6
  410206:	4618      	mov	r0, r3
  410208:	4b28      	ldr	r3, [pc, #160]	; (4102ac <xNetworkInterfaceInitialise+0xd0>)
  41020a:	4798      	blx	r3

		/* The handler task is created at the highest possible priority to
		ensure the interrupt handler can return directly to it. */
		xTaskCreate( prvEMACHandlerTask, "EMAC", configEMAC_TASK_STACK_SIZE, NULL, configMAX_PRIORITIES - 1, &xEMACTaskHandle );
  41020c:	4b24      	ldr	r3, [pc, #144]	; (4102a0 <xNetworkInterfaceInitialise+0xc4>)
  41020e:	9301      	str	r3, [sp, #4]
  410210:	2303      	movs	r3, #3
  410212:	9300      	str	r3, [sp, #0]
  410214:	2300      	movs	r3, #0
  410216:	f44f 5280 	mov.w	r2, #4096	; 0x1000
  41021a:	4925      	ldr	r1, [pc, #148]	; (4102b0 <xNetworkInterfaceInitialise+0xd4>)
  41021c:	4825      	ldr	r0, [pc, #148]	; (4102b4 <xNetworkInterfaceInitialise+0xd8>)
  41021e:	4c26      	ldr	r4, [pc, #152]	; (4102b8 <xNetworkInterfaceInitialise+0xdc>)
  410220:	47a0      	blx	r4
		configASSERT( xEMACTaskHandle );
  410222:	4b1f      	ldr	r3, [pc, #124]	; (4102a0 <xNetworkInterfaceInitialise+0xc4>)
  410224:	681b      	ldr	r3, [r3, #0]
  410226:	2b00      	cmp	r3, #0
  410228:	d104      	bne.n	410234 <xNetworkInterfaceInitialise+0x58>
  41022a:	22eb      	movs	r2, #235	; 0xeb
  41022c:	4923      	ldr	r1, [pc, #140]	; (4102bc <xNetworkInterfaceInitialise+0xe0>)
  41022e:	4824      	ldr	r0, [pc, #144]	; (4102c0 <xNetworkInterfaceInitialise+0xe4>)
  410230:	4b24      	ldr	r3, [pc, #144]	; (4102c4 <xNetworkInterfaceInitialise+0xe8>)
  410232:	4798      	blx	r3
	}

	if( xTxBufferQueue == NULL )
  410234:	4b24      	ldr	r3, [pc, #144]	; (4102c8 <xNetworkInterfaceInitialise+0xec>)
  410236:	681b      	ldr	r3, [r3, #0]
  410238:	2b00      	cmp	r3, #0
  41023a:	d110      	bne.n	41025e <xNetworkInterfaceInitialise+0x82>
	{
		xTxBufferQueue = xQueueCreate( GMAC_TX_BUFFERS, sizeof( void * ) );
  41023c:	2200      	movs	r2, #0
  41023e:	2104      	movs	r1, #4
  410240:	2008      	movs	r0, #8
  410242:	4b22      	ldr	r3, [pc, #136]	; (4102cc <xNetworkInterfaceInitialise+0xf0>)
  410244:	4798      	blx	r3
  410246:	4602      	mov	r2, r0
  410248:	4b1f      	ldr	r3, [pc, #124]	; (4102c8 <xNetworkInterfaceInitialise+0xec>)
  41024a:	601a      	str	r2, [r3, #0]
		configASSERT( xTxBufferQueue );
  41024c:	4b1e      	ldr	r3, [pc, #120]	; (4102c8 <xNetworkInterfaceInitialise+0xec>)
  41024e:	681b      	ldr	r3, [r3, #0]
  410250:	2b00      	cmp	r3, #0
  410252:	d104      	bne.n	41025e <xNetworkInterfaceInitialise+0x82>
  410254:	22f1      	movs	r2, #241	; 0xf1
  410256:	4919      	ldr	r1, [pc, #100]	; (4102bc <xNetworkInterfaceInitialise+0xe0>)
  410258:	4819      	ldr	r0, [pc, #100]	; (4102c0 <xNetworkInterfaceInitialise+0xe4>)
  41025a:	4b1a      	ldr	r3, [pc, #104]	; (4102c4 <xNetworkInterfaceInitialise+0xe8>)
  41025c:	4798      	blx	r3
	}

	if( xTXDescriptorSemaphore == NULL )
  41025e:	4b1c      	ldr	r3, [pc, #112]	; (4102d0 <xNetworkInterfaceInitialise+0xf4>)
  410260:	681b      	ldr	r3, [r3, #0]
  410262:	2b00      	cmp	r3, #0
  410264:	d10f      	bne.n	410286 <xNetworkInterfaceInitialise+0xaa>
	{
		xTXDescriptorSemaphore = xSemaphoreCreateCounting( ( UBaseType_t ) GMAC_TX_BUFFERS, ( UBaseType_t ) GMAC_TX_BUFFERS );
  410266:	2108      	movs	r1, #8
  410268:	2008      	movs	r0, #8
  41026a:	4b1a      	ldr	r3, [pc, #104]	; (4102d4 <xNetworkInterfaceInitialise+0xf8>)
  41026c:	4798      	blx	r3
  41026e:	4602      	mov	r2, r0
  410270:	4b17      	ldr	r3, [pc, #92]	; (4102d0 <xNetworkInterfaceInitialise+0xf4>)
  410272:	601a      	str	r2, [r3, #0]
		configASSERT( xTXDescriptorSemaphore );
  410274:	4b16      	ldr	r3, [pc, #88]	; (4102d0 <xNetworkInterfaceInitialise+0xf4>)
  410276:	681b      	ldr	r3, [r3, #0]
  410278:	2b00      	cmp	r3, #0
  41027a:	d104      	bne.n	410286 <xNetworkInterfaceInitialise+0xaa>
  41027c:	22f7      	movs	r2, #247	; 0xf7
  41027e:	490f      	ldr	r1, [pc, #60]	; (4102bc <xNetworkInterfaceInitialise+0xe0>)
  410280:	480f      	ldr	r0, [pc, #60]	; (4102c0 <xNetworkInterfaceInitialise+0xe4>)
  410282:	4b10      	ldr	r3, [pc, #64]	; (4102c4 <xNetworkInterfaceInitialise+0xe8>)
  410284:	4798      	blx	r3
	}
	/* When returning non-zero, the stack will become active and
    start DHCP (in configured) */
	return ( ulPHYLinkStatus & BMSR_LINK_STATUS ) != 0;
  410286:	4b14      	ldr	r3, [pc, #80]	; (4102d8 <xNetworkInterfaceInitialise+0xfc>)
  410288:	681b      	ldr	r3, [r3, #0]
  41028a:	f003 0304 	and.w	r3, r3, #4
  41028e:	2b00      	cmp	r3, #0
  410290:	bf14      	ite	ne
  410292:	2301      	movne	r3, #1
  410294:	2300      	moveq	r3, #0
  410296:	b2db      	uxtb	r3, r3
}
  410298:	4618      	mov	r0, r3
  41029a:	370c      	adds	r7, #12
  41029c:	46bd      	mov	sp, r7
  41029e:	bd90      	pop	{r4, r7, pc}
  4102a0:	2000b3b0 	.word	0x2000b3b0
  4102a4:	0041036d 	.word	0x0041036d
  4102a8:	10624dd3 	.word	0x10624dd3
  4102ac:	004104ad 	.word	0x004104ad
  4102b0:	0041df34 	.word	0x0041df34
  4102b4:	00410731 	.word	0x00410731
  4102b8:	004122f9 	.word	0x004122f9
  4102bc:	0041df3c 	.word	0x0041df3c
  4102c0:	0041dfb0 	.word	0x0041dfb0
  4102c4:	00416c7d 	.word	0x00416c7d
  4102c8:	2000b3b4 	.word	0x2000b3b4
  4102cc:	00411711 	.word	0x00411711
  4102d0:	2000b3b8 	.word	0x2000b3b8
  4102d4:	004117cd 	.word	0x004117cd
  4102d8:	2000b374 	.word	0x2000b374

004102dc <xNetworkInterfaceOutput>:
	return xResult;
}
/*-----------------------------------------------------------*/

BaseType_t xNetworkInterfaceOutput( NetworkBufferDescriptor_t * const pxDescriptor, BaseType_t bReleaseAfterSend )
{
  4102dc:	b590      	push	{r4, r7, lr}
  4102de:	b085      	sub	sp, #20
  4102e0:	af00      	add	r7, sp, #0
  4102e2:	6078      	str	r0, [r7, #4]
  4102e4:	6039      	str	r1, [r7, #0]
/* Do not wait too long for a free TX DMA buffer. */
const TickType_t xBlockTimeTicks = pdMS_TO_TICKS( 50u );
  4102e6:	2332      	movs	r3, #50	; 0x32
  4102e8:	60fb      	str	r3, [r7, #12]

	do {
		if( ( ulPHYLinkStatus & BMSR_LINK_STATUS ) == 0 )
  4102ea:	4b18      	ldr	r3, [pc, #96]	; (41034c <xNetworkInterfaceOutput+0x70>)
  4102ec:	681b      	ldr	r3, [r3, #0]
  4102ee:	f003 0304 	and.w	r3, r3, #4
  4102f2:	2b00      	cmp	r3, #0
  4102f4:	d01b      	beq.n	41032e <xNetworkInterfaceOutput+0x52>
		{
			/* Do not attempt to send packets as long as the Link Status is low. */
			break;
		}
		if( xTXDescriptorSemaphore == NULL )
  4102f6:	4b16      	ldr	r3, [pc, #88]	; (410350 <xNetworkInterfaceOutput+0x74>)
  4102f8:	681b      	ldr	r3, [r3, #0]
  4102fa:	2b00      	cmp	r3, #0
  4102fc:	d019      	beq.n	410332 <xNetworkInterfaceOutput+0x56>
		{
			/* Semaphore has not been created yet? */
			break;
		}
		if( xSemaphoreTake( xTXDescriptorSemaphore, xBlockTimeTicks ) != pdPASS )
  4102fe:	4b14      	ldr	r3, [pc, #80]	; (410350 <xNetworkInterfaceOutput+0x74>)
  410300:	681b      	ldr	r3, [r3, #0]
  410302:	68f9      	ldr	r1, [r7, #12]
  410304:	4618      	mov	r0, r3
  410306:	4b13      	ldr	r3, [pc, #76]	; (410354 <xNetworkInterfaceOutput+0x78>)
  410308:	4798      	blx	r3
  41030a:	4603      	mov	r3, r0
  41030c:	2b01      	cmp	r3, #1
  41030e:	d005      	beq.n	41031c <xNetworkInterfaceOutput+0x40>
		{
			/* Time-out waiting for a free TX descriptor. */
			tx_release_count[ 3 ]++;
  410310:	4b11      	ldr	r3, [pc, #68]	; (410358 <xNetworkInterfaceOutput+0x7c>)
  410312:	68db      	ldr	r3, [r3, #12]
  410314:	3301      	adds	r3, #1
  410316:	4a10      	ldr	r2, [pc, #64]	; (410358 <xNetworkInterfaceOutput+0x7c>)
  410318:	60d3      	str	r3, [r2, #12]
			break;
  41031a:	e00b      	b.n	410334 <xNetworkInterfaceOutput+0x58>
			/* Confirm that the pxDescriptor may be kept by the driver. */
			configASSERT( bReleaseAfterSend != pdFALSE );
		}
		#endif /* ipconfigZERO_COPY_TX_DRIVER */

		gmac_dev_write( &gs_gmac_dev, (void *)pxDescriptor->pucEthernetBuffer, pxDescriptor->xDataLength, prvTxCallback );
  41031c:	687b      	ldr	r3, [r7, #4]
  41031e:	6999      	ldr	r1, [r3, #24]
  410320:	687b      	ldr	r3, [r7, #4]
  410322:	69da      	ldr	r2, [r3, #28]
  410324:	4b0d      	ldr	r3, [pc, #52]	; (41035c <xNetworkInterfaceOutput+0x80>)
  410326:	480e      	ldr	r0, [pc, #56]	; (410360 <xNetworkInterfaceOutput+0x84>)
  410328:	4c0e      	ldr	r4, [pc, #56]	; (410364 <xNetworkInterfaceOutput+0x88>)
  41032a:	47a0      	blx	r4
  41032c:	e002      	b.n	410334 <xNetworkInterfaceOutput+0x58>
			break;
  41032e:	bf00      	nop
  410330:	e000      	b.n	410334 <xNetworkInterfaceOutput+0x58>
			break;
  410332:	bf00      	nop
		#endif /* ipconfigZERO_COPY_TX_DRIVER */
		/* Not interested in a call-back after TX. */
		iptraceNETWORK_INTERFACE_TRANSMIT();
	} while( 0 );

	if( bReleaseAfterSend != pdFALSE )
  410334:	683b      	ldr	r3, [r7, #0]
  410336:	2b00      	cmp	r3, #0
  410338:	d002      	beq.n	410340 <xNetworkInterfaceOutput+0x64>
	{
		vReleaseNetworkBufferAndDescriptor( pxDescriptor );
  41033a:	6878      	ldr	r0, [r7, #4]
  41033c:	4b0a      	ldr	r3, [pc, #40]	; (410368 <xNetworkInterfaceOutput+0x8c>)
  41033e:	4798      	blx	r3
	}
	return pdTRUE;
  410340:	2301      	movs	r3, #1
}
  410342:	4618      	mov	r0, r3
  410344:	3714      	adds	r7, #20
  410346:	46bd      	mov	sp, r7
  410348:	bd90      	pop	{r4, r7, pc}
  41034a:	bf00      	nop
  41034c:	2000b374 	.word	0x2000b374
  410350:	2000b3b8 	.word	0x2000b3b8
  410354:	00411db1 	.word	0x00411db1
  410358:	2000b5d8 	.word	0x2000b5d8
  41035c:	00410171 	.word	0x00410171
  410360:	2000b37c 	.word	0x2000b37c
  410364:	0040fc7d 	.word	0x0040fc7d
  410368:	0040f2ed 	.word	0x0040f2ed

0041036c <prvGMACInit>:
/*-----------------------------------------------------------*/

static BaseType_t prvGMACInit( void )
{
  41036c:	b580      	push	{r7, lr}
  41036e:	b084      	sub	sp, #16
  410370:	af00      	add	r7, sp, #0
uint32_t ncfgr;

	gmac_options_t gmac_option;

	memset( &gmac_option, '\0', sizeof( gmac_option ) );
  410372:	1d3b      	adds	r3, r7, #4
  410374:	2208      	movs	r2, #8
  410376:	2100      	movs	r1, #0
  410378:	4618      	mov	r0, r3
  41037a:	4b25      	ldr	r3, [pc, #148]	; (410410 <prvGMACInit+0xa4>)
  41037c:	4798      	blx	r3
	gmac_option.uc_copy_all_frame = 0;
  41037e:	2300      	movs	r3, #0
  410380:	713b      	strb	r3, [r7, #4]
	gmac_option.uc_no_boardcast = 0;
  410382:	2300      	movs	r3, #0
  410384:	717b      	strb	r3, [r7, #5]
	memcpy( gmac_option.uc_mac_addr, ucMACAddress, sizeof( gmac_option.uc_mac_addr ) );
  410386:	4a23      	ldr	r2, [pc, #140]	; (410414 <prvGMACInit+0xa8>)
  410388:	1dbb      	adds	r3, r7, #6
  41038a:	6811      	ldr	r1, [r2, #0]
  41038c:	6019      	str	r1, [r3, #0]
  41038e:	8892      	ldrh	r2, [r2, #4]
  410390:	809a      	strh	r2, [r3, #4]

	gs_gmac_dev.p_hw = GMAC;
  410392:	4b21      	ldr	r3, [pc, #132]	; (410418 <prvGMACInit+0xac>)
  410394:	4a21      	ldr	r2, [pc, #132]	; (41041c <prvGMACInit+0xb0>)
  410396:	601a      	str	r2, [r3, #0]
	gmac_dev_init( GMAC, &gs_gmac_dev, &gmac_option );
  410398:	1d3b      	adds	r3, r7, #4
  41039a:	461a      	mov	r2, r3
  41039c:	491e      	ldr	r1, [pc, #120]	; (410418 <prvGMACInit+0xac>)
  41039e:	481f      	ldr	r0, [pc, #124]	; (41041c <prvGMACInit+0xb0>)
  4103a0:	4b1f      	ldr	r3, [pc, #124]	; (410420 <prvGMACInit+0xb4>)
  4103a2:	4798      	blx	r3

	#define configMAC_INTERRUPT_PRIORITY 6 // HICS
	NVIC_SetPriority( GMAC_IRQn, configMAC_INTERRUPT_PRIORITY );
  4103a4:	2106      	movs	r1, #6
  4103a6:	202c      	movs	r0, #44	; 0x2c
  4103a8:	4b1e      	ldr	r3, [pc, #120]	; (410424 <prvGMACInit+0xb8>)
  4103aa:	4798      	blx	r3
	NVIC_EnableIRQ( GMAC_IRQn );
  4103ac:	202c      	movs	r0, #44	; 0x2c
  4103ae:	4b1e      	ldr	r3, [pc, #120]	; (410428 <prvGMACInit+0xbc>)
  4103b0:	4798      	blx	r3

	/* Contact the Ethernet PHY and store it's address in 'ethernet_phy_addr' */
	ethernet_phy_init( GMAC, ETHERNET_CONF_PHY_ADDR, sysclk_get_cpu_hz() );
  4103b2:	4b1e      	ldr	r3, [pc, #120]	; (41042c <prvGMACInit+0xc0>)
  4103b4:	4798      	blx	r3
  4103b6:	4603      	mov	r3, r0
  4103b8:	461a      	mov	r2, r3
  4103ba:	2100      	movs	r1, #0
  4103bc:	4817      	ldr	r0, [pc, #92]	; (41041c <prvGMACInit+0xb0>)
  4103be:	4b1c      	ldr	r3, [pc, #112]	; (410430 <prvGMACInit+0xc4>)
  4103c0:	4798      	blx	r3

	ethernet_phy_auto_negotiate( GMAC, ethernet_phy_addr );
  4103c2:	4b1c      	ldr	r3, [pc, #112]	; (410434 <prvGMACInit+0xc8>)
  4103c4:	681b      	ldr	r3, [r3, #0]
  4103c6:	b2db      	uxtb	r3, r3
  4103c8:	4619      	mov	r1, r3
  4103ca:	4814      	ldr	r0, [pc, #80]	; (41041c <prvGMACInit+0xb0>)
  4103cc:	4b1a      	ldr	r3, [pc, #104]	; (410438 <prvGMACInit+0xcc>)
  4103ce:	4798      	blx	r3
	ethernet_phy_set_link( GMAC, ethernet_phy_addr, 1 );
  4103d0:	4b18      	ldr	r3, [pc, #96]	; (410434 <prvGMACInit+0xc8>)
  4103d2:	681b      	ldr	r3, [r3, #0]
  4103d4:	b2db      	uxtb	r3, r3
  4103d6:	2201      	movs	r2, #1
  4103d8:	4619      	mov	r1, r3
  4103da:	4810      	ldr	r0, [pc, #64]	; (41041c <prvGMACInit+0xb0>)
  4103dc:	4b17      	ldr	r3, [pc, #92]	; (41043c <prvGMACInit+0xd0>)
  4103de:	4798      	blx	r3

	/* The GMAC driver will call a hook prvRxCallback(), which
	in turn will wake-up the task by calling vTaskNotifyGiveFromISR() */
	gmac_dev_set_rx_callback( &gs_gmac_dev, prvRxCallback );
  4103e0:	4917      	ldr	r1, [pc, #92]	; (410440 <prvGMACInit+0xd4>)
  4103e2:	480d      	ldr	r0, [pc, #52]	; (410418 <prvGMACInit+0xac>)
  4103e4:	4b17      	ldr	r3, [pc, #92]	; (410444 <prvGMACInit+0xd8>)
  4103e6:	4798      	blx	r3
	gmac_set_address( GMAC, 1, (uint8_t*)llmnr_mac_address );
  4103e8:	4a17      	ldr	r2, [pc, #92]	; (410448 <prvGMACInit+0xdc>)
  4103ea:	2101      	movs	r1, #1
  4103ec:	480b      	ldr	r0, [pc, #44]	; (41041c <prvGMACInit+0xb0>)
  4103ee:	4b17      	ldr	r3, [pc, #92]	; (41044c <prvGMACInit+0xe0>)
  4103f0:	4798      	blx	r3

	ncfgr = GMAC_NCFGR_SPD | GMAC_NCFGR_FD;
  4103f2:	2303      	movs	r3, #3
  4103f4:	60fb      	str	r3, [r7, #12]

	GMAC->GMAC_NCFGR = ( GMAC->GMAC_NCFGR & ~( GMAC_NCFGR_SPD | GMAC_NCFGR_FD ) ) | ncfgr;
  4103f6:	4909      	ldr	r1, [pc, #36]	; (41041c <prvGMACInit+0xb0>)
  4103f8:	4b08      	ldr	r3, [pc, #32]	; (41041c <prvGMACInit+0xb0>)
  4103fa:	685b      	ldr	r3, [r3, #4]
  4103fc:	f023 0203 	bic.w	r2, r3, #3
  410400:	68fb      	ldr	r3, [r7, #12]
  410402:	4313      	orrs	r3, r2
  410404:	604b      	str	r3, [r1, #4]

	return 1;
  410406:	2301      	movs	r3, #1
}
  410408:	4618      	mov	r0, r3
  41040a:	3710      	adds	r7, #16
  41040c:	46bd      	mov	sp, r7
  41040e:	bd80      	pop	{r7, pc}
  410410:	00416f01 	.word	0x00416f01
  410414:	0041e6d8 	.word	0x0041e6d8
  410418:	2000b37c 	.word	0x2000b37c
  41041c:	40034000 	.word	0x40034000
  410420:	0040f95d 	.word	0x0040f95d
  410424:	0040ff4d 	.word	0x0040ff4d
  410428:	0040ff19 	.word	0x0040ff19
  41042c:	004100cd 	.word	0x004100cd
  410430:	00403431 	.word	0x00403431
  410434:	20006bc4 	.word	0x20006bc4
  410438:	004035d9 	.word	0x004035d9
  41043c:	004034a5 	.word	0x004034a5
  410440:	00410125 	.word	0x00410125
  410444:	0040fd4d 	.word	0x0040fd4d
  410448:	0041df2c 	.word	0x0041df2c
  41044c:	0040ffd9 	.word	0x0040ffd9

00410450 <ulReadMDIO>:
/*-----------------------------------------------------------*/

static inline unsigned long ulReadMDIO( unsigned /*short*/ usAddress )
{
  410450:	b590      	push	{r4, r7, lr}
  410452:	b087      	sub	sp, #28
  410454:	af00      	add	r7, sp, #0
  410456:	6078      	str	r0, [r7, #4]
uint32_t ulValue, ulReturn;
int rc;

	gmac_enable_management( GMAC, 1 );
  410458:	2101      	movs	r1, #1
  41045a:	4810      	ldr	r0, [pc, #64]	; (41049c <ulReadMDIO+0x4c>)
  41045c:	4b10      	ldr	r3, [pc, #64]	; (4104a0 <ulReadMDIO+0x50>)
  41045e:	4798      	blx	r3
	rc = gmac_phy_read( GMAC, ethernet_phy_addr, usAddress, &ulValue );
  410460:	4b10      	ldr	r3, [pc, #64]	; (4104a4 <ulReadMDIO+0x54>)
  410462:	681b      	ldr	r3, [r3, #0]
  410464:	b2d9      	uxtb	r1, r3
  410466:	687b      	ldr	r3, [r7, #4]
  410468:	b2da      	uxtb	r2, r3
  41046a:	f107 030c 	add.w	r3, r7, #12
  41046e:	480b      	ldr	r0, [pc, #44]	; (41049c <ulReadMDIO+0x4c>)
  410470:	4c0d      	ldr	r4, [pc, #52]	; (4104a8 <ulReadMDIO+0x58>)
  410472:	47a0      	blx	r4
  410474:	4603      	mov	r3, r0
  410476:	613b      	str	r3, [r7, #16]
	gmac_enable_management( GMAC, 0 );
  410478:	2100      	movs	r1, #0
  41047a:	4808      	ldr	r0, [pc, #32]	; (41049c <ulReadMDIO+0x4c>)
  41047c:	4b08      	ldr	r3, [pc, #32]	; (4104a0 <ulReadMDIO+0x50>)
  41047e:	4798      	blx	r3
	if( rc == GMAC_OK )
  410480:	693b      	ldr	r3, [r7, #16]
  410482:	2b00      	cmp	r3, #0
  410484:	d102      	bne.n	41048c <ulReadMDIO+0x3c>
	{
		ulReturn = ulValue;
  410486:	68fb      	ldr	r3, [r7, #12]
  410488:	617b      	str	r3, [r7, #20]
  41048a:	e001      	b.n	410490 <ulReadMDIO+0x40>
	}
	else
	{
		ulReturn = 0UL;
  41048c:	2300      	movs	r3, #0
  41048e:	617b      	str	r3, [r7, #20]
	}

	return ulReturn;
  410490:	697b      	ldr	r3, [r7, #20]
}
  410492:	4618      	mov	r0, r3
  410494:	371c      	adds	r7, #28
  410496:	46bd      	mov	sp, r7
  410498:	bd90      	pop	{r4, r7, pc}
  41049a:	bf00      	nop
  41049c:	40034000 	.word	0x40034000
  4104a0:	0040ffa1 	.word	0x0040ffa1
  4104a4:	20006bc4 	.word	0x20006bc4
  4104a8:	00403a5d 	.word	0x00403a5d

004104ac <xGMACWaitLS>:
/*-----------------------------------------------------------*/

static BaseType_t xGMACWaitLS( TickType_t xMaxTime )
{
  4104ac:	b590      	push	{r4, r7, lr}
  4104ae:	b087      	sub	sp, #28
  4104b0:	af00      	add	r7, sp, #0
  4104b2:	6078      	str	r0, [r7, #4]
TickType_t xStartTime = xTaskGetTickCount();
  4104b4:	4b1b      	ldr	r3, [pc, #108]	; (410524 <xGMACWaitLS+0x78>)
  4104b6:	4798      	blx	r3
  4104b8:	6138      	str	r0, [r7, #16]
TickType_t xEndTime;
BaseType_t xReturn;
const TickType_t xShortTime = pdMS_TO_TICKS( 100UL );
  4104ba:	2364      	movs	r3, #100	; 0x64
  4104bc:	60fb      	str	r3, [r7, #12]

	for( ;; )
	{
		xEndTime = xTaskGetTickCount();
  4104be:	4b19      	ldr	r3, [pc, #100]	; (410524 <xGMACWaitLS+0x78>)
  4104c0:	4798      	blx	r3
  4104c2:	60b8      	str	r0, [r7, #8]

		if( ( xEndTime - xStartTime ) > xMaxTime )
  4104c4:	68ba      	ldr	r2, [r7, #8]
  4104c6:	693b      	ldr	r3, [r7, #16]
  4104c8:	1ad2      	subs	r2, r2, r3
  4104ca:	687b      	ldr	r3, [r7, #4]
  4104cc:	429a      	cmp	r2, r3
  4104ce:	d902      	bls.n	4104d6 <xGMACWaitLS+0x2a>
		{
			/* Wated more than xMaxTime, return. */
			xReturn = pdFALSE;
  4104d0:	2300      	movs	r3, #0
  4104d2:	617b      	str	r3, [r7, #20]
			break;
  4104d4:	e012      	b.n	4104fc <xGMACWaitLS+0x50>
		}

		/* Check the link status again. */
		ulPHYLinkStatus = ulReadMDIO( PHY_REG_01_BMSR );
  4104d6:	2001      	movs	r0, #1
  4104d8:	4b13      	ldr	r3, [pc, #76]	; (410528 <xGMACWaitLS+0x7c>)
  4104da:	4798      	blx	r3
  4104dc:	4602      	mov	r2, r0
  4104de:	4b13      	ldr	r3, [pc, #76]	; (41052c <xGMACWaitLS+0x80>)
  4104e0:	601a      	str	r2, [r3, #0]

		if( ( ulPHYLinkStatus & BMSR_LINK_STATUS ) != 0 )
  4104e2:	4b12      	ldr	r3, [pc, #72]	; (41052c <xGMACWaitLS+0x80>)
  4104e4:	681b      	ldr	r3, [r3, #0]
  4104e6:	f003 0304 	and.w	r3, r3, #4
  4104ea:	2b00      	cmp	r3, #0
  4104ec:	d002      	beq.n	4104f4 <xGMACWaitLS+0x48>
		{
			/* Link is up - return. */
			xReturn = pdTRUE;
  4104ee:	2301      	movs	r3, #1
  4104f0:	617b      	str	r3, [r7, #20]
			break;
  4104f2:	e003      	b.n	4104fc <xGMACWaitLS+0x50>
		}

		/* Link is down - wait in the Blocked state for a short while (to allow
		other tasks to execute) before checking again. */
		vTaskDelay( xShortTime );
  4104f4:	68f8      	ldr	r0, [r7, #12]
  4104f6:	4b0e      	ldr	r3, [pc, #56]	; (410530 <xGMACWaitLS+0x84>)
  4104f8:	4798      	blx	r3
		xEndTime = xTaskGetTickCount();
  4104fa:	e7e0      	b.n	4104be <xGMACWaitLS+0x12>
	}

	FreeRTOS_printf( ( "xGMACWaitLS: %ld (PHY %d) freq %lu Mz\n",
  4104fc:	4b0d      	ldr	r3, [pc, #52]	; (410534 <xGMACWaitLS+0x88>)
  4104fe:	681c      	ldr	r4, [r3, #0]
  410500:	4b0d      	ldr	r3, [pc, #52]	; (410538 <xGMACWaitLS+0x8c>)
  410502:	4798      	blx	r3
  410504:	4602      	mov	r2, r0
  410506:	4b0d      	ldr	r3, [pc, #52]	; (41053c <xGMACWaitLS+0x90>)
  410508:	fba3 2302 	umull	r2, r3, r3, r2
  41050c:	0c9b      	lsrs	r3, r3, #18
  41050e:	4622      	mov	r2, r4
  410510:	6979      	ldr	r1, [r7, #20]
  410512:	480b      	ldr	r0, [pc, #44]	; (410540 <xGMACWaitLS+0x94>)
  410514:	4c0b      	ldr	r4, [pc, #44]	; (410544 <xGMACWaitLS+0x98>)
  410516:	47a0      	blx	r4
		xReturn,
		ethernet_phy_addr,
		sysclk_get_cpu_hz() / HZ_PER_MHZ ) );

	return xReturn;
  410518:	697b      	ldr	r3, [r7, #20]
}
  41051a:	4618      	mov	r0, r3
  41051c:	371c      	adds	r7, #28
  41051e:	46bd      	mov	sp, r7
  410520:	bd90      	pop	{r4, r7, pc}
  410522:	bf00      	nop
  410524:	004127d1 	.word	0x004127d1
  410528:	00410451 	.word	0x00410451
  41052c:	2000b374 	.word	0x2000b374
  410530:	0041256d 	.word	0x0041256d
  410534:	20006bc4 	.word	0x20006bc4
  410538:	004100cd 	.word	0x004100cd
  41053c:	431bde83 	.word	0x431bde83
  410540:	0041dfc0 	.word	0x0041dfc0
  410544:	00416c7d 	.word	0x00416c7d

00410548 <vGMACGenerateChecksum>:

//#if( ipconfigDRIVER_INCLUDED_TX_IP_CHECKSUM == 1 ) && ( ipconfigHAS_TX_CRC_OFFLOADING == 0 )

	//void vGMACGenerateChecksum( uint8_t *apBuffer )
	void vGMACGenerateChecksum( uint8_t *apBuffer, uint32_t ul_size ) // HICS
	{
  410548:	b580      	push	{r7, lr}
  41054a:	b084      	sub	sp, #16
  41054c:	af00      	add	r7, sp, #0
  41054e:	6078      	str	r0, [r7, #4]
  410550:	6039      	str	r1, [r7, #0]
	ProtocolPacket_t *xProtPacket = (ProtocolPacket_t *)apBuffer;
  410552:	687b      	ldr	r3, [r7, #4]
  410554:	60fb      	str	r3, [r7, #12]

		if ( xProtPacket->xTCPPacket.xEthernetHeader.usFrameType == ipIPv4_FRAME_TYPE )
  410556:	68fb      	ldr	r3, [r7, #12]
  410558:	899b      	ldrh	r3, [r3, #12]
  41055a:	b29b      	uxth	r3, r3
  41055c:	2b08      	cmp	r3, #8
  41055e:	d128      	bne.n	4105b2 <vGMACGenerateChecksum+0x6a>
		{
			IPHeader_t *pxIPHeader = &( xProtPacket->xTCPPacket.xIPHeader );
  410560:	68fb      	ldr	r3, [r7, #12]
  410562:	330e      	adds	r3, #14
  410564:	60bb      	str	r3, [r7, #8]

			/* Calculate the IP header checksum. */
			pxIPHeader->usHeaderChecksum = 0x00;
  410566:	68bb      	ldr	r3, [r7, #8]
  410568:	2200      	movs	r2, #0
  41056a:	729a      	strb	r2, [r3, #10]
  41056c:	2200      	movs	r2, #0
  41056e:	72da      	strb	r2, [r3, #11]
			pxIPHeader->usHeaderChecksum = usGenerateChecksum( 0u, ( uint8_t * ) &( pxIPHeader->ucVersionHeaderLength ), ipSIZE_OF_IPv4_HEADER );
  410570:	68bb      	ldr	r3, [r7, #8]
  410572:	2214      	movs	r2, #20
  410574:	4619      	mov	r1, r3
  410576:	2000      	movs	r0, #0
  410578:	4b10      	ldr	r3, [pc, #64]	; (4105bc <vGMACGenerateChecksum+0x74>)
  41057a:	4798      	blx	r3
  41057c:	4603      	mov	r3, r0
  41057e:	461a      	mov	r2, r3
  410580:	68bb      	ldr	r3, [r7, #8]
  410582:	815a      	strh	r2, [r3, #10]
			pxIPHeader->usHeaderChecksum = ~FreeRTOS_htons( pxIPHeader->usHeaderChecksum );
  410584:	68bb      	ldr	r3, [r7, #8]
  410586:	895b      	ldrh	r3, [r3, #10]
  410588:	b29b      	uxth	r3, r3
  41058a:	021b      	lsls	r3, r3, #8
  41058c:	b21a      	sxth	r2, r3
  41058e:	68bb      	ldr	r3, [r7, #8]
  410590:	895b      	ldrh	r3, [r3, #10]
  410592:	b29b      	uxth	r3, r3
  410594:	0a1b      	lsrs	r3, r3, #8
  410596:	b29b      	uxth	r3, r3
  410598:	b21b      	sxth	r3, r3
  41059a:	4313      	orrs	r3, r2
  41059c:	b21b      	sxth	r3, r3
  41059e:	b29b      	uxth	r3, r3
  4105a0:	43db      	mvns	r3, r3
  4105a2:	b29a      	uxth	r2, r3
  4105a4:	68bb      	ldr	r3, [r7, #8]
  4105a6:	815a      	strh	r2, [r3, #10]
			/* Calculate the TCP checksum for an outgoing packet. */
			//usGenerateProtocolChecksum( ( uint8_t * ) apBuffer, pdTRUE );
			//usGenerateProtocolChecksum( ( uint8_t * ) apBuffer, apBuffer->xDataLength, pdTRUE ); // HICS: NOK
			//xProtPacket->xTCPPacket->xEthernetHeader->
			//pxBuffer->xDataLength
			usGenerateProtocolChecksum( ( uint8_t * ) apBuffer, ul_size, pdTRUE ); // HICS
  4105a8:	2201      	movs	r2, #1
  4105aa:	6839      	ldr	r1, [r7, #0]
  4105ac:	6878      	ldr	r0, [r7, #4]
  4105ae:	4b04      	ldr	r3, [pc, #16]	; (4105c0 <vGMACGenerateChecksum+0x78>)
  4105b0:	4798      	blx	r3
			
			
			
		}
	}
  4105b2:	bf00      	nop
  4105b4:	3710      	adds	r7, #16
  4105b6:	46bd      	mov	sp, r7
  4105b8:	bd80      	pop	{r7, pc}
  4105ba:	bf00      	nop
  4105bc:	004085c5 	.word	0x004085c5
  4105c0:	004082e5 	.word	0x004082e5

004105c4 <prvEMACRxPoll>:

//#endif
/*-----------------------------------------------------------*/

static uint32_t prvEMACRxPoll( void )
{
  4105c4:	b590      	push	{r4, r7, lr}
  4105c6:	b087      	sub	sp, #28
  4105c8:	af00      	add	r7, sp, #0
unsigned char *pucUseBuffer;
uint32_t ulReceiveCount, ulResult, ulReturnValue = 0;
  4105ca:	2300      	movs	r3, #0
  4105cc:	613b      	str	r3, [r7, #16]
static NetworkBufferDescriptor_t *pxNextNetworkBufferDescriptor = NULL;
const UBaseType_t xMinDescriptorsToLeave = 2UL;
  4105ce:	2302      	movs	r3, #2
  4105d0:	60fb      	str	r3, [r7, #12]
const TickType_t xBlockTime = pdMS_TO_TICKS( 100UL );
  4105d2:	2364      	movs	r3, #100	; 0x64
  4105d4:	60bb      	str	r3, [r7, #8]

	for( ;; )
	{
		/* If pxNextNetworkBufferDescriptor was not left pointing at a valid
		descriptor then allocate one now. */
		if( ( pxNextNetworkBufferDescriptor == NULL ) && ( uxGetNumberOfFreeNetworkBuffers() > xMinDescriptorsToLeave ) )
  4105d6:	4b2a      	ldr	r3, [pc, #168]	; (410680 <prvEMACRxPoll+0xbc>)
  4105d8:	681b      	ldr	r3, [r3, #0]
  4105da:	2b00      	cmp	r3, #0
  4105dc:	d10d      	bne.n	4105fa <prvEMACRxPoll+0x36>
  4105de:	4b29      	ldr	r3, [pc, #164]	; (410684 <prvEMACRxPoll+0xc0>)
  4105e0:	4798      	blx	r3
  4105e2:	4602      	mov	r2, r0
  4105e4:	68fb      	ldr	r3, [r7, #12]
  4105e6:	429a      	cmp	r2, r3
  4105e8:	d907      	bls.n	4105fa <prvEMACRxPoll+0x36>
		{
			pxNextNetworkBufferDescriptor = pxGetNetworkBufferWithDescriptor( ipTOTAL_ETHERNET_FRAME_SIZE, xBlockTime );
  4105ea:	68b9      	ldr	r1, [r7, #8]
  4105ec:	f240 508e 	movw	r0, #1422	; 0x58e
  4105f0:	4b25      	ldr	r3, [pc, #148]	; (410688 <prvEMACRxPoll+0xc4>)
  4105f2:	4798      	blx	r3
  4105f4:	4602      	mov	r2, r0
  4105f6:	4b22      	ldr	r3, [pc, #136]	; (410680 <prvEMACRxPoll+0xbc>)
  4105f8:	601a      	str	r2, [r3, #0]
		}

		if( pxNextNetworkBufferDescriptor != NULL )
  4105fa:	4b21      	ldr	r3, [pc, #132]	; (410680 <prvEMACRxPoll+0xbc>)
  4105fc:	681b      	ldr	r3, [r3, #0]
  4105fe:	2b00      	cmp	r3, #0
  410600:	d005      	beq.n	41060e <prvEMACRxPoll+0x4a>
		{
			/* Point pucUseBuffer to the buffer pointed to by the descriptor. */
			pucUseBuffer = ( unsigned char* ) ( pxNextNetworkBufferDescriptor->pucEthernetBuffer - ipconfigPACKET_FILLER_SIZE );
  410602:	4b1f      	ldr	r3, [pc, #124]	; (410680 <prvEMACRxPoll+0xbc>)
  410604:	681b      	ldr	r3, [r3, #0]
  410606:	699b      	ldr	r3, [r3, #24]
  410608:	3b02      	subs	r3, #2
  41060a:	617b      	str	r3, [r7, #20]
  41060c:	e001      	b.n	410612 <prvEMACRxPoll+0x4e>
		}
		else
		{
			/* As long as pxNextNetworkBufferDescriptor is NULL, the incoming
			messages will be flushed and ignored. */
			pucUseBuffer = NULL;
  41060e:	2300      	movs	r3, #0
  410610:	617b      	str	r3, [r7, #20]
		}

		/* Read the next packet from the hardware into pucUseBuffer. */
		ulResult = gmac_dev_read( &gs_gmac_dev, pucUseBuffer, ipTOTAL_ETHERNET_FRAME_SIZE, &ulReceiveCount );
  410612:	463b      	mov	r3, r7
  410614:	f240 528e 	movw	r2, #1422	; 0x58e
  410618:	6979      	ldr	r1, [r7, #20]
  41061a:	481c      	ldr	r0, [pc, #112]	; (41068c <prvEMACRxPoll+0xc8>)
  41061c:	4c1c      	ldr	r4, [pc, #112]	; (410690 <prvEMACRxPoll+0xcc>)
  41061e:	47a0      	blx	r4
  410620:	6078      	str	r0, [r7, #4]

		if( ( ulResult != GMAC_OK ) || ( ulReceiveCount == 0 ) )
  410622:	687b      	ldr	r3, [r7, #4]
  410624:	2b00      	cmp	r3, #0
  410626:	d126      	bne.n	410676 <prvEMACRxPoll+0xb2>
  410628:	683b      	ldr	r3, [r7, #0]
  41062a:	2b00      	cmp	r3, #0
  41062c:	d023      	beq.n	410676 <prvEMACRxPoll+0xb2>
		{
			/* No data from the hardware. */
			break;
		}

		if( pxNextNetworkBufferDescriptor == NULL )
  41062e:	4b14      	ldr	r3, [pc, #80]	; (410680 <prvEMACRxPoll+0xbc>)
  410630:	681b      	ldr	r3, [r3, #0]
  410632:	2b00      	cmp	r3, #0
  410634:	d01d      	beq.n	410672 <prvEMACRxPoll+0xae>
			iptraceETHERNET_RX_EVENT_LOST();
			continue;
		}

		iptraceNETWORK_INTERFACE_RECEIVE();
		pxNextNetworkBufferDescriptor->xDataLength = ( size_t ) ulReceiveCount;
  410636:	4b12      	ldr	r3, [pc, #72]	; (410680 <prvEMACRxPoll+0xbc>)
  410638:	681b      	ldr	r3, [r3, #0]
  41063a:	683a      	ldr	r2, [r7, #0]
  41063c:	61da      	str	r2, [r3, #28]
		xRxEvent.pvData = ( void * ) pxNextNetworkBufferDescriptor;
  41063e:	4b10      	ldr	r3, [pc, #64]	; (410680 <prvEMACRxPoll+0xbc>)
  410640:	681b      	ldr	r3, [r3, #0]
  410642:	4a14      	ldr	r2, [pc, #80]	; (410694 <prvEMACRxPoll+0xd0>)
  410644:	6053      	str	r3, [r2, #4]

		/* Send the descriptor to the IP task for processing. */
		if( xSendEventStructToIPTask( &xRxEvent, xBlockTime ) != pdTRUE )
  410646:	68b9      	ldr	r1, [r7, #8]
  410648:	4812      	ldr	r0, [pc, #72]	; (410694 <prvEMACRxPoll+0xd0>)
  41064a:	4b13      	ldr	r3, [pc, #76]	; (410698 <prvEMACRxPoll+0xd4>)
  41064c:	4798      	blx	r3
  41064e:	4603      	mov	r3, r0
  410650:	2b01      	cmp	r3, #1
  410652:	d007      	beq.n	410664 <prvEMACRxPoll+0xa0>
		{
			/* The buffer could not be sent to the stack so must be released
			again. */
			vReleaseNetworkBufferAndDescriptor( pxNextNetworkBufferDescriptor );
  410654:	4b0a      	ldr	r3, [pc, #40]	; (410680 <prvEMACRxPoll+0xbc>)
  410656:	681b      	ldr	r3, [r3, #0]
  410658:	4618      	mov	r0, r3
  41065a:	4b10      	ldr	r3, [pc, #64]	; (41069c <prvEMACRxPoll+0xd8>)
  41065c:	4798      	blx	r3
			iptraceETHERNET_RX_EVENT_LOST();
			FreeRTOS_printf( ( "prvEMACRxPoll: Can not queue return packet!\n" ) );
  41065e:	4810      	ldr	r0, [pc, #64]	; (4106a0 <prvEMACRxPoll+0xdc>)
  410660:	4b10      	ldr	r3, [pc, #64]	; (4106a4 <prvEMACRxPoll+0xe0>)
  410662:	4798      	blx	r3
		}

		/* Now the buffer has either been passed to the IP-task,
		or it has been released in the code above. */
		pxNextNetworkBufferDescriptor = NULL;
  410664:	4b06      	ldr	r3, [pc, #24]	; (410680 <prvEMACRxPoll+0xbc>)
  410666:	2200      	movs	r2, #0
  410668:	601a      	str	r2, [r3, #0]
		ulReturnValue++;
  41066a:	693b      	ldr	r3, [r7, #16]
  41066c:	3301      	adds	r3, #1
  41066e:	613b      	str	r3, [r7, #16]
  410670:	e7b1      	b.n	4105d6 <prvEMACRxPoll+0x12>
			continue;
  410672:	bf00      	nop
		if( ( pxNextNetworkBufferDescriptor == NULL ) && ( uxGetNumberOfFreeNetworkBuffers() > xMinDescriptorsToLeave ) )
  410674:	e7af      	b.n	4105d6 <prvEMACRxPoll+0x12>
	}

	return ulReturnValue;
  410676:	693b      	ldr	r3, [r7, #16]
}
  410678:	4618      	mov	r0, r3
  41067a:	371c      	adds	r7, #28
  41067c:	46bd      	mov	sp, r7
  41067e:	bd90      	pop	{r4, r7, pc}
  410680:	2000b3bc 	.word	0x2000b3bc
  410684:	0040f369 	.word	0x0040f369
  410688:	0040f1d5 	.word	0x0040f1d5
  41068c:	2000b37c 	.word	0x2000b37c
  410690:	0040fb8d 	.word	0x0040fb8d
  410694:	20000120 	.word	0x20000120
  410698:	00407e49 	.word	0x00407e49
  41069c:	0040f2ed 	.word	0x0040f2ed
  4106a0:	0041dfe8 	.word	0x0041dfe8
  4106a4:	00416c7d 	.word	0x00416c7d

004106a8 <vCheckBuffersAndQueue>:
/*-----------------------------------------------------------*/

void vCheckBuffersAndQueue( void )
{
  4106a8:	b580      	push	{r7, lr}
  4106aa:	af00      	add	r7, sp, #0
#endif
static UBaseType_t uxCurrentCount;

	#if( ipconfigCHECK_IP_QUEUE_SPACE != 0 )
	{
		uxCurrentCount = uxGetMinimumIPQueueSpace();
  4106ac:	4b17      	ldr	r3, [pc, #92]	; (41070c <vCheckBuffersAndQueue+0x64>)
  4106ae:	4798      	blx	r3
  4106b0:	4602      	mov	r2, r0
  4106b2:	4b17      	ldr	r3, [pc, #92]	; (410710 <vCheckBuffersAndQueue+0x68>)
  4106b4:	601a      	str	r2, [r3, #0]
		if( uxLastMinQueueSpace != uxCurrentCount )
  4106b6:	4b17      	ldr	r3, [pc, #92]	; (410714 <vCheckBuffersAndQueue+0x6c>)
  4106b8:	681a      	ldr	r2, [r3, #0]
  4106ba:	4b15      	ldr	r3, [pc, #84]	; (410710 <vCheckBuffersAndQueue+0x68>)
  4106bc:	681b      	ldr	r3, [r3, #0]
  4106be:	429a      	cmp	r2, r3
  4106c0:	d009      	beq.n	4106d6 <vCheckBuffersAndQueue+0x2e>
		{
			/* The logging produced below may be helpful
			while tuning +TCP: see how many buffers are in use. */
			uxLastMinQueueSpace = uxCurrentCount;
  4106c2:	4b13      	ldr	r3, [pc, #76]	; (410710 <vCheckBuffersAndQueue+0x68>)
  4106c4:	681b      	ldr	r3, [r3, #0]
  4106c6:	4a13      	ldr	r2, [pc, #76]	; (410714 <vCheckBuffersAndQueue+0x6c>)
  4106c8:	6013      	str	r3, [r2, #0]
			FreeRTOS_printf( ( "Queue space: lowest %lu\n", uxCurrentCount ) );
  4106ca:	4b11      	ldr	r3, [pc, #68]	; (410710 <vCheckBuffersAndQueue+0x68>)
  4106cc:	681b      	ldr	r3, [r3, #0]
  4106ce:	4619      	mov	r1, r3
  4106d0:	4811      	ldr	r0, [pc, #68]	; (410718 <vCheckBuffersAndQueue+0x70>)
  4106d2:	4b12      	ldr	r3, [pc, #72]	; (41071c <vCheckBuffersAndQueue+0x74>)
  4106d4:	4798      	blx	r3
		}
	}
	#endif /* ipconfigCHECK_IP_QUEUE_SPACE */
	uxCurrentCount = uxGetMinimumFreeNetworkBuffers();
  4106d6:	4b12      	ldr	r3, [pc, #72]	; (410720 <vCheckBuffersAndQueue+0x78>)
  4106d8:	4798      	blx	r3
  4106da:	4602      	mov	r2, r0
  4106dc:	4b0c      	ldr	r3, [pc, #48]	; (410710 <vCheckBuffersAndQueue+0x68>)
  4106de:	601a      	str	r2, [r3, #0]
	if( uxLastMinBufferCount != uxCurrentCount )
  4106e0:	4b10      	ldr	r3, [pc, #64]	; (410724 <vCheckBuffersAndQueue+0x7c>)
  4106e2:	681a      	ldr	r2, [r3, #0]
  4106e4:	4b0a      	ldr	r3, [pc, #40]	; (410710 <vCheckBuffersAndQueue+0x68>)
  4106e6:	681b      	ldr	r3, [r3, #0]
  4106e8:	429a      	cmp	r2, r3
  4106ea:	d00c      	beq.n	410706 <vCheckBuffersAndQueue+0x5e>
	{
		/* The logging produced below may be helpful
		while tuning +TCP: see how many buffers are in use. */
		uxLastMinBufferCount = uxCurrentCount;
  4106ec:	4b08      	ldr	r3, [pc, #32]	; (410710 <vCheckBuffersAndQueue+0x68>)
  4106ee:	681b      	ldr	r3, [r3, #0]
  4106f0:	4a0c      	ldr	r2, [pc, #48]	; (410724 <vCheckBuffersAndQueue+0x7c>)
  4106f2:	6013      	str	r3, [r2, #0]
		FreeRTOS_printf( ( "Network buffers: %lu lowest %lu\n",
  4106f4:	4b0c      	ldr	r3, [pc, #48]	; (410728 <vCheckBuffersAndQueue+0x80>)
  4106f6:	4798      	blx	r3
  4106f8:	4601      	mov	r1, r0
  4106fa:	4b05      	ldr	r3, [pc, #20]	; (410710 <vCheckBuffersAndQueue+0x68>)
  4106fc:	681b      	ldr	r3, [r3, #0]
  4106fe:	461a      	mov	r2, r3
  410700:	480a      	ldr	r0, [pc, #40]	; (41072c <vCheckBuffersAndQueue+0x84>)
  410702:	4b06      	ldr	r3, [pc, #24]	; (41071c <vCheckBuffersAndQueue+0x74>)
  410704:	4798      	blx	r3
			uxGetNumberOfFreeNetworkBuffers(), uxCurrentCount ) );
	}

}
  410706:	bf00      	nop
  410708:	bd80      	pop	{r7, pc}
  41070a:	bf00      	nop
  41070c:	004087cd 	.word	0x004087cd
  410710:	2000b3c0 	.word	0x2000b3c0
  410714:	2000b3c4 	.word	0x2000b3c4
  410718:	0041e018 	.word	0x0041e018
  41071c:	00416c7d 	.word	0x00416c7d
  410720:	0040f381 	.word	0x0040f381
  410724:	2000b3c8 	.word	0x2000b3c8
  410728:	0040f369 	.word	0x0040f369
  41072c:	0041e034 	.word	0x0041e034

00410730 <prvEMACHandlerTask>:

static void prvEMACHandlerTask( void *pvParameters )
{
  410730:	b590      	push	{r4, r7, lr}
  410732:	b08b      	sub	sp, #44	; 0x2c
  410734:	af00      	add	r7, sp, #0
  410736:	6078      	str	r0, [r7, #4]
UBaseType_t uxCount;
#if( ipconfigZERO_COPY_TX_DRIVER != 0 )
	NetworkBufferDescriptor_t *pxBuffer;
#endif
uint8_t *pucBuffer;
BaseType_t xResult = 0;
  410738:	2300      	movs	r3, #0
  41073a:	627b      	str	r3, [r7, #36]	; 0x24
uint32_t xStatus;
const TickType_t ulMaxBlockTime = pdMS_TO_TICKS( EMAC_MAX_BLOCK_TIME_MS );
  41073c:	2364      	movs	r3, #100	; 0x64
  41073e:	623b      	str	r3, [r7, #32]

	/* Remove compiler warnings about unused parameters. */
	( void ) pvParameters;

	configASSERT( xEMACTaskHandle );
  410740:	4b57      	ldr	r3, [pc, #348]	; (4108a0 <prvEMACHandlerTask+0x170>)
  410742:	681b      	ldr	r3, [r3, #0]
  410744:	2b00      	cmp	r3, #0
  410746:	d105      	bne.n	410754 <prvEMACHandlerTask+0x24>
  410748:	f44f 720f 	mov.w	r2, #572	; 0x23c
  41074c:	4955      	ldr	r1, [pc, #340]	; (4108a4 <prvEMACHandlerTask+0x174>)
  41074e:	4856      	ldr	r0, [pc, #344]	; (4108a8 <prvEMACHandlerTask+0x178>)
  410750:	4b56      	ldr	r3, [pc, #344]	; (4108ac <prvEMACHandlerTask+0x17c>)
  410752:	4798      	blx	r3

	vTaskSetTimeOutState( &xPhyTime );
  410754:	f107 0310 	add.w	r3, r7, #16
  410758:	4618      	mov	r0, r3
  41075a:	4b55      	ldr	r3, [pc, #340]	; (4108b0 <prvEMACHandlerTask+0x180>)
  41075c:	4798      	blx	r3
	xPhyRemTime = pdMS_TO_TICKS( PHY_LS_LOW_CHECK_TIME_MS );
  41075e:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
  410762:	60fb      	str	r3, [r7, #12]

	for( ;; )
	{
		vCheckBuffersAndQueue();
  410764:	4b53      	ldr	r3, [pc, #332]	; (4108b4 <prvEMACHandlerTask+0x184>)
  410766:	4798      	blx	r3

		if( ( ulISREvents & EMAC_IF_ALL_EVENT ) == 0 )
  410768:	4b53      	ldr	r3, [pc, #332]	; (4108b8 <prvEMACHandlerTask+0x188>)
  41076a:	681b      	ldr	r3, [r3, #0]
  41076c:	f003 0307 	and.w	r3, r3, #7
  410770:	2b00      	cmp	r3, #0
  410772:	d103      	bne.n	41077c <prvEMACHandlerTask+0x4c>
		{
			/* No events to process now, wait for the next. */
			ulTaskNotifyTake( pdFALSE, ulMaxBlockTime );
  410774:	6a39      	ldr	r1, [r7, #32]
  410776:	2000      	movs	r0, #0
  410778:	4b50      	ldr	r3, [pc, #320]	; (4108bc <prvEMACHandlerTask+0x18c>)
  41077a:	4798      	blx	r3
		}

		if( ( ulISREvents & EMAC_IF_RX_EVENT ) != 0 )
  41077c:	4b4e      	ldr	r3, [pc, #312]	; (4108b8 <prvEMACHandlerTask+0x188>)
  41077e:	681b      	ldr	r3, [r3, #0]
  410780:	f003 0301 	and.w	r3, r3, #1
  410784:	2b00      	cmp	r3, #0
  410786:	d009      	beq.n	41079c <prvEMACHandlerTask+0x6c>
		{
			ulISREvents &= ~EMAC_IF_RX_EVENT;
  410788:	4b4b      	ldr	r3, [pc, #300]	; (4108b8 <prvEMACHandlerTask+0x188>)
  41078a:	681b      	ldr	r3, [r3, #0]
  41078c:	f023 0301 	bic.w	r3, r3, #1
  410790:	4a49      	ldr	r2, [pc, #292]	; (4108b8 <prvEMACHandlerTask+0x188>)
  410792:	6013      	str	r3, [r2, #0]

			/* Wait for the EMAC interrupt to indicate that another packet has been
			received. */
			xResult = prvEMACRxPoll();
  410794:	4b4a      	ldr	r3, [pc, #296]	; (4108c0 <prvEMACHandlerTask+0x190>)
  410796:	4798      	blx	r3
  410798:	4603      	mov	r3, r0
  41079a:	627b      	str	r3, [r7, #36]	; 0x24
		}

		if( ( ulISREvents & EMAC_IF_TX_EVENT ) != 0 )
  41079c:	4b46      	ldr	r3, [pc, #280]	; (4108b8 <prvEMACHandlerTask+0x188>)
  41079e:	681b      	ldr	r3, [r3, #0]
  4107a0:	f003 0302 	and.w	r3, r3, #2
  4107a4:	2b00      	cmp	r3, #0
  4107a6:	d026      	beq.n	4107f6 <prvEMACHandlerTask+0xc6>
		{
			/* Future extension: code to release TX buffers if zero-copy is used. */
			ulISREvents &= ~EMAC_IF_TX_EVENT;
  4107a8:	4b43      	ldr	r3, [pc, #268]	; (4108b8 <prvEMACHandlerTask+0x188>)
  4107aa:	681b      	ldr	r3, [r3, #0]
  4107ac:	f023 0302 	bic.w	r3, r3, #2
  4107b0:	4a41      	ldr	r2, [pc, #260]	; (4108b8 <prvEMACHandlerTask+0x188>)
  4107b2:	6013      	str	r3, [r2, #0]
			while( xQueueReceive( xTxBufferQueue, &pucBuffer, 0 ) != pdFALSE )
  4107b4:	e014      	b.n	4107e0 <prvEMACHandlerTask+0xb0>
						tx_release_count[ 1 ]++;
					}
				}
				#else
				{
					tx_release_count[ 0 ]++;
  4107b6:	4b43      	ldr	r3, [pc, #268]	; (4108c4 <prvEMACHandlerTask+0x194>)
  4107b8:	681b      	ldr	r3, [r3, #0]
  4107ba:	3301      	adds	r3, #1
  4107bc:	4a41      	ldr	r2, [pc, #260]	; (4108c4 <prvEMACHandlerTask+0x194>)
  4107be:	6013      	str	r3, [r2, #0]
				}
				#endif
				uxCount = uxQueueMessagesWaiting( ( QueueHandle_t ) xTXDescriptorSemaphore );
  4107c0:	4b41      	ldr	r3, [pc, #260]	; (4108c8 <prvEMACHandlerTask+0x198>)
  4107c2:	681b      	ldr	r3, [r3, #0]
  4107c4:	4618      	mov	r0, r3
  4107c6:	4b41      	ldr	r3, [pc, #260]	; (4108cc <prvEMACHandlerTask+0x19c>)
  4107c8:	4798      	blx	r3
  4107ca:	61b8      	str	r0, [r7, #24]
				if( uxCount < GMAC_TX_BUFFERS )
  4107cc:	69bb      	ldr	r3, [r7, #24]
  4107ce:	2b07      	cmp	r3, #7
  4107d0:	d806      	bhi.n	4107e0 <prvEMACHandlerTask+0xb0>
				{
					/* Tell the counting semaphore that one more TX descriptor is available. */
					xSemaphoreGive( xTXDescriptorSemaphore );
  4107d2:	4b3d      	ldr	r3, [pc, #244]	; (4108c8 <prvEMACHandlerTask+0x198>)
  4107d4:	6818      	ldr	r0, [r3, #0]
  4107d6:	2300      	movs	r3, #0
  4107d8:	2200      	movs	r2, #0
  4107da:	2100      	movs	r1, #0
  4107dc:	4c3c      	ldr	r4, [pc, #240]	; (4108d0 <prvEMACHandlerTask+0x1a0>)
  4107de:	47a0      	blx	r4
			while( xQueueReceive( xTxBufferQueue, &pucBuffer, 0 ) != pdFALSE )
  4107e0:	4b3c      	ldr	r3, [pc, #240]	; (4108d4 <prvEMACHandlerTask+0x1a4>)
  4107e2:	681b      	ldr	r3, [r3, #0]
  4107e4:	f107 0108 	add.w	r1, r7, #8
  4107e8:	2200      	movs	r2, #0
  4107ea:	4618      	mov	r0, r3
  4107ec:	4b3a      	ldr	r3, [pc, #232]	; (4108d8 <prvEMACHandlerTask+0x1a8>)
  4107ee:	4798      	blx	r3
  4107f0:	4603      	mov	r3, r0
  4107f2:	2b00      	cmp	r3, #0
  4107f4:	d1df      	bne.n	4107b6 <prvEMACHandlerTask+0x86>
				}
			}
		}

		if( ( ulISREvents & EMAC_IF_ERR_EVENT ) != 0 )
  4107f6:	4b30      	ldr	r3, [pc, #192]	; (4108b8 <prvEMACHandlerTask+0x188>)
  4107f8:	681b      	ldr	r3, [r3, #0]
  4107fa:	f003 0304 	and.w	r3, r3, #4
  4107fe:	2b00      	cmp	r3, #0
  410800:	d005      	beq.n	41080e <prvEMACHandlerTask+0xde>
		{
			/* Future extension: logging about errors that occurred. */
			ulISREvents &= ~EMAC_IF_ERR_EVENT;
  410802:	4b2d      	ldr	r3, [pc, #180]	; (4108b8 <prvEMACHandlerTask+0x188>)
  410804:	681b      	ldr	r3, [r3, #0]
  410806:	f023 0304 	bic.w	r3, r3, #4
  41080a:	4a2b      	ldr	r2, [pc, #172]	; (4108b8 <prvEMACHandlerTask+0x188>)
  41080c:	6013      	str	r3, [r2, #0]
		}

		if( xResult > 0 )
  41080e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  410810:	2b00      	cmp	r3, #0
  410812:	dd0a      	ble.n	41082a <prvEMACHandlerTask+0xfa>
		{
			/* A packet was received. No need to check for the PHY status now,
			but set a timer to check it later on. */
			vTaskSetTimeOutState( &xPhyTime );
  410814:	f107 0310 	add.w	r3, r7, #16
  410818:	4618      	mov	r0, r3
  41081a:	4b25      	ldr	r3, [pc, #148]	; (4108b0 <prvEMACHandlerTask+0x180>)
  41081c:	4798      	blx	r3
			xPhyRemTime = pdMS_TO_TICKS( PHY_LS_HIGH_CHECK_TIME_MS );
  41081e:	f643 2398 	movw	r3, #15000	; 0x3a98
  410822:	60fb      	str	r3, [r7, #12]
			xResult = 0;
  410824:	2300      	movs	r3, #0
  410826:	627b      	str	r3, [r7, #36]	; 0x24
  410828:	e79c      	b.n	410764 <prvEMACHandlerTask+0x34>
		}
		else if( xTaskCheckForTimeOut( &xPhyTime, &xPhyRemTime ) != pdFALSE )
  41082a:	f107 020c 	add.w	r2, r7, #12
  41082e:	f107 0310 	add.w	r3, r7, #16
  410832:	4611      	mov	r1, r2
  410834:	4618      	mov	r0, r3
  410836:	4b29      	ldr	r3, [pc, #164]	; (4108dc <prvEMACHandlerTask+0x1ac>)
  410838:	4798      	blx	r3
  41083a:	4603      	mov	r3, r0
  41083c:	2b00      	cmp	r3, #0
  41083e:	d091      	beq.n	410764 <prvEMACHandlerTask+0x34>
		{
			/* Check the link status again. */
			xStatus = ulReadMDIO( PHY_REG_01_BMSR );
  410840:	2001      	movs	r0, #1
  410842:	4b27      	ldr	r3, [pc, #156]	; (4108e0 <prvEMACHandlerTask+0x1b0>)
  410844:	4798      	blx	r3
  410846:	61f8      	str	r0, [r7, #28]

			if( ( ulPHYLinkStatus & BMSR_LINK_STATUS ) != ( xStatus & BMSR_LINK_STATUS ) )
  410848:	4b26      	ldr	r3, [pc, #152]	; (4108e4 <prvEMACHandlerTask+0x1b4>)
  41084a:	681a      	ldr	r2, [r3, #0]
  41084c:	69fb      	ldr	r3, [r7, #28]
  41084e:	4053      	eors	r3, r2
  410850:	f003 0304 	and.w	r3, r3, #4
  410854:	2b00      	cmp	r3, #0
  410856:	d00f      	beq.n	410878 <prvEMACHandlerTask+0x148>
			{
				ulPHYLinkStatus = xStatus;
  410858:	4a22      	ldr	r2, [pc, #136]	; (4108e4 <prvEMACHandlerTask+0x1b4>)
  41085a:	69fb      	ldr	r3, [r7, #28]
  41085c:	6013      	str	r3, [r2, #0]
				FreeRTOS_printf( ( "prvEMACHandlerTask: PHY LS now %d\n", ( ulPHYLinkStatus & BMSR_LINK_STATUS ) != 0 ) );
  41085e:	4b21      	ldr	r3, [pc, #132]	; (4108e4 <prvEMACHandlerTask+0x1b4>)
  410860:	681b      	ldr	r3, [r3, #0]
  410862:	f003 0304 	and.w	r3, r3, #4
  410866:	2b00      	cmp	r3, #0
  410868:	bf14      	ite	ne
  41086a:	2301      	movne	r3, #1
  41086c:	2300      	moveq	r3, #0
  41086e:	b2db      	uxtb	r3, r3
  410870:	4619      	mov	r1, r3
  410872:	481d      	ldr	r0, [pc, #116]	; (4108e8 <prvEMACHandlerTask+0x1b8>)
  410874:	4b0d      	ldr	r3, [pc, #52]	; (4108ac <prvEMACHandlerTask+0x17c>)
  410876:	4798      	blx	r3
			}

			vTaskSetTimeOutState( &xPhyTime );
  410878:	f107 0310 	add.w	r3, r7, #16
  41087c:	4618      	mov	r0, r3
  41087e:	4b0c      	ldr	r3, [pc, #48]	; (4108b0 <prvEMACHandlerTask+0x180>)
  410880:	4798      	blx	r3
			if( ( ulPHYLinkStatus & BMSR_LINK_STATUS ) != 0 )
  410882:	4b18      	ldr	r3, [pc, #96]	; (4108e4 <prvEMACHandlerTask+0x1b4>)
  410884:	681b      	ldr	r3, [r3, #0]
  410886:	f003 0304 	and.w	r3, r3, #4
  41088a:	2b00      	cmp	r3, #0
  41088c:	d003      	beq.n	410896 <prvEMACHandlerTask+0x166>
			{
				xPhyRemTime = pdMS_TO_TICKS( PHY_LS_HIGH_CHECK_TIME_MS );
  41088e:	f643 2398 	movw	r3, #15000	; 0x3a98
  410892:	60fb      	str	r3, [r7, #12]
  410894:	e766      	b.n	410764 <prvEMACHandlerTask+0x34>
			}
			else
			{
				xPhyRemTime = pdMS_TO_TICKS( PHY_LS_LOW_CHECK_TIME_MS );
  410896:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
  41089a:	60fb      	str	r3, [r7, #12]
		vCheckBuffersAndQueue();
  41089c:	e762      	b.n	410764 <prvEMACHandlerTask+0x34>
  41089e:	bf00      	nop
  4108a0:	2000b3b0 	.word	0x2000b3b0
  4108a4:	0041df3c 	.word	0x0041df3c
  4108a8:	0041dfb0 	.word	0x0041dfb0
  4108ac:	00416c7d 	.word	0x00416c7d
  4108b0:	00412c89 	.word	0x00412c89
  4108b4:	004106a9 	.word	0x004106a9
  4108b8:	2000b370 	.word	0x2000b370
  4108bc:	00413279 	.word	0x00413279
  4108c0:	004105c5 	.word	0x004105c5
  4108c4:	2000b5d8 	.word	0x2000b5d8
  4108c8:	2000b3b8 	.word	0x2000b3b8
  4108cc:	00411fa9 	.word	0x00411fa9
  4108d0:	00411831 	.word	0x00411831
  4108d4:	2000b3b4 	.word	0x2000b3b4
  4108d8:	00411c15 	.word	0x00411c15
  4108dc:	00412d0d 	.word	0x00412d0d
  4108e0:	00410451 	.word	0x00410451
  4108e4:	2000b374 	.word	0x2000b374
  4108e8:	0041e058 	.word	0x0041e058

004108ec <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
  4108ec:	b580      	push	{r7, lr}
  4108ee:	b082      	sub	sp, #8
  4108f0:	af00      	add	r7, sp, #0
		TickType_t alignment requirements the cast is safe.  In other cases,
		where the natural word size of the architecture is less than
		sizeof( TickType_t ), the TickType_t variables will be accessed in two
		or more reads operations, and the alignment requirements is only that
		of each individual read. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
  4108f2:	2018      	movs	r0, #24
  4108f4:	4b09      	ldr	r3, [pc, #36]	; (41091c <xEventGroupCreate+0x30>)
  4108f6:	4798      	blx	r3
  4108f8:	6078      	str	r0, [r7, #4]

		if( pxEventBits != NULL )
  4108fa:	687b      	ldr	r3, [r7, #4]
  4108fc:	2b00      	cmp	r3, #0
  4108fe:	d007      	beq.n	410910 <xEventGroupCreate+0x24>
		{
			pxEventBits->uxEventBits = 0;
  410900:	687b      	ldr	r3, [r7, #4]
  410902:	2200      	movs	r2, #0
  410904:	601a      	str	r2, [r3, #0]
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
  410906:	687b      	ldr	r3, [r7, #4]
  410908:	3304      	adds	r3, #4
  41090a:	4618      	mov	r0, r3
  41090c:	4b04      	ldr	r3, [pc, #16]	; (410920 <xEventGroupCreate+0x34>)
  41090e:	4798      	blx	r3
		else
		{
			traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
		}

		return pxEventBits;
  410910:	687b      	ldr	r3, [r7, #4]
	}
  410912:	4618      	mov	r0, r3
  410914:	3708      	adds	r7, #8
  410916:	46bd      	mov	sp, r7
  410918:	bd80      	pop	{r7, pc}
  41091a:	bf00      	nop
  41091c:	004111e5 	.word	0x004111e5
  410920:	00410ce1 	.word	0x00410ce1

00410924 <xEventGroupWaitBits>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
  410924:	b580      	push	{r7, lr}
  410926:	b08c      	sub	sp, #48	; 0x30
  410928:	af00      	add	r7, sp, #0
  41092a:	60f8      	str	r0, [r7, #12]
  41092c:	60b9      	str	r1, [r7, #8]
  41092e:	607a      	str	r2, [r7, #4]
  410930:	603b      	str	r3, [r7, #0]
EventGroup_t *pxEventBits = xEventGroup;
  410932:	68fb      	ldr	r3, [r7, #12]
  410934:	627b      	str	r3, [r7, #36]	; 0x24
EventBits_t uxReturn, uxControlBits = 0;
  410936:	2300      	movs	r3, #0
  410938:	62bb      	str	r3, [r7, #40]	; 0x28
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
  41093a:	2300      	movs	r3, #0
  41093c:	623b      	str	r3, [r7, #32]

	/* Check the user is not attempting to wait on the bits used by the kernel
	itself, and that at least one bit is being requested. */
	configASSERT( xEventGroup );
  41093e:	68fb      	ldr	r3, [r7, #12]
  410940:	2b00      	cmp	r3, #0
  410942:	d105      	bne.n	410950 <xEventGroupWaitBits+0x2c>
  410944:	f44f 72a0 	mov.w	r2, #320	; 0x140
  410948:	4949      	ldr	r1, [pc, #292]	; (410a70 <xEventGroupWaitBits+0x14c>)
  41094a:	484a      	ldr	r0, [pc, #296]	; (410a74 <xEventGroupWaitBits+0x150>)
  41094c:	4b4a      	ldr	r3, [pc, #296]	; (410a78 <xEventGroupWaitBits+0x154>)
  41094e:	4798      	blx	r3
	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
  410950:	68bb      	ldr	r3, [r7, #8]
  410952:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
  410956:	2b00      	cmp	r3, #0
  410958:	d005      	beq.n	410966 <xEventGroupWaitBits+0x42>
  41095a:	f240 1241 	movw	r2, #321	; 0x141
  41095e:	4944      	ldr	r1, [pc, #272]	; (410a70 <xEventGroupWaitBits+0x14c>)
  410960:	4844      	ldr	r0, [pc, #272]	; (410a74 <xEventGroupWaitBits+0x150>)
  410962:	4b45      	ldr	r3, [pc, #276]	; (410a78 <xEventGroupWaitBits+0x154>)
  410964:	4798      	blx	r3
	configASSERT( uxBitsToWaitFor != 0 );
  410966:	68bb      	ldr	r3, [r7, #8]
  410968:	2b00      	cmp	r3, #0
  41096a:	d105      	bne.n	410978 <xEventGroupWaitBits+0x54>
  41096c:	f44f 72a1 	mov.w	r2, #322	; 0x142
  410970:	493f      	ldr	r1, [pc, #252]	; (410a70 <xEventGroupWaitBits+0x14c>)
  410972:	4840      	ldr	r0, [pc, #256]	; (410a74 <xEventGroupWaitBits+0x150>)
  410974:	4b40      	ldr	r3, [pc, #256]	; (410a78 <xEventGroupWaitBits+0x154>)
  410976:	4798      	blx	r3
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
  410978:	4b40      	ldr	r3, [pc, #256]	; (410a7c <xEventGroupWaitBits+0x158>)
  41097a:	4798      	blx	r3
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
  41097c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  41097e:	681b      	ldr	r3, [r3, #0]
  410980:	61fb      	str	r3, [r7, #28]

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
  410982:	683a      	ldr	r2, [r7, #0]
  410984:	68b9      	ldr	r1, [r7, #8]
  410986:	69f8      	ldr	r0, [r7, #28]
  410988:	4b3d      	ldr	r3, [pc, #244]	; (410a80 <xEventGroupWaitBits+0x15c>)
  41098a:	4798      	blx	r3
  41098c:	61b8      	str	r0, [r7, #24]

		if( xWaitConditionMet != pdFALSE )
  41098e:	69bb      	ldr	r3, [r7, #24]
  410990:	2b00      	cmp	r3, #0
  410992:	d00e      	beq.n	4109b2 <xEventGroupWaitBits+0x8e>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
  410994:	69fb      	ldr	r3, [r7, #28]
  410996:	62fb      	str	r3, [r7, #44]	; 0x2c
			xTicksToWait = ( TickType_t ) 0;
  410998:	2300      	movs	r3, #0
  41099a:	63bb      	str	r3, [r7, #56]	; 0x38

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
  41099c:	687b      	ldr	r3, [r7, #4]
  41099e:	2b00      	cmp	r3, #0
  4109a0:	d028      	beq.n	4109f4 <xEventGroupWaitBits+0xd0>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
  4109a2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4109a4:	681a      	ldr	r2, [r3, #0]
  4109a6:	68bb      	ldr	r3, [r7, #8]
  4109a8:	43db      	mvns	r3, r3
  4109aa:	401a      	ands	r2, r3
  4109ac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4109ae:	601a      	str	r2, [r3, #0]
  4109b0:	e020      	b.n	4109f4 <xEventGroupWaitBits+0xd0>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
  4109b2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  4109b4:	2b00      	cmp	r3, #0
  4109b6:	d104      	bne.n	4109c2 <xEventGroupWaitBits+0x9e>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
  4109b8:	69fb      	ldr	r3, [r7, #28]
  4109ba:	62fb      	str	r3, [r7, #44]	; 0x2c
			xTimeoutOccurred = pdTRUE;
  4109bc:	2301      	movs	r3, #1
  4109be:	623b      	str	r3, [r7, #32]
  4109c0:	e018      	b.n	4109f4 <xEventGroupWaitBits+0xd0>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
  4109c2:	687b      	ldr	r3, [r7, #4]
  4109c4:	2b00      	cmp	r3, #0
  4109c6:	d003      	beq.n	4109d0 <xEventGroupWaitBits+0xac>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
  4109c8:	6abb      	ldr	r3, [r7, #40]	; 0x28
  4109ca:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
  4109ce:	62bb      	str	r3, [r7, #40]	; 0x28
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
  4109d0:	683b      	ldr	r3, [r7, #0]
  4109d2:	2b00      	cmp	r3, #0
  4109d4:	d003      	beq.n	4109de <xEventGroupWaitBits+0xba>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
  4109d6:	6abb      	ldr	r3, [r7, #40]	; 0x28
  4109d8:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
  4109dc:	62bb      	str	r3, [r7, #40]	; 0x28
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
  4109de:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4109e0:	1d18      	adds	r0, r3, #4
  4109e2:	68ba      	ldr	r2, [r7, #8]
  4109e4:	6abb      	ldr	r3, [r7, #40]	; 0x28
  4109e6:	4313      	orrs	r3, r2
  4109e8:	6bba      	ldr	r2, [r7, #56]	; 0x38
  4109ea:	4619      	mov	r1, r3
  4109ec:	4b25      	ldr	r3, [pc, #148]	; (410a84 <xEventGroupWaitBits+0x160>)
  4109ee:	4798      	blx	r3

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
  4109f0:	2300      	movs	r3, #0
  4109f2:	62fb      	str	r3, [r7, #44]	; 0x2c

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
  4109f4:	4b24      	ldr	r3, [pc, #144]	; (410a88 <xEventGroupWaitBits+0x164>)
  4109f6:	4798      	blx	r3
  4109f8:	6178      	str	r0, [r7, #20]

	if( xTicksToWait != ( TickType_t ) 0 )
  4109fa:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  4109fc:	2b00      	cmp	r3, #0
  4109fe:	d031      	beq.n	410a64 <xEventGroupWaitBits+0x140>
	{
		if( xAlreadyYielded == pdFALSE )
  410a00:	697b      	ldr	r3, [r7, #20]
  410a02:	2b00      	cmp	r3, #0
  410a04:	d107      	bne.n	410a16 <xEventGroupWaitBits+0xf2>
		{
			portYIELD_WITHIN_API();
  410a06:	4b21      	ldr	r3, [pc, #132]	; (410a8c <xEventGroupWaitBits+0x168>)
  410a08:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  410a0c:	601a      	str	r2, [r3, #0]
  410a0e:	f3bf 8f4f 	dsb	sy
  410a12:	f3bf 8f6f 	isb	sy

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
  410a16:	4b1e      	ldr	r3, [pc, #120]	; (410a90 <xEventGroupWaitBits+0x16c>)
  410a18:	4798      	blx	r3
  410a1a:	62f8      	str	r0, [r7, #44]	; 0x2c

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
  410a1c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  410a1e:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
  410a22:	2b00      	cmp	r3, #0
  410a24:	d11a      	bne.n	410a5c <xEventGroupWaitBits+0x138>
		{
			taskENTER_CRITICAL();
  410a26:	4b1b      	ldr	r3, [pc, #108]	; (410a94 <xEventGroupWaitBits+0x170>)
  410a28:	4798      	blx	r3
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
  410a2a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  410a2c:	681b      	ldr	r3, [r3, #0]
  410a2e:	62fb      	str	r3, [r7, #44]	; 0x2c

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
  410a30:	683a      	ldr	r2, [r7, #0]
  410a32:	68b9      	ldr	r1, [r7, #8]
  410a34:	6af8      	ldr	r0, [r7, #44]	; 0x2c
  410a36:	4b12      	ldr	r3, [pc, #72]	; (410a80 <xEventGroupWaitBits+0x15c>)
  410a38:	4798      	blx	r3
  410a3a:	4603      	mov	r3, r0
  410a3c:	2b00      	cmp	r3, #0
  410a3e:	d009      	beq.n	410a54 <xEventGroupWaitBits+0x130>
				{
					if( xClearOnExit != pdFALSE )
  410a40:	687b      	ldr	r3, [r7, #4]
  410a42:	2b00      	cmp	r3, #0
  410a44:	d006      	beq.n	410a54 <xEventGroupWaitBits+0x130>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
  410a46:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  410a48:	681a      	ldr	r2, [r3, #0]
  410a4a:	68bb      	ldr	r3, [r7, #8]
  410a4c:	43db      	mvns	r3, r3
  410a4e:	401a      	ands	r2, r3
  410a50:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  410a52:	601a      	str	r2, [r3, #0]
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				xTimeoutOccurred = pdTRUE;
  410a54:	2301      	movs	r3, #1
  410a56:	623b      	str	r3, [r7, #32]
			}
			taskEXIT_CRITICAL();
  410a58:	4b0f      	ldr	r3, [pc, #60]	; (410a98 <xEventGroupWaitBits+0x174>)
  410a5a:	4798      	blx	r3
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
  410a5c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  410a5e:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
  410a62:	62fb      	str	r3, [r7, #44]	; 0x2c
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
  410a64:	6afb      	ldr	r3, [r7, #44]	; 0x2c
}
  410a66:	4618      	mov	r0, r3
  410a68:	3730      	adds	r7, #48	; 0x30
  410a6a:	46bd      	mov	sp, r7
  410a6c:	bd80      	pop	{r7, pc}
  410a6e:	bf00      	nop
  410a70:	0041e07c 	.word	0x0041e07c
  410a74:	0041e0bc 	.word	0x0041e0bc
  410a78:	00416c7d 	.word	0x00416c7d
  410a7c:	0041267d 	.word	0x0041267d
  410a80:	00410c9d 	.word	0x00410c9d
  410a84:	00412a7d 	.word	0x00412a7d
  410a88:	00412699 	.word	0x00412699
  410a8c:	e000ed04 	.word	0xe000ed04
  410a90:	00413221 	.word	0x00413221
  410a94:	0041103d 	.word	0x0041103d
  410a98:	00411099 	.word	0x00411099

00410a9c <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
  410a9c:	b580      	push	{r7, lr}
  410a9e:	b084      	sub	sp, #16
  410aa0:	af00      	add	r7, sp, #0
  410aa2:	6078      	str	r0, [r7, #4]
  410aa4:	6039      	str	r1, [r7, #0]
EventGroup_t *pxEventBits = xEventGroup;
  410aa6:	687b      	ldr	r3, [r7, #4]
  410aa8:	60fb      	str	r3, [r7, #12]
EventBits_t uxReturn;

	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
  410aaa:	687b      	ldr	r3, [r7, #4]
  410aac:	2b00      	cmp	r3, #0
  410aae:	d105      	bne.n	410abc <xEventGroupClearBits+0x20>
  410ab0:	f44f 72ea 	mov.w	r2, #468	; 0x1d4
  410ab4:	4910      	ldr	r1, [pc, #64]	; (410af8 <xEventGroupClearBits+0x5c>)
  410ab6:	4811      	ldr	r0, [pc, #68]	; (410afc <xEventGroupClearBits+0x60>)
  410ab8:	4b11      	ldr	r3, [pc, #68]	; (410b00 <xEventGroupClearBits+0x64>)
  410aba:	4798      	blx	r3
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
  410abc:	683b      	ldr	r3, [r7, #0]
  410abe:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
  410ac2:	2b00      	cmp	r3, #0
  410ac4:	d005      	beq.n	410ad2 <xEventGroupClearBits+0x36>
  410ac6:	f240 12d5 	movw	r2, #469	; 0x1d5
  410aca:	490b      	ldr	r1, [pc, #44]	; (410af8 <xEventGroupClearBits+0x5c>)
  410acc:	480b      	ldr	r0, [pc, #44]	; (410afc <xEventGroupClearBits+0x60>)
  410ace:	4b0c      	ldr	r3, [pc, #48]	; (410b00 <xEventGroupClearBits+0x64>)
  410ad0:	4798      	blx	r3

	taskENTER_CRITICAL();
  410ad2:	4b0c      	ldr	r3, [pc, #48]	; (410b04 <xEventGroupClearBits+0x68>)
  410ad4:	4798      	blx	r3
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
  410ad6:	68fb      	ldr	r3, [r7, #12]
  410ad8:	681b      	ldr	r3, [r3, #0]
  410ada:	60bb      	str	r3, [r7, #8]

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
  410adc:	68fb      	ldr	r3, [r7, #12]
  410ade:	681a      	ldr	r2, [r3, #0]
  410ae0:	683b      	ldr	r3, [r7, #0]
  410ae2:	43db      	mvns	r3, r3
  410ae4:	401a      	ands	r2, r3
  410ae6:	68fb      	ldr	r3, [r7, #12]
  410ae8:	601a      	str	r2, [r3, #0]
	}
	taskEXIT_CRITICAL();
  410aea:	4b07      	ldr	r3, [pc, #28]	; (410b08 <xEventGroupClearBits+0x6c>)
  410aec:	4798      	blx	r3

	return uxReturn;
  410aee:	68bb      	ldr	r3, [r7, #8]
}
  410af0:	4618      	mov	r0, r3
  410af2:	3710      	adds	r7, #16
  410af4:	46bd      	mov	sp, r7
  410af6:	bd80      	pop	{r7, pc}
  410af8:	0041e07c 	.word	0x0041e07c
  410afc:	0041e0bc 	.word	0x0041e0bc
  410b00:	00416c7d 	.word	0x00416c7d
  410b04:	0041103d 	.word	0x0041103d
  410b08:	00411099 	.word	0x00411099

00410b0c <xEventGroupSetBits>:
	return uxReturn;
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
  410b0c:	b580      	push	{r7, lr}
  410b0e:	b08c      	sub	sp, #48	; 0x30
  410b10:	af00      	add	r7, sp, #0
  410b12:	6078      	str	r0, [r7, #4]
  410b14:	6039      	str	r1, [r7, #0]
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
  410b16:	2300      	movs	r3, #0
  410b18:	62bb      	str	r3, [r7, #40]	; 0x28
EventGroup_t *pxEventBits = xEventGroup;
  410b1a:	687b      	ldr	r3, [r7, #4]
  410b1c:	623b      	str	r3, [r7, #32]
BaseType_t xMatchFound = pdFALSE;
  410b1e:	2300      	movs	r3, #0
  410b20:	627b      	str	r3, [r7, #36]	; 0x24

	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
  410b22:	687b      	ldr	r3, [r7, #4]
  410b24:	2b00      	cmp	r3, #0
  410b26:	d105      	bne.n	410b34 <xEventGroupSetBits+0x28>
  410b28:	f240 2212 	movw	r2, #530	; 0x212
  410b2c:	4938      	ldr	r1, [pc, #224]	; (410c10 <xEventGroupSetBits+0x104>)
  410b2e:	4839      	ldr	r0, [pc, #228]	; (410c14 <xEventGroupSetBits+0x108>)
  410b30:	4b39      	ldr	r3, [pc, #228]	; (410c18 <xEventGroupSetBits+0x10c>)
  410b32:	4798      	blx	r3
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
  410b34:	683b      	ldr	r3, [r7, #0]
  410b36:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
  410b3a:	2b00      	cmp	r3, #0
  410b3c:	d005      	beq.n	410b4a <xEventGroupSetBits+0x3e>
  410b3e:	f240 2213 	movw	r2, #531	; 0x213
  410b42:	4933      	ldr	r1, [pc, #204]	; (410c10 <xEventGroupSetBits+0x104>)
  410b44:	4833      	ldr	r0, [pc, #204]	; (410c14 <xEventGroupSetBits+0x108>)
  410b46:	4b34      	ldr	r3, [pc, #208]	; (410c18 <xEventGroupSetBits+0x10c>)
  410b48:	4798      	blx	r3

	pxList = &( pxEventBits->xTasksWaitingForBits );
  410b4a:	6a3b      	ldr	r3, [r7, #32]
  410b4c:	3304      	adds	r3, #4
  410b4e:	61fb      	str	r3, [r7, #28]
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  410b50:	69fb      	ldr	r3, [r7, #28]
  410b52:	3308      	adds	r3, #8
  410b54:	61bb      	str	r3, [r7, #24]
	vTaskSuspendAll();
  410b56:	4b31      	ldr	r3, [pc, #196]	; (410c1c <xEventGroupSetBits+0x110>)
  410b58:	4798      	blx	r3
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
  410b5a:	69fb      	ldr	r3, [r7, #28]
  410b5c:	68db      	ldr	r3, [r3, #12]
  410b5e:	62fb      	str	r3, [r7, #44]	; 0x2c

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
  410b60:	6a3b      	ldr	r3, [r7, #32]
  410b62:	681a      	ldr	r2, [r3, #0]
  410b64:	683b      	ldr	r3, [r7, #0]
  410b66:	431a      	orrs	r2, r3
  410b68:	6a3b      	ldr	r3, [r7, #32]
  410b6a:	601a      	str	r2, [r3, #0]

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
  410b6c:	e03c      	b.n	410be8 <xEventGroupSetBits+0xdc>
		{
			pxNext = listGET_NEXT( pxListItem );
  410b6e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  410b70:	685b      	ldr	r3, [r3, #4]
  410b72:	617b      	str	r3, [r7, #20]
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
  410b74:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  410b76:	681b      	ldr	r3, [r3, #0]
  410b78:	613b      	str	r3, [r7, #16]
			xMatchFound = pdFALSE;
  410b7a:	2300      	movs	r3, #0
  410b7c:	627b      	str	r3, [r7, #36]	; 0x24

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
  410b7e:	693b      	ldr	r3, [r7, #16]
  410b80:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
  410b84:	60fb      	str	r3, [r7, #12]
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
  410b86:	693b      	ldr	r3, [r7, #16]
  410b88:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
  410b8c:	613b      	str	r3, [r7, #16]

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
  410b8e:	68fb      	ldr	r3, [r7, #12]
  410b90:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
  410b94:	2b00      	cmp	r3, #0
  410b96:	d108      	bne.n	410baa <xEventGroupSetBits+0x9e>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
  410b98:	6a3b      	ldr	r3, [r7, #32]
  410b9a:	681a      	ldr	r2, [r3, #0]
  410b9c:	693b      	ldr	r3, [r7, #16]
  410b9e:	4013      	ands	r3, r2
  410ba0:	2b00      	cmp	r3, #0
  410ba2:	d00b      	beq.n	410bbc <xEventGroupSetBits+0xb0>
				{
					xMatchFound = pdTRUE;
  410ba4:	2301      	movs	r3, #1
  410ba6:	627b      	str	r3, [r7, #36]	; 0x24
  410ba8:	e008      	b.n	410bbc <xEventGroupSetBits+0xb0>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
  410baa:	6a3b      	ldr	r3, [r7, #32]
  410bac:	681a      	ldr	r2, [r3, #0]
  410bae:	693b      	ldr	r3, [r7, #16]
  410bb0:	401a      	ands	r2, r3
  410bb2:	693b      	ldr	r3, [r7, #16]
  410bb4:	429a      	cmp	r2, r3
  410bb6:	d101      	bne.n	410bbc <xEventGroupSetBits+0xb0>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
  410bb8:	2301      	movs	r3, #1
  410bba:	627b      	str	r3, [r7, #36]	; 0x24
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
  410bbc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  410bbe:	2b00      	cmp	r3, #0
  410bc0:	d010      	beq.n	410be4 <xEventGroupSetBits+0xd8>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
  410bc2:	68fb      	ldr	r3, [r7, #12]
  410bc4:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
  410bc8:	2b00      	cmp	r3, #0
  410bca:	d003      	beq.n	410bd4 <xEventGroupSetBits+0xc8>
				{
					uxBitsToClear |= uxBitsWaitedFor;
  410bcc:	6aba      	ldr	r2, [r7, #40]	; 0x28
  410bce:	693b      	ldr	r3, [r7, #16]
  410bd0:	4313      	orrs	r3, r2
  410bd2:	62bb      	str	r3, [r7, #40]	; 0x28
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
  410bd4:	6a3b      	ldr	r3, [r7, #32]
  410bd6:	681b      	ldr	r3, [r3, #0]
  410bd8:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
  410bdc:	4619      	mov	r1, r3
  410bde:	6af8      	ldr	r0, [r7, #44]	; 0x2c
  410be0:	4b0f      	ldr	r3, [pc, #60]	; (410c20 <xEventGroupSetBits+0x114>)
  410be2:	4798      	blx	r3
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
  410be4:	697b      	ldr	r3, [r7, #20]
  410be6:	62fb      	str	r3, [r7, #44]	; 0x2c
		while( pxListItem != pxListEnd )
  410be8:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  410bea:	69bb      	ldr	r3, [r7, #24]
  410bec:	429a      	cmp	r2, r3
  410bee:	d1be      	bne.n	410b6e <xEventGroupSetBits+0x62>
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
  410bf0:	6a3b      	ldr	r3, [r7, #32]
  410bf2:	681a      	ldr	r2, [r3, #0]
  410bf4:	6abb      	ldr	r3, [r7, #40]	; 0x28
  410bf6:	43db      	mvns	r3, r3
  410bf8:	401a      	ands	r2, r3
  410bfa:	6a3b      	ldr	r3, [r7, #32]
  410bfc:	601a      	str	r2, [r3, #0]
	}
	( void ) xTaskResumeAll();
  410bfe:	4b09      	ldr	r3, [pc, #36]	; (410c24 <xEventGroupSetBits+0x118>)
  410c00:	4798      	blx	r3

	return pxEventBits->uxEventBits;
  410c02:	6a3b      	ldr	r3, [r7, #32]
  410c04:	681b      	ldr	r3, [r3, #0]
}
  410c06:	4618      	mov	r0, r3
  410c08:	3730      	adds	r7, #48	; 0x30
  410c0a:	46bd      	mov	sp, r7
  410c0c:	bd80      	pop	{r7, pc}
  410c0e:	bf00      	nop
  410c10:	0041e07c 	.word	0x0041e07c
  410c14:	0041e0bc 	.word	0x0041e0bc
  410c18:	00416c7d 	.word	0x00416c7d
  410c1c:	0041267d 	.word	0x0041267d
  410c20:	00412bc5 	.word	0x00412bc5
  410c24:	00412699 	.word	0x00412699

00410c28 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
  410c28:	b580      	push	{r7, lr}
  410c2a:	b084      	sub	sp, #16
  410c2c:	af00      	add	r7, sp, #0
  410c2e:	6078      	str	r0, [r7, #4]
EventGroup_t *pxEventBits = xEventGroup;
  410c30:	687b      	ldr	r3, [r7, #4]
  410c32:	60fb      	str	r3, [r7, #12]
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
  410c34:	68fb      	ldr	r3, [r7, #12]
  410c36:	3304      	adds	r3, #4
  410c38:	60bb      	str	r3, [r7, #8]

	vTaskSuspendAll();
  410c3a:	4b11      	ldr	r3, [pc, #68]	; (410c80 <vEventGroupDelete+0x58>)
  410c3c:	4798      	blx	r3
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
  410c3e:	e012      	b.n	410c66 <vEventGroupDelete+0x3e>
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
  410c40:	68bb      	ldr	r3, [r7, #8]
  410c42:	68da      	ldr	r2, [r3, #12]
  410c44:	68bb      	ldr	r3, [r7, #8]
  410c46:	3308      	adds	r3, #8
  410c48:	429a      	cmp	r2, r3
  410c4a:	d105      	bne.n	410c58 <vEventGroupDelete+0x30>
  410c4c:	f240 2272 	movw	r2, #626	; 0x272
  410c50:	490c      	ldr	r1, [pc, #48]	; (410c84 <vEventGroupDelete+0x5c>)
  410c52:	480d      	ldr	r0, [pc, #52]	; (410c88 <vEventGroupDelete+0x60>)
  410c54:	4b0d      	ldr	r3, [pc, #52]	; (410c8c <vEventGroupDelete+0x64>)
  410c56:	4798      	blx	r3
			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
  410c58:	68bb      	ldr	r3, [r7, #8]
  410c5a:	68db      	ldr	r3, [r3, #12]
  410c5c:	f04f 7100 	mov.w	r1, #33554432	; 0x2000000
  410c60:	4618      	mov	r0, r3
  410c62:	4b0b      	ldr	r3, [pc, #44]	; (410c90 <vEventGroupDelete+0x68>)
  410c64:	4798      	blx	r3
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
  410c66:	68bb      	ldr	r3, [r7, #8]
  410c68:	681b      	ldr	r3, [r3, #0]
  410c6a:	2b00      	cmp	r3, #0
  410c6c:	d1e8      	bne.n	410c40 <vEventGroupDelete+0x18>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
  410c6e:	68f8      	ldr	r0, [r7, #12]
  410c70:	4b08      	ldr	r3, [pc, #32]	; (410c94 <vEventGroupDelete+0x6c>)
  410c72:	4798      	blx	r3
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
  410c74:	4b08      	ldr	r3, [pc, #32]	; (410c98 <vEventGroupDelete+0x70>)
  410c76:	4798      	blx	r3
}
  410c78:	bf00      	nop
  410c7a:	3710      	adds	r7, #16
  410c7c:	46bd      	mov	sp, r7
  410c7e:	bd80      	pop	{r7, pc}
  410c80:	0041267d 	.word	0x0041267d
  410c84:	0041e07c 	.word	0x0041e07c
  410c88:	0041e0bc 	.word	0x0041e0bc
  410c8c:	00416c7d 	.word	0x00416c7d
  410c90:	00412bc5 	.word	0x00412bc5
  410c94:	004113a1 	.word	0x004113a1
  410c98:	00412699 	.word	0x00412699

00410c9c <prvTestWaitCondition>:
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
}
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
  410c9c:	b480      	push	{r7}
  410c9e:	b087      	sub	sp, #28
  410ca0:	af00      	add	r7, sp, #0
  410ca2:	60f8      	str	r0, [r7, #12]
  410ca4:	60b9      	str	r1, [r7, #8]
  410ca6:	607a      	str	r2, [r7, #4]
BaseType_t xWaitConditionMet = pdFALSE;
  410ca8:	2300      	movs	r3, #0
  410caa:	617b      	str	r3, [r7, #20]

	if( xWaitForAllBits == pdFALSE )
  410cac:	687b      	ldr	r3, [r7, #4]
  410cae:	2b00      	cmp	r3, #0
  410cb0:	d107      	bne.n	410cc2 <prvTestWaitCondition+0x26>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
  410cb2:	68fa      	ldr	r2, [r7, #12]
  410cb4:	68bb      	ldr	r3, [r7, #8]
  410cb6:	4013      	ands	r3, r2
  410cb8:	2b00      	cmp	r3, #0
  410cba:	d00a      	beq.n	410cd2 <prvTestWaitCondition+0x36>
		{
			xWaitConditionMet = pdTRUE;
  410cbc:	2301      	movs	r3, #1
  410cbe:	617b      	str	r3, [r7, #20]
  410cc0:	e007      	b.n	410cd2 <prvTestWaitCondition+0x36>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
  410cc2:	68fa      	ldr	r2, [r7, #12]
  410cc4:	68bb      	ldr	r3, [r7, #8]
  410cc6:	401a      	ands	r2, r3
  410cc8:	68bb      	ldr	r3, [r7, #8]
  410cca:	429a      	cmp	r2, r3
  410ccc:	d101      	bne.n	410cd2 <prvTestWaitCondition+0x36>
		{
			xWaitConditionMet = pdTRUE;
  410cce:	2301      	movs	r3, #1
  410cd0:	617b      	str	r3, [r7, #20]
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
  410cd2:	697b      	ldr	r3, [r7, #20]
}
  410cd4:	4618      	mov	r0, r3
  410cd6:	371c      	adds	r7, #28
  410cd8:	46bd      	mov	sp, r7
  410cda:	f85d 7b04 	ldr.w	r7, [sp], #4
  410cde:	4770      	bx	lr

00410ce0 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
  410ce0:	b480      	push	{r7}
  410ce2:	b083      	sub	sp, #12
  410ce4:	af00      	add	r7, sp, #0
  410ce6:	6078      	str	r0, [r7, #4]
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  410ce8:	687b      	ldr	r3, [r7, #4]
  410cea:	f103 0208 	add.w	r2, r3, #8
  410cee:	687b      	ldr	r3, [r7, #4]
  410cf0:	605a      	str	r2, [r3, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
  410cf2:	687b      	ldr	r3, [r7, #4]
  410cf4:	f04f 32ff 	mov.w	r2, #4294967295
  410cf8:	609a      	str	r2, [r3, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  410cfa:	687b      	ldr	r3, [r7, #4]
  410cfc:	f103 0208 	add.w	r2, r3, #8
  410d00:	687b      	ldr	r3, [r7, #4]
  410d02:	60da      	str	r2, [r3, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  410d04:	687b      	ldr	r3, [r7, #4]
  410d06:	f103 0208 	add.w	r2, r3, #8
  410d0a:	687b      	ldr	r3, [r7, #4]
  410d0c:	611a      	str	r2, [r3, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
  410d0e:	687b      	ldr	r3, [r7, #4]
  410d10:	2200      	movs	r2, #0
  410d12:	601a      	str	r2, [r3, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
  410d14:	bf00      	nop
  410d16:	370c      	adds	r7, #12
  410d18:	46bd      	mov	sp, r7
  410d1a:	f85d 7b04 	ldr.w	r7, [sp], #4
  410d1e:	4770      	bx	lr

00410d20 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
  410d20:	b480      	push	{r7}
  410d22:	b083      	sub	sp, #12
  410d24:	af00      	add	r7, sp, #0
  410d26:	6078      	str	r0, [r7, #4]
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
  410d28:	687b      	ldr	r3, [r7, #4]
  410d2a:	2200      	movs	r2, #0
  410d2c:	611a      	str	r2, [r3, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
  410d2e:	bf00      	nop
  410d30:	370c      	adds	r7, #12
  410d32:	46bd      	mov	sp, r7
  410d34:	f85d 7b04 	ldr.w	r7, [sp], #4
  410d38:	4770      	bx	lr

00410d3a <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
  410d3a:	b480      	push	{r7}
  410d3c:	b085      	sub	sp, #20
  410d3e:	af00      	add	r7, sp, #0
  410d40:	6078      	str	r0, [r7, #4]
  410d42:	6039      	str	r1, [r7, #0]
ListItem_t * const pxIndex = pxList->pxIndex;
  410d44:	687b      	ldr	r3, [r7, #4]
  410d46:	685b      	ldr	r3, [r3, #4]
  410d48:	60fb      	str	r3, [r7, #12]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
  410d4a:	683b      	ldr	r3, [r7, #0]
  410d4c:	68fa      	ldr	r2, [r7, #12]
  410d4e:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
  410d50:	68fb      	ldr	r3, [r7, #12]
  410d52:	689a      	ldr	r2, [r3, #8]
  410d54:	683b      	ldr	r3, [r7, #0]
  410d56:	609a      	str	r2, [r3, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
  410d58:	68fb      	ldr	r3, [r7, #12]
  410d5a:	689b      	ldr	r3, [r3, #8]
  410d5c:	683a      	ldr	r2, [r7, #0]
  410d5e:	605a      	str	r2, [r3, #4]
	pxIndex->pxPrevious = pxNewListItem;
  410d60:	68fb      	ldr	r3, [r7, #12]
  410d62:	683a      	ldr	r2, [r7, #0]
  410d64:	609a      	str	r2, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
  410d66:	683b      	ldr	r3, [r7, #0]
  410d68:	687a      	ldr	r2, [r7, #4]
  410d6a:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
  410d6c:	687b      	ldr	r3, [r7, #4]
  410d6e:	681b      	ldr	r3, [r3, #0]
  410d70:	1c5a      	adds	r2, r3, #1
  410d72:	687b      	ldr	r3, [r7, #4]
  410d74:	601a      	str	r2, [r3, #0]
}
  410d76:	bf00      	nop
  410d78:	3714      	adds	r7, #20
  410d7a:	46bd      	mov	sp, r7
  410d7c:	f85d 7b04 	ldr.w	r7, [sp], #4
  410d80:	4770      	bx	lr

00410d82 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
  410d82:	b480      	push	{r7}
  410d84:	b085      	sub	sp, #20
  410d86:	af00      	add	r7, sp, #0
  410d88:	6078      	str	r0, [r7, #4]
  410d8a:	6039      	str	r1, [r7, #0]
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
  410d8c:	683b      	ldr	r3, [r7, #0]
  410d8e:	681b      	ldr	r3, [r3, #0]
  410d90:	60bb      	str	r3, [r7, #8]
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
  410d92:	68bb      	ldr	r3, [r7, #8]
  410d94:	f1b3 3fff 	cmp.w	r3, #4294967295
  410d98:	d103      	bne.n	410da2 <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
  410d9a:	687b      	ldr	r3, [r7, #4]
  410d9c:	691b      	ldr	r3, [r3, #16]
  410d9e:	60fb      	str	r3, [r7, #12]
  410da0:	e00c      	b.n	410dbc <vListInsert+0x3a>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
  410da2:	687b      	ldr	r3, [r7, #4]
  410da4:	3308      	adds	r3, #8
  410da6:	60fb      	str	r3, [r7, #12]
  410da8:	e002      	b.n	410db0 <vListInsert+0x2e>
  410daa:	68fb      	ldr	r3, [r7, #12]
  410dac:	685b      	ldr	r3, [r3, #4]
  410dae:	60fb      	str	r3, [r7, #12]
  410db0:	68fb      	ldr	r3, [r7, #12]
  410db2:	685b      	ldr	r3, [r3, #4]
  410db4:	681a      	ldr	r2, [r3, #0]
  410db6:	68bb      	ldr	r3, [r7, #8]
  410db8:	429a      	cmp	r2, r3
  410dba:	d9f6      	bls.n	410daa <vListInsert+0x28>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
  410dbc:	68fb      	ldr	r3, [r7, #12]
  410dbe:	685a      	ldr	r2, [r3, #4]
  410dc0:	683b      	ldr	r3, [r7, #0]
  410dc2:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
  410dc4:	683b      	ldr	r3, [r7, #0]
  410dc6:	685b      	ldr	r3, [r3, #4]
  410dc8:	683a      	ldr	r2, [r7, #0]
  410dca:	609a      	str	r2, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
  410dcc:	683b      	ldr	r3, [r7, #0]
  410dce:	68fa      	ldr	r2, [r7, #12]
  410dd0:	609a      	str	r2, [r3, #8]
	pxIterator->pxNext = pxNewListItem;
  410dd2:	68fb      	ldr	r3, [r7, #12]
  410dd4:	683a      	ldr	r2, [r7, #0]
  410dd6:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
  410dd8:	683b      	ldr	r3, [r7, #0]
  410dda:	687a      	ldr	r2, [r7, #4]
  410ddc:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
  410dde:	687b      	ldr	r3, [r7, #4]
  410de0:	681b      	ldr	r3, [r3, #0]
  410de2:	1c5a      	adds	r2, r3, #1
  410de4:	687b      	ldr	r3, [r7, #4]
  410de6:	601a      	str	r2, [r3, #0]
}
  410de8:	bf00      	nop
  410dea:	3714      	adds	r7, #20
  410dec:	46bd      	mov	sp, r7
  410dee:	f85d 7b04 	ldr.w	r7, [sp], #4
  410df2:	4770      	bx	lr

00410df4 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
  410df4:	b480      	push	{r7}
  410df6:	b085      	sub	sp, #20
  410df8:	af00      	add	r7, sp, #0
  410dfa:	6078      	str	r0, [r7, #4]
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
  410dfc:	687b      	ldr	r3, [r7, #4]
  410dfe:	691b      	ldr	r3, [r3, #16]
  410e00:	60fb      	str	r3, [r7, #12]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
  410e02:	687b      	ldr	r3, [r7, #4]
  410e04:	685b      	ldr	r3, [r3, #4]
  410e06:	687a      	ldr	r2, [r7, #4]
  410e08:	6892      	ldr	r2, [r2, #8]
  410e0a:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
  410e0c:	687b      	ldr	r3, [r7, #4]
  410e0e:	689b      	ldr	r3, [r3, #8]
  410e10:	687a      	ldr	r2, [r7, #4]
  410e12:	6852      	ldr	r2, [r2, #4]
  410e14:	605a      	str	r2, [r3, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
  410e16:	68fb      	ldr	r3, [r7, #12]
  410e18:	685a      	ldr	r2, [r3, #4]
  410e1a:	687b      	ldr	r3, [r7, #4]
  410e1c:	429a      	cmp	r2, r3
  410e1e:	d103      	bne.n	410e28 <uxListRemove+0x34>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
  410e20:	687b      	ldr	r3, [r7, #4]
  410e22:	689a      	ldr	r2, [r3, #8]
  410e24:	68fb      	ldr	r3, [r7, #12]
  410e26:	605a      	str	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
  410e28:	687b      	ldr	r3, [r7, #4]
  410e2a:	2200      	movs	r2, #0
  410e2c:	611a      	str	r2, [r3, #16]
	( pxList->uxNumberOfItems )--;
  410e2e:	68fb      	ldr	r3, [r7, #12]
  410e30:	681b      	ldr	r3, [r3, #0]
  410e32:	1e5a      	subs	r2, r3, #1
  410e34:	68fb      	ldr	r3, [r7, #12]
  410e36:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
  410e38:	68fb      	ldr	r3, [r7, #12]
  410e3a:	681b      	ldr	r3, [r3, #0]
}
  410e3c:	4618      	mov	r0, r3
  410e3e:	3714      	adds	r7, #20
  410e40:	46bd      	mov	sp, r7
  410e42:	f85d 7b04 	ldr.w	r7, [sp], #4
  410e46:	4770      	bx	lr

00410e48 <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
  410e48:	b480      	push	{r7}
  410e4a:	b085      	sub	sp, #20
  410e4c:	af00      	add	r7, sp, #0
  410e4e:	60f8      	str	r0, [r7, #12]
  410e50:	60b9      	str	r1, [r7, #8]
  410e52:	607a      	str	r2, [r7, #4]
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */
	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
  410e54:	68fb      	ldr	r3, [r7, #12]
  410e56:	3b04      	subs	r3, #4
  410e58:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
  410e5a:	68fb      	ldr	r3, [r7, #12]
  410e5c:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
  410e60:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
  410e62:	68fb      	ldr	r3, [r7, #12]
  410e64:	3b04      	subs	r3, #4
  410e66:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
  410e68:	68bb      	ldr	r3, [r7, #8]
  410e6a:	f023 0201 	bic.w	r2, r3, #1
  410e6e:	68fb      	ldr	r3, [r7, #12]
  410e70:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
  410e72:	68fb      	ldr	r3, [r7, #12]
  410e74:	3b04      	subs	r3, #4
  410e76:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
  410e78:	4a09      	ldr	r2, [pc, #36]	; (410ea0 <pxPortInitialiseStack+0x58>)
  410e7a:	68fb      	ldr	r3, [r7, #12]
  410e7c:	601a      	str	r2, [r3, #0]
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
  410e7e:	68fb      	ldr	r3, [r7, #12]
  410e80:	3b14      	subs	r3, #20
  410e82:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
  410e84:	687a      	ldr	r2, [r7, #4]
  410e86:	68fb      	ldr	r3, [r7, #12]
  410e88:	601a      	str	r2, [r3, #0]
	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
  410e8a:	68fb      	ldr	r3, [r7, #12]
  410e8c:	3b20      	subs	r3, #32
  410e8e:	60fb      	str	r3, [r7, #12]

	return pxTopOfStack;
  410e90:	68fb      	ldr	r3, [r7, #12]
}
  410e92:	4618      	mov	r0, r3
  410e94:	3714      	adds	r7, #20
  410e96:	46bd      	mov	sp, r7
  410e98:	f85d 7b04 	ldr.w	r7, [sp], #4
  410e9c:	4770      	bx	lr
  410e9e:	bf00      	nop
  410ea0:	00410ea5 	.word	0x00410ea5

00410ea4 <prvTaskExitError>:
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
  410ea4:	b580      	push	{r7, lr}
  410ea6:	b082      	sub	sp, #8
  410ea8:	af00      	add	r7, sp, #0
volatile uint32_t ulDummy = 0UL;
  410eaa:	2300      	movs	r3, #0
  410eac:	603b      	str	r3, [r7, #0]
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
  410eae:	4b0d      	ldr	r3, [pc, #52]	; (410ee4 <prvTaskExitError+0x40>)
  410eb0:	681b      	ldr	r3, [r3, #0]
  410eb2:	f1b3 3fff 	cmp.w	r3, #4294967295
  410eb6:	d004      	beq.n	410ec2 <prvTaskExitError+0x1e>
  410eb8:	22cd      	movs	r2, #205	; 0xcd
  410eba:	490b      	ldr	r1, [pc, #44]	; (410ee8 <prvTaskExitError+0x44>)
  410ebc:	480b      	ldr	r0, [pc, #44]	; (410eec <prvTaskExitError+0x48>)
  410ebe:	4b0c      	ldr	r3, [pc, #48]	; (410ef0 <prvTaskExitError+0x4c>)
  410ec0:	4798      	blx	r3

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
  410ec2:	f04f 0350 	mov.w	r3, #80	; 0x50
  410ec6:	f383 8811 	msr	BASEPRI, r3
  410eca:	f3bf 8f6f 	isb	sy
  410ece:	f3bf 8f4f 	dsb	sy
  410ed2:	607b      	str	r3, [r7, #4]
	portDISABLE_INTERRUPTS();
	while( ulDummy == 0 )
  410ed4:	bf00      	nop
  410ed6:	683b      	ldr	r3, [r7, #0]
  410ed8:	2b00      	cmp	r3, #0
  410eda:	d0fc      	beq.n	410ed6 <prvTaskExitError+0x32>
		about code appearing after this function is called - making ulDummy
		volatile makes the compiler think the function could return and
		therefore not output an 'unreachable code' warning for code that appears
		after it. */
	}
}
  410edc:	bf00      	nop
  410ede:	3708      	adds	r7, #8
  410ee0:	46bd      	mov	sp, r7
  410ee2:	bd80      	pop	{r7, pc}
  410ee4:	20000128 	.word	0x20000128
  410ee8:	0041e0cc 	.word	0x0041e0cc
  410eec:	0041e118 	.word	0x0041e118
  410ef0:	00416c7d 	.word	0x00416c7d
	...

00410f00 <SVC_Handler>:
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
  410f00:	4b07      	ldr	r3, [pc, #28]	; (410f20 <pxCurrentTCBConst2>)
  410f02:	6819      	ldr	r1, [r3, #0]
  410f04:	6808      	ldr	r0, [r1, #0]
  410f06:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
  410f0a:	f380 8809 	msr	PSP, r0
  410f0e:	f3bf 8f6f 	isb	sy
  410f12:	f04f 0000 	mov.w	r0, #0
  410f16:	f380 8811 	msr	BASEPRI, r0
  410f1a:	f04e 0e0d 	orr.w	lr, lr, #13
  410f1e:	4770      	bx	lr

00410f20 <pxCurrentTCBConst2>:
  410f20:	2000b404 	.word	0x2000b404
					"	bx r14							\n"
					"									\n"
					"	.align 4						\n"
					"pxCurrentTCBConst2: .word pxCurrentTCB				\n"
				);
}
  410f24:	bf00      	nop
  410f26:	bf00      	nop

00410f28 <prvPortStartFirstTask>:
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile(
  410f28:	4806      	ldr	r0, [pc, #24]	; (410f44 <prvPortStartFirstTask+0x1c>)
  410f2a:	6800      	ldr	r0, [r0, #0]
  410f2c:	6800      	ldr	r0, [r0, #0]
  410f2e:	f380 8808 	msr	MSP, r0
  410f32:	b662      	cpsie	i
  410f34:	b661      	cpsie	f
  410f36:	f3bf 8f4f 	dsb	sy
  410f3a:	f3bf 8f6f 	isb	sy
  410f3e:	df00      	svc	0
  410f40:	bf00      	nop
					" dsb					\n"
					" isb					\n"
					" svc 0					\n" /* System call to start first task. */
					" nop					\n"
				);
}
  410f42:	bf00      	nop
  410f44:	e000ed08 	.word	0xe000ed08

00410f48 <xPortStartScheduler>:

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
  410f48:	b580      	push	{r7, lr}
  410f4a:	b084      	sub	sp, #16
  410f4c:	af00      	add	r7, sp, #0
	configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );

	#if( configASSERT_DEFINED == 1 )
	{
		volatile uint32_t ulOriginalPriority;
		volatile uint8_t * const pucFirstUserPriorityRegister = ( volatile uint8_t * const ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );
  410f4e:	4b2f      	ldr	r3, [pc, #188]	; (41100c <xPortStartScheduler+0xc4>)
  410f50:	60fb      	str	r3, [r7, #12]
		functions can be called.  ISR safe functions are those that end in
		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
		ensure interrupt entry is as fast and simple as possible.

		Save the interrupt priority value that is about to be clobbered. */
		ulOriginalPriority = *pucFirstUserPriorityRegister;
  410f52:	68fb      	ldr	r3, [r7, #12]
  410f54:	781b      	ldrb	r3, [r3, #0]
  410f56:	b2db      	uxtb	r3, r3
  410f58:	60bb      	str	r3, [r7, #8]

		/* Determine the number of priority bits available.  First write to all
		possible bits. */
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
  410f5a:	68fb      	ldr	r3, [r7, #12]
  410f5c:	22ff      	movs	r2, #255	; 0xff
  410f5e:	701a      	strb	r2, [r3, #0]

		/* Read the value back to see how many bits stuck. */
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
  410f60:	68fb      	ldr	r3, [r7, #12]
  410f62:	781b      	ldrb	r3, [r3, #0]
  410f64:	b2db      	uxtb	r3, r3
  410f66:	71fb      	strb	r3, [r7, #7]

		/* Use the same mask on the maximum system call priority. */
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
  410f68:	79fb      	ldrb	r3, [r7, #7]
  410f6a:	b2db      	uxtb	r3, r3
  410f6c:	f003 0350 	and.w	r3, r3, #80	; 0x50
  410f70:	b2da      	uxtb	r2, r3
  410f72:	4b27      	ldr	r3, [pc, #156]	; (411010 <xPortStartScheduler+0xc8>)
  410f74:	701a      	strb	r2, [r3, #0]

		/* Calculate the maximum acceptable priority group value for the number
		of bits read back. */
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
  410f76:	4b27      	ldr	r3, [pc, #156]	; (411014 <xPortStartScheduler+0xcc>)
  410f78:	2207      	movs	r2, #7
  410f7a:	601a      	str	r2, [r3, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
  410f7c:	e009      	b.n	410f92 <xPortStartScheduler+0x4a>
		{
			ulMaxPRIGROUPValue--;
  410f7e:	4b25      	ldr	r3, [pc, #148]	; (411014 <xPortStartScheduler+0xcc>)
  410f80:	681b      	ldr	r3, [r3, #0]
  410f82:	3b01      	subs	r3, #1
  410f84:	4a23      	ldr	r2, [pc, #140]	; (411014 <xPortStartScheduler+0xcc>)
  410f86:	6013      	str	r3, [r2, #0]
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
  410f88:	79fb      	ldrb	r3, [r7, #7]
  410f8a:	b2db      	uxtb	r3, r3
  410f8c:	005b      	lsls	r3, r3, #1
  410f8e:	b2db      	uxtb	r3, r3
  410f90:	71fb      	strb	r3, [r7, #7]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
  410f92:	79fb      	ldrb	r3, [r7, #7]
  410f94:	b2db      	uxtb	r3, r3
  410f96:	f003 0380 	and.w	r3, r3, #128	; 0x80
  410f9a:	2b80      	cmp	r3, #128	; 0x80
  410f9c:	d0ef      	beq.n	410f7e <xPortStartScheduler+0x36>
		#ifdef __NVIC_PRIO_BITS
		{
			/* Check the CMSIS configuration that defines the number of
			priority bits matches the number of priority bits actually queried
			from the hardware. */
			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == __NVIC_PRIO_BITS );
  410f9e:	4b1d      	ldr	r3, [pc, #116]	; (411014 <xPortStartScheduler+0xcc>)
  410fa0:	681b      	ldr	r3, [r3, #0]
  410fa2:	f1c3 0307 	rsb	r3, r3, #7
  410fa6:	2b04      	cmp	r3, #4
  410fa8:	d005      	beq.n	410fb6 <xPortStartScheduler+0x6e>
  410faa:	f44f 7298 	mov.w	r2, #304	; 0x130
  410fae:	491a      	ldr	r1, [pc, #104]	; (411018 <xPortStartScheduler+0xd0>)
  410fb0:	481a      	ldr	r0, [pc, #104]	; (41101c <xPortStartScheduler+0xd4>)
  410fb2:	4b1b      	ldr	r3, [pc, #108]	; (411020 <xPortStartScheduler+0xd8>)
  410fb4:	4798      	blx	r3
		}
		#endif

		/* Shift the priority group value back to its position within the AIRCR
		register. */
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
  410fb6:	4b17      	ldr	r3, [pc, #92]	; (411014 <xPortStartScheduler+0xcc>)
  410fb8:	681b      	ldr	r3, [r3, #0]
  410fba:	021b      	lsls	r3, r3, #8
  410fbc:	4a15      	ldr	r2, [pc, #84]	; (411014 <xPortStartScheduler+0xcc>)
  410fbe:	6013      	str	r3, [r2, #0]
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
  410fc0:	4b14      	ldr	r3, [pc, #80]	; (411014 <xPortStartScheduler+0xcc>)
  410fc2:	681b      	ldr	r3, [r3, #0]
  410fc4:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
  410fc8:	4a12      	ldr	r2, [pc, #72]	; (411014 <xPortStartScheduler+0xcc>)
  410fca:	6013      	str	r3, [r2, #0]

		/* Restore the clobbered interrupt priority register to its original
		value. */
		*pucFirstUserPriorityRegister = ulOriginalPriority;
  410fcc:	68bb      	ldr	r3, [r7, #8]
  410fce:	b2da      	uxtb	r2, r3
  410fd0:	68fb      	ldr	r3, [r7, #12]
  410fd2:	701a      	strb	r2, [r3, #0]
	}
	#endif /* conifgASSERT_DEFINED */

	/* Make PendSV and SysTick the lowest priority interrupts. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
  410fd4:	4a13      	ldr	r2, [pc, #76]	; (411024 <xPortStartScheduler+0xdc>)
  410fd6:	4b13      	ldr	r3, [pc, #76]	; (411024 <xPortStartScheduler+0xdc>)
  410fd8:	681b      	ldr	r3, [r3, #0]
  410fda:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
  410fde:	6013      	str	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
  410fe0:	4a10      	ldr	r2, [pc, #64]	; (411024 <xPortStartScheduler+0xdc>)
  410fe2:	4b10      	ldr	r3, [pc, #64]	; (411024 <xPortStartScheduler+0xdc>)
  410fe4:	681b      	ldr	r3, [r3, #0]
  410fe6:	f043 4370 	orr.w	r3, r3, #4026531840	; 0xf0000000
  410fea:	6013      	str	r3, [r2, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	vPortSetupTimerInterrupt();
  410fec:	4b0e      	ldr	r3, [pc, #56]	; (411028 <xPortStartScheduler+0xe0>)
  410fee:	4798      	blx	r3

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
  410ff0:	4b0e      	ldr	r3, [pc, #56]	; (41102c <xPortStartScheduler+0xe4>)
  410ff2:	2200      	movs	r2, #0
  410ff4:	601a      	str	r2, [r3, #0]

	/* Start the first task. */
	prvPortStartFirstTask();
  410ff6:	4b0e      	ldr	r3, [pc, #56]	; (411030 <xPortStartScheduler+0xe8>)
  410ff8:	4798      	blx	r3
	exit error function to prevent compiler warnings about a static function
	not being called in the case that the application writer overrides this
	functionality by defining configTASK_RETURN_ADDRESS.  Call
	vTaskSwitchContext() so link time optimisation does not remove the
	symbol. */
	vTaskSwitchContext();
  410ffa:	4b0e      	ldr	r3, [pc, #56]	; (411034 <xPortStartScheduler+0xec>)
  410ffc:	4798      	blx	r3
	prvTaskExitError();
  410ffe:	4b0e      	ldr	r3, [pc, #56]	; (411038 <xPortStartScheduler+0xf0>)
  411000:	4798      	blx	r3

	/* Should not get here! */
	return 0;
  411002:	2300      	movs	r3, #0
}
  411004:	4618      	mov	r0, r3
  411006:	3710      	adds	r7, #16
  411008:	46bd      	mov	sp, r7
  41100a:	bd80      	pop	{r7, pc}
  41100c:	e000e400 	.word	0xe000e400
  411010:	2000b3cc 	.word	0x2000b3cc
  411014:	2000b3d0 	.word	0x2000b3d0
  411018:	0041e0cc 	.word	0x0041e0cc
  41101c:	0041e118 	.word	0x0041e118
  411020:	00416c7d 	.word	0x00416c7d
  411024:	e000ed20 	.word	0xe000ed20
  411028:	0041118d 	.word	0x0041118d
  41102c:	20000128 	.word	0x20000128
  411030:	00410f29 	.word	0x00410f29
  411034:	0041294d 	.word	0x0041294d
  411038:	00410ea5 	.word	0x00410ea5

0041103c <vPortEnterCritical>:
	configASSERT( uxCriticalNesting == 1000UL );
}
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
  41103c:	b580      	push	{r7, lr}
  41103e:	b082      	sub	sp, #8
  411040:	af00      	add	r7, sp, #0
  411042:	f04f 0350 	mov.w	r3, #80	; 0x50
  411046:	f383 8811 	msr	BASEPRI, r3
  41104a:	f3bf 8f6f 	isb	sy
  41104e:	f3bf 8f4f 	dsb	sy
  411052:	607b      	str	r3, [r7, #4]
	portDISABLE_INTERRUPTS();
	uxCriticalNesting++;
  411054:	4b0b      	ldr	r3, [pc, #44]	; (411084 <vPortEnterCritical+0x48>)
  411056:	681b      	ldr	r3, [r3, #0]
  411058:	3301      	adds	r3, #1
  41105a:	4a0a      	ldr	r2, [pc, #40]	; (411084 <vPortEnterCritical+0x48>)
  41105c:	6013      	str	r3, [r2, #0]
	/* This is not the interrupt safe version of the enter critical function so
	assert() if it is being called from an interrupt context.  Only API
	functions that end in "FromISR" can be used in an interrupt.  Only assert if
	the critical nesting count is 1 to protect against recursive calls if the
	assert function also uses a critical section. */
	if( uxCriticalNesting == 1 )
  41105e:	4b09      	ldr	r3, [pc, #36]	; (411084 <vPortEnterCritical+0x48>)
  411060:	681b      	ldr	r3, [r3, #0]
  411062:	2b01      	cmp	r3, #1
  411064:	d10a      	bne.n	41107c <vPortEnterCritical+0x40>
	{
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
  411066:	4b08      	ldr	r3, [pc, #32]	; (411088 <vPortEnterCritical+0x4c>)
  411068:	681b      	ldr	r3, [r3, #0]
  41106a:	b2db      	uxtb	r3, r3
  41106c:	2b00      	cmp	r3, #0
  41106e:	d005      	beq.n	41107c <vPortEnterCritical+0x40>
  411070:	f44f 72bc 	mov.w	r2, #376	; 0x178
  411074:	4905      	ldr	r1, [pc, #20]	; (41108c <vPortEnterCritical+0x50>)
  411076:	4806      	ldr	r0, [pc, #24]	; (411090 <vPortEnterCritical+0x54>)
  411078:	4b06      	ldr	r3, [pc, #24]	; (411094 <vPortEnterCritical+0x58>)
  41107a:	4798      	blx	r3
	}
}
  41107c:	bf00      	nop
  41107e:	3708      	adds	r7, #8
  411080:	46bd      	mov	sp, r7
  411082:	bd80      	pop	{r7, pc}
  411084:	20000128 	.word	0x20000128
  411088:	e000ed04 	.word	0xe000ed04
  41108c:	0041e0cc 	.word	0x0041e0cc
  411090:	0041e118 	.word	0x0041e118
  411094:	00416c7d 	.word	0x00416c7d

00411098 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
  411098:	b580      	push	{r7, lr}
  41109a:	b082      	sub	sp, #8
  41109c:	af00      	add	r7, sp, #0
	configASSERT( uxCriticalNesting );
  41109e:	4b0e      	ldr	r3, [pc, #56]	; (4110d8 <vPortExitCritical+0x40>)
  4110a0:	681b      	ldr	r3, [r3, #0]
  4110a2:	2b00      	cmp	r3, #0
  4110a4:	d105      	bne.n	4110b2 <vPortExitCritical+0x1a>
  4110a6:	f240 127f 	movw	r2, #383	; 0x17f
  4110aa:	490c      	ldr	r1, [pc, #48]	; (4110dc <vPortExitCritical+0x44>)
  4110ac:	480c      	ldr	r0, [pc, #48]	; (4110e0 <vPortExitCritical+0x48>)
  4110ae:	4b0d      	ldr	r3, [pc, #52]	; (4110e4 <vPortExitCritical+0x4c>)
  4110b0:	4798      	blx	r3
	uxCriticalNesting--;
  4110b2:	4b09      	ldr	r3, [pc, #36]	; (4110d8 <vPortExitCritical+0x40>)
  4110b4:	681b      	ldr	r3, [r3, #0]
  4110b6:	3b01      	subs	r3, #1
  4110b8:	4a07      	ldr	r2, [pc, #28]	; (4110d8 <vPortExitCritical+0x40>)
  4110ba:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
  4110bc:	4b06      	ldr	r3, [pc, #24]	; (4110d8 <vPortExitCritical+0x40>)
  4110be:	681b      	ldr	r3, [r3, #0]
  4110c0:	2b00      	cmp	r3, #0
  4110c2:	d104      	bne.n	4110ce <vPortExitCritical+0x36>
  4110c4:	2300      	movs	r3, #0
  4110c6:	607b      	str	r3, [r7, #4]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
  4110c8:	687b      	ldr	r3, [r7, #4]
  4110ca:	f383 8811 	msr	BASEPRI, r3
	{
		portENABLE_INTERRUPTS();
	}
}
  4110ce:	bf00      	nop
  4110d0:	3708      	adds	r7, #8
  4110d2:	46bd      	mov	sp, r7
  4110d4:	bd80      	pop	{r7, pc}
  4110d6:	bf00      	nop
  4110d8:	20000128 	.word	0x20000128
  4110dc:	0041e0cc 	.word	0x0041e0cc
  4110e0:	0041e118 	.word	0x0041e118
  4110e4:	00416c7d 	.word	0x00416c7d
	...

004110f0 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
  4110f0:	f3ef 8009 	mrs	r0, PSP
  4110f4:	f3bf 8f6f 	isb	sy
  4110f8:	4b0d      	ldr	r3, [pc, #52]	; (411130 <pxCurrentTCBConst>)
  4110fa:	681a      	ldr	r2, [r3, #0]
  4110fc:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
  411100:	6010      	str	r0, [r2, #0]
  411102:	e92d 4008 	stmdb	sp!, {r3, lr}
  411106:	f04f 0050 	mov.w	r0, #80	; 0x50
  41110a:	f380 8811 	msr	BASEPRI, r0
  41110e:	f001 fc1d 	bl	41294c <vTaskSwitchContext>
  411112:	f04f 0000 	mov.w	r0, #0
  411116:	f380 8811 	msr	BASEPRI, r0
  41111a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  41111e:	6819      	ldr	r1, [r3, #0]
  411120:	6808      	ldr	r0, [r1, #0]
  411122:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
  411126:	f380 8809 	msr	PSP, r0
  41112a:	f3bf 8f6f 	isb	sy
  41112e:	4770      	bx	lr

00411130 <pxCurrentTCBConst>:
  411130:	2000b404 	.word	0x2000b404
	"										\n"
	"	.align 4							\n"
	"pxCurrentTCBConst: .word pxCurrentTCB	\n"
	::"i"(configMAX_SYSCALL_INTERRUPT_PRIORITY)
	);
}
  411134:	bf00      	nop
  411136:	bf00      	nop

00411138 <SysTick_Handler>:
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
  411138:	b580      	push	{r7, lr}
  41113a:	b082      	sub	sp, #8
  41113c:	af00      	add	r7, sp, #0
	__asm volatile
  41113e:	f04f 0350 	mov.w	r3, #80	; 0x50
  411142:	f383 8811 	msr	BASEPRI, r3
  411146:	f3bf 8f6f 	isb	sy
  41114a:	f3bf 8f4f 	dsb	sy
  41114e:	607b      	str	r3, [r7, #4]
	known. */
	portDISABLE_INTERRUPTS();
	{

		// HICS:
		HICS_LED_Toggle();
  411150:	4b0a      	ldr	r3, [pc, #40]	; (41117c <SysTick_Handler+0x44>)
  411152:	4798      	blx	r3
		DESAC_SwicthDebounce();		
  411154:	4b0a      	ldr	r3, [pc, #40]	; (411180 <SysTick_Handler+0x48>)
  411156:	4798      	blx	r3
		
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
  411158:	4b0a      	ldr	r3, [pc, #40]	; (411184 <SysTick_Handler+0x4c>)
  41115a:	4798      	blx	r3
  41115c:	4603      	mov	r3, r0
  41115e:	2b00      	cmp	r3, #0
  411160:	d003      	beq.n	41116a <SysTick_Handler+0x32>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
  411162:	4b09      	ldr	r3, [pc, #36]	; (411188 <SysTick_Handler+0x50>)
  411164:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  411168:	601a      	str	r2, [r3, #0]
  41116a:	2300      	movs	r3, #0
  41116c:	603b      	str	r3, [r7, #0]
	__asm volatile
  41116e:	683b      	ldr	r3, [r7, #0]
  411170:	f383 8811 	msr	BASEPRI, r3
		}
	}
	portENABLE_INTERRUPTS();
}
  411174:	bf00      	nop
  411176:	3708      	adds	r7, #8
  411178:	46bd      	mov	sp, r7
  41117a:	bd80      	pop	{r7, pc}
  41117c:	004150a9 	.word	0x004150a9
  411180:	00414bf1 	.word	0x00414bf1
  411184:	004127f1 	.word	0x004127f1
  411188:	e000ed04 	.word	0xe000ed04

0041118c <vPortSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
__attribute__(( weak )) void vPortSetupTimerInterrupt( void )
{
  41118c:	b480      	push	{r7}
  41118e:	af00      	add	r7, sp, #0
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */

	/* Stop and clear the SysTick. */
	portNVIC_SYSTICK_CTRL_REG = 0UL;
  411190:	4b08      	ldr	r3, [pc, #32]	; (4111b4 <vPortSetupTimerInterrupt+0x28>)
  411192:	2200      	movs	r2, #0
  411194:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
  411196:	4b08      	ldr	r3, [pc, #32]	; (4111b8 <vPortSetupTimerInterrupt+0x2c>)
  411198:	2200      	movs	r2, #0
  41119a:	601a      	str	r2, [r3, #0]

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
  41119c:	4b07      	ldr	r3, [pc, #28]	; (4111bc <vPortSetupTimerInterrupt+0x30>)
  41119e:	4a08      	ldr	r2, [pc, #32]	; (4111c0 <vPortSetupTimerInterrupt+0x34>)
  4111a0:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
  4111a2:	4b04      	ldr	r3, [pc, #16]	; (4111b4 <vPortSetupTimerInterrupt+0x28>)
  4111a4:	2207      	movs	r2, #7
  4111a6:	601a      	str	r2, [r3, #0]
}
  4111a8:	bf00      	nop
  4111aa:	46bd      	mov	sp, r7
  4111ac:	f85d 7b04 	ldr.w	r7, [sp], #4
  4111b0:	4770      	bx	lr
  4111b2:	bf00      	nop
  4111b4:	e000e010 	.word	0xe000e010
  4111b8:	e000e018 	.word	0xe000e018
  4111bc:	e000e014 	.word	0xe000e014
  4111c0:	0001d4bf 	.word	0x0001d4bf

004111c4 <vApplicationMallocFailedHook>:

/*-----------------------------------------------------------*/

// HICS
void vApplicationMallocFailedHook(void)
{
  4111c4:	b580      	push	{r7, lr}
  4111c6:	af00      	add	r7, sp, #0
	printf("\n\nERROR: vApplicationMallocFailedHook()\n\n");
  4111c8:	4803      	ldr	r0, [pc, #12]	; (4111d8 <vApplicationMallocFailedHook+0x14>)
  4111ca:	4b04      	ldr	r3, [pc, #16]	; (4111dc <vApplicationMallocFailedHook+0x18>)
  4111cc:	4798      	blx	r3

	// HICS debug error and reset
	WDT_Debug_printf_state(1);	// Print status e reset por watchdog
  4111ce:	2001      	movs	r0, #1
  4111d0:	4b03      	ldr	r3, [pc, #12]	; (4111e0 <vApplicationMallocFailedHook+0x1c>)
  4111d2:	4798      	blx	r3

	
}
  4111d4:	bf00      	nop
  4111d6:	bd80      	pop	{r7, pc}
  4111d8:	0041e128 	.word	0x0041e128
  4111dc:	00416c7d 	.word	0x00416c7d
  4111e0:	004158d9 	.word	0x004158d9

004111e4 <pvPortMalloc>:
volatile uint32_t dwmyFreeTM_cx=0;
volatile uint8_t bypvPortMalloc=0;	


void *pvPortMalloc( size_t xWantedSize )
{
  4111e4:	b580      	push	{r7, lr}
  4111e6:	b086      	sub	sp, #24
  4111e8:	af00      	add	r7, sp, #0
  4111ea:	6078      	str	r0, [r7, #4]
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
  4111ec:	2300      	movs	r3, #0
  4111ee:	60fb      	str	r3, [r7, #12]

	bypvPortMalloc=1;	// HICS_debug
  4111f0:	4b5b      	ldr	r3, [pc, #364]	; (411360 <pvPortMalloc+0x17c>)
  4111f2:	2201      	movs	r2, #1
  4111f4:	701a      	strb	r2, [r3, #0]

	vTaskSuspendAll();
  4111f6:	4b5b      	ldr	r3, [pc, #364]	; (411364 <pvPortMalloc+0x180>)
  4111f8:	4798      	blx	r3
	{
		dwmyMalloc_cx++; // HICS_debug
  4111fa:	4b5b      	ldr	r3, [pc, #364]	; (411368 <pvPortMalloc+0x184>)
  4111fc:	681b      	ldr	r3, [r3, #0]
  4111fe:	3301      	adds	r3, #1
  411200:	4a59      	ldr	r2, [pc, #356]	; (411368 <pvPortMalloc+0x184>)
  411202:	6013      	str	r3, [r2, #0]
		
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
  411204:	4b59      	ldr	r3, [pc, #356]	; (41136c <pvPortMalloc+0x188>)
  411206:	681b      	ldr	r3, [r3, #0]
  411208:	2b00      	cmp	r3, #0
  41120a:	d101      	bne.n	411210 <pvPortMalloc+0x2c>
		{
			prvHeapInit();
  41120c:	4b58      	ldr	r3, [pc, #352]	; (411370 <pvPortMalloc+0x18c>)
  41120e:	4798      	blx	r3

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
  411210:	4b58      	ldr	r3, [pc, #352]	; (411374 <pvPortMalloc+0x190>)
  411212:	681a      	ldr	r2, [r3, #0]
  411214:	687b      	ldr	r3, [r7, #4]
  411216:	4013      	ands	r3, r2
  411218:	2b00      	cmp	r3, #0
  41121a:	f040 8087 	bne.w	41132c <pvPortMalloc+0x148>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
  41121e:	687b      	ldr	r3, [r7, #4]
  411220:	2b00      	cmp	r3, #0
  411222:	d017      	beq.n	411254 <pvPortMalloc+0x70>
			{
				xWantedSize += xHeapStructSize;
  411224:	2208      	movs	r2, #8
  411226:	687b      	ldr	r3, [r7, #4]
  411228:	4413      	add	r3, r2
  41122a:	607b      	str	r3, [r7, #4]

				/* Ensure that blocks are always aligned to the required number
				of bytes. */
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
  41122c:	687b      	ldr	r3, [r7, #4]
  41122e:	f003 0307 	and.w	r3, r3, #7
  411232:	2b00      	cmp	r3, #0
  411234:	d00e      	beq.n	411254 <pvPortMalloc+0x70>
				{
					/* Byte alignment required. */
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
  411236:	687b      	ldr	r3, [r7, #4]
  411238:	f023 0307 	bic.w	r3, r3, #7
  41123c:	3308      	adds	r3, #8
  41123e:	607b      	str	r3, [r7, #4]
					configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );
  411240:	687b      	ldr	r3, [r7, #4]
  411242:	f003 0307 	and.w	r3, r3, #7
  411246:	2b00      	cmp	r3, #0
  411248:	d004      	beq.n	411254 <pvPortMalloc+0x70>
  41124a:	22b5      	movs	r2, #181	; 0xb5
  41124c:	494a      	ldr	r1, [pc, #296]	; (411378 <pvPortMalloc+0x194>)
  41124e:	484b      	ldr	r0, [pc, #300]	; (41137c <pvPortMalloc+0x198>)
  411250:	4b4b      	ldr	r3, [pc, #300]	; (411380 <pvPortMalloc+0x19c>)
  411252:	4798      	blx	r3
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
  411254:	687b      	ldr	r3, [r7, #4]
  411256:	2b00      	cmp	r3, #0
  411258:	d068      	beq.n	41132c <pvPortMalloc+0x148>
  41125a:	4b4a      	ldr	r3, [pc, #296]	; (411384 <pvPortMalloc+0x1a0>)
  41125c:	681b      	ldr	r3, [r3, #0]
  41125e:	687a      	ldr	r2, [r7, #4]
  411260:	429a      	cmp	r2, r3
  411262:	d863      	bhi.n	41132c <pvPortMalloc+0x148>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
  411264:	4b48      	ldr	r3, [pc, #288]	; (411388 <pvPortMalloc+0x1a4>)
  411266:	613b      	str	r3, [r7, #16]
				pxBlock = xStart.pxNextFreeBlock;
  411268:	4b47      	ldr	r3, [pc, #284]	; (411388 <pvPortMalloc+0x1a4>)
  41126a:	681b      	ldr	r3, [r3, #0]
  41126c:	617b      	str	r3, [r7, #20]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
  41126e:	e004      	b.n	41127a <pvPortMalloc+0x96>
				{
					pxPreviousBlock = pxBlock;
  411270:	697b      	ldr	r3, [r7, #20]
  411272:	613b      	str	r3, [r7, #16]
					pxBlock = pxBlock->pxNextFreeBlock;
  411274:	697b      	ldr	r3, [r7, #20]
  411276:	681b      	ldr	r3, [r3, #0]
  411278:	617b      	str	r3, [r7, #20]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
  41127a:	697b      	ldr	r3, [r7, #20]
  41127c:	685a      	ldr	r2, [r3, #4]
  41127e:	687b      	ldr	r3, [r7, #4]
  411280:	429a      	cmp	r2, r3
  411282:	d203      	bcs.n	41128c <pvPortMalloc+0xa8>
  411284:	697b      	ldr	r3, [r7, #20]
  411286:	681b      	ldr	r3, [r3, #0]
  411288:	2b00      	cmp	r3, #0
  41128a:	d1f1      	bne.n	411270 <pvPortMalloc+0x8c>
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
  41128c:	4b37      	ldr	r3, [pc, #220]	; (41136c <pvPortMalloc+0x188>)
  41128e:	681b      	ldr	r3, [r3, #0]
  411290:	697a      	ldr	r2, [r7, #20]
  411292:	429a      	cmp	r2, r3
  411294:	d04a      	beq.n	41132c <pvPortMalloc+0x148>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
  411296:	693b      	ldr	r3, [r7, #16]
  411298:	681b      	ldr	r3, [r3, #0]
  41129a:	2208      	movs	r2, #8
  41129c:	4413      	add	r3, r2
  41129e:	60fb      	str	r3, [r7, #12]

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
  4112a0:	697b      	ldr	r3, [r7, #20]
  4112a2:	681a      	ldr	r2, [r3, #0]
  4112a4:	693b      	ldr	r3, [r7, #16]
  4112a6:	601a      	str	r2, [r3, #0]

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
  4112a8:	697b      	ldr	r3, [r7, #20]
  4112aa:	685a      	ldr	r2, [r3, #4]
  4112ac:	687b      	ldr	r3, [r7, #4]
  4112ae:	1ad2      	subs	r2, r2, r3
  4112b0:	2308      	movs	r3, #8
  4112b2:	005b      	lsls	r3, r3, #1
  4112b4:	429a      	cmp	r2, r3
  4112b6:	d919      	bls.n	4112ec <pvPortMalloc+0x108>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
  4112b8:	697a      	ldr	r2, [r7, #20]
  4112ba:	687b      	ldr	r3, [r7, #4]
  4112bc:	4413      	add	r3, r2
  4112be:	60bb      	str	r3, [r7, #8]
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
  4112c0:	68bb      	ldr	r3, [r7, #8]
  4112c2:	f003 0307 	and.w	r3, r3, #7
  4112c6:	2b00      	cmp	r3, #0
  4112c8:	d004      	beq.n	4112d4 <pvPortMalloc+0xf0>
  4112ca:	22e2      	movs	r2, #226	; 0xe2
  4112cc:	492a      	ldr	r1, [pc, #168]	; (411378 <pvPortMalloc+0x194>)
  4112ce:	482b      	ldr	r0, [pc, #172]	; (41137c <pvPortMalloc+0x198>)
  4112d0:	4b2b      	ldr	r3, [pc, #172]	; (411380 <pvPortMalloc+0x19c>)
  4112d2:	4798      	blx	r3

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
  4112d4:	697b      	ldr	r3, [r7, #20]
  4112d6:	685a      	ldr	r2, [r3, #4]
  4112d8:	687b      	ldr	r3, [r7, #4]
  4112da:	1ad2      	subs	r2, r2, r3
  4112dc:	68bb      	ldr	r3, [r7, #8]
  4112de:	605a      	str	r2, [r3, #4]
						pxBlock->xBlockSize = xWantedSize;
  4112e0:	697b      	ldr	r3, [r7, #20]
  4112e2:	687a      	ldr	r2, [r7, #4]
  4112e4:	605a      	str	r2, [r3, #4]

						/* Insert the new block into the list of free blocks. */
						prvInsertBlockIntoFreeList( pxNewBlockLink );
  4112e6:	68b8      	ldr	r0, [r7, #8]
  4112e8:	4b28      	ldr	r3, [pc, #160]	; (41138c <pvPortMalloc+0x1a8>)
  4112ea:	4798      	blx	r3
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
  4112ec:	4b25      	ldr	r3, [pc, #148]	; (411384 <pvPortMalloc+0x1a0>)
  4112ee:	681a      	ldr	r2, [r3, #0]
  4112f0:	697b      	ldr	r3, [r7, #20]
  4112f2:	685b      	ldr	r3, [r3, #4]
  4112f4:	1ad3      	subs	r3, r2, r3
  4112f6:	4a23      	ldr	r2, [pc, #140]	; (411384 <pvPortMalloc+0x1a0>)
  4112f8:	6013      	str	r3, [r2, #0]

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
  4112fa:	4b22      	ldr	r3, [pc, #136]	; (411384 <pvPortMalloc+0x1a0>)
  4112fc:	681a      	ldr	r2, [r3, #0]
  4112fe:	4b24      	ldr	r3, [pc, #144]	; (411390 <pvPortMalloc+0x1ac>)
  411300:	681b      	ldr	r3, [r3, #0]
  411302:	429a      	cmp	r2, r3
  411304:	d203      	bcs.n	41130e <pvPortMalloc+0x12a>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
  411306:	4b1f      	ldr	r3, [pc, #124]	; (411384 <pvPortMalloc+0x1a0>)
  411308:	681b      	ldr	r3, [r3, #0]
  41130a:	4a21      	ldr	r2, [pc, #132]	; (411390 <pvPortMalloc+0x1ac>)
  41130c:	6013      	str	r3, [r2, #0]
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
  41130e:	697b      	ldr	r3, [r7, #20]
  411310:	685a      	ldr	r2, [r3, #4]
  411312:	4b18      	ldr	r3, [pc, #96]	; (411374 <pvPortMalloc+0x190>)
  411314:	681b      	ldr	r3, [r3, #0]
  411316:	431a      	orrs	r2, r3
  411318:	697b      	ldr	r3, [r7, #20]
  41131a:	605a      	str	r2, [r3, #4]
					pxBlock->pxNextFreeBlock = NULL;
  41131c:	697b      	ldr	r3, [r7, #20]
  41131e:	2200      	movs	r2, #0
  411320:	601a      	str	r2, [r3, #0]
					xNumberOfSuccessfulAllocations++;
  411322:	4b1c      	ldr	r3, [pc, #112]	; (411394 <pvPortMalloc+0x1b0>)
  411324:	681b      	ldr	r3, [r3, #0]
  411326:	3301      	adds	r3, #1
  411328:	4a1a      	ldr	r2, [pc, #104]	; (411394 <pvPortMalloc+0x1b0>)
  41132a:	6013      	str	r3, [r2, #0]
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
  41132c:	4b1a      	ldr	r3, [pc, #104]	; (411398 <pvPortMalloc+0x1b4>)
  41132e:	4798      	blx	r3

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
  411330:	68fb      	ldr	r3, [r7, #12]
  411332:	2b00      	cmp	r3, #0
  411334:	d101      	bne.n	41133a <pvPortMalloc+0x156>
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
  411336:	4b19      	ldr	r3, [pc, #100]	; (41139c <pvPortMalloc+0x1b8>)
  411338:	4798      	blx	r3
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif

	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
  41133a:	68fb      	ldr	r3, [r7, #12]
  41133c:	f003 0307 	and.w	r3, r3, #7
  411340:	2b00      	cmp	r3, #0
  411342:	d005      	beq.n	411350 <pvPortMalloc+0x16c>
  411344:	f240 1223 	movw	r2, #291	; 0x123
  411348:	490b      	ldr	r1, [pc, #44]	; (411378 <pvPortMalloc+0x194>)
  41134a:	480c      	ldr	r0, [pc, #48]	; (41137c <pvPortMalloc+0x198>)
  41134c:	4b0c      	ldr	r3, [pc, #48]	; (411380 <pvPortMalloc+0x19c>)
  41134e:	4798      	blx	r3
	
	bypvPortMalloc=0;	// HICS_debug
  411350:	4b03      	ldr	r3, [pc, #12]	; (411360 <pvPortMalloc+0x17c>)
  411352:	2200      	movs	r2, #0
  411354:	701a      	strb	r2, [r3, #0]
	
	return pvReturn;
  411356:	68fb      	ldr	r3, [r7, #12]
}
  411358:	4618      	mov	r0, r3
  41135a:	3718      	adds	r7, #24
  41135c:	46bd      	mov	sp, r7
  41135e:	bd80      	pop	{r7, pc}
  411360:	2000b400 	.word	0x2000b400
  411364:	0041267d 	.word	0x0041267d
  411368:	2000b3f4 	.word	0x2000b3f4
  41136c:	2000b3dc 	.word	0x2000b3dc
  411370:	004114d1 	.word	0x004114d1
  411374:	2000b3f0 	.word	0x2000b3f0
  411378:	0041e154 	.word	0x0041e154
  41137c:	0041e1a0 	.word	0x0041e1a0
  411380:	00416c7d 	.word	0x00416c7d
  411384:	2000b3e0 	.word	0x2000b3e0
  411388:	2000b3d4 	.word	0x2000b3d4
  41138c:	00411595 	.word	0x00411595
  411390:	2000b3e4 	.word	0x2000b3e4
  411394:	2000b3e8 	.word	0x2000b3e8
  411398:	00412699 	.word	0x00412699
  41139c:	004111c5 	.word	0x004111c5

004113a0 <vPortFree>:

volatile uint8_t byvPortFree=0;	// HICS_debug


void vPortFree( void *pv )
{
  4113a0:	b580      	push	{r7, lr}
  4113a2:	b084      	sub	sp, #16
  4113a4:	af00      	add	r7, sp, #0
  4113a6:	6078      	str	r0, [r7, #4]
uint8_t *puc = ( uint8_t * ) pv;
  4113a8:	687b      	ldr	r3, [r7, #4]
  4113aa:	60fb      	str	r3, [r7, #12]
BlockLink_t *pxLink;

	byvPortFree=1;	// HICS_debug
  4113ac:	4b30      	ldr	r3, [pc, #192]	; (411470 <vPortFree+0xd0>)
  4113ae:	2201      	movs	r2, #1
  4113b0:	701a      	strb	r2, [r3, #0]

	if( pv != NULL )
  4113b2:	687b      	ldr	r3, [r7, #4]
  4113b4:	2b00      	cmp	r3, #0
  4113b6:	d054      	beq.n	411462 <vPortFree+0xc2>
	{
		dwmyFree_cx++; // HICS_debug
  4113b8:	4b2e      	ldr	r3, [pc, #184]	; (411474 <vPortFree+0xd4>)
  4113ba:	681b      	ldr	r3, [r3, #0]
  4113bc:	3301      	adds	r3, #1
  4113be:	4a2d      	ldr	r2, [pc, #180]	; (411474 <vPortFree+0xd4>)
  4113c0:	6013      	str	r3, [r2, #0]
		
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= xHeapStructSize;
  4113c2:	2308      	movs	r3, #8
  4113c4:	425b      	negs	r3, r3
  4113c6:	68fa      	ldr	r2, [r7, #12]
  4113c8:	4413      	add	r3, r2
  4113ca:	60fb      	str	r3, [r7, #12]

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;
  4113cc:	68fb      	ldr	r3, [r7, #12]
  4113ce:	60bb      	str	r3, [r7, #8]

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
  4113d0:	68bb      	ldr	r3, [r7, #8]
  4113d2:	685a      	ldr	r2, [r3, #4]
  4113d4:	4b28      	ldr	r3, [pc, #160]	; (411478 <vPortFree+0xd8>)
  4113d6:	681b      	ldr	r3, [r3, #0]
  4113d8:	4013      	ands	r3, r2
  4113da:	2b00      	cmp	r3, #0
  4113dc:	d105      	bne.n	4113ea <vPortFree+0x4a>
  4113de:	f240 1241 	movw	r2, #321	; 0x141
  4113e2:	4926      	ldr	r1, [pc, #152]	; (41147c <vPortFree+0xdc>)
  4113e4:	4826      	ldr	r0, [pc, #152]	; (411480 <vPortFree+0xe0>)
  4113e6:	4b27      	ldr	r3, [pc, #156]	; (411484 <vPortFree+0xe4>)
  4113e8:	4798      	blx	r3
		configASSERT( pxLink->pxNextFreeBlock == NULL );
  4113ea:	68bb      	ldr	r3, [r7, #8]
  4113ec:	681b      	ldr	r3, [r3, #0]
  4113ee:	2b00      	cmp	r3, #0
  4113f0:	d005      	beq.n	4113fe <vPortFree+0x5e>
  4113f2:	f44f 72a1 	mov.w	r2, #322	; 0x142
  4113f6:	4921      	ldr	r1, [pc, #132]	; (41147c <vPortFree+0xdc>)
  4113f8:	4821      	ldr	r0, [pc, #132]	; (411480 <vPortFree+0xe0>)
  4113fa:	4b22      	ldr	r3, [pc, #136]	; (411484 <vPortFree+0xe4>)
  4113fc:	4798      	blx	r3

		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
  4113fe:	68bb      	ldr	r3, [r7, #8]
  411400:	685a      	ldr	r2, [r3, #4]
  411402:	4b1d      	ldr	r3, [pc, #116]	; (411478 <vPortFree+0xd8>)
  411404:	681b      	ldr	r3, [r3, #0]
  411406:	4013      	ands	r3, r2
  411408:	2b00      	cmp	r3, #0
  41140a:	d025      	beq.n	411458 <vPortFree+0xb8>
		{
			if( pxLink->pxNextFreeBlock == NULL )
  41140c:	68bb      	ldr	r3, [r7, #8]
  41140e:	681b      	ldr	r3, [r3, #0]
  411410:	2b00      	cmp	r3, #0
  411412:	d11b      	bne.n	41144c <vPortFree+0xac>
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
  411414:	68bb      	ldr	r3, [r7, #8]
  411416:	685a      	ldr	r2, [r3, #4]
  411418:	4b17      	ldr	r3, [pc, #92]	; (411478 <vPortFree+0xd8>)
  41141a:	681b      	ldr	r3, [r3, #0]
  41141c:	43db      	mvns	r3, r3
  41141e:	401a      	ands	r2, r3
  411420:	68bb      	ldr	r3, [r7, #8]
  411422:	605a      	str	r2, [r3, #4]

				vTaskSuspendAll();
  411424:	4b18      	ldr	r3, [pc, #96]	; (411488 <vPortFree+0xe8>)
  411426:	4798      	blx	r3
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
  411428:	68bb      	ldr	r3, [r7, #8]
  41142a:	685a      	ldr	r2, [r3, #4]
  41142c:	4b17      	ldr	r3, [pc, #92]	; (41148c <vPortFree+0xec>)
  41142e:	681b      	ldr	r3, [r3, #0]
  411430:	4413      	add	r3, r2
  411432:	4a16      	ldr	r2, [pc, #88]	; (41148c <vPortFree+0xec>)
  411434:	6013      	str	r3, [r2, #0]
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
  411436:	68b8      	ldr	r0, [r7, #8]
  411438:	4b15      	ldr	r3, [pc, #84]	; (411490 <vPortFree+0xf0>)
  41143a:	4798      	blx	r3
					xNumberOfSuccessfulFrees++;
  41143c:	4b15      	ldr	r3, [pc, #84]	; (411494 <vPortFree+0xf4>)
  41143e:	681b      	ldr	r3, [r3, #0]
  411440:	3301      	adds	r3, #1
  411442:	4a14      	ldr	r2, [pc, #80]	; (411494 <vPortFree+0xf4>)
  411444:	6013      	str	r3, [r2, #0]
				}
				( void ) xTaskResumeAll();
  411446:	4b14      	ldr	r3, [pc, #80]	; (411498 <vPortFree+0xf8>)
  411448:	4798      	blx	r3
  41144a:	e00a      	b.n	411462 <vPortFree+0xc2>
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
				dwmyFreeTM_cx++;	// HICS_debug
  41144c:	4b13      	ldr	r3, [pc, #76]	; (41149c <vPortFree+0xfc>)
  41144e:	681b      	ldr	r3, [r3, #0]
  411450:	3301      	adds	r3, #1
  411452:	4a12      	ldr	r2, [pc, #72]	; (41149c <vPortFree+0xfc>)
  411454:	6013      	str	r3, [r2, #0]
  411456:	e004      	b.n	411462 <vPortFree+0xc2>
			}
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
			dwmyFreeTM_cx++;	// HICS_debug
  411458:	4b10      	ldr	r3, [pc, #64]	; (41149c <vPortFree+0xfc>)
  41145a:	681b      	ldr	r3, [r3, #0]
  41145c:	3301      	adds	r3, #1
  41145e:	4a0f      	ldr	r2, [pc, #60]	; (41149c <vPortFree+0xfc>)
  411460:	6013      	str	r3, [r2, #0]
		}
	}
	
	byvPortFree=0;	// HICS_debug
  411462:	4b03      	ldr	r3, [pc, #12]	; (411470 <vPortFree+0xd0>)
  411464:	2200      	movs	r2, #0
  411466:	701a      	strb	r2, [r3, #0]
	
	
}
  411468:	bf00      	nop
  41146a:	3710      	adds	r7, #16
  41146c:	46bd      	mov	sp, r7
  41146e:	bd80      	pop	{r7, pc}
  411470:	2000b401 	.word	0x2000b401
  411474:	2000b3f8 	.word	0x2000b3f8
  411478:	2000b3f0 	.word	0x2000b3f0
  41147c:	0041e154 	.word	0x0041e154
  411480:	0041e1a0 	.word	0x0041e1a0
  411484:	00416c7d 	.word	0x00416c7d
  411488:	0041267d 	.word	0x0041267d
  41148c:	2000b3e0 	.word	0x2000b3e0
  411490:	00411595 	.word	0x00411595
  411494:	2000b3ec 	.word	0x2000b3ec
  411498:	00412699 	.word	0x00412699
  41149c:	2000b3fc 	.word	0x2000b3fc

004114a0 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
  4114a0:	b480      	push	{r7}
  4114a2:	af00      	add	r7, sp, #0
	return xFreeBytesRemaining;
  4114a4:	4b03      	ldr	r3, [pc, #12]	; (4114b4 <xPortGetFreeHeapSize+0x14>)
  4114a6:	681b      	ldr	r3, [r3, #0]
}
  4114a8:	4618      	mov	r0, r3
  4114aa:	46bd      	mov	sp, r7
  4114ac:	f85d 7b04 	ldr.w	r7, [sp], #4
  4114b0:	4770      	bx	lr
  4114b2:	bf00      	nop
  4114b4:	2000b3e0 	.word	0x2000b3e0

004114b8 <xPortGetMinimumEverFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetMinimumEverFreeHeapSize( void )
{
  4114b8:	b480      	push	{r7}
  4114ba:	af00      	add	r7, sp, #0
	return xMinimumEverFreeBytesRemaining;
  4114bc:	4b03      	ldr	r3, [pc, #12]	; (4114cc <xPortGetMinimumEverFreeHeapSize+0x14>)
  4114be:	681b      	ldr	r3, [r3, #0]
}
  4114c0:	4618      	mov	r0, r3
  4114c2:	46bd      	mov	sp, r7
  4114c4:	f85d 7b04 	ldr.w	r7, [sp], #4
  4114c8:	4770      	bx	lr
  4114ca:	bf00      	nop
  4114cc:	2000b3e4 	.word	0x2000b3e4

004114d0 <prvHeapInit>:
	/* This just exists to keep the linker quiet. */
}
/*-----------------------------------------------------------*/

static void prvHeapInit( void )
{
  4114d0:	b480      	push	{r7}
  4114d2:	b085      	sub	sp, #20
  4114d4:	af00      	add	r7, sp, #0
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;
size_t uxAddress;
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
  4114d6:	f44f 23a0 	mov.w	r3, #327680	; 0x50000
  4114da:	60bb      	str	r3, [r7, #8]

	/* Ensure the heap starts on a correctly aligned boundary. */
	uxAddress = ( size_t ) ucHeap;
  4114dc:	4b27      	ldr	r3, [pc, #156]	; (41157c <prvHeapInit+0xac>)
  4114de:	60fb      	str	r3, [r7, #12]

	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
  4114e0:	68fb      	ldr	r3, [r7, #12]
  4114e2:	f003 0307 	and.w	r3, r3, #7
  4114e6:	2b00      	cmp	r3, #0
  4114e8:	d00c      	beq.n	411504 <prvHeapInit+0x34>
	{
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
  4114ea:	68fb      	ldr	r3, [r7, #12]
  4114ec:	3307      	adds	r3, #7
  4114ee:	60fb      	str	r3, [r7, #12]
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
  4114f0:	68fb      	ldr	r3, [r7, #12]
  4114f2:	f023 0307 	bic.w	r3, r3, #7
  4114f6:	60fb      	str	r3, [r7, #12]
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
  4114f8:	68ba      	ldr	r2, [r7, #8]
  4114fa:	68fb      	ldr	r3, [r7, #12]
  4114fc:	1ad3      	subs	r3, r2, r3
  4114fe:	4a1f      	ldr	r2, [pc, #124]	; (41157c <prvHeapInit+0xac>)
  411500:	4413      	add	r3, r2
  411502:	60bb      	str	r3, [r7, #8]
	}

	pucAlignedHeap = ( uint8_t * ) uxAddress;
  411504:	68fb      	ldr	r3, [r7, #12]
  411506:	607b      	str	r3, [r7, #4]

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
  411508:	4a1d      	ldr	r2, [pc, #116]	; (411580 <prvHeapInit+0xb0>)
  41150a:	687b      	ldr	r3, [r7, #4]
  41150c:	6013      	str	r3, [r2, #0]
	xStart.xBlockSize = ( size_t ) 0;
  41150e:	4b1c      	ldr	r3, [pc, #112]	; (411580 <prvHeapInit+0xb0>)
  411510:	2200      	movs	r2, #0
  411512:	605a      	str	r2, [r3, #4]

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
  411514:	687a      	ldr	r2, [r7, #4]
  411516:	68bb      	ldr	r3, [r7, #8]
  411518:	4413      	add	r3, r2
  41151a:	60fb      	str	r3, [r7, #12]
	uxAddress -= xHeapStructSize;
  41151c:	2208      	movs	r2, #8
  41151e:	68fb      	ldr	r3, [r7, #12]
  411520:	1a9b      	subs	r3, r3, r2
  411522:	60fb      	str	r3, [r7, #12]
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
  411524:	68fb      	ldr	r3, [r7, #12]
  411526:	f023 0307 	bic.w	r3, r3, #7
  41152a:	60fb      	str	r3, [r7, #12]
	pxEnd = ( void * ) uxAddress;
  41152c:	68fb      	ldr	r3, [r7, #12]
  41152e:	4a15      	ldr	r2, [pc, #84]	; (411584 <prvHeapInit+0xb4>)
  411530:	6013      	str	r3, [r2, #0]
	pxEnd->xBlockSize = 0;
  411532:	4b14      	ldr	r3, [pc, #80]	; (411584 <prvHeapInit+0xb4>)
  411534:	681b      	ldr	r3, [r3, #0]
  411536:	2200      	movs	r2, #0
  411538:	605a      	str	r2, [r3, #4]
	pxEnd->pxNextFreeBlock = NULL;
  41153a:	4b12      	ldr	r3, [pc, #72]	; (411584 <prvHeapInit+0xb4>)
  41153c:	681b      	ldr	r3, [r3, #0]
  41153e:	2200      	movs	r2, #0
  411540:	601a      	str	r2, [r3, #0]

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
  411542:	687b      	ldr	r3, [r7, #4]
  411544:	603b      	str	r3, [r7, #0]
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
  411546:	683b      	ldr	r3, [r7, #0]
  411548:	68fa      	ldr	r2, [r7, #12]
  41154a:	1ad2      	subs	r2, r2, r3
  41154c:	683b      	ldr	r3, [r7, #0]
  41154e:	605a      	str	r2, [r3, #4]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
  411550:	4b0c      	ldr	r3, [pc, #48]	; (411584 <prvHeapInit+0xb4>)
  411552:	681a      	ldr	r2, [r3, #0]
  411554:	683b      	ldr	r3, [r7, #0]
  411556:	601a      	str	r2, [r3, #0]

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
  411558:	683b      	ldr	r3, [r7, #0]
  41155a:	685b      	ldr	r3, [r3, #4]
  41155c:	4a0a      	ldr	r2, [pc, #40]	; (411588 <prvHeapInit+0xb8>)
  41155e:	6013      	str	r3, [r2, #0]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
  411560:	683b      	ldr	r3, [r7, #0]
  411562:	685b      	ldr	r3, [r3, #4]
  411564:	4a09      	ldr	r2, [pc, #36]	; (41158c <prvHeapInit+0xbc>)
  411566:	6013      	str	r3, [r2, #0]

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
  411568:	4b09      	ldr	r3, [pc, #36]	; (411590 <prvHeapInit+0xc0>)
  41156a:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
  41156e:	601a      	str	r2, [r3, #0]
}
  411570:	bf00      	nop
  411572:	3714      	adds	r7, #20
  411574:	46bd      	mov	sp, r7
  411576:	f85d 7b04 	ldr.w	r7, [sp], #4
  41157a:	4770      	bx	lr
  41157c:	61000000 	.word	0x61000000
  411580:	2000b3d4 	.word	0x2000b3d4
  411584:	2000b3dc 	.word	0x2000b3dc
  411588:	2000b3e4 	.word	0x2000b3e4
  41158c:	2000b3e0 	.word	0x2000b3e0
  411590:	2000b3f0 	.word	0x2000b3f0

00411594 <prvInsertBlockIntoFreeList>:
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
  411594:	b480      	push	{r7}
  411596:	b085      	sub	sp, #20
  411598:	af00      	add	r7, sp, #0
  41159a:	6078      	str	r0, [r7, #4]
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
  41159c:	4b28      	ldr	r3, [pc, #160]	; (411640 <prvInsertBlockIntoFreeList+0xac>)
  41159e:	60fb      	str	r3, [r7, #12]
  4115a0:	e002      	b.n	4115a8 <prvInsertBlockIntoFreeList+0x14>
  4115a2:	68fb      	ldr	r3, [r7, #12]
  4115a4:	681b      	ldr	r3, [r3, #0]
  4115a6:	60fb      	str	r3, [r7, #12]
  4115a8:	68fb      	ldr	r3, [r7, #12]
  4115aa:	681a      	ldr	r2, [r3, #0]
  4115ac:	687b      	ldr	r3, [r7, #4]
  4115ae:	429a      	cmp	r2, r3
  4115b0:	d3f7      	bcc.n	4115a2 <prvInsertBlockIntoFreeList+0xe>
		/* Nothing to do here, just iterate to the right position. */
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
  4115b2:	68fb      	ldr	r3, [r7, #12]
  4115b4:	60bb      	str	r3, [r7, #8]
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
  4115b6:	68fb      	ldr	r3, [r7, #12]
  4115b8:	685b      	ldr	r3, [r3, #4]
  4115ba:	68ba      	ldr	r2, [r7, #8]
  4115bc:	441a      	add	r2, r3
  4115be:	687b      	ldr	r3, [r7, #4]
  4115c0:	429a      	cmp	r2, r3
  4115c2:	d108      	bne.n	4115d6 <prvInsertBlockIntoFreeList+0x42>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
  4115c4:	68fb      	ldr	r3, [r7, #12]
  4115c6:	685a      	ldr	r2, [r3, #4]
  4115c8:	687b      	ldr	r3, [r7, #4]
  4115ca:	685b      	ldr	r3, [r3, #4]
  4115cc:	441a      	add	r2, r3
  4115ce:	68fb      	ldr	r3, [r7, #12]
  4115d0:	605a      	str	r2, [r3, #4]
		pxBlockToInsert = pxIterator;
  4115d2:	68fb      	ldr	r3, [r7, #12]
  4115d4:	607b      	str	r3, [r7, #4]
		mtCOVERAGE_TEST_MARKER();
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
  4115d6:	687b      	ldr	r3, [r7, #4]
  4115d8:	60bb      	str	r3, [r7, #8]
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
  4115da:	687b      	ldr	r3, [r7, #4]
  4115dc:	685b      	ldr	r3, [r3, #4]
  4115de:	68ba      	ldr	r2, [r7, #8]
  4115e0:	441a      	add	r2, r3
  4115e2:	68fb      	ldr	r3, [r7, #12]
  4115e4:	681b      	ldr	r3, [r3, #0]
  4115e6:	429a      	cmp	r2, r3
  4115e8:	d118      	bne.n	41161c <prvInsertBlockIntoFreeList+0x88>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
  4115ea:	68fb      	ldr	r3, [r7, #12]
  4115ec:	681a      	ldr	r2, [r3, #0]
  4115ee:	4b15      	ldr	r3, [pc, #84]	; (411644 <prvInsertBlockIntoFreeList+0xb0>)
  4115f0:	681b      	ldr	r3, [r3, #0]
  4115f2:	429a      	cmp	r2, r3
  4115f4:	d00d      	beq.n	411612 <prvInsertBlockIntoFreeList+0x7e>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
  4115f6:	687b      	ldr	r3, [r7, #4]
  4115f8:	685a      	ldr	r2, [r3, #4]
  4115fa:	68fb      	ldr	r3, [r7, #12]
  4115fc:	681b      	ldr	r3, [r3, #0]
  4115fe:	685b      	ldr	r3, [r3, #4]
  411600:	441a      	add	r2, r3
  411602:	687b      	ldr	r3, [r7, #4]
  411604:	605a      	str	r2, [r3, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
  411606:	68fb      	ldr	r3, [r7, #12]
  411608:	681b      	ldr	r3, [r3, #0]
  41160a:	681a      	ldr	r2, [r3, #0]
  41160c:	687b      	ldr	r3, [r7, #4]
  41160e:	601a      	str	r2, [r3, #0]
  411610:	e008      	b.n	411624 <prvInsertBlockIntoFreeList+0x90>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
  411612:	4b0c      	ldr	r3, [pc, #48]	; (411644 <prvInsertBlockIntoFreeList+0xb0>)
  411614:	681a      	ldr	r2, [r3, #0]
  411616:	687b      	ldr	r3, [r7, #4]
  411618:	601a      	str	r2, [r3, #0]
  41161a:	e003      	b.n	411624 <prvInsertBlockIntoFreeList+0x90>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
  41161c:	68fb      	ldr	r3, [r7, #12]
  41161e:	681a      	ldr	r2, [r3, #0]
  411620:	687b      	ldr	r3, [r7, #4]
  411622:	601a      	str	r2, [r3, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
  411624:	68fa      	ldr	r2, [r7, #12]
  411626:	687b      	ldr	r3, [r7, #4]
  411628:	429a      	cmp	r2, r3
  41162a:	d002      	beq.n	411632 <prvInsertBlockIntoFreeList+0x9e>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
  41162c:	68fb      	ldr	r3, [r7, #12]
  41162e:	687a      	ldr	r2, [r7, #4]
  411630:	601a      	str	r2, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
  411632:	bf00      	nop
  411634:	3714      	adds	r7, #20
  411636:	46bd      	mov	sp, r7
  411638:	f85d 7b04 	ldr.w	r7, [sp], #4
  41163c:	4770      	bx	lr
  41163e:	bf00      	nop
  411640:	2000b3d4 	.word	0x2000b3d4
  411644:	2000b3dc 	.word	0x2000b3dc

00411648 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
  411648:	b580      	push	{r7, lr}
  41164a:	b084      	sub	sp, #16
  41164c:	af00      	add	r7, sp, #0
  41164e:	6078      	str	r0, [r7, #4]
  411650:	6039      	str	r1, [r7, #0]
Queue_t * const pxQueue = xQueue;
  411652:	687b      	ldr	r3, [r7, #4]
  411654:	60fb      	str	r3, [r7, #12]

	configASSERT( pxQueue );
  411656:	68fb      	ldr	r3, [r7, #12]
  411658:	2b00      	cmp	r3, #0
  41165a:	d105      	bne.n	411668 <xQueueGenericReset+0x20>
  41165c:	f240 1203 	movw	r2, #259	; 0x103
  411660:	4924      	ldr	r1, [pc, #144]	; (4116f4 <xQueueGenericReset+0xac>)
  411662:	4825      	ldr	r0, [pc, #148]	; (4116f8 <xQueueGenericReset+0xb0>)
  411664:	4b25      	ldr	r3, [pc, #148]	; (4116fc <xQueueGenericReset+0xb4>)
  411666:	4798      	blx	r3

	taskENTER_CRITICAL();
  411668:	4b25      	ldr	r3, [pc, #148]	; (411700 <xQueueGenericReset+0xb8>)
  41166a:	4798      	blx	r3
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
  41166c:	68fb      	ldr	r3, [r7, #12]
  41166e:	681a      	ldr	r2, [r3, #0]
  411670:	68fb      	ldr	r3, [r7, #12]
  411672:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  411674:	68f9      	ldr	r1, [r7, #12]
  411676:	6c09      	ldr	r1, [r1, #64]	; 0x40
  411678:	fb01 f303 	mul.w	r3, r1, r3
  41167c:	441a      	add	r2, r3
  41167e:	68fb      	ldr	r3, [r7, #12]
  411680:	609a      	str	r2, [r3, #8]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
  411682:	68fb      	ldr	r3, [r7, #12]
  411684:	2200      	movs	r2, #0
  411686:	639a      	str	r2, [r3, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
  411688:	68fb      	ldr	r3, [r7, #12]
  41168a:	681a      	ldr	r2, [r3, #0]
  41168c:	68fb      	ldr	r3, [r7, #12]
  41168e:	605a      	str	r2, [r3, #4]
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
  411690:	68fb      	ldr	r3, [r7, #12]
  411692:	681a      	ldr	r2, [r3, #0]
  411694:	68fb      	ldr	r3, [r7, #12]
  411696:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  411698:	3b01      	subs	r3, #1
  41169a:	68f9      	ldr	r1, [r7, #12]
  41169c:	6c09      	ldr	r1, [r1, #64]	; 0x40
  41169e:	fb01 f303 	mul.w	r3, r1, r3
  4116a2:	441a      	add	r2, r3
  4116a4:	68fb      	ldr	r3, [r7, #12]
  4116a6:	60da      	str	r2, [r3, #12]
		pxQueue->cRxLock = queueUNLOCKED;
  4116a8:	68fb      	ldr	r3, [r7, #12]
  4116aa:	22ff      	movs	r2, #255	; 0xff
  4116ac:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
		pxQueue->cTxLock = queueUNLOCKED;
  4116b0:	68fb      	ldr	r3, [r7, #12]
  4116b2:	22ff      	movs	r2, #255	; 0xff
  4116b4:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45

		if( xNewQueue == pdFALSE )
  4116b8:	683b      	ldr	r3, [r7, #0]
  4116ba:	2b00      	cmp	r3, #0
  4116bc:	d109      	bne.n	4116d2 <xQueueGenericReset+0x8a>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  4116be:	68fb      	ldr	r3, [r7, #12]
  4116c0:	691b      	ldr	r3, [r3, #16]
  4116c2:	2b00      	cmp	r3, #0
  4116c4:	d00f      	beq.n	4116e6 <xQueueGenericReset+0x9e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  4116c6:	68fb      	ldr	r3, [r7, #12]
  4116c8:	3310      	adds	r3, #16
  4116ca:	4618      	mov	r0, r3
  4116cc:	4b0d      	ldr	r3, [pc, #52]	; (411704 <xQueueGenericReset+0xbc>)
  4116ce:	4798      	blx	r3
  4116d0:	e009      	b.n	4116e6 <xQueueGenericReset+0x9e>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
  4116d2:	68fb      	ldr	r3, [r7, #12]
  4116d4:	3310      	adds	r3, #16
  4116d6:	4618      	mov	r0, r3
  4116d8:	4b0b      	ldr	r3, [pc, #44]	; (411708 <xQueueGenericReset+0xc0>)
  4116da:	4798      	blx	r3
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
  4116dc:	68fb      	ldr	r3, [r7, #12]
  4116de:	3324      	adds	r3, #36	; 0x24
  4116e0:	4618      	mov	r0, r3
  4116e2:	4b09      	ldr	r3, [pc, #36]	; (411708 <xQueueGenericReset+0xc0>)
  4116e4:	4798      	blx	r3
		}
	}
	taskEXIT_CRITICAL();
  4116e6:	4b09      	ldr	r3, [pc, #36]	; (41170c <xQueueGenericReset+0xc4>)
  4116e8:	4798      	blx	r3

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
  4116ea:	2301      	movs	r3, #1
}
  4116ec:	4618      	mov	r0, r3
  4116ee:	3710      	adds	r7, #16
  4116f0:	46bd      	mov	sp, r7
  4116f2:	bd80      	pop	{r7, pc}
  4116f4:	0041e1b0 	.word	0x0041e1b0
  4116f8:	0041e1e8 	.word	0x0041e1e8
  4116fc:	00416c7d 	.word	0x00416c7d
  411700:	0041103d 	.word	0x0041103d
  411704:	00412af5 	.word	0x00412af5
  411708:	00410ce1 	.word	0x00410ce1
  41170c:	00411099 	.word	0x00411099

00411710 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
  411710:	b590      	push	{r4, r7, lr}
  411712:	b08b      	sub	sp, #44	; 0x2c
  411714:	af02      	add	r7, sp, #8
  411716:	60f8      	str	r0, [r7, #12]
  411718:	60b9      	str	r1, [r7, #8]
  41171a:	4613      	mov	r3, r2
  41171c:	71fb      	strb	r3, [r7, #7]
	Queue_t *pxNewQueue;
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
  41171e:	68fb      	ldr	r3, [r7, #12]
  411720:	2b00      	cmp	r3, #0
  411722:	d105      	bne.n	411730 <xQueueGenericCreate+0x20>
  411724:	f44f 72bb 	mov.w	r2, #374	; 0x176
  411728:	4912      	ldr	r1, [pc, #72]	; (411774 <xQueueGenericCreate+0x64>)
  41172a:	4813      	ldr	r0, [pc, #76]	; (411778 <xQueueGenericCreate+0x68>)
  41172c:	4b13      	ldr	r3, [pc, #76]	; (41177c <xQueueGenericCreate+0x6c>)
  41172e:	4798      	blx	r3

		/* Allocate enough space to hold the maximum number of items that
		can be in the queue at any time.  It is valid for uxItemSize to be
		zero in the case the queue is used as a semaphore. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  411730:	68fb      	ldr	r3, [r7, #12]
  411732:	68ba      	ldr	r2, [r7, #8]
  411734:	fb02 f303 	mul.w	r3, r2, r3
  411738:	61fb      	str	r3, [r7, #28]
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
  41173a:	69fb      	ldr	r3, [r7, #28]
  41173c:	3348      	adds	r3, #72	; 0x48
  41173e:	4618      	mov	r0, r3
  411740:	4b0f      	ldr	r3, [pc, #60]	; (411780 <xQueueGenericCreate+0x70>)
  411742:	4798      	blx	r3
  411744:	61b8      	str	r0, [r7, #24]

		if( pxNewQueue != NULL )
  411746:	69bb      	ldr	r3, [r7, #24]
  411748:	2b00      	cmp	r3, #0
  41174a:	d00d      	beq.n	411768 <xQueueGenericCreate+0x58>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
  41174c:	69bb      	ldr	r3, [r7, #24]
  41174e:	617b      	str	r3, [r7, #20]
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
  411750:	697b      	ldr	r3, [r7, #20]
  411752:	3348      	adds	r3, #72	; 0x48
  411754:	617b      	str	r3, [r7, #20]
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
  411756:	79fa      	ldrb	r2, [r7, #7]
  411758:	69bb      	ldr	r3, [r7, #24]
  41175a:	9300      	str	r3, [sp, #0]
  41175c:	4613      	mov	r3, r2
  41175e:	697a      	ldr	r2, [r7, #20]
  411760:	68b9      	ldr	r1, [r7, #8]
  411762:	68f8      	ldr	r0, [r7, #12]
  411764:	4c07      	ldr	r4, [pc, #28]	; (411784 <xQueueGenericCreate+0x74>)
  411766:	47a0      	blx	r4
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
  411768:	69bb      	ldr	r3, [r7, #24]
	}
  41176a:	4618      	mov	r0, r3
  41176c:	3724      	adds	r7, #36	; 0x24
  41176e:	46bd      	mov	sp, r7
  411770:	bd90      	pop	{r4, r7, pc}
  411772:	bf00      	nop
  411774:	0041e1b0 	.word	0x0041e1b0
  411778:	0041e1e8 	.word	0x0041e1e8
  41177c:	00416c7d 	.word	0x00416c7d
  411780:	004111e5 	.word	0x004111e5
  411784:	00411789 	.word	0x00411789

00411788 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
  411788:	b580      	push	{r7, lr}
  41178a:	b084      	sub	sp, #16
  41178c:	af00      	add	r7, sp, #0
  41178e:	60f8      	str	r0, [r7, #12]
  411790:	60b9      	str	r1, [r7, #8]
  411792:	607a      	str	r2, [r7, #4]
  411794:	70fb      	strb	r3, [r7, #3]
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
  411796:	68bb      	ldr	r3, [r7, #8]
  411798:	2b00      	cmp	r3, #0
  41179a:	d103      	bne.n	4117a4 <prvInitialiseNewQueue+0x1c>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
  41179c:	69bb      	ldr	r3, [r7, #24]
  41179e:	69ba      	ldr	r2, [r7, #24]
  4117a0:	601a      	str	r2, [r3, #0]
  4117a2:	e002      	b.n	4117aa <prvInitialiseNewQueue+0x22>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
  4117a4:	69bb      	ldr	r3, [r7, #24]
  4117a6:	687a      	ldr	r2, [r7, #4]
  4117a8:	601a      	str	r2, [r3, #0]
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
  4117aa:	69bb      	ldr	r3, [r7, #24]
  4117ac:	68fa      	ldr	r2, [r7, #12]
  4117ae:	63da      	str	r2, [r3, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
  4117b0:	69bb      	ldr	r3, [r7, #24]
  4117b2:	68ba      	ldr	r2, [r7, #8]
  4117b4:	641a      	str	r2, [r3, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
  4117b6:	2101      	movs	r1, #1
  4117b8:	69b8      	ldr	r0, [r7, #24]
  4117ba:	4b03      	ldr	r3, [pc, #12]	; (4117c8 <prvInitialiseNewQueue+0x40>)
  4117bc:	4798      	blx	r3
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
  4117be:	bf00      	nop
  4117c0:	3710      	adds	r7, #16
  4117c2:	46bd      	mov	sp, r7
  4117c4:	bd80      	pop	{r7, pc}
  4117c6:	bf00      	nop
  4117c8:	00411649 	.word	0x00411649

004117cc <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
	{
  4117cc:	b580      	push	{r7, lr}
  4117ce:	b084      	sub	sp, #16
  4117d0:	af00      	add	r7, sp, #0
  4117d2:	6078      	str	r0, [r7, #4]
  4117d4:	6039      	str	r1, [r7, #0]
	QueueHandle_t xHandle;

		configASSERT( uxMaxCount != 0 );
  4117d6:	687b      	ldr	r3, [r7, #4]
  4117d8:	2b00      	cmp	r3, #0
  4117da:	d105      	bne.n	4117e8 <xQueueCreateCountingSemaphore+0x1c>
  4117dc:	f240 22ce 	movw	r2, #718	; 0x2ce
  4117e0:	490f      	ldr	r1, [pc, #60]	; (411820 <xQueueCreateCountingSemaphore+0x54>)
  4117e2:	4810      	ldr	r0, [pc, #64]	; (411824 <xQueueCreateCountingSemaphore+0x58>)
  4117e4:	4b10      	ldr	r3, [pc, #64]	; (411828 <xQueueCreateCountingSemaphore+0x5c>)
  4117e6:	4798      	blx	r3
		configASSERT( uxInitialCount <= uxMaxCount );
  4117e8:	683a      	ldr	r2, [r7, #0]
  4117ea:	687b      	ldr	r3, [r7, #4]
  4117ec:	429a      	cmp	r2, r3
  4117ee:	d905      	bls.n	4117fc <xQueueCreateCountingSemaphore+0x30>
  4117f0:	f240 22cf 	movw	r2, #719	; 0x2cf
  4117f4:	490a      	ldr	r1, [pc, #40]	; (411820 <xQueueCreateCountingSemaphore+0x54>)
  4117f6:	480b      	ldr	r0, [pc, #44]	; (411824 <xQueueCreateCountingSemaphore+0x58>)
  4117f8:	4b0b      	ldr	r3, [pc, #44]	; (411828 <xQueueCreateCountingSemaphore+0x5c>)
  4117fa:	4798      	blx	r3

		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
  4117fc:	2202      	movs	r2, #2
  4117fe:	2100      	movs	r1, #0
  411800:	6878      	ldr	r0, [r7, #4]
  411802:	4b0a      	ldr	r3, [pc, #40]	; (41182c <xQueueCreateCountingSemaphore+0x60>)
  411804:	4798      	blx	r3
  411806:	60f8      	str	r0, [r7, #12]

		if( xHandle != NULL )
  411808:	68fb      	ldr	r3, [r7, #12]
  41180a:	2b00      	cmp	r3, #0
  41180c:	d002      	beq.n	411814 <xQueueCreateCountingSemaphore+0x48>
		{
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
  41180e:	68fb      	ldr	r3, [r7, #12]
  411810:	683a      	ldr	r2, [r7, #0]
  411812:	639a      	str	r2, [r3, #56]	; 0x38
		else
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		return xHandle;
  411814:	68fb      	ldr	r3, [r7, #12]
	}
  411816:	4618      	mov	r0, r3
  411818:	3710      	adds	r7, #16
  41181a:	46bd      	mov	sp, r7
  41181c:	bd80      	pop	{r7, pc}
  41181e:	bf00      	nop
  411820:	0041e1b0 	.word	0x0041e1b0
  411824:	0041e1e8 	.word	0x0041e1e8
  411828:	00416c7d 	.word	0x00416c7d
  41182c:	00411711 	.word	0x00411711

00411830 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
  411830:	b580      	push	{r7, lr}
  411832:	b08a      	sub	sp, #40	; 0x28
  411834:	af00      	add	r7, sp, #0
  411836:	60f8      	str	r0, [r7, #12]
  411838:	60b9      	str	r1, [r7, #8]
  41183a:	607a      	str	r2, [r7, #4]
  41183c:	603b      	str	r3, [r7, #0]
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
  41183e:	2300      	movs	r3, #0
  411840:	627b      	str	r3, [r7, #36]	; 0x24
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
  411842:	68fb      	ldr	r3, [r7, #12]
  411844:	623b      	str	r3, [r7, #32]

	configASSERT( pxQueue );
  411846:	6a3b      	ldr	r3, [r7, #32]
  411848:	2b00      	cmp	r3, #0
  41184a:	d105      	bne.n	411858 <xQueueGenericSend+0x28>
  41184c:	f240 22ea 	movw	r2, #746	; 0x2ea
  411850:	4956      	ldr	r1, [pc, #344]	; (4119ac <xQueueGenericSend+0x17c>)
  411852:	4857      	ldr	r0, [pc, #348]	; (4119b0 <xQueueGenericSend+0x180>)
  411854:	4b57      	ldr	r3, [pc, #348]	; (4119b4 <xQueueGenericSend+0x184>)
  411856:	4798      	blx	r3
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
  411858:	68bb      	ldr	r3, [r7, #8]
  41185a:	2b00      	cmp	r3, #0
  41185c:	d103      	bne.n	411866 <xQueueGenericSend+0x36>
  41185e:	6a3b      	ldr	r3, [r7, #32]
  411860:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  411862:	2b00      	cmp	r3, #0
  411864:	d101      	bne.n	41186a <xQueueGenericSend+0x3a>
  411866:	2301      	movs	r3, #1
  411868:	e000      	b.n	41186c <xQueueGenericSend+0x3c>
  41186a:	2300      	movs	r3, #0
  41186c:	2b00      	cmp	r3, #0
  41186e:	d105      	bne.n	41187c <xQueueGenericSend+0x4c>
  411870:	f240 22eb 	movw	r2, #747	; 0x2eb
  411874:	494d      	ldr	r1, [pc, #308]	; (4119ac <xQueueGenericSend+0x17c>)
  411876:	484e      	ldr	r0, [pc, #312]	; (4119b0 <xQueueGenericSend+0x180>)
  411878:	4b4e      	ldr	r3, [pc, #312]	; (4119b4 <xQueueGenericSend+0x184>)
  41187a:	4798      	blx	r3
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
  41187c:	683b      	ldr	r3, [r7, #0]
  41187e:	2b02      	cmp	r3, #2
  411880:	d103      	bne.n	41188a <xQueueGenericSend+0x5a>
  411882:	6a3b      	ldr	r3, [r7, #32]
  411884:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  411886:	2b01      	cmp	r3, #1
  411888:	d101      	bne.n	41188e <xQueueGenericSend+0x5e>
  41188a:	2301      	movs	r3, #1
  41188c:	e000      	b.n	411890 <xQueueGenericSend+0x60>
  41188e:	2300      	movs	r3, #0
  411890:	2b00      	cmp	r3, #0
  411892:	d105      	bne.n	4118a0 <xQueueGenericSend+0x70>
  411894:	f44f 723b 	mov.w	r2, #748	; 0x2ec
  411898:	4944      	ldr	r1, [pc, #272]	; (4119ac <xQueueGenericSend+0x17c>)
  41189a:	4845      	ldr	r0, [pc, #276]	; (4119b0 <xQueueGenericSend+0x180>)
  41189c:	4b45      	ldr	r3, [pc, #276]	; (4119b4 <xQueueGenericSend+0x184>)
  41189e:	4798      	blx	r3
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
  4118a0:	4b45      	ldr	r3, [pc, #276]	; (4119b8 <xQueueGenericSend+0x188>)
  4118a2:	4798      	blx	r3
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
  4118a4:	6a3b      	ldr	r3, [r7, #32]
  4118a6:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  4118a8:	6a3b      	ldr	r3, [r7, #32]
  4118aa:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  4118ac:	429a      	cmp	r2, r3
  4118ae:	d302      	bcc.n	4118b6 <xQueueGenericSend+0x86>
  4118b0:	683b      	ldr	r3, [r7, #0]
  4118b2:	2b02      	cmp	r3, #2
  4118b4:	d112      	bne.n	4118dc <xQueueGenericSend+0xac>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
  4118b6:	683a      	ldr	r2, [r7, #0]
  4118b8:	68b9      	ldr	r1, [r7, #8]
  4118ba:	6a38      	ldr	r0, [r7, #32]
  4118bc:	4b3f      	ldr	r3, [pc, #252]	; (4119bc <xQueueGenericSend+0x18c>)
  4118be:	4798      	blx	r3
  4118c0:	61f8      	str	r0, [r7, #28]

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  4118c2:	6a3b      	ldr	r3, [r7, #32]
  4118c4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  4118c6:	2b00      	cmp	r3, #0
  4118c8:	d004      	beq.n	4118d4 <xQueueGenericSend+0xa4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  4118ca:	6a3b      	ldr	r3, [r7, #32]
  4118cc:	3324      	adds	r3, #36	; 0x24
  4118ce:	4618      	mov	r0, r3
  4118d0:	4b3b      	ldr	r3, [pc, #236]	; (4119c0 <xQueueGenericSend+0x190>)
  4118d2:	4798      	blx	r3
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
  4118d4:	4b3b      	ldr	r3, [pc, #236]	; (4119c4 <xQueueGenericSend+0x194>)
  4118d6:	4798      	blx	r3
				return pdPASS;
  4118d8:	2301      	movs	r3, #1
  4118da:	e062      	b.n	4119a2 <xQueueGenericSend+0x172>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
  4118dc:	687b      	ldr	r3, [r7, #4]
  4118de:	2b00      	cmp	r3, #0
  4118e0:	d103      	bne.n	4118ea <xQueueGenericSend+0xba>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
  4118e2:	4b38      	ldr	r3, [pc, #224]	; (4119c4 <xQueueGenericSend+0x194>)
  4118e4:	4798      	blx	r3

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
  4118e6:	2300      	movs	r3, #0
  4118e8:	e05b      	b.n	4119a2 <xQueueGenericSend+0x172>
				}
				else if( xEntryTimeSet == pdFALSE )
  4118ea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4118ec:	2b00      	cmp	r3, #0
  4118ee:	d106      	bne.n	4118fe <xQueueGenericSend+0xce>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
  4118f0:	f107 0314 	add.w	r3, r7, #20
  4118f4:	4618      	mov	r0, r3
  4118f6:	4b34      	ldr	r3, [pc, #208]	; (4119c8 <xQueueGenericSend+0x198>)
  4118f8:	4798      	blx	r3
					xEntryTimeSet = pdTRUE;
  4118fa:	2301      	movs	r3, #1
  4118fc:	627b      	str	r3, [r7, #36]	; 0x24
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
  4118fe:	4b31      	ldr	r3, [pc, #196]	; (4119c4 <xQueueGenericSend+0x194>)
  411900:	4798      	blx	r3

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
  411902:	4b32      	ldr	r3, [pc, #200]	; (4119cc <xQueueGenericSend+0x19c>)
  411904:	4798      	blx	r3
		prvLockQueue( pxQueue );
  411906:	4b2c      	ldr	r3, [pc, #176]	; (4119b8 <xQueueGenericSend+0x188>)
  411908:	4798      	blx	r3
  41190a:	6a3b      	ldr	r3, [r7, #32]
  41190c:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
  411910:	b25b      	sxtb	r3, r3
  411912:	f1b3 3fff 	cmp.w	r3, #4294967295
  411916:	d103      	bne.n	411920 <xQueueGenericSend+0xf0>
  411918:	6a3b      	ldr	r3, [r7, #32]
  41191a:	2200      	movs	r2, #0
  41191c:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
  411920:	6a3b      	ldr	r3, [r7, #32]
  411922:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
  411926:	b25b      	sxtb	r3, r3
  411928:	f1b3 3fff 	cmp.w	r3, #4294967295
  41192c:	d103      	bne.n	411936 <xQueueGenericSend+0x106>
  41192e:	6a3b      	ldr	r3, [r7, #32]
  411930:	2200      	movs	r2, #0
  411932:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
  411936:	4b23      	ldr	r3, [pc, #140]	; (4119c4 <xQueueGenericSend+0x194>)
  411938:	4798      	blx	r3

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  41193a:	1d3a      	adds	r2, r7, #4
  41193c:	f107 0314 	add.w	r3, r7, #20
  411940:	4611      	mov	r1, r2
  411942:	4618      	mov	r0, r3
  411944:	4b22      	ldr	r3, [pc, #136]	; (4119d0 <xQueueGenericSend+0x1a0>)
  411946:	4798      	blx	r3
  411948:	4603      	mov	r3, r0
  41194a:	2b00      	cmp	r3, #0
  41194c:	d123      	bne.n	411996 <xQueueGenericSend+0x166>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
  41194e:	6a38      	ldr	r0, [r7, #32]
  411950:	4b20      	ldr	r3, [pc, #128]	; (4119d4 <xQueueGenericSend+0x1a4>)
  411952:	4798      	blx	r3
  411954:	4603      	mov	r3, r0
  411956:	2b00      	cmp	r3, #0
  411958:	d017      	beq.n	41198a <xQueueGenericSend+0x15a>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
  41195a:	6a3b      	ldr	r3, [r7, #32]
  41195c:	3310      	adds	r3, #16
  41195e:	687a      	ldr	r2, [r7, #4]
  411960:	4611      	mov	r1, r2
  411962:	4618      	mov	r0, r3
  411964:	4b1c      	ldr	r3, [pc, #112]	; (4119d8 <xQueueGenericSend+0x1a8>)
  411966:	4798      	blx	r3
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
  411968:	6a38      	ldr	r0, [r7, #32]
  41196a:	4b1c      	ldr	r3, [pc, #112]	; (4119dc <xQueueGenericSend+0x1ac>)
  41196c:	4798      	blx	r3
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
  41196e:	4b1c      	ldr	r3, [pc, #112]	; (4119e0 <xQueueGenericSend+0x1b0>)
  411970:	4798      	blx	r3
  411972:	4603      	mov	r3, r0
  411974:	2b00      	cmp	r3, #0
  411976:	d193      	bne.n	4118a0 <xQueueGenericSend+0x70>
				{
					portYIELD_WITHIN_API();
  411978:	4b1a      	ldr	r3, [pc, #104]	; (4119e4 <xQueueGenericSend+0x1b4>)
  41197a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  41197e:	601a      	str	r2, [r3, #0]
  411980:	f3bf 8f4f 	dsb	sy
  411984:	f3bf 8f6f 	isb	sy
  411988:	e78a      	b.n	4118a0 <xQueueGenericSend+0x70>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
  41198a:	6a38      	ldr	r0, [r7, #32]
  41198c:	4b13      	ldr	r3, [pc, #76]	; (4119dc <xQueueGenericSend+0x1ac>)
  41198e:	4798      	blx	r3
				( void ) xTaskResumeAll();
  411990:	4b13      	ldr	r3, [pc, #76]	; (4119e0 <xQueueGenericSend+0x1b0>)
  411992:	4798      	blx	r3
  411994:	e784      	b.n	4118a0 <xQueueGenericSend+0x70>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
  411996:	6a38      	ldr	r0, [r7, #32]
  411998:	4b10      	ldr	r3, [pc, #64]	; (4119dc <xQueueGenericSend+0x1ac>)
  41199a:	4798      	blx	r3
			( void ) xTaskResumeAll();
  41199c:	4b10      	ldr	r3, [pc, #64]	; (4119e0 <xQueueGenericSend+0x1b0>)
  41199e:	4798      	blx	r3

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
  4119a0:	2300      	movs	r3, #0
		}
	} /*lint -restore */
}
  4119a2:	4618      	mov	r0, r3
  4119a4:	3728      	adds	r7, #40	; 0x28
  4119a6:	46bd      	mov	sp, r7
  4119a8:	bd80      	pop	{r7, pc}
  4119aa:	bf00      	nop
  4119ac:	0041e1b0 	.word	0x0041e1b0
  4119b0:	0041e1e8 	.word	0x0041e1e8
  4119b4:	00416c7d 	.word	0x00416c7d
  4119b8:	0041103d 	.word	0x0041103d
  4119bc:	004120ad 	.word	0x004120ad
  4119c0:	00412af5 	.word	0x00412af5
  4119c4:	00411099 	.word	0x00411099
  4119c8:	00412ce1 	.word	0x00412ce1
  4119cc:	0041267d 	.word	0x0041267d
  4119d0:	00412d0d 	.word	0x00412d0d
  4119d4:	004122c1 	.word	0x004122c1
  4119d8:	00412a29 	.word	0x00412a29
  4119dc:	004121d9 	.word	0x004121d9
  4119e0:	00412699 	.word	0x00412699
  4119e4:	e000ed04 	.word	0xe000ed04

004119e8 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
  4119e8:	b580      	push	{r7, lr}
  4119ea:	b08c      	sub	sp, #48	; 0x30
  4119ec:	af00      	add	r7, sp, #0
  4119ee:	60f8      	str	r0, [r7, #12]
  4119f0:	60b9      	str	r1, [r7, #8]
  4119f2:	607a      	str	r2, [r7, #4]
  4119f4:	603b      	str	r3, [r7, #0]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
  4119f6:	68fb      	ldr	r3, [r7, #12]
  4119f8:	62bb      	str	r3, [r7, #40]	; 0x28

	configASSERT( pxQueue );
  4119fa:	6abb      	ldr	r3, [r7, #40]	; 0x28
  4119fc:	2b00      	cmp	r3, #0
  4119fe:	d105      	bne.n	411a0c <xQueueGenericSendFromISR+0x24>
  411a00:	f44f 726f 	mov.w	r2, #956	; 0x3bc
  411a04:	493d      	ldr	r1, [pc, #244]	; (411afc <xQueueGenericSendFromISR+0x114>)
  411a06:	483e      	ldr	r0, [pc, #248]	; (411b00 <xQueueGenericSendFromISR+0x118>)
  411a08:	4b3e      	ldr	r3, [pc, #248]	; (411b04 <xQueueGenericSendFromISR+0x11c>)
  411a0a:	4798      	blx	r3
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
  411a0c:	68bb      	ldr	r3, [r7, #8]
  411a0e:	2b00      	cmp	r3, #0
  411a10:	d103      	bne.n	411a1a <xQueueGenericSendFromISR+0x32>
  411a12:	6abb      	ldr	r3, [r7, #40]	; 0x28
  411a14:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  411a16:	2b00      	cmp	r3, #0
  411a18:	d101      	bne.n	411a1e <xQueueGenericSendFromISR+0x36>
  411a1a:	2301      	movs	r3, #1
  411a1c:	e000      	b.n	411a20 <xQueueGenericSendFromISR+0x38>
  411a1e:	2300      	movs	r3, #0
  411a20:	2b00      	cmp	r3, #0
  411a22:	d105      	bne.n	411a30 <xQueueGenericSendFromISR+0x48>
  411a24:	f240 32bd 	movw	r2, #957	; 0x3bd
  411a28:	4934      	ldr	r1, [pc, #208]	; (411afc <xQueueGenericSendFromISR+0x114>)
  411a2a:	4835      	ldr	r0, [pc, #212]	; (411b00 <xQueueGenericSendFromISR+0x118>)
  411a2c:	4b35      	ldr	r3, [pc, #212]	; (411b04 <xQueueGenericSendFromISR+0x11c>)
  411a2e:	4798      	blx	r3
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
  411a30:	683b      	ldr	r3, [r7, #0]
  411a32:	2b02      	cmp	r3, #2
  411a34:	d103      	bne.n	411a3e <xQueueGenericSendFromISR+0x56>
  411a36:	6abb      	ldr	r3, [r7, #40]	; 0x28
  411a38:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  411a3a:	2b01      	cmp	r3, #1
  411a3c:	d101      	bne.n	411a42 <xQueueGenericSendFromISR+0x5a>
  411a3e:	2301      	movs	r3, #1
  411a40:	e000      	b.n	411a44 <xQueueGenericSendFromISR+0x5c>
  411a42:	2300      	movs	r3, #0
  411a44:	2b00      	cmp	r3, #0
  411a46:	d105      	bne.n	411a54 <xQueueGenericSendFromISR+0x6c>
  411a48:	f240 32be 	movw	r2, #958	; 0x3be
  411a4c:	492b      	ldr	r1, [pc, #172]	; (411afc <xQueueGenericSendFromISR+0x114>)
  411a4e:	482c      	ldr	r0, [pc, #176]	; (411b00 <xQueueGenericSendFromISR+0x118>)
  411a50:	4b2c      	ldr	r3, [pc, #176]	; (411b04 <xQueueGenericSendFromISR+0x11c>)
  411a52:	4798      	blx	r3
	__asm volatile
  411a54:	f3ef 8211 	mrs	r2, BASEPRI
  411a58:	f04f 0350 	mov.w	r3, #80	; 0x50
  411a5c:	f383 8811 	msr	BASEPRI, r3
  411a60:	f3bf 8f6f 	isb	sy
  411a64:	f3bf 8f4f 	dsb	sy
  411a68:	61ba      	str	r2, [r7, #24]
  411a6a:	617b      	str	r3, [r7, #20]
	return ulOriginalBASEPRI;
  411a6c:	69bb      	ldr	r3, [r7, #24]
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  411a6e:	627b      	str	r3, [r7, #36]	; 0x24
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
  411a70:	6abb      	ldr	r3, [r7, #40]	; 0x28
  411a72:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  411a74:	6abb      	ldr	r3, [r7, #40]	; 0x28
  411a76:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  411a78:	429a      	cmp	r2, r3
  411a7a:	d302      	bcc.n	411a82 <xQueueGenericSendFromISR+0x9a>
  411a7c:	683b      	ldr	r3, [r7, #0]
  411a7e:	2b02      	cmp	r3, #2
  411a80:	d12f      	bne.n	411ae2 <xQueueGenericSendFromISR+0xfa>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
  411a82:	6abb      	ldr	r3, [r7, #40]	; 0x28
  411a84:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
  411a88:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
			const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
  411a8c:	6abb      	ldr	r3, [r7, #40]	; 0x28
  411a8e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  411a90:	61fb      	str	r3, [r7, #28]
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
  411a92:	683a      	ldr	r2, [r7, #0]
  411a94:	68b9      	ldr	r1, [r7, #8]
  411a96:	6ab8      	ldr	r0, [r7, #40]	; 0x28
  411a98:	4b1b      	ldr	r3, [pc, #108]	; (411b08 <xQueueGenericSendFromISR+0x120>)
  411a9a:	4798      	blx	r3

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
  411a9c:	f997 3023 	ldrsb.w	r3, [r7, #35]	; 0x23
  411aa0:	f1b3 3fff 	cmp.w	r3, #4294967295
  411aa4:	d112      	bne.n	411acc <xQueueGenericSendFromISR+0xe4>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  411aa6:	6abb      	ldr	r3, [r7, #40]	; 0x28
  411aa8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  411aaa:	2b00      	cmp	r3, #0
  411aac:	d016      	beq.n	411adc <xQueueGenericSendFromISR+0xf4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  411aae:	6abb      	ldr	r3, [r7, #40]	; 0x28
  411ab0:	3324      	adds	r3, #36	; 0x24
  411ab2:	4618      	mov	r0, r3
  411ab4:	4b15      	ldr	r3, [pc, #84]	; (411b0c <xQueueGenericSendFromISR+0x124>)
  411ab6:	4798      	blx	r3
  411ab8:	4603      	mov	r3, r0
  411aba:	2b00      	cmp	r3, #0
  411abc:	d00e      	beq.n	411adc <xQueueGenericSendFromISR+0xf4>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
  411abe:	687b      	ldr	r3, [r7, #4]
  411ac0:	2b00      	cmp	r3, #0
  411ac2:	d00b      	beq.n	411adc <xQueueGenericSendFromISR+0xf4>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
  411ac4:	687b      	ldr	r3, [r7, #4]
  411ac6:	2201      	movs	r2, #1
  411ac8:	601a      	str	r2, [r3, #0]
  411aca:	e007      	b.n	411adc <xQueueGenericSendFromISR+0xf4>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
  411acc:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
  411ad0:	3301      	adds	r3, #1
  411ad2:	b2db      	uxtb	r3, r3
  411ad4:	b25a      	sxtb	r2, r3
  411ad6:	6abb      	ldr	r3, [r7, #40]	; 0x28
  411ad8:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
			}

			xReturn = pdPASS;
  411adc:	2301      	movs	r3, #1
  411ade:	62fb      	str	r3, [r7, #44]	; 0x2c
		{
  411ae0:	e001      	b.n	411ae6 <xQueueGenericSendFromISR+0xfe>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
  411ae2:	2300      	movs	r3, #0
  411ae4:	62fb      	str	r3, [r7, #44]	; 0x2c
  411ae6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  411ae8:	613b      	str	r3, [r7, #16]
	__asm volatile
  411aea:	693b      	ldr	r3, [r7, #16]
  411aec:	f383 8811 	msr	BASEPRI, r3
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
  411af0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
}
  411af2:	4618      	mov	r0, r3
  411af4:	3730      	adds	r7, #48	; 0x30
  411af6:	46bd      	mov	sp, r7
  411af8:	bd80      	pop	{r7, pc}
  411afa:	bf00      	nop
  411afc:	0041e1b0 	.word	0x0041e1b0
  411b00:	0041e1e8 	.word	0x0041e1e8
  411b04:	00416c7d 	.word	0x00416c7d
  411b08:	004120ad 	.word	0x004120ad
  411b0c:	00412af5 	.word	0x00412af5

00411b10 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
  411b10:	b580      	push	{r7, lr}
  411b12:	b08a      	sub	sp, #40	; 0x28
  411b14:	af00      	add	r7, sp, #0
  411b16:	6078      	str	r0, [r7, #4]
  411b18:	6039      	str	r1, [r7, #0]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
  411b1a:	687b      	ldr	r3, [r7, #4]
  411b1c:	623b      	str	r3, [r7, #32]
	item size is 0.  Don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */

	configASSERT( pxQueue );
  411b1e:	6a3b      	ldr	r3, [r7, #32]
  411b20:	2b00      	cmp	r3, #0
  411b22:	d105      	bne.n	411b30 <xQueueGiveFromISR+0x20>
  411b24:	f240 4264 	movw	r2, #1124	; 0x464
  411b28:	4936      	ldr	r1, [pc, #216]	; (411c04 <xQueueGiveFromISR+0xf4>)
  411b2a:	4837      	ldr	r0, [pc, #220]	; (411c08 <xQueueGiveFromISR+0xf8>)
  411b2c:	4b37      	ldr	r3, [pc, #220]	; (411c0c <xQueueGiveFromISR+0xfc>)
  411b2e:	4798      	blx	r3

	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
	if the item size is not 0. */
	configASSERT( pxQueue->uxItemSize == 0 );
  411b30:	6a3b      	ldr	r3, [r7, #32]
  411b32:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  411b34:	2b00      	cmp	r3, #0
  411b36:	d005      	beq.n	411b44 <xQueueGiveFromISR+0x34>
  411b38:	f44f 628d 	mov.w	r2, #1128	; 0x468
  411b3c:	4931      	ldr	r1, [pc, #196]	; (411c04 <xQueueGiveFromISR+0xf4>)
  411b3e:	4832      	ldr	r0, [pc, #200]	; (411c08 <xQueueGiveFromISR+0xf8>)
  411b40:	4b32      	ldr	r3, [pc, #200]	; (411c0c <xQueueGiveFromISR+0xfc>)
  411b42:	4798      	blx	r3

	/* Normally a mutex would not be given from an interrupt, especially if
	there is a mutex holder, as priority inheritance makes no sense for an
	interrupts, only tasks. */
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
  411b44:	6a3b      	ldr	r3, [r7, #32]
  411b46:	681b      	ldr	r3, [r3, #0]
  411b48:	2b00      	cmp	r3, #0
  411b4a:	d103      	bne.n	411b54 <xQueueGiveFromISR+0x44>
  411b4c:	6a3b      	ldr	r3, [r7, #32]
  411b4e:	689b      	ldr	r3, [r3, #8]
  411b50:	2b00      	cmp	r3, #0
  411b52:	d101      	bne.n	411b58 <xQueueGiveFromISR+0x48>
  411b54:	2301      	movs	r3, #1
  411b56:	e000      	b.n	411b5a <xQueueGiveFromISR+0x4a>
  411b58:	2300      	movs	r3, #0
  411b5a:	2b00      	cmp	r3, #0
  411b5c:	d105      	bne.n	411b6a <xQueueGiveFromISR+0x5a>
  411b5e:	f240 426d 	movw	r2, #1133	; 0x46d
  411b62:	4928      	ldr	r1, [pc, #160]	; (411c04 <xQueueGiveFromISR+0xf4>)
  411b64:	4828      	ldr	r0, [pc, #160]	; (411c08 <xQueueGiveFromISR+0xf8>)
  411b66:	4b29      	ldr	r3, [pc, #164]	; (411c0c <xQueueGiveFromISR+0xfc>)
  411b68:	4798      	blx	r3
	__asm volatile
  411b6a:	f3ef 8211 	mrs	r2, BASEPRI
  411b6e:	f04f 0350 	mov.w	r3, #80	; 0x50
  411b72:	f383 8811 	msr	BASEPRI, r3
  411b76:	f3bf 8f6f 	isb	sy
  411b7a:	f3bf 8f4f 	dsb	sy
  411b7e:	613a      	str	r2, [r7, #16]
  411b80:	60fb      	str	r3, [r7, #12]
	return ulOriginalBASEPRI;
  411b82:	693b      	ldr	r3, [r7, #16]
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  411b84:	61fb      	str	r3, [r7, #28]
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
  411b86:	6a3b      	ldr	r3, [r7, #32]
  411b88:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  411b8a:	61bb      	str	r3, [r7, #24]

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
  411b8c:	6a3b      	ldr	r3, [r7, #32]
  411b8e:	6bda      	ldr	r2, [r3, #60]	; 0x3c
  411b90:	69bb      	ldr	r3, [r7, #24]
  411b92:	429a      	cmp	r2, r3
  411b94:	d929      	bls.n	411bea <xQueueGiveFromISR+0xda>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
  411b96:	6a3b      	ldr	r3, [r7, #32]
  411b98:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
  411b9c:	75fb      	strb	r3, [r7, #23]
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
  411b9e:	69bb      	ldr	r3, [r7, #24]
  411ba0:	1c5a      	adds	r2, r3, #1
  411ba2:	6a3b      	ldr	r3, [r7, #32]
  411ba4:	639a      	str	r2, [r3, #56]	; 0x38

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
  411ba6:	f997 3017 	ldrsb.w	r3, [r7, #23]
  411baa:	f1b3 3fff 	cmp.w	r3, #4294967295
  411bae:	d112      	bne.n	411bd6 <xQueueGiveFromISR+0xc6>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  411bb0:	6a3b      	ldr	r3, [r7, #32]
  411bb2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  411bb4:	2b00      	cmp	r3, #0
  411bb6:	d015      	beq.n	411be4 <xQueueGiveFromISR+0xd4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  411bb8:	6a3b      	ldr	r3, [r7, #32]
  411bba:	3324      	adds	r3, #36	; 0x24
  411bbc:	4618      	mov	r0, r3
  411bbe:	4b14      	ldr	r3, [pc, #80]	; (411c10 <xQueueGiveFromISR+0x100>)
  411bc0:	4798      	blx	r3
  411bc2:	4603      	mov	r3, r0
  411bc4:	2b00      	cmp	r3, #0
  411bc6:	d00d      	beq.n	411be4 <xQueueGiveFromISR+0xd4>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
  411bc8:	683b      	ldr	r3, [r7, #0]
  411bca:	2b00      	cmp	r3, #0
  411bcc:	d00a      	beq.n	411be4 <xQueueGiveFromISR+0xd4>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
  411bce:	683b      	ldr	r3, [r7, #0]
  411bd0:	2201      	movs	r2, #1
  411bd2:	601a      	str	r2, [r3, #0]
  411bd4:	e006      	b.n	411be4 <xQueueGiveFromISR+0xd4>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
  411bd6:	7dfb      	ldrb	r3, [r7, #23]
  411bd8:	3301      	adds	r3, #1
  411bda:	b2db      	uxtb	r3, r3
  411bdc:	b25a      	sxtb	r2, r3
  411bde:	6a3b      	ldr	r3, [r7, #32]
  411be0:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
			}

			xReturn = pdPASS;
  411be4:	2301      	movs	r3, #1
  411be6:	627b      	str	r3, [r7, #36]	; 0x24
  411be8:	e001      	b.n	411bee <xQueueGiveFromISR+0xde>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
  411bea:	2300      	movs	r3, #0
  411bec:	627b      	str	r3, [r7, #36]	; 0x24
  411bee:	69fb      	ldr	r3, [r7, #28]
  411bf0:	60bb      	str	r3, [r7, #8]
	__asm volatile
  411bf2:	68bb      	ldr	r3, [r7, #8]
  411bf4:	f383 8811 	msr	BASEPRI, r3
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
  411bf8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
  411bfa:	4618      	mov	r0, r3
  411bfc:	3728      	adds	r7, #40	; 0x28
  411bfe:	46bd      	mov	sp, r7
  411c00:	bd80      	pop	{r7, pc}
  411c02:	bf00      	nop
  411c04:	0041e1b0 	.word	0x0041e1b0
  411c08:	0041e1e8 	.word	0x0041e1e8
  411c0c:	00416c7d 	.word	0x00416c7d
  411c10:	00412af5 	.word	0x00412af5

00411c14 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
  411c14:	b580      	push	{r7, lr}
  411c16:	b08a      	sub	sp, #40	; 0x28
  411c18:	af00      	add	r7, sp, #0
  411c1a:	60f8      	str	r0, [r7, #12]
  411c1c:	60b9      	str	r1, [r7, #8]
  411c1e:	607a      	str	r2, [r7, #4]
BaseType_t xEntryTimeSet = pdFALSE;
  411c20:	2300      	movs	r3, #0
  411c22:	627b      	str	r3, [r7, #36]	; 0x24
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
  411c24:	68fb      	ldr	r3, [r7, #12]
  411c26:	623b      	str	r3, [r7, #32]

	/* Check the pointer is not NULL. */
	configASSERT( ( pxQueue ) );
  411c28:	6a3b      	ldr	r3, [r7, #32]
  411c2a:	2b00      	cmp	r3, #0
  411c2c:	d105      	bne.n	411c3a <xQueueReceive+0x26>
  411c2e:	f240 5204 	movw	r2, #1284	; 0x504
  411c32:	4950      	ldr	r1, [pc, #320]	; (411d74 <xQueueReceive+0x160>)
  411c34:	4850      	ldr	r0, [pc, #320]	; (411d78 <xQueueReceive+0x164>)
  411c36:	4b51      	ldr	r3, [pc, #324]	; (411d7c <xQueueReceive+0x168>)
  411c38:	4798      	blx	r3

	/* The buffer into which data is received can only be NULL if the data size
	is zero (so no data is copied into the buffer. */
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
  411c3a:	68bb      	ldr	r3, [r7, #8]
  411c3c:	2b00      	cmp	r3, #0
  411c3e:	d103      	bne.n	411c48 <xQueueReceive+0x34>
  411c40:	6a3b      	ldr	r3, [r7, #32]
  411c42:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  411c44:	2b00      	cmp	r3, #0
  411c46:	d101      	bne.n	411c4c <xQueueReceive+0x38>
  411c48:	2301      	movs	r3, #1
  411c4a:	e000      	b.n	411c4e <xQueueReceive+0x3a>
  411c4c:	2300      	movs	r3, #0
  411c4e:	2b00      	cmp	r3, #0
  411c50:	d105      	bne.n	411c5e <xQueueReceive+0x4a>
  411c52:	f44f 62a1 	mov.w	r2, #1288	; 0x508
  411c56:	4947      	ldr	r1, [pc, #284]	; (411d74 <xQueueReceive+0x160>)
  411c58:	4847      	ldr	r0, [pc, #284]	; (411d78 <xQueueReceive+0x164>)
  411c5a:	4b48      	ldr	r3, [pc, #288]	; (411d7c <xQueueReceive+0x168>)
  411c5c:	4798      	blx	r3
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
  411c5e:	4b48      	ldr	r3, [pc, #288]	; (411d80 <xQueueReceive+0x16c>)
  411c60:	4798      	blx	r3
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
  411c62:	6a3b      	ldr	r3, [r7, #32]
  411c64:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  411c66:	61fb      	str	r3, [r7, #28]

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
  411c68:	69fb      	ldr	r3, [r7, #28]
  411c6a:	2b00      	cmp	r3, #0
  411c6c:	d014      	beq.n	411c98 <xQueueReceive+0x84>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
  411c6e:	68b9      	ldr	r1, [r7, #8]
  411c70:	6a38      	ldr	r0, [r7, #32]
  411c72:	4b44      	ldr	r3, [pc, #272]	; (411d84 <xQueueReceive+0x170>)
  411c74:	4798      	blx	r3
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
  411c76:	69fb      	ldr	r3, [r7, #28]
  411c78:	1e5a      	subs	r2, r3, #1
  411c7a:	6a3b      	ldr	r3, [r7, #32]
  411c7c:	639a      	str	r2, [r3, #56]	; 0x38

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  411c7e:	6a3b      	ldr	r3, [r7, #32]
  411c80:	691b      	ldr	r3, [r3, #16]
  411c82:	2b00      	cmp	r3, #0
  411c84:	d004      	beq.n	411c90 <xQueueReceive+0x7c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  411c86:	6a3b      	ldr	r3, [r7, #32]
  411c88:	3310      	adds	r3, #16
  411c8a:	4618      	mov	r0, r3
  411c8c:	4b3e      	ldr	r3, [pc, #248]	; (411d88 <xQueueReceive+0x174>)
  411c8e:	4798      	blx	r3
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
  411c90:	4b3e      	ldr	r3, [pc, #248]	; (411d8c <xQueueReceive+0x178>)
  411c92:	4798      	blx	r3
				return pdPASS;
  411c94:	2301      	movs	r3, #1
  411c96:	e069      	b.n	411d6c <xQueueReceive+0x158>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
  411c98:	687b      	ldr	r3, [r7, #4]
  411c9a:	2b00      	cmp	r3, #0
  411c9c:	d103      	bne.n	411ca6 <xQueueReceive+0x92>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
  411c9e:	4b3b      	ldr	r3, [pc, #236]	; (411d8c <xQueueReceive+0x178>)
  411ca0:	4798      	blx	r3
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
  411ca2:	2300      	movs	r3, #0
  411ca4:	e062      	b.n	411d6c <xQueueReceive+0x158>
				}
				else if( xEntryTimeSet == pdFALSE )
  411ca6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  411ca8:	2b00      	cmp	r3, #0
  411caa:	d106      	bne.n	411cba <xQueueReceive+0xa6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
  411cac:	f107 0314 	add.w	r3, r7, #20
  411cb0:	4618      	mov	r0, r3
  411cb2:	4b37      	ldr	r3, [pc, #220]	; (411d90 <xQueueReceive+0x17c>)
  411cb4:	4798      	blx	r3
					xEntryTimeSet = pdTRUE;
  411cb6:	2301      	movs	r3, #1
  411cb8:	627b      	str	r3, [r7, #36]	; 0x24
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
  411cba:	4b34      	ldr	r3, [pc, #208]	; (411d8c <xQueueReceive+0x178>)
  411cbc:	4798      	blx	r3

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
  411cbe:	4b35      	ldr	r3, [pc, #212]	; (411d94 <xQueueReceive+0x180>)
  411cc0:	4798      	blx	r3
		prvLockQueue( pxQueue );
  411cc2:	4b2f      	ldr	r3, [pc, #188]	; (411d80 <xQueueReceive+0x16c>)
  411cc4:	4798      	blx	r3
  411cc6:	6a3b      	ldr	r3, [r7, #32]
  411cc8:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
  411ccc:	b25b      	sxtb	r3, r3
  411cce:	f1b3 3fff 	cmp.w	r3, #4294967295
  411cd2:	d103      	bne.n	411cdc <xQueueReceive+0xc8>
  411cd4:	6a3b      	ldr	r3, [r7, #32]
  411cd6:	2200      	movs	r2, #0
  411cd8:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
  411cdc:	6a3b      	ldr	r3, [r7, #32]
  411cde:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
  411ce2:	b25b      	sxtb	r3, r3
  411ce4:	f1b3 3fff 	cmp.w	r3, #4294967295
  411ce8:	d103      	bne.n	411cf2 <xQueueReceive+0xde>
  411cea:	6a3b      	ldr	r3, [r7, #32]
  411cec:	2200      	movs	r2, #0
  411cee:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
  411cf2:	4b26      	ldr	r3, [pc, #152]	; (411d8c <xQueueReceive+0x178>)
  411cf4:	4798      	blx	r3

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  411cf6:	1d3a      	adds	r2, r7, #4
  411cf8:	f107 0314 	add.w	r3, r7, #20
  411cfc:	4611      	mov	r1, r2
  411cfe:	4618      	mov	r0, r3
  411d00:	4b25      	ldr	r3, [pc, #148]	; (411d98 <xQueueReceive+0x184>)
  411d02:	4798      	blx	r3
  411d04:	4603      	mov	r3, r0
  411d06:	2b00      	cmp	r3, #0
  411d08:	d123      	bne.n	411d52 <xQueueReceive+0x13e>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
  411d0a:	6a38      	ldr	r0, [r7, #32]
  411d0c:	4b23      	ldr	r3, [pc, #140]	; (411d9c <xQueueReceive+0x188>)
  411d0e:	4798      	blx	r3
  411d10:	4603      	mov	r3, r0
  411d12:	2b00      	cmp	r3, #0
  411d14:	d017      	beq.n	411d46 <xQueueReceive+0x132>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
  411d16:	6a3b      	ldr	r3, [r7, #32]
  411d18:	3324      	adds	r3, #36	; 0x24
  411d1a:	687a      	ldr	r2, [r7, #4]
  411d1c:	4611      	mov	r1, r2
  411d1e:	4618      	mov	r0, r3
  411d20:	4b1f      	ldr	r3, [pc, #124]	; (411da0 <xQueueReceive+0x18c>)
  411d22:	4798      	blx	r3
				prvUnlockQueue( pxQueue );
  411d24:	6a38      	ldr	r0, [r7, #32]
  411d26:	4b1f      	ldr	r3, [pc, #124]	; (411da4 <xQueueReceive+0x190>)
  411d28:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
  411d2a:	4b1f      	ldr	r3, [pc, #124]	; (411da8 <xQueueReceive+0x194>)
  411d2c:	4798      	blx	r3
  411d2e:	4603      	mov	r3, r0
  411d30:	2b00      	cmp	r3, #0
  411d32:	d194      	bne.n	411c5e <xQueueReceive+0x4a>
				{
					portYIELD_WITHIN_API();
  411d34:	4b1d      	ldr	r3, [pc, #116]	; (411dac <xQueueReceive+0x198>)
  411d36:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  411d3a:	601a      	str	r2, [r3, #0]
  411d3c:	f3bf 8f4f 	dsb	sy
  411d40:	f3bf 8f6f 	isb	sy
  411d44:	e78b      	b.n	411c5e <xQueueReceive+0x4a>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
  411d46:	6a38      	ldr	r0, [r7, #32]
  411d48:	4b16      	ldr	r3, [pc, #88]	; (411da4 <xQueueReceive+0x190>)
  411d4a:	4798      	blx	r3
				( void ) xTaskResumeAll();
  411d4c:	4b16      	ldr	r3, [pc, #88]	; (411da8 <xQueueReceive+0x194>)
  411d4e:	4798      	blx	r3
  411d50:	e785      	b.n	411c5e <xQueueReceive+0x4a>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
  411d52:	6a38      	ldr	r0, [r7, #32]
  411d54:	4b13      	ldr	r3, [pc, #76]	; (411da4 <xQueueReceive+0x190>)
  411d56:	4798      	blx	r3
			( void ) xTaskResumeAll();
  411d58:	4b13      	ldr	r3, [pc, #76]	; (411da8 <xQueueReceive+0x194>)
  411d5a:	4798      	blx	r3

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
  411d5c:	6a38      	ldr	r0, [r7, #32]
  411d5e:	4b0f      	ldr	r3, [pc, #60]	; (411d9c <xQueueReceive+0x188>)
  411d60:	4798      	blx	r3
  411d62:	4603      	mov	r3, r0
  411d64:	2b00      	cmp	r3, #0
  411d66:	f43f af7a 	beq.w	411c5e <xQueueReceive+0x4a>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
  411d6a:	2300      	movs	r3, #0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
  411d6c:	4618      	mov	r0, r3
  411d6e:	3728      	adds	r7, #40	; 0x28
  411d70:	46bd      	mov	sp, r7
  411d72:	bd80      	pop	{r7, pc}
  411d74:	0041e1b0 	.word	0x0041e1b0
  411d78:	0041e1e8 	.word	0x0041e1e8
  411d7c:	00416c7d 	.word	0x00416c7d
  411d80:	0041103d 	.word	0x0041103d
  411d84:	00412189 	.word	0x00412189
  411d88:	00412af5 	.word	0x00412af5
  411d8c:	00411099 	.word	0x00411099
  411d90:	00412ce1 	.word	0x00412ce1
  411d94:	0041267d 	.word	0x0041267d
  411d98:	00412d0d 	.word	0x00412d0d
  411d9c:	0041228d 	.word	0x0041228d
  411da0:	00412a29 	.word	0x00412a29
  411da4:	004121d9 	.word	0x004121d9
  411da8:	00412699 	.word	0x00412699
  411dac:	e000ed04 	.word	0xe000ed04

00411db0 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
  411db0:	b580      	push	{r7, lr}
  411db2:	b08a      	sub	sp, #40	; 0x28
  411db4:	af00      	add	r7, sp, #0
  411db6:	6078      	str	r0, [r7, #4]
  411db8:	6039      	str	r1, [r7, #0]
BaseType_t xEntryTimeSet = pdFALSE;
  411dba:	2300      	movs	r3, #0
  411dbc:	627b      	str	r3, [r7, #36]	; 0x24
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
  411dbe:	687b      	ldr	r3, [r7, #4]
  411dc0:	61fb      	str	r3, [r7, #28]

#if( configUSE_MUTEXES == 1 )
	BaseType_t xInheritanceOccurred = pdFALSE;
  411dc2:	2300      	movs	r3, #0
  411dc4:	623b      	str	r3, [r7, #32]
#endif

	/* Check the queue pointer is not NULL. */
	configASSERT( ( pxQueue ) );
  411dc6:	69fb      	ldr	r3, [r7, #28]
  411dc8:	2b00      	cmp	r3, #0
  411dca:	d105      	bne.n	411dd8 <xQueueSemaphoreTake+0x28>
  411dcc:	f240 5295 	movw	r2, #1429	; 0x595
  411dd0:	4963      	ldr	r1, [pc, #396]	; (411f60 <xQueueSemaphoreTake+0x1b0>)
  411dd2:	4864      	ldr	r0, [pc, #400]	; (411f64 <xQueueSemaphoreTake+0x1b4>)
  411dd4:	4b64      	ldr	r3, [pc, #400]	; (411f68 <xQueueSemaphoreTake+0x1b8>)
  411dd6:	4798      	blx	r3

	/* Check this really is a semaphore, in which case the item size will be
	0. */
	configASSERT( pxQueue->uxItemSize == 0 );
  411dd8:	69fb      	ldr	r3, [r7, #28]
  411dda:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  411ddc:	2b00      	cmp	r3, #0
  411dde:	d005      	beq.n	411dec <xQueueSemaphoreTake+0x3c>
  411de0:	f240 5299 	movw	r2, #1433	; 0x599
  411de4:	495e      	ldr	r1, [pc, #376]	; (411f60 <xQueueSemaphoreTake+0x1b0>)
  411de6:	485f      	ldr	r0, [pc, #380]	; (411f64 <xQueueSemaphoreTake+0x1b4>)
  411de8:	4b5f      	ldr	r3, [pc, #380]	; (411f68 <xQueueSemaphoreTake+0x1b8>)
  411dea:	4798      	blx	r3
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
  411dec:	4b5f      	ldr	r3, [pc, #380]	; (411f6c <xQueueSemaphoreTake+0x1bc>)
  411dee:	4798      	blx	r3
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
  411df0:	69fb      	ldr	r3, [r7, #28]
  411df2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  411df4:	61bb      	str	r3, [r7, #24]

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
  411df6:	69bb      	ldr	r3, [r7, #24]
  411df8:	2b00      	cmp	r3, #0
  411dfa:	d019      	beq.n	411e30 <xQueueSemaphoreTake+0x80>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
  411dfc:	69bb      	ldr	r3, [r7, #24]
  411dfe:	1e5a      	subs	r2, r3, #1
  411e00:	69fb      	ldr	r3, [r7, #28]
  411e02:	639a      	str	r2, [r3, #56]	; 0x38

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  411e04:	69fb      	ldr	r3, [r7, #28]
  411e06:	681b      	ldr	r3, [r3, #0]
  411e08:	2b00      	cmp	r3, #0
  411e0a:	d104      	bne.n	411e16 <xQueueSemaphoreTake+0x66>
					{
						/* Record the information required to implement
						priority inheritance should it become necessary. */
						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
  411e0c:	4b58      	ldr	r3, [pc, #352]	; (411f70 <xQueueSemaphoreTake+0x1c0>)
  411e0e:	4798      	blx	r3
  411e10:	4602      	mov	r2, r0
  411e12:	69fb      	ldr	r3, [r7, #28]
  411e14:	609a      	str	r2, [r3, #8]
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  411e16:	69fb      	ldr	r3, [r7, #28]
  411e18:	691b      	ldr	r3, [r3, #16]
  411e1a:	2b00      	cmp	r3, #0
  411e1c:	d004      	beq.n	411e28 <xQueueSemaphoreTake+0x78>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  411e1e:	69fb      	ldr	r3, [r7, #28]
  411e20:	3310      	adds	r3, #16
  411e22:	4618      	mov	r0, r3
  411e24:	4b53      	ldr	r3, [pc, #332]	; (411f74 <xQueueSemaphoreTake+0x1c4>)
  411e26:	4798      	blx	r3
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
  411e28:	4b53      	ldr	r3, [pc, #332]	; (411f78 <xQueueSemaphoreTake+0x1c8>)
  411e2a:	4798      	blx	r3
				return pdPASS;
  411e2c:	2301      	movs	r3, #1
  411e2e:	e092      	b.n	411f56 <xQueueSemaphoreTake+0x1a6>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
  411e30:	683b      	ldr	r3, [r7, #0]
  411e32:	2b00      	cmp	r3, #0
  411e34:	d10c      	bne.n	411e50 <xQueueSemaphoreTake+0xa0>
					/* For inheritance to have occurred there must have been an
					initial timeout, and an adjusted timeout cannot become 0, as
					if it were 0 the function would have exited. */
					#if( configUSE_MUTEXES == 1 )
					{
						configASSERT( xInheritanceOccurred == pdFALSE );
  411e36:	6a3b      	ldr	r3, [r7, #32]
  411e38:	2b00      	cmp	r3, #0
  411e3a:	d005      	beq.n	411e48 <xQueueSemaphoreTake+0x98>
  411e3c:	f240 52e5 	movw	r2, #1509	; 0x5e5
  411e40:	4947      	ldr	r1, [pc, #284]	; (411f60 <xQueueSemaphoreTake+0x1b0>)
  411e42:	4848      	ldr	r0, [pc, #288]	; (411f64 <xQueueSemaphoreTake+0x1b4>)
  411e44:	4b48      	ldr	r3, [pc, #288]	; (411f68 <xQueueSemaphoreTake+0x1b8>)
  411e46:	4798      	blx	r3
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
  411e48:	4b4b      	ldr	r3, [pc, #300]	; (411f78 <xQueueSemaphoreTake+0x1c8>)
  411e4a:	4798      	blx	r3
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
  411e4c:	2300      	movs	r3, #0
  411e4e:	e082      	b.n	411f56 <xQueueSemaphoreTake+0x1a6>
				}
				else if( xEntryTimeSet == pdFALSE )
  411e50:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  411e52:	2b00      	cmp	r3, #0
  411e54:	d106      	bne.n	411e64 <xQueueSemaphoreTake+0xb4>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
  411e56:	f107 030c 	add.w	r3, r7, #12
  411e5a:	4618      	mov	r0, r3
  411e5c:	4b47      	ldr	r3, [pc, #284]	; (411f7c <xQueueSemaphoreTake+0x1cc>)
  411e5e:	4798      	blx	r3
					xEntryTimeSet = pdTRUE;
  411e60:	2301      	movs	r3, #1
  411e62:	627b      	str	r3, [r7, #36]	; 0x24
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
  411e64:	4b44      	ldr	r3, [pc, #272]	; (411f78 <xQueueSemaphoreTake+0x1c8>)
  411e66:	4798      	blx	r3

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
  411e68:	4b45      	ldr	r3, [pc, #276]	; (411f80 <xQueueSemaphoreTake+0x1d0>)
  411e6a:	4798      	blx	r3
		prvLockQueue( pxQueue );
  411e6c:	4b3f      	ldr	r3, [pc, #252]	; (411f6c <xQueueSemaphoreTake+0x1bc>)
  411e6e:	4798      	blx	r3
  411e70:	69fb      	ldr	r3, [r7, #28]
  411e72:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
  411e76:	b25b      	sxtb	r3, r3
  411e78:	f1b3 3fff 	cmp.w	r3, #4294967295
  411e7c:	d103      	bne.n	411e86 <xQueueSemaphoreTake+0xd6>
  411e7e:	69fb      	ldr	r3, [r7, #28]
  411e80:	2200      	movs	r2, #0
  411e82:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
  411e86:	69fb      	ldr	r3, [r7, #28]
  411e88:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
  411e8c:	b25b      	sxtb	r3, r3
  411e8e:	f1b3 3fff 	cmp.w	r3, #4294967295
  411e92:	d103      	bne.n	411e9c <xQueueSemaphoreTake+0xec>
  411e94:	69fb      	ldr	r3, [r7, #28]
  411e96:	2200      	movs	r2, #0
  411e98:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
  411e9c:	4b36      	ldr	r3, [pc, #216]	; (411f78 <xQueueSemaphoreTake+0x1c8>)
  411e9e:	4798      	blx	r3

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  411ea0:	463a      	mov	r2, r7
  411ea2:	f107 030c 	add.w	r3, r7, #12
  411ea6:	4611      	mov	r1, r2
  411ea8:	4618      	mov	r0, r3
  411eaa:	4b36      	ldr	r3, [pc, #216]	; (411f84 <xQueueSemaphoreTake+0x1d4>)
  411eac:	4798      	blx	r3
  411eae:	4603      	mov	r3, r0
  411eb0:	2b00      	cmp	r3, #0
  411eb2:	d132      	bne.n	411f1a <xQueueSemaphoreTake+0x16a>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
  411eb4:	69f8      	ldr	r0, [r7, #28]
  411eb6:	4b34      	ldr	r3, [pc, #208]	; (411f88 <xQueueSemaphoreTake+0x1d8>)
  411eb8:	4798      	blx	r3
  411eba:	4603      	mov	r3, r0
  411ebc:	2b00      	cmp	r3, #0
  411ebe:	d026      	beq.n	411f0e <xQueueSemaphoreTake+0x15e>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  411ec0:	69fb      	ldr	r3, [r7, #28]
  411ec2:	681b      	ldr	r3, [r3, #0]
  411ec4:	2b00      	cmp	r3, #0
  411ec6:	d109      	bne.n	411edc <xQueueSemaphoreTake+0x12c>
					{
						taskENTER_CRITICAL();
  411ec8:	4b28      	ldr	r3, [pc, #160]	; (411f6c <xQueueSemaphoreTake+0x1bc>)
  411eca:	4798      	blx	r3
						{
							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
  411ecc:	69fb      	ldr	r3, [r7, #28]
  411ece:	689b      	ldr	r3, [r3, #8]
  411ed0:	4618      	mov	r0, r3
  411ed2:	4b2e      	ldr	r3, [pc, #184]	; (411f8c <xQueueSemaphoreTake+0x1dc>)
  411ed4:	4798      	blx	r3
  411ed6:	6238      	str	r0, [r7, #32]
						}
						taskEXIT_CRITICAL();
  411ed8:	4b27      	ldr	r3, [pc, #156]	; (411f78 <xQueueSemaphoreTake+0x1c8>)
  411eda:	4798      	blx	r3
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
  411edc:	69fb      	ldr	r3, [r7, #28]
  411ede:	3324      	adds	r3, #36	; 0x24
  411ee0:	683a      	ldr	r2, [r7, #0]
  411ee2:	4611      	mov	r1, r2
  411ee4:	4618      	mov	r0, r3
  411ee6:	4b2a      	ldr	r3, [pc, #168]	; (411f90 <xQueueSemaphoreTake+0x1e0>)
  411ee8:	4798      	blx	r3
				prvUnlockQueue( pxQueue );
  411eea:	69f8      	ldr	r0, [r7, #28]
  411eec:	4b29      	ldr	r3, [pc, #164]	; (411f94 <xQueueSemaphoreTake+0x1e4>)
  411eee:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
  411ef0:	4b29      	ldr	r3, [pc, #164]	; (411f98 <xQueueSemaphoreTake+0x1e8>)
  411ef2:	4798      	blx	r3
  411ef4:	4603      	mov	r3, r0
  411ef6:	2b00      	cmp	r3, #0
  411ef8:	f47f af78 	bne.w	411dec <xQueueSemaphoreTake+0x3c>
				{
					portYIELD_WITHIN_API();
  411efc:	4b27      	ldr	r3, [pc, #156]	; (411f9c <xQueueSemaphoreTake+0x1ec>)
  411efe:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  411f02:	601a      	str	r2, [r3, #0]
  411f04:	f3bf 8f4f 	dsb	sy
  411f08:	f3bf 8f6f 	isb	sy
  411f0c:	e76e      	b.n	411dec <xQueueSemaphoreTake+0x3c>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
  411f0e:	69f8      	ldr	r0, [r7, #28]
  411f10:	4b20      	ldr	r3, [pc, #128]	; (411f94 <xQueueSemaphoreTake+0x1e4>)
  411f12:	4798      	blx	r3
				( void ) xTaskResumeAll();
  411f14:	4b20      	ldr	r3, [pc, #128]	; (411f98 <xQueueSemaphoreTake+0x1e8>)
  411f16:	4798      	blx	r3
  411f18:	e768      	b.n	411dec <xQueueSemaphoreTake+0x3c>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
  411f1a:	69f8      	ldr	r0, [r7, #28]
  411f1c:	4b1d      	ldr	r3, [pc, #116]	; (411f94 <xQueueSemaphoreTake+0x1e4>)
  411f1e:	4798      	blx	r3
			( void ) xTaskResumeAll();
  411f20:	4b1d      	ldr	r3, [pc, #116]	; (411f98 <xQueueSemaphoreTake+0x1e8>)
  411f22:	4798      	blx	r3

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
  411f24:	69f8      	ldr	r0, [r7, #28]
  411f26:	4b18      	ldr	r3, [pc, #96]	; (411f88 <xQueueSemaphoreTake+0x1d8>)
  411f28:	4798      	blx	r3
  411f2a:	4603      	mov	r3, r0
  411f2c:	2b00      	cmp	r3, #0
  411f2e:	f43f af5d 	beq.w	411dec <xQueueSemaphoreTake+0x3c>
				#if ( configUSE_MUTEXES == 1 )
				{
					/* xInheritanceOccurred could only have be set if
					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
					test the mutex type again to check it is actually a mutex. */
					if( xInheritanceOccurred != pdFALSE )
  411f32:	6a3b      	ldr	r3, [r7, #32]
  411f34:	2b00      	cmp	r3, #0
  411f36:	d00d      	beq.n	411f54 <xQueueSemaphoreTake+0x1a4>
					{
						taskENTER_CRITICAL();
  411f38:	4b0c      	ldr	r3, [pc, #48]	; (411f6c <xQueueSemaphoreTake+0x1bc>)
  411f3a:	4798      	blx	r3
							/* This task blocking on the mutex caused another
							task to inherit this task's priority.  Now this task
							has timed out the priority should be disinherited
							again, but only as low as the next highest priority
							task that is waiting for the same mutex. */
							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
  411f3c:	69f8      	ldr	r0, [r7, #28]
  411f3e:	4b18      	ldr	r3, [pc, #96]	; (411fa0 <xQueueSemaphoreTake+0x1f0>)
  411f40:	4798      	blx	r3
  411f42:	6178      	str	r0, [r7, #20]
							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
  411f44:	69fb      	ldr	r3, [r7, #28]
  411f46:	689b      	ldr	r3, [r3, #8]
  411f48:	6979      	ldr	r1, [r7, #20]
  411f4a:	4618      	mov	r0, r3
  411f4c:	4b15      	ldr	r3, [pc, #84]	; (411fa4 <xQueueSemaphoreTake+0x1f4>)
  411f4e:	4798      	blx	r3
						}
						taskEXIT_CRITICAL();
  411f50:	4b09      	ldr	r3, [pc, #36]	; (411f78 <xQueueSemaphoreTake+0x1c8>)
  411f52:	4798      	blx	r3
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
  411f54:	2300      	movs	r3, #0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
  411f56:	4618      	mov	r0, r3
  411f58:	3728      	adds	r7, #40	; 0x28
  411f5a:	46bd      	mov	sp, r7
  411f5c:	bd80      	pop	{r7, pc}
  411f5e:	bf00      	nop
  411f60:	0041e1b0 	.word	0x0041e1b0
  411f64:	0041e1e8 	.word	0x0041e1e8
  411f68:	00416c7d 	.word	0x00416c7d
  411f6c:	0041103d 	.word	0x0041103d
  411f70:	00413251 	.word	0x00413251
  411f74:	00412af5 	.word	0x00412af5
  411f78:	00411099 	.word	0x00411099
  411f7c:	00412ce1 	.word	0x00412ce1
  411f80:	0041267d 	.word	0x0041267d
  411f84:	00412d0d 	.word	0x00412d0d
  411f88:	0041228d 	.word	0x0041228d
  411f8c:	00412f05 	.word	0x00412f05
  411f90:	00412a29 	.word	0x00412a29
  411f94:	004121d9 	.word	0x004121d9
  411f98:	00412699 	.word	0x00412699
  411f9c:	e000ed04 	.word	0xe000ed04
  411fa0:	0041207d 	.word	0x0041207d
  411fa4:	00413105 	.word	0x00413105

00411fa8 <uxQueueMessagesWaiting>:
	return xReturn;
}
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
  411fa8:	b580      	push	{r7, lr}
  411faa:	b084      	sub	sp, #16
  411fac:	af00      	add	r7, sp, #0
  411fae:	6078      	str	r0, [r7, #4]
UBaseType_t uxReturn;

	configASSERT( xQueue );
  411fb0:	687b      	ldr	r3, [r7, #4]
  411fb2:	2b00      	cmp	r3, #0
  411fb4:	d105      	bne.n	411fc2 <uxQueueMessagesWaiting+0x1a>
  411fb6:	f240 728e 	movw	r2, #1934	; 0x78e
  411fba:	4908      	ldr	r1, [pc, #32]	; (411fdc <uxQueueMessagesWaiting+0x34>)
  411fbc:	4808      	ldr	r0, [pc, #32]	; (411fe0 <uxQueueMessagesWaiting+0x38>)
  411fbe:	4b09      	ldr	r3, [pc, #36]	; (411fe4 <uxQueueMessagesWaiting+0x3c>)
  411fc0:	4798      	blx	r3

	taskENTER_CRITICAL();
  411fc2:	4b09      	ldr	r3, [pc, #36]	; (411fe8 <uxQueueMessagesWaiting+0x40>)
  411fc4:	4798      	blx	r3
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
  411fc6:	687b      	ldr	r3, [r7, #4]
  411fc8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  411fca:	60fb      	str	r3, [r7, #12]
	}
	taskEXIT_CRITICAL();
  411fcc:	4b07      	ldr	r3, [pc, #28]	; (411fec <uxQueueMessagesWaiting+0x44>)
  411fce:	4798      	blx	r3

	return uxReturn;
  411fd0:	68fb      	ldr	r3, [r7, #12]
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
  411fd2:	4618      	mov	r0, r3
  411fd4:	3710      	adds	r7, #16
  411fd6:	46bd      	mov	sp, r7
  411fd8:	bd80      	pop	{r7, pc}
  411fda:	bf00      	nop
  411fdc:	0041e1b0 	.word	0x0041e1b0
  411fe0:	0041e1e8 	.word	0x0041e1e8
  411fe4:	00416c7d 	.word	0x00416c7d
  411fe8:	0041103d 	.word	0x0041103d
  411fec:	00411099 	.word	0x00411099

00411ff0 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
  411ff0:	b580      	push	{r7, lr}
  411ff2:	b084      	sub	sp, #16
  411ff4:	af00      	add	r7, sp, #0
  411ff6:	6078      	str	r0, [r7, #4]
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
  411ff8:	687b      	ldr	r3, [r7, #4]
  411ffa:	60fb      	str	r3, [r7, #12]

	configASSERT( pxQueue );
  411ffc:	68fb      	ldr	r3, [r7, #12]
  411ffe:	2b00      	cmp	r3, #0
  412000:	d105      	bne.n	41200e <uxQueueSpacesAvailable+0x1e>
  412002:	f240 729f 	movw	r2, #1951	; 0x79f
  412006:	4909      	ldr	r1, [pc, #36]	; (41202c <uxQueueSpacesAvailable+0x3c>)
  412008:	4809      	ldr	r0, [pc, #36]	; (412030 <uxQueueSpacesAvailable+0x40>)
  41200a:	4b0a      	ldr	r3, [pc, #40]	; (412034 <uxQueueSpacesAvailable+0x44>)
  41200c:	4798      	blx	r3

	taskENTER_CRITICAL();
  41200e:	4b0a      	ldr	r3, [pc, #40]	; (412038 <uxQueueSpacesAvailable+0x48>)
  412010:	4798      	blx	r3
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
  412012:	68fb      	ldr	r3, [r7, #12]
  412014:	6bda      	ldr	r2, [r3, #60]	; 0x3c
  412016:	68fb      	ldr	r3, [r7, #12]
  412018:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  41201a:	1ad3      	subs	r3, r2, r3
  41201c:	60bb      	str	r3, [r7, #8]
	}
	taskEXIT_CRITICAL();
  41201e:	4b07      	ldr	r3, [pc, #28]	; (41203c <uxQueueSpacesAvailable+0x4c>)
  412020:	4798      	blx	r3

	return uxReturn;
  412022:	68bb      	ldr	r3, [r7, #8]
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
  412024:	4618      	mov	r0, r3
  412026:	3710      	adds	r7, #16
  412028:	46bd      	mov	sp, r7
  41202a:	bd80      	pop	{r7, pc}
  41202c:	0041e1b0 	.word	0x0041e1b0
  412030:	0041e1e8 	.word	0x0041e1e8
  412034:	00416c7d 	.word	0x00416c7d
  412038:	0041103d 	.word	0x0041103d
  41203c:	00411099 	.word	0x00411099

00412040 <vQueueDelete>:
	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
  412040:	b580      	push	{r7, lr}
  412042:	b084      	sub	sp, #16
  412044:	af00      	add	r7, sp, #0
  412046:	6078      	str	r0, [r7, #4]
Queue_t * const pxQueue = xQueue;
  412048:	687b      	ldr	r3, [r7, #4]
  41204a:	60fb      	str	r3, [r7, #12]

	configASSERT( pxQueue );
  41204c:	68fb      	ldr	r3, [r7, #12]
  41204e:	2b00      	cmp	r3, #0
  412050:	d105      	bne.n	41205e <vQueueDelete+0x1e>
  412052:	f240 72bb 	movw	r2, #1979	; 0x7bb
  412056:	4905      	ldr	r1, [pc, #20]	; (41206c <vQueueDelete+0x2c>)
  412058:	4805      	ldr	r0, [pc, #20]	; (412070 <vQueueDelete+0x30>)
  41205a:	4b06      	ldr	r3, [pc, #24]	; (412074 <vQueueDelete+0x34>)
  41205c:	4798      	blx	r3

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
  41205e:	68f8      	ldr	r0, [r7, #12]
  412060:	4b05      	ldr	r3, [pc, #20]	; (412078 <vQueueDelete+0x38>)
  412062:	4798      	blx	r3
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
  412064:	bf00      	nop
  412066:	3710      	adds	r7, #16
  412068:	46bd      	mov	sp, r7
  41206a:	bd80      	pop	{r7, pc}
  41206c:	0041e1b0 	.word	0x0041e1b0
  412070:	0041e1e8 	.word	0x0041e1e8
  412074:	00416c7d 	.word	0x00416c7d
  412078:	004113a1 	.word	0x004113a1

0041207c <prvGetDisinheritPriorityAfterTimeout>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
	{
  41207c:	b480      	push	{r7}
  41207e:	b085      	sub	sp, #20
  412080:	af00      	add	r7, sp, #0
  412082:	6078      	str	r0, [r7, #4]
		priority, but the waiting task times out, then the holder should
		disinherit the priority - but only down to the highest priority of any
		other tasks that are waiting for the same mutex.  For this purpose,
		return the priority of the highest priority task that is waiting for the
		mutex. */
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
  412084:	687b      	ldr	r3, [r7, #4]
  412086:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  412088:	2b00      	cmp	r3, #0
  41208a:	d006      	beq.n	41209a <prvGetDisinheritPriorityAfterTimeout+0x1e>
		{
			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
  41208c:	687b      	ldr	r3, [r7, #4]
  41208e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  412090:	681b      	ldr	r3, [r3, #0]
  412092:	f1c3 0304 	rsb	r3, r3, #4
  412096:	60fb      	str	r3, [r7, #12]
  412098:	e001      	b.n	41209e <prvGetDisinheritPriorityAfterTimeout+0x22>
		}
		else
		{
			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
  41209a:	2300      	movs	r3, #0
  41209c:	60fb      	str	r3, [r7, #12]
		}

		return uxHighestPriorityOfWaitingTasks;
  41209e:	68fb      	ldr	r3, [r7, #12]
	}
  4120a0:	4618      	mov	r0, r3
  4120a2:	3714      	adds	r7, #20
  4120a4:	46bd      	mov	sp, r7
  4120a6:	f85d 7b04 	ldr.w	r7, [sp], #4
  4120aa:	4770      	bx	lr

004120ac <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
  4120ac:	b580      	push	{r7, lr}
  4120ae:	b086      	sub	sp, #24
  4120b0:	af00      	add	r7, sp, #0
  4120b2:	60f8      	str	r0, [r7, #12]
  4120b4:	60b9      	str	r1, [r7, #8]
  4120b6:	607a      	str	r2, [r7, #4]
BaseType_t xReturn = pdFALSE;
  4120b8:	2300      	movs	r3, #0
  4120ba:	617b      	str	r3, [r7, #20]
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
  4120bc:	68fb      	ldr	r3, [r7, #12]
  4120be:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  4120c0:	613b      	str	r3, [r7, #16]

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
  4120c2:	68fb      	ldr	r3, [r7, #12]
  4120c4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  4120c6:	2b00      	cmp	r3, #0
  4120c8:	d10d      	bne.n	4120e6 <prvCopyDataToQueue+0x3a>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  4120ca:	68fb      	ldr	r3, [r7, #12]
  4120cc:	681b      	ldr	r3, [r3, #0]
  4120ce:	2b00      	cmp	r3, #0
  4120d0:	d14d      	bne.n	41216e <prvCopyDataToQueue+0xc2>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
  4120d2:	68fb      	ldr	r3, [r7, #12]
  4120d4:	689b      	ldr	r3, [r3, #8]
  4120d6:	4618      	mov	r0, r3
  4120d8:	4b29      	ldr	r3, [pc, #164]	; (412180 <prvCopyDataToQueue+0xd4>)
  4120da:	4798      	blx	r3
  4120dc:	6178      	str	r0, [r7, #20]
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
  4120de:	68fb      	ldr	r3, [r7, #12]
  4120e0:	2200      	movs	r2, #0
  4120e2:	609a      	str	r2, [r3, #8]
  4120e4:	e043      	b.n	41216e <prvCopyDataToQueue+0xc2>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
  4120e6:	687b      	ldr	r3, [r7, #4]
  4120e8:	2b00      	cmp	r3, #0
  4120ea:	d119      	bne.n	412120 <prvCopyDataToQueue+0x74>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
  4120ec:	68fb      	ldr	r3, [r7, #12]
  4120ee:	6858      	ldr	r0, [r3, #4]
  4120f0:	68fb      	ldr	r3, [r7, #12]
  4120f2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  4120f4:	461a      	mov	r2, r3
  4120f6:	68b9      	ldr	r1, [r7, #8]
  4120f8:	4b22      	ldr	r3, [pc, #136]	; (412184 <prvCopyDataToQueue+0xd8>)
  4120fa:	4798      	blx	r3
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
  4120fc:	68fb      	ldr	r3, [r7, #12]
  4120fe:	685a      	ldr	r2, [r3, #4]
  412100:	68fb      	ldr	r3, [r7, #12]
  412102:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  412104:	441a      	add	r2, r3
  412106:	68fb      	ldr	r3, [r7, #12]
  412108:	605a      	str	r2, [r3, #4]
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
  41210a:	68fb      	ldr	r3, [r7, #12]
  41210c:	685a      	ldr	r2, [r3, #4]
  41210e:	68fb      	ldr	r3, [r7, #12]
  412110:	689b      	ldr	r3, [r3, #8]
  412112:	429a      	cmp	r2, r3
  412114:	d32b      	bcc.n	41216e <prvCopyDataToQueue+0xc2>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
  412116:	68fb      	ldr	r3, [r7, #12]
  412118:	681a      	ldr	r2, [r3, #0]
  41211a:	68fb      	ldr	r3, [r7, #12]
  41211c:	605a      	str	r2, [r3, #4]
  41211e:	e026      	b.n	41216e <prvCopyDataToQueue+0xc2>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
  412120:	68fb      	ldr	r3, [r7, #12]
  412122:	68d8      	ldr	r0, [r3, #12]
  412124:	68fb      	ldr	r3, [r7, #12]
  412126:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  412128:	461a      	mov	r2, r3
  41212a:	68b9      	ldr	r1, [r7, #8]
  41212c:	4b15      	ldr	r3, [pc, #84]	; (412184 <prvCopyDataToQueue+0xd8>)
  41212e:	4798      	blx	r3
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
  412130:	68fb      	ldr	r3, [r7, #12]
  412132:	68da      	ldr	r2, [r3, #12]
  412134:	68fb      	ldr	r3, [r7, #12]
  412136:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  412138:	425b      	negs	r3, r3
  41213a:	441a      	add	r2, r3
  41213c:	68fb      	ldr	r3, [r7, #12]
  41213e:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
  412140:	68fb      	ldr	r3, [r7, #12]
  412142:	68da      	ldr	r2, [r3, #12]
  412144:	68fb      	ldr	r3, [r7, #12]
  412146:	681b      	ldr	r3, [r3, #0]
  412148:	429a      	cmp	r2, r3
  41214a:	d207      	bcs.n	41215c <prvCopyDataToQueue+0xb0>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
  41214c:	68fb      	ldr	r3, [r7, #12]
  41214e:	689a      	ldr	r2, [r3, #8]
  412150:	68fb      	ldr	r3, [r7, #12]
  412152:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  412154:	425b      	negs	r3, r3
  412156:	441a      	add	r2, r3
  412158:	68fb      	ldr	r3, [r7, #12]
  41215a:	60da      	str	r2, [r3, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
  41215c:	687b      	ldr	r3, [r7, #4]
  41215e:	2b02      	cmp	r3, #2
  412160:	d105      	bne.n	41216e <prvCopyDataToQueue+0xc2>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
  412162:	693b      	ldr	r3, [r7, #16]
  412164:	2b00      	cmp	r3, #0
  412166:	d002      	beq.n	41216e <prvCopyDataToQueue+0xc2>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
  412168:	693b      	ldr	r3, [r7, #16]
  41216a:	3b01      	subs	r3, #1
  41216c:	613b      	str	r3, [r7, #16]
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
  41216e:	693b      	ldr	r3, [r7, #16]
  412170:	1c5a      	adds	r2, r3, #1
  412172:	68fb      	ldr	r3, [r7, #12]
  412174:	639a      	str	r2, [r3, #56]	; 0x38

	return xReturn;
  412176:	697b      	ldr	r3, [r7, #20]
}
  412178:	4618      	mov	r0, r3
  41217a:	3718      	adds	r7, #24
  41217c:	46bd      	mov	sp, r7
  41217e:	bd80      	pop	{r7, pc}
  412180:	00412ff9 	.word	0x00412ff9
  412184:	00416d05 	.word	0x00416d05

00412188 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
  412188:	b580      	push	{r7, lr}
  41218a:	b082      	sub	sp, #8
  41218c:	af00      	add	r7, sp, #0
  41218e:	6078      	str	r0, [r7, #4]
  412190:	6039      	str	r1, [r7, #0]
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
  412192:	687b      	ldr	r3, [r7, #4]
  412194:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  412196:	2b00      	cmp	r3, #0
  412198:	d018      	beq.n	4121cc <prvCopyDataFromQueue+0x44>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
  41219a:	687b      	ldr	r3, [r7, #4]
  41219c:	68da      	ldr	r2, [r3, #12]
  41219e:	687b      	ldr	r3, [r7, #4]
  4121a0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  4121a2:	441a      	add	r2, r3
  4121a4:	687b      	ldr	r3, [r7, #4]
  4121a6:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
  4121a8:	687b      	ldr	r3, [r7, #4]
  4121aa:	68da      	ldr	r2, [r3, #12]
  4121ac:	687b      	ldr	r3, [r7, #4]
  4121ae:	689b      	ldr	r3, [r3, #8]
  4121b0:	429a      	cmp	r2, r3
  4121b2:	d303      	bcc.n	4121bc <prvCopyDataFromQueue+0x34>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
  4121b4:	687b      	ldr	r3, [r7, #4]
  4121b6:	681a      	ldr	r2, [r3, #0]
  4121b8:	687b      	ldr	r3, [r7, #4]
  4121ba:	60da      	str	r2, [r3, #12]
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
  4121bc:	687b      	ldr	r3, [r7, #4]
  4121be:	68d9      	ldr	r1, [r3, #12]
  4121c0:	687b      	ldr	r3, [r7, #4]
  4121c2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  4121c4:	461a      	mov	r2, r3
  4121c6:	6838      	ldr	r0, [r7, #0]
  4121c8:	4b02      	ldr	r3, [pc, #8]	; (4121d4 <prvCopyDataFromQueue+0x4c>)
  4121ca:	4798      	blx	r3
	}
}
  4121cc:	bf00      	nop
  4121ce:	3708      	adds	r7, #8
  4121d0:	46bd      	mov	sp, r7
  4121d2:	bd80      	pop	{r7, pc}
  4121d4:	00416d05 	.word	0x00416d05

004121d8 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
  4121d8:	b580      	push	{r7, lr}
  4121da:	b084      	sub	sp, #16
  4121dc:	af00      	add	r7, sp, #0
  4121de:	6078      	str	r0, [r7, #4]

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
  4121e0:	4b26      	ldr	r3, [pc, #152]	; (41227c <prvUnlockQueue+0xa4>)
  4121e2:	4798      	blx	r3
	{
		int8_t cTxLock = pxQueue->cTxLock;
  4121e4:	687b      	ldr	r3, [r7, #4]
  4121e6:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
  4121ea:	73fb      	strb	r3, [r7, #15]

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
  4121ec:	e011      	b.n	412212 <prvUnlockQueue+0x3a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  4121ee:	687b      	ldr	r3, [r7, #4]
  4121f0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  4121f2:	2b00      	cmp	r3, #0
  4121f4:	d012      	beq.n	41221c <prvUnlockQueue+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  4121f6:	687b      	ldr	r3, [r7, #4]
  4121f8:	3324      	adds	r3, #36	; 0x24
  4121fa:	4618      	mov	r0, r3
  4121fc:	4b20      	ldr	r3, [pc, #128]	; (412280 <prvUnlockQueue+0xa8>)
  4121fe:	4798      	blx	r3
  412200:	4603      	mov	r3, r0
  412202:	2b00      	cmp	r3, #0
  412204:	d001      	beq.n	41220a <prvUnlockQueue+0x32>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
  412206:	4b1f      	ldr	r3, [pc, #124]	; (412284 <prvUnlockQueue+0xac>)
  412208:	4798      	blx	r3
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
  41220a:	7bfb      	ldrb	r3, [r7, #15]
  41220c:	3b01      	subs	r3, #1
  41220e:	b2db      	uxtb	r3, r3
  412210:	73fb      	strb	r3, [r7, #15]
		while( cTxLock > queueLOCKED_UNMODIFIED )
  412212:	f997 300f 	ldrsb.w	r3, [r7, #15]
  412216:	2b00      	cmp	r3, #0
  412218:	dce9      	bgt.n	4121ee <prvUnlockQueue+0x16>
  41221a:	e000      	b.n	41221e <prvUnlockQueue+0x46>
					break;
  41221c:	bf00      	nop
		}

		pxQueue->cTxLock = queueUNLOCKED;
  41221e:	687b      	ldr	r3, [r7, #4]
  412220:	22ff      	movs	r2, #255	; 0xff
  412222:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
	}
	taskEXIT_CRITICAL();
  412226:	4b18      	ldr	r3, [pc, #96]	; (412288 <prvUnlockQueue+0xb0>)
  412228:	4798      	blx	r3

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
  41222a:	4b14      	ldr	r3, [pc, #80]	; (41227c <prvUnlockQueue+0xa4>)
  41222c:	4798      	blx	r3
	{
		int8_t cRxLock = pxQueue->cRxLock;
  41222e:	687b      	ldr	r3, [r7, #4]
  412230:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
  412234:	73bb      	strb	r3, [r7, #14]

		while( cRxLock > queueLOCKED_UNMODIFIED )
  412236:	e011      	b.n	41225c <prvUnlockQueue+0x84>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  412238:	687b      	ldr	r3, [r7, #4]
  41223a:	691b      	ldr	r3, [r3, #16]
  41223c:	2b00      	cmp	r3, #0
  41223e:	d012      	beq.n	412266 <prvUnlockQueue+0x8e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  412240:	687b      	ldr	r3, [r7, #4]
  412242:	3310      	adds	r3, #16
  412244:	4618      	mov	r0, r3
  412246:	4b0e      	ldr	r3, [pc, #56]	; (412280 <prvUnlockQueue+0xa8>)
  412248:	4798      	blx	r3
  41224a:	4603      	mov	r3, r0
  41224c:	2b00      	cmp	r3, #0
  41224e:	d001      	beq.n	412254 <prvUnlockQueue+0x7c>
				{
					vTaskMissedYield();
  412250:	4b0c      	ldr	r3, [pc, #48]	; (412284 <prvUnlockQueue+0xac>)
  412252:	4798      	blx	r3
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
  412254:	7bbb      	ldrb	r3, [r7, #14]
  412256:	3b01      	subs	r3, #1
  412258:	b2db      	uxtb	r3, r3
  41225a:	73bb      	strb	r3, [r7, #14]
		while( cRxLock > queueLOCKED_UNMODIFIED )
  41225c:	f997 300e 	ldrsb.w	r3, [r7, #14]
  412260:	2b00      	cmp	r3, #0
  412262:	dce9      	bgt.n	412238 <prvUnlockQueue+0x60>
  412264:	e000      	b.n	412268 <prvUnlockQueue+0x90>
			}
			else
			{
				break;
  412266:	bf00      	nop
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
  412268:	687b      	ldr	r3, [r7, #4]
  41226a:	22ff      	movs	r2, #255	; 0xff
  41226c:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
  412270:	4b05      	ldr	r3, [pc, #20]	; (412288 <prvUnlockQueue+0xb0>)
  412272:	4798      	blx	r3
}
  412274:	bf00      	nop
  412276:	3710      	adds	r7, #16
  412278:	46bd      	mov	sp, r7
  41227a:	bd80      	pop	{r7, pc}
  41227c:	0041103d 	.word	0x0041103d
  412280:	00412af5 	.word	0x00412af5
  412284:	00412dd5 	.word	0x00412dd5
  412288:	00411099 	.word	0x00411099

0041228c <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
  41228c:	b580      	push	{r7, lr}
  41228e:	b084      	sub	sp, #16
  412290:	af00      	add	r7, sp, #0
  412292:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	taskENTER_CRITICAL();
  412294:	4b08      	ldr	r3, [pc, #32]	; (4122b8 <prvIsQueueEmpty+0x2c>)
  412296:	4798      	blx	r3
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
  412298:	687b      	ldr	r3, [r7, #4]
  41229a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  41229c:	2b00      	cmp	r3, #0
  41229e:	d102      	bne.n	4122a6 <prvIsQueueEmpty+0x1a>
		{
			xReturn = pdTRUE;
  4122a0:	2301      	movs	r3, #1
  4122a2:	60fb      	str	r3, [r7, #12]
  4122a4:	e001      	b.n	4122aa <prvIsQueueEmpty+0x1e>
		}
		else
		{
			xReturn = pdFALSE;
  4122a6:	2300      	movs	r3, #0
  4122a8:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
  4122aa:	4b04      	ldr	r3, [pc, #16]	; (4122bc <prvIsQueueEmpty+0x30>)
  4122ac:	4798      	blx	r3

	return xReturn;
  4122ae:	68fb      	ldr	r3, [r7, #12]
}
  4122b0:	4618      	mov	r0, r3
  4122b2:	3710      	adds	r7, #16
  4122b4:	46bd      	mov	sp, r7
  4122b6:	bd80      	pop	{r7, pc}
  4122b8:	0041103d 	.word	0x0041103d
  4122bc:	00411099 	.word	0x00411099

004122c0 <prvIsQueueFull>:
	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
  4122c0:	b580      	push	{r7, lr}
  4122c2:	b084      	sub	sp, #16
  4122c4:	af00      	add	r7, sp, #0
  4122c6:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	taskENTER_CRITICAL();
  4122c8:	4b09      	ldr	r3, [pc, #36]	; (4122f0 <prvIsQueueFull+0x30>)
  4122ca:	4798      	blx	r3
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
  4122cc:	687b      	ldr	r3, [r7, #4]
  4122ce:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  4122d0:	687b      	ldr	r3, [r7, #4]
  4122d2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  4122d4:	429a      	cmp	r2, r3
  4122d6:	d102      	bne.n	4122de <prvIsQueueFull+0x1e>
		{
			xReturn = pdTRUE;
  4122d8:	2301      	movs	r3, #1
  4122da:	60fb      	str	r3, [r7, #12]
  4122dc:	e001      	b.n	4122e2 <prvIsQueueFull+0x22>
		}
		else
		{
			xReturn = pdFALSE;
  4122de:	2300      	movs	r3, #0
  4122e0:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
  4122e2:	4b04      	ldr	r3, [pc, #16]	; (4122f4 <prvIsQueueFull+0x34>)
  4122e4:	4798      	blx	r3

	return xReturn;
  4122e6:	68fb      	ldr	r3, [r7, #12]
}
  4122e8:	4618      	mov	r0, r3
  4122ea:	3710      	adds	r7, #16
  4122ec:	46bd      	mov	sp, r7
  4122ee:	bd80      	pop	{r7, pc}
  4122f0:	0041103d 	.word	0x0041103d
  4122f4:	00411099 	.word	0x00411099

004122f8 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
  4122f8:	b590      	push	{r4, r7, lr}
  4122fa:	b08d      	sub	sp, #52	; 0x34
  4122fc:	af04      	add	r7, sp, #16
  4122fe:	60f8      	str	r0, [r7, #12]
  412300:	60b9      	str	r1, [r7, #8]
  412302:	603b      	str	r3, [r7, #0]
  412304:	4613      	mov	r3, r2
  412306:	80fb      	strh	r3, [r7, #6]
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
  412308:	88fb      	ldrh	r3, [r7, #6]
  41230a:	009b      	lsls	r3, r3, #2
  41230c:	4618      	mov	r0, r3
  41230e:	4b1b      	ldr	r3, [pc, #108]	; (41237c <xTaskCreate+0x84>)
  412310:	4798      	blx	r3
  412312:	6178      	str	r0, [r7, #20]

			if( pxStack != NULL )
  412314:	697b      	ldr	r3, [r7, #20]
  412316:	2b00      	cmp	r3, #0
  412318:	d00e      	beq.n	412338 <xTaskCreate+0x40>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
  41231a:	2058      	movs	r0, #88	; 0x58
  41231c:	4b17      	ldr	r3, [pc, #92]	; (41237c <xTaskCreate+0x84>)
  41231e:	4798      	blx	r3
  412320:	61f8      	str	r0, [r7, #28]

				if( pxNewTCB != NULL )
  412322:	69fb      	ldr	r3, [r7, #28]
  412324:	2b00      	cmp	r3, #0
  412326:	d003      	beq.n	412330 <xTaskCreate+0x38>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
  412328:	69fb      	ldr	r3, [r7, #28]
  41232a:	697a      	ldr	r2, [r7, #20]
  41232c:	631a      	str	r2, [r3, #48]	; 0x30
  41232e:	e005      	b.n	41233c <xTaskCreate+0x44>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
  412330:	6978      	ldr	r0, [r7, #20]
  412332:	4b13      	ldr	r3, [pc, #76]	; (412380 <xTaskCreate+0x88>)
  412334:	4798      	blx	r3
  412336:	e001      	b.n	41233c <xTaskCreate+0x44>
				}
			}
			else
			{
				pxNewTCB = NULL;
  412338:	2300      	movs	r3, #0
  41233a:	61fb      	str	r3, [r7, #28]
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
  41233c:	69fb      	ldr	r3, [r7, #28]
  41233e:	2b00      	cmp	r3, #0
  412340:	d013      	beq.n	41236a <xTaskCreate+0x72>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
  412342:	88fa      	ldrh	r2, [r7, #6]
  412344:	2300      	movs	r3, #0
  412346:	9303      	str	r3, [sp, #12]
  412348:	69fb      	ldr	r3, [r7, #28]
  41234a:	9302      	str	r3, [sp, #8]
  41234c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  41234e:	9301      	str	r3, [sp, #4]
  412350:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  412352:	9300      	str	r3, [sp, #0]
  412354:	683b      	ldr	r3, [r7, #0]
  412356:	68b9      	ldr	r1, [r7, #8]
  412358:	68f8      	ldr	r0, [r7, #12]
  41235a:	4c0a      	ldr	r4, [pc, #40]	; (412384 <xTaskCreate+0x8c>)
  41235c:	47a0      	blx	r4
			prvAddNewTaskToReadyList( pxNewTCB );
  41235e:	69f8      	ldr	r0, [r7, #28]
  412360:	4b09      	ldr	r3, [pc, #36]	; (412388 <xTaskCreate+0x90>)
  412362:	4798      	blx	r3
			xReturn = pdPASS;
  412364:	2301      	movs	r3, #1
  412366:	61bb      	str	r3, [r7, #24]
  412368:	e002      	b.n	412370 <xTaskCreate+0x78>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
  41236a:	f04f 33ff 	mov.w	r3, #4294967295
  41236e:	61bb      	str	r3, [r7, #24]
		}

		return xReturn;
  412370:	69bb      	ldr	r3, [r7, #24]
	}
  412372:	4618      	mov	r0, r3
  412374:	3724      	adds	r7, #36	; 0x24
  412376:	46bd      	mov	sp, r7
  412378:	bd90      	pop	{r4, r7, pc}
  41237a:	bf00      	nop
  41237c:	004111e5 	.word	0x004111e5
  412380:	004113a1 	.word	0x004113a1
  412384:	0041238d 	.word	0x0041238d
  412388:	004124a5 	.word	0x004124a5

0041238c <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
  41238c:	b580      	push	{r7, lr}
  41238e:	b086      	sub	sp, #24
  412390:	af00      	add	r7, sp, #0
  412392:	60f8      	str	r0, [r7, #12]
  412394:	60b9      	str	r1, [r7, #8]
  412396:	607a      	str	r2, [r7, #4]
  412398:	603b      	str	r3, [r7, #0]
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
  41239a:	6abb      	ldr	r3, [r7, #40]	; 0x28
  41239c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  41239e:	687b      	ldr	r3, [r7, #4]
  4123a0:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
  4123a4:	3b01      	subs	r3, #1
  4123a6:	009b      	lsls	r3, r3, #2
  4123a8:	4413      	add	r3, r2
  4123aa:	613b      	str	r3, [r7, #16]
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
  4123ac:	693b      	ldr	r3, [r7, #16]
  4123ae:	f023 0307 	bic.w	r3, r3, #7
  4123b2:	613b      	str	r3, [r7, #16]

		/* Check the alignment of the calculated top of stack is correct. */
		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
  4123b4:	693b      	ldr	r3, [r7, #16]
  4123b6:	f003 0307 	and.w	r3, r3, #7
  4123ba:	2b00      	cmp	r3, #0
  4123bc:	d005      	beq.n	4123ca <prvInitialiseNewTask+0x3e>
  4123be:	f44f 7259 	mov.w	r2, #868	; 0x364
  4123c2:	4933      	ldr	r1, [pc, #204]	; (412490 <prvInitialiseNewTask+0x104>)
  4123c4:	4833      	ldr	r0, [pc, #204]	; (412494 <prvInitialiseNewTask+0x108>)
  4123c6:	4b34      	ldr	r3, [pc, #208]	; (412498 <prvInitialiseNewTask+0x10c>)
  4123c8:	4798      	blx	r3
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
  4123ca:	68bb      	ldr	r3, [r7, #8]
  4123cc:	2b00      	cmp	r3, #0
  4123ce:	d01f      	beq.n	412410 <prvInitialiseNewTask+0x84>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
  4123d0:	2300      	movs	r3, #0
  4123d2:	617b      	str	r3, [r7, #20]
  4123d4:	e012      	b.n	4123fc <prvInitialiseNewTask+0x70>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
  4123d6:	68ba      	ldr	r2, [r7, #8]
  4123d8:	697b      	ldr	r3, [r7, #20]
  4123da:	4413      	add	r3, r2
  4123dc:	7819      	ldrb	r1, [r3, #0]
  4123de:	6aba      	ldr	r2, [r7, #40]	; 0x28
  4123e0:	697b      	ldr	r3, [r7, #20]
  4123e2:	4413      	add	r3, r2
  4123e4:	3334      	adds	r3, #52	; 0x34
  4123e6:	460a      	mov	r2, r1
  4123e8:	701a      	strb	r2, [r3, #0]

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
  4123ea:	68ba      	ldr	r2, [r7, #8]
  4123ec:	697b      	ldr	r3, [r7, #20]
  4123ee:	4413      	add	r3, r2
  4123f0:	781b      	ldrb	r3, [r3, #0]
  4123f2:	2b00      	cmp	r3, #0
  4123f4:	d006      	beq.n	412404 <prvInitialiseNewTask+0x78>
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
  4123f6:	697b      	ldr	r3, [r7, #20]
  4123f8:	3301      	adds	r3, #1
  4123fa:	617b      	str	r3, [r7, #20]
  4123fc:	697b      	ldr	r3, [r7, #20]
  4123fe:	2b13      	cmp	r3, #19
  412400:	d9e9      	bls.n	4123d6 <prvInitialiseNewTask+0x4a>
  412402:	e000      	b.n	412406 <prvInitialiseNewTask+0x7a>
			{
				break;
  412404:	bf00      	nop
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
  412406:	6abb      	ldr	r3, [r7, #40]	; 0x28
  412408:	2200      	movs	r2, #0
  41240a:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47
  41240e:	e003      	b.n	412418 <prvInitialiseNewTask+0x8c>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
  412410:	6abb      	ldr	r3, [r7, #40]	; 0x28
  412412:	2200      	movs	r2, #0
  412414:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
  412418:	6a3b      	ldr	r3, [r7, #32]
  41241a:	2b03      	cmp	r3, #3
  41241c:	d901      	bls.n	412422 <prvInitialiseNewTask+0x96>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
  41241e:	2303      	movs	r3, #3
  412420:	623b      	str	r3, [r7, #32]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
  412422:	6abb      	ldr	r3, [r7, #40]	; 0x28
  412424:	6a3a      	ldr	r2, [r7, #32]
  412426:	62da      	str	r2, [r3, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
  412428:	6abb      	ldr	r3, [r7, #40]	; 0x28
  41242a:	6a3a      	ldr	r2, [r7, #32]
  41242c:	649a      	str	r2, [r3, #72]	; 0x48
		pxNewTCB->uxMutexesHeld = 0;
  41242e:	6abb      	ldr	r3, [r7, #40]	; 0x28
  412430:	2200      	movs	r2, #0
  412432:	64da      	str	r2, [r3, #76]	; 0x4c
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
  412434:	6abb      	ldr	r3, [r7, #40]	; 0x28
  412436:	3304      	adds	r3, #4
  412438:	4618      	mov	r0, r3
  41243a:	4b18      	ldr	r3, [pc, #96]	; (41249c <prvInitialiseNewTask+0x110>)
  41243c:	4798      	blx	r3
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
  41243e:	6abb      	ldr	r3, [r7, #40]	; 0x28
  412440:	3318      	adds	r3, #24
  412442:	4618      	mov	r0, r3
  412444:	4b15      	ldr	r3, [pc, #84]	; (41249c <prvInitialiseNewTask+0x110>)
  412446:	4798      	blx	r3

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
  412448:	6abb      	ldr	r3, [r7, #40]	; 0x28
  41244a:	6aba      	ldr	r2, [r7, #40]	; 0x28
  41244c:	611a      	str	r2, [r3, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  41244e:	6a3b      	ldr	r3, [r7, #32]
  412450:	f1c3 0204 	rsb	r2, r3, #4
  412454:	6abb      	ldr	r3, [r7, #40]	; 0x28
  412456:	619a      	str	r2, [r3, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
  412458:	6abb      	ldr	r3, [r7, #40]	; 0x28
  41245a:	6aba      	ldr	r2, [r7, #40]	; 0x28
  41245c:	625a      	str	r2, [r3, #36]	; 0x24
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
  41245e:	6abb      	ldr	r3, [r7, #40]	; 0x28
  412460:	2200      	movs	r2, #0
  412462:	651a      	str	r2, [r3, #80]	; 0x50
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
  412464:	6abb      	ldr	r3, [r7, #40]	; 0x28
  412466:	2200      	movs	r2, #0
  412468:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
  41246c:	683a      	ldr	r2, [r7, #0]
  41246e:	68f9      	ldr	r1, [r7, #12]
  412470:	6938      	ldr	r0, [r7, #16]
  412472:	4b0b      	ldr	r3, [pc, #44]	; (4124a0 <prvInitialiseNewTask+0x114>)
  412474:	4798      	blx	r3
  412476:	4602      	mov	r2, r0
  412478:	6abb      	ldr	r3, [r7, #40]	; 0x28
  41247a:	601a      	str	r2, [r3, #0]
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
  41247c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  41247e:	2b00      	cmp	r3, #0
  412480:	d002      	beq.n	412488 <prvInitialiseNewTask+0xfc>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
  412482:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  412484:	6aba      	ldr	r2, [r7, #40]	; 0x28
  412486:	601a      	str	r2, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
  412488:	bf00      	nop
  41248a:	3718      	adds	r7, #24
  41248c:	46bd      	mov	sp, r7
  41248e:	bd80      	pop	{r7, pc}
  412490:	0041e1f8 	.word	0x0041e1f8
  412494:	0041e230 	.word	0x0041e230
  412498:	00416c7d 	.word	0x00416c7d
  41249c:	00410d21 	.word	0x00410d21
  4124a0:	00410e49 	.word	0x00410e49

004124a4 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
  4124a4:	b580      	push	{r7, lr}
  4124a6:	b082      	sub	sp, #8
  4124a8:	af00      	add	r7, sp, #0
  4124aa:	6078      	str	r0, [r7, #4]
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
  4124ac:	4b25      	ldr	r3, [pc, #148]	; (412544 <prvAddNewTaskToReadyList+0xa0>)
  4124ae:	4798      	blx	r3
	{
		uxCurrentNumberOfTasks++;
  4124b0:	4b25      	ldr	r3, [pc, #148]	; (412548 <prvAddNewTaskToReadyList+0xa4>)
  4124b2:	681b      	ldr	r3, [r3, #0]
  4124b4:	3301      	adds	r3, #1
  4124b6:	4a24      	ldr	r2, [pc, #144]	; (412548 <prvAddNewTaskToReadyList+0xa4>)
  4124b8:	6013      	str	r3, [r2, #0]
		if( pxCurrentTCB == NULL )
  4124ba:	4b24      	ldr	r3, [pc, #144]	; (41254c <prvAddNewTaskToReadyList+0xa8>)
  4124bc:	681b      	ldr	r3, [r3, #0]
  4124be:	2b00      	cmp	r3, #0
  4124c0:	d109      	bne.n	4124d6 <prvAddNewTaskToReadyList+0x32>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
  4124c2:	4a22      	ldr	r2, [pc, #136]	; (41254c <prvAddNewTaskToReadyList+0xa8>)
  4124c4:	687b      	ldr	r3, [r7, #4]
  4124c6:	6013      	str	r3, [r2, #0]

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
  4124c8:	4b1f      	ldr	r3, [pc, #124]	; (412548 <prvAddNewTaskToReadyList+0xa4>)
  4124ca:	681b      	ldr	r3, [r3, #0]
  4124cc:	2b01      	cmp	r3, #1
  4124ce:	d110      	bne.n	4124f2 <prvAddNewTaskToReadyList+0x4e>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
  4124d0:	4b1f      	ldr	r3, [pc, #124]	; (412550 <prvAddNewTaskToReadyList+0xac>)
  4124d2:	4798      	blx	r3
  4124d4:	e00d      	b.n	4124f2 <prvAddNewTaskToReadyList+0x4e>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
  4124d6:	4b1f      	ldr	r3, [pc, #124]	; (412554 <prvAddNewTaskToReadyList+0xb0>)
  4124d8:	681b      	ldr	r3, [r3, #0]
  4124da:	2b00      	cmp	r3, #0
  4124dc:	d109      	bne.n	4124f2 <prvAddNewTaskToReadyList+0x4e>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
  4124de:	4b1b      	ldr	r3, [pc, #108]	; (41254c <prvAddNewTaskToReadyList+0xa8>)
  4124e0:	681b      	ldr	r3, [r3, #0]
  4124e2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  4124e4:	687b      	ldr	r3, [r7, #4]
  4124e6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  4124e8:	429a      	cmp	r2, r3
  4124ea:	d802      	bhi.n	4124f2 <prvAddNewTaskToReadyList+0x4e>
				{
					pxCurrentTCB = pxNewTCB;
  4124ec:	4a17      	ldr	r2, [pc, #92]	; (41254c <prvAddNewTaskToReadyList+0xa8>)
  4124ee:	687b      	ldr	r3, [r7, #4]
  4124f0:	6013      	str	r3, [r2, #0]
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
  4124f2:	4b19      	ldr	r3, [pc, #100]	; (412558 <prvAddNewTaskToReadyList+0xb4>)
  4124f4:	681b      	ldr	r3, [r3, #0]
  4124f6:	3301      	adds	r3, #1
  4124f8:	4a17      	ldr	r2, [pc, #92]	; (412558 <prvAddNewTaskToReadyList+0xb4>)
  4124fa:	6013      	str	r3, [r2, #0]
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
  4124fc:	687b      	ldr	r3, [r7, #4]
  4124fe:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  412500:	2201      	movs	r2, #1
  412502:	409a      	lsls	r2, r3
  412504:	4b15      	ldr	r3, [pc, #84]	; (41255c <prvAddNewTaskToReadyList+0xb8>)
  412506:	681b      	ldr	r3, [r3, #0]
  412508:	4313      	orrs	r3, r2
  41250a:	4a14      	ldr	r2, [pc, #80]	; (41255c <prvAddNewTaskToReadyList+0xb8>)
  41250c:	6013      	str	r3, [r2, #0]
  41250e:	687b      	ldr	r3, [r7, #4]
  412510:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  412512:	4613      	mov	r3, r2
  412514:	009b      	lsls	r3, r3, #2
  412516:	4413      	add	r3, r2
  412518:	009b      	lsls	r3, r3, #2
  41251a:	4a11      	ldr	r2, [pc, #68]	; (412560 <prvAddNewTaskToReadyList+0xbc>)
  41251c:	441a      	add	r2, r3
  41251e:	687b      	ldr	r3, [r7, #4]
  412520:	3304      	adds	r3, #4
  412522:	4619      	mov	r1, r3
  412524:	4610      	mov	r0, r2
  412526:	4b0f      	ldr	r3, [pc, #60]	; (412564 <prvAddNewTaskToReadyList+0xc0>)
  412528:	4798      	blx	r3

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
  41252a:	4b0f      	ldr	r3, [pc, #60]	; (412568 <prvAddNewTaskToReadyList+0xc4>)
  41252c:	4798      	blx	r3

	if( xSchedulerRunning != pdFALSE )
  41252e:	4b09      	ldr	r3, [pc, #36]	; (412554 <prvAddNewTaskToReadyList+0xb0>)
  412530:	681b      	ldr	r3, [r3, #0]
  412532:	2b00      	cmp	r3, #0
  412534:	d001      	beq.n	41253a <prvAddNewTaskToReadyList+0x96>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
  412536:	4b05      	ldr	r3, [pc, #20]	; (41254c <prvAddNewTaskToReadyList+0xa8>)
  412538:	681b      	ldr	r3, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
  41253a:	bf00      	nop
  41253c:	3708      	adds	r7, #8
  41253e:	46bd      	mov	sp, r7
  412540:	bd80      	pop	{r7, pc}
  412542:	bf00      	nop
  412544:	0041103d 	.word	0x0041103d
  412548:	2000b4b0 	.word	0x2000b4b0
  41254c:	2000b404 	.word	0x2000b404
  412550:	00412e1d 	.word	0x00412e1d
  412554:	2000b4bc 	.word	0x2000b4bc
  412558:	2000b4cc 	.word	0x2000b4cc
  41255c:	2000b4b8 	.word	0x2000b4b8
  412560:	2000b408 	.word	0x2000b408
  412564:	00410d3b 	.word	0x00410d3b
  412568:	00411099 	.word	0x00411099

0041256c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
  41256c:	b580      	push	{r7, lr}
  41256e:	b084      	sub	sp, #16
  412570:	af00      	add	r7, sp, #0
  412572:	6078      	str	r0, [r7, #4]
	BaseType_t xAlreadyYielded = pdFALSE;
  412574:	2300      	movs	r3, #0
  412576:	60fb      	str	r3, [r7, #12]

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
  412578:	687b      	ldr	r3, [r7, #4]
  41257a:	2b00      	cmp	r3, #0
  41257c:	d012      	beq.n	4125a4 <vTaskDelay+0x38>
		{
			configASSERT( uxSchedulerSuspended == 0 );
  41257e:	4b11      	ldr	r3, [pc, #68]	; (4125c4 <vTaskDelay+0x58>)
  412580:	681b      	ldr	r3, [r3, #0]
  412582:	2b00      	cmp	r3, #0
  412584:	d005      	beq.n	412592 <vTaskDelay+0x26>
  412586:	f240 5244 	movw	r2, #1348	; 0x544
  41258a:	490f      	ldr	r1, [pc, #60]	; (4125c8 <vTaskDelay+0x5c>)
  41258c:	480f      	ldr	r0, [pc, #60]	; (4125cc <vTaskDelay+0x60>)
  41258e:	4b10      	ldr	r3, [pc, #64]	; (4125d0 <vTaskDelay+0x64>)
  412590:	4798      	blx	r3
			vTaskSuspendAll();
  412592:	4b10      	ldr	r3, [pc, #64]	; (4125d4 <vTaskDelay+0x68>)
  412594:	4798      	blx	r3
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
  412596:	2100      	movs	r1, #0
  412598:	6878      	ldr	r0, [r7, #4]
  41259a:	4b0f      	ldr	r3, [pc, #60]	; (4125d8 <vTaskDelay+0x6c>)
  41259c:	4798      	blx	r3
			}
			xAlreadyYielded = xTaskResumeAll();
  41259e:	4b0f      	ldr	r3, [pc, #60]	; (4125dc <vTaskDelay+0x70>)
  4125a0:	4798      	blx	r3
  4125a2:	60f8      	str	r0, [r7, #12]
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
  4125a4:	68fb      	ldr	r3, [r7, #12]
  4125a6:	2b00      	cmp	r3, #0
  4125a8:	d107      	bne.n	4125ba <vTaskDelay+0x4e>
		{
			portYIELD_WITHIN_API();
  4125aa:	4b0d      	ldr	r3, [pc, #52]	; (4125e0 <vTaskDelay+0x74>)
  4125ac:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  4125b0:	601a      	str	r2, [r3, #0]
  4125b2:	f3bf 8f4f 	dsb	sy
  4125b6:	f3bf 8f6f 	isb	sy
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
  4125ba:	bf00      	nop
  4125bc:	3710      	adds	r7, #16
  4125be:	46bd      	mov	sp, r7
  4125c0:	bd80      	pop	{r7, pc}
  4125c2:	bf00      	nop
  4125c4:	2000b4d8 	.word	0x2000b4d8
  4125c8:	0041e1f8 	.word	0x0041e1f8
  4125cc:	0041e230 	.word	0x0041e230
  4125d0:	00416c7d 	.word	0x00416c7d
  4125d4:	0041267d 	.word	0x0041267d
  4125d8:	00413431 	.word	0x00413431
  4125dc:	00412699 	.word	0x00412699
  4125e0:	e000ed04 	.word	0xe000ed04

004125e4 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
  4125e4:	b590      	push	{r4, r7, lr}
  4125e6:	b085      	sub	sp, #20
  4125e8:	af02      	add	r7, sp, #8
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
  4125ea:	4b19      	ldr	r3, [pc, #100]	; (412650 <vTaskStartScheduler+0x6c>)
  4125ec:	9301      	str	r3, [sp, #4]
  4125ee:	2300      	movs	r3, #0
  4125f0:	9300      	str	r3, [sp, #0]
  4125f2:	2300      	movs	r3, #0
  4125f4:	f44f 6280 	mov.w	r2, #1024	; 0x400
  4125f8:	4916      	ldr	r1, [pc, #88]	; (412654 <vTaskStartScheduler+0x70>)
  4125fa:	4817      	ldr	r0, [pc, #92]	; (412658 <vTaskStartScheduler+0x74>)
  4125fc:	4c17      	ldr	r4, [pc, #92]	; (41265c <vTaskStartScheduler+0x78>)
  4125fe:	47a0      	blx	r4
  412600:	6078      	str	r0, [r7, #4]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
  412602:	687b      	ldr	r3, [r7, #4]
  412604:	2b01      	cmp	r3, #1
  412606:	d115      	bne.n	412634 <vTaskStartScheduler+0x50>
	__asm volatile
  412608:	f04f 0350 	mov.w	r3, #80	; 0x50
  41260c:	f383 8811 	msr	BASEPRI, r3
  412610:	f3bf 8f6f 	isb	sy
  412614:	f3bf 8f4f 	dsb	sy
  412618:	603b      	str	r3, [r7, #0]
			for additional information. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
  41261a:	4b11      	ldr	r3, [pc, #68]	; (412660 <vTaskStartScheduler+0x7c>)
  41261c:	f04f 32ff 	mov.w	r2, #4294967295
  412620:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
  412622:	4b10      	ldr	r3, [pc, #64]	; (412664 <vTaskStartScheduler+0x80>)
  412624:	2201      	movs	r2, #1
  412626:	601a      	str	r2, [r3, #0]
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  412628:	4b0f      	ldr	r3, [pc, #60]	; (412668 <vTaskStartScheduler+0x84>)
  41262a:	2200      	movs	r2, #0
  41262c:	601a      	str	r2, [r3, #0]

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
  41262e:	4b0f      	ldr	r3, [pc, #60]	; (41266c <vTaskStartScheduler+0x88>)
  412630:	4798      	blx	r3
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
  412632:	e009      	b.n	412648 <vTaskStartScheduler+0x64>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
  412634:	687b      	ldr	r3, [r7, #4]
  412636:	f1b3 3fff 	cmp.w	r3, #4294967295
  41263a:	d105      	bne.n	412648 <vTaskStartScheduler+0x64>
  41263c:	f640 022a 	movw	r2, #2090	; 0x82a
  412640:	490b      	ldr	r1, [pc, #44]	; (412670 <vTaskStartScheduler+0x8c>)
  412642:	480c      	ldr	r0, [pc, #48]	; (412674 <vTaskStartScheduler+0x90>)
  412644:	4b0c      	ldr	r3, [pc, #48]	; (412678 <vTaskStartScheduler+0x94>)
  412646:	4798      	blx	r3
}
  412648:	bf00      	nop
  41264a:	370c      	adds	r7, #12
  41264c:	46bd      	mov	sp, r7
  41264e:	bd90      	pop	{r4, r7, pc}
  412650:	2000b4d4 	.word	0x2000b4d4
  412654:	0041e240 	.word	0x0041e240
  412658:	00412ded 	.word	0x00412ded
  41265c:	004122f9 	.word	0x004122f9
  412660:	2000b4d0 	.word	0x2000b4d0
  412664:	2000b4bc 	.word	0x2000b4bc
  412668:	2000b4b4 	.word	0x2000b4b4
  41266c:	00410f49 	.word	0x00410f49
  412670:	0041e1f8 	.word	0x0041e1f8
  412674:	0041e230 	.word	0x0041e230
  412678:	00416c7d 	.word	0x00416c7d

0041267c <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
  41267c:	b480      	push	{r7}
  41267e:	af00      	add	r7, sp, #0
	do not otherwise exhibit real time behaviour. */
	portSOFTWARE_BARRIER();

	/* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
	is used to allow calls to vTaskSuspendAll() to nest. */
	++uxSchedulerSuspended;
  412680:	4b04      	ldr	r3, [pc, #16]	; (412694 <vTaskSuspendAll+0x18>)
  412682:	681b      	ldr	r3, [r3, #0]
  412684:	3301      	adds	r3, #1
  412686:	4a03      	ldr	r2, [pc, #12]	; (412694 <vTaskSuspendAll+0x18>)
  412688:	6013      	str	r3, [r2, #0]

	/* Enforces ordering for ports and optimised compilers that may otherwise place
	the above increment elsewhere. */
	portMEMORY_BARRIER();
}
  41268a:	bf00      	nop
  41268c:	46bd      	mov	sp, r7
  41268e:	f85d 7b04 	ldr.w	r7, [sp], #4
  412692:	4770      	bx	lr
  412694:	2000b4d8 	.word	0x2000b4d8

00412698 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
  412698:	b580      	push	{r7, lr}
  41269a:	b084      	sub	sp, #16
  41269c:	af00      	add	r7, sp, #0
TCB_t *pxTCB = NULL;
  41269e:	2300      	movs	r3, #0
  4126a0:	60fb      	str	r3, [r7, #12]
BaseType_t xAlreadyYielded = pdFALSE;
  4126a2:	2300      	movs	r3, #0
  4126a4:	607b      	str	r3, [r7, #4]

	/* If uxSchedulerSuspended is zero then this function does not match a
	previous call to vTaskSuspendAll(). */
	configASSERT( uxSchedulerSuspended );
  4126a6:	4b39      	ldr	r3, [pc, #228]	; (41278c <xTaskResumeAll+0xf4>)
  4126a8:	681b      	ldr	r3, [r3, #0]
  4126aa:	2b00      	cmp	r3, #0
  4126ac:	d105      	bne.n	4126ba <xTaskResumeAll+0x22>
  4126ae:	f640 0299 	movw	r2, #2201	; 0x899
  4126b2:	4937      	ldr	r1, [pc, #220]	; (412790 <xTaskResumeAll+0xf8>)
  4126b4:	4837      	ldr	r0, [pc, #220]	; (412794 <xTaskResumeAll+0xfc>)
  4126b6:	4b38      	ldr	r3, [pc, #224]	; (412798 <xTaskResumeAll+0x100>)
  4126b8:	4798      	blx	r3
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
  4126ba:	4b38      	ldr	r3, [pc, #224]	; (41279c <xTaskResumeAll+0x104>)
  4126bc:	4798      	blx	r3
	{
		--uxSchedulerSuspended;
  4126be:	4b33      	ldr	r3, [pc, #204]	; (41278c <xTaskResumeAll+0xf4>)
  4126c0:	681b      	ldr	r3, [r3, #0]
  4126c2:	3b01      	subs	r3, #1
  4126c4:	4a31      	ldr	r2, [pc, #196]	; (41278c <xTaskResumeAll+0xf4>)
  4126c6:	6013      	str	r3, [r2, #0]

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
  4126c8:	4b30      	ldr	r3, [pc, #192]	; (41278c <xTaskResumeAll+0xf4>)
  4126ca:	681b      	ldr	r3, [r3, #0]
  4126cc:	2b00      	cmp	r3, #0
  4126ce:	d155      	bne.n	41277c <xTaskResumeAll+0xe4>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
  4126d0:	4b33      	ldr	r3, [pc, #204]	; (4127a0 <xTaskResumeAll+0x108>)
  4126d2:	681b      	ldr	r3, [r3, #0]
  4126d4:	2b00      	cmp	r3, #0
  4126d6:	d051      	beq.n	41277c <xTaskResumeAll+0xe4>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
  4126d8:	e02e      	b.n	412738 <xTaskResumeAll+0xa0>
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
  4126da:	4b32      	ldr	r3, [pc, #200]	; (4127a4 <xTaskResumeAll+0x10c>)
  4126dc:	68db      	ldr	r3, [r3, #12]
  4126de:	68db      	ldr	r3, [r3, #12]
  4126e0:	60fb      	str	r3, [r7, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
  4126e2:	68fb      	ldr	r3, [r7, #12]
  4126e4:	3318      	adds	r3, #24
  4126e6:	4618      	mov	r0, r3
  4126e8:	4b2f      	ldr	r3, [pc, #188]	; (4127a8 <xTaskResumeAll+0x110>)
  4126ea:	4798      	blx	r3
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
  4126ec:	68fb      	ldr	r3, [r7, #12]
  4126ee:	3304      	adds	r3, #4
  4126f0:	4618      	mov	r0, r3
  4126f2:	4b2d      	ldr	r3, [pc, #180]	; (4127a8 <xTaskResumeAll+0x110>)
  4126f4:	4798      	blx	r3
					prvAddTaskToReadyList( pxTCB );
  4126f6:	68fb      	ldr	r3, [r7, #12]
  4126f8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  4126fa:	2201      	movs	r2, #1
  4126fc:	409a      	lsls	r2, r3
  4126fe:	4b2b      	ldr	r3, [pc, #172]	; (4127ac <xTaskResumeAll+0x114>)
  412700:	681b      	ldr	r3, [r3, #0]
  412702:	4313      	orrs	r3, r2
  412704:	4a29      	ldr	r2, [pc, #164]	; (4127ac <xTaskResumeAll+0x114>)
  412706:	6013      	str	r3, [r2, #0]
  412708:	68fb      	ldr	r3, [r7, #12]
  41270a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  41270c:	4613      	mov	r3, r2
  41270e:	009b      	lsls	r3, r3, #2
  412710:	4413      	add	r3, r2
  412712:	009b      	lsls	r3, r3, #2
  412714:	4a26      	ldr	r2, [pc, #152]	; (4127b0 <xTaskResumeAll+0x118>)
  412716:	441a      	add	r2, r3
  412718:	68fb      	ldr	r3, [r7, #12]
  41271a:	3304      	adds	r3, #4
  41271c:	4619      	mov	r1, r3
  41271e:	4610      	mov	r0, r2
  412720:	4b24      	ldr	r3, [pc, #144]	; (4127b4 <xTaskResumeAll+0x11c>)
  412722:	4798      	blx	r3

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  412724:	68fb      	ldr	r3, [r7, #12]
  412726:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  412728:	4b23      	ldr	r3, [pc, #140]	; (4127b8 <xTaskResumeAll+0x120>)
  41272a:	681b      	ldr	r3, [r3, #0]
  41272c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  41272e:	429a      	cmp	r2, r3
  412730:	d302      	bcc.n	412738 <xTaskResumeAll+0xa0>
					{
						xYieldPending = pdTRUE;
  412732:	4b22      	ldr	r3, [pc, #136]	; (4127bc <xTaskResumeAll+0x124>)
  412734:	2201      	movs	r2, #1
  412736:	601a      	str	r2, [r3, #0]
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
  412738:	4b1a      	ldr	r3, [pc, #104]	; (4127a4 <xTaskResumeAll+0x10c>)
  41273a:	681b      	ldr	r3, [r3, #0]
  41273c:	2b00      	cmp	r3, #0
  41273e:	d1cc      	bne.n	4126da <xTaskResumeAll+0x42>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
  412740:	68fb      	ldr	r3, [r7, #12]
  412742:	2b00      	cmp	r3, #0
  412744:	d001      	beq.n	41274a <xTaskResumeAll+0xb2>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
  412746:	4b1e      	ldr	r3, [pc, #120]	; (4127c0 <xTaskResumeAll+0x128>)
  412748:	4798      	blx	r3
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
  41274a:	4b1e      	ldr	r3, [pc, #120]	; (4127c4 <xTaskResumeAll+0x12c>)
  41274c:	681b      	ldr	r3, [r3, #0]
  41274e:	60bb      	str	r3, [r7, #8]

					if( xPendedCounts > ( TickType_t ) 0U )
  412750:	68bb      	ldr	r3, [r7, #8]
  412752:	2b00      	cmp	r3, #0
  412754:	d010      	beq.n	412778 <xTaskResumeAll+0xe0>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
  412756:	4b1c      	ldr	r3, [pc, #112]	; (4127c8 <xTaskResumeAll+0x130>)
  412758:	4798      	blx	r3
  41275a:	4603      	mov	r3, r0
  41275c:	2b00      	cmp	r3, #0
  41275e:	d002      	beq.n	412766 <xTaskResumeAll+0xce>
							{
								xYieldPending = pdTRUE;
  412760:	4b16      	ldr	r3, [pc, #88]	; (4127bc <xTaskResumeAll+0x124>)
  412762:	2201      	movs	r2, #1
  412764:	601a      	str	r2, [r3, #0]
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--xPendedCounts;
  412766:	68bb      	ldr	r3, [r7, #8]
  412768:	3b01      	subs	r3, #1
  41276a:	60bb      	str	r3, [r7, #8]
						} while( xPendedCounts > ( TickType_t ) 0U );
  41276c:	68bb      	ldr	r3, [r7, #8]
  41276e:	2b00      	cmp	r3, #0
  412770:	d1f1      	bne.n	412756 <xTaskResumeAll+0xbe>

						xPendedTicks = 0;
  412772:	4b14      	ldr	r3, [pc, #80]	; (4127c4 <xTaskResumeAll+0x12c>)
  412774:	2200      	movs	r2, #0
  412776:	601a      	str	r2, [r3, #0]
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
  412778:	4b10      	ldr	r3, [pc, #64]	; (4127bc <xTaskResumeAll+0x124>)
  41277a:	681b      	ldr	r3, [r3, #0]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
  41277c:	4b13      	ldr	r3, [pc, #76]	; (4127cc <xTaskResumeAll+0x134>)
  41277e:	4798      	blx	r3

	return xAlreadyYielded;
  412780:	687b      	ldr	r3, [r7, #4]
}
  412782:	4618      	mov	r0, r3
  412784:	3710      	adds	r7, #16
  412786:	46bd      	mov	sp, r7
  412788:	bd80      	pop	{r7, pc}
  41278a:	bf00      	nop
  41278c:	2000b4d8 	.word	0x2000b4d8
  412790:	0041e1f8 	.word	0x0041e1f8
  412794:	0041e230 	.word	0x0041e230
  412798:	00416c7d 	.word	0x00416c7d
  41279c:	0041103d 	.word	0x0041103d
  4127a0:	2000b4b0 	.word	0x2000b4b0
  4127a4:	2000b488 	.word	0x2000b488
  4127a8:	00410df5 	.word	0x00410df5
  4127ac:	2000b4b8 	.word	0x2000b4b8
  4127b0:	2000b408 	.word	0x2000b408
  4127b4:	00410d3b 	.word	0x00410d3b
  4127b8:	2000b404 	.word	0x2000b404
  4127bc:	2000b4c4 	.word	0x2000b4c4
  4127c0:	00412ea5 	.word	0x00412ea5
  4127c4:	2000b4c0 	.word	0x2000b4c0
  4127c8:	004127f1 	.word	0x004127f1
  4127cc:	00411099 	.word	0x00411099

004127d0 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
  4127d0:	b480      	push	{r7}
  4127d2:	b083      	sub	sp, #12
  4127d4:	af00      	add	r7, sp, #0
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
	{
		xTicks = xTickCount;
  4127d6:	4b05      	ldr	r3, [pc, #20]	; (4127ec <xTaskGetTickCount+0x1c>)
  4127d8:	681b      	ldr	r3, [r3, #0]
  4127da:	607b      	str	r3, [r7, #4]
	}
	portTICK_TYPE_EXIT_CRITICAL();

	return xTicks;
  4127dc:	687b      	ldr	r3, [r7, #4]
}
  4127de:	4618      	mov	r0, r3
  4127e0:	370c      	adds	r7, #12
  4127e2:	46bd      	mov	sp, r7
  4127e4:	f85d 7b04 	ldr.w	r7, [sp], #4
  4127e8:	4770      	bx	lr
  4127ea:	bf00      	nop
  4127ec:	2000b4b4 	.word	0x2000b4b4

004127f0 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
  4127f0:	b580      	push	{r7, lr}
  4127f2:	b086      	sub	sp, #24
  4127f4:	af00      	add	r7, sp, #0
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
  4127f6:	2300      	movs	r3, #0
  4127f8:	617b      	str	r3, [r7, #20]

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
  4127fa:	4b3c      	ldr	r3, [pc, #240]	; (4128ec <xTaskIncrementTick+0xfc>)
  4127fc:	681b      	ldr	r3, [r3, #0]
  4127fe:	2b00      	cmp	r3, #0
  412800:	d16a      	bne.n	4128d8 <xTaskIncrementTick+0xe8>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
  412802:	4b3b      	ldr	r3, [pc, #236]	; (4128f0 <xTaskIncrementTick+0x100>)
  412804:	681b      	ldr	r3, [r3, #0]
  412806:	3301      	adds	r3, #1
  412808:	613b      	str	r3, [r7, #16]

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
  41280a:	4a39      	ldr	r2, [pc, #228]	; (4128f0 <xTaskIncrementTick+0x100>)
  41280c:	693b      	ldr	r3, [r7, #16]
  41280e:	6013      	str	r3, [r2, #0]

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
  412810:	693b      	ldr	r3, [r7, #16]
  412812:	2b00      	cmp	r3, #0
  412814:	d11b      	bne.n	41284e <xTaskIncrementTick+0x5e>
		{
			taskSWITCH_DELAYED_LISTS();
  412816:	4b37      	ldr	r3, [pc, #220]	; (4128f4 <xTaskIncrementTick+0x104>)
  412818:	681b      	ldr	r3, [r3, #0]
  41281a:	681b      	ldr	r3, [r3, #0]
  41281c:	2b00      	cmp	r3, #0
  41281e:	d005      	beq.n	41282c <xTaskIncrementTick+0x3c>
  412820:	f640 22a9 	movw	r2, #2729	; 0xaa9
  412824:	4934      	ldr	r1, [pc, #208]	; (4128f8 <xTaskIncrementTick+0x108>)
  412826:	4835      	ldr	r0, [pc, #212]	; (4128fc <xTaskIncrementTick+0x10c>)
  412828:	4b35      	ldr	r3, [pc, #212]	; (412900 <xTaskIncrementTick+0x110>)
  41282a:	4798      	blx	r3
  41282c:	4b31      	ldr	r3, [pc, #196]	; (4128f4 <xTaskIncrementTick+0x104>)
  41282e:	681b      	ldr	r3, [r3, #0]
  412830:	60fb      	str	r3, [r7, #12]
  412832:	4b34      	ldr	r3, [pc, #208]	; (412904 <xTaskIncrementTick+0x114>)
  412834:	681b      	ldr	r3, [r3, #0]
  412836:	4a2f      	ldr	r2, [pc, #188]	; (4128f4 <xTaskIncrementTick+0x104>)
  412838:	6013      	str	r3, [r2, #0]
  41283a:	4a32      	ldr	r2, [pc, #200]	; (412904 <xTaskIncrementTick+0x114>)
  41283c:	68fb      	ldr	r3, [r7, #12]
  41283e:	6013      	str	r3, [r2, #0]
  412840:	4b31      	ldr	r3, [pc, #196]	; (412908 <xTaskIncrementTick+0x118>)
  412842:	681b      	ldr	r3, [r3, #0]
  412844:	3301      	adds	r3, #1
  412846:	4a30      	ldr	r2, [pc, #192]	; (412908 <xTaskIncrementTick+0x118>)
  412848:	6013      	str	r3, [r2, #0]
  41284a:	4b30      	ldr	r3, [pc, #192]	; (41290c <xTaskIncrementTick+0x11c>)
  41284c:	4798      	blx	r3

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
  41284e:	4b30      	ldr	r3, [pc, #192]	; (412910 <xTaskIncrementTick+0x120>)
  412850:	681b      	ldr	r3, [r3, #0]
  412852:	693a      	ldr	r2, [r7, #16]
  412854:	429a      	cmp	r2, r3
  412856:	d344      	bcc.n	4128e2 <xTaskIncrementTick+0xf2>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
  412858:	4b26      	ldr	r3, [pc, #152]	; (4128f4 <xTaskIncrementTick+0x104>)
  41285a:	681b      	ldr	r3, [r3, #0]
  41285c:	681b      	ldr	r3, [r3, #0]
  41285e:	2b00      	cmp	r3, #0
  412860:	d104      	bne.n	41286c <xTaskIncrementTick+0x7c>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  412862:	4b2b      	ldr	r3, [pc, #172]	; (412910 <xTaskIncrementTick+0x120>)
  412864:	f04f 32ff 	mov.w	r2, #4294967295
  412868:	601a      	str	r2, [r3, #0]
					break;
  41286a:	e03a      	b.n	4128e2 <xTaskIncrementTick+0xf2>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
  41286c:	4b21      	ldr	r3, [pc, #132]	; (4128f4 <xTaskIncrementTick+0x104>)
  41286e:	681b      	ldr	r3, [r3, #0]
  412870:	68db      	ldr	r3, [r3, #12]
  412872:	68db      	ldr	r3, [r3, #12]
  412874:	60bb      	str	r3, [r7, #8]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
  412876:	68bb      	ldr	r3, [r7, #8]
  412878:	685b      	ldr	r3, [r3, #4]
  41287a:	607b      	str	r3, [r7, #4]

					if( xConstTickCount < xItemValue )
  41287c:	693a      	ldr	r2, [r7, #16]
  41287e:	687b      	ldr	r3, [r7, #4]
  412880:	429a      	cmp	r2, r3
  412882:	d203      	bcs.n	41288c <xTaskIncrementTick+0x9c>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
  412884:	4a22      	ldr	r2, [pc, #136]	; (412910 <xTaskIncrementTick+0x120>)
  412886:	687b      	ldr	r3, [r7, #4]
  412888:	6013      	str	r3, [r2, #0]
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
  41288a:	e02a      	b.n	4128e2 <xTaskIncrementTick+0xf2>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
  41288c:	68bb      	ldr	r3, [r7, #8]
  41288e:	3304      	adds	r3, #4
  412890:	4618      	mov	r0, r3
  412892:	4b20      	ldr	r3, [pc, #128]	; (412914 <xTaskIncrementTick+0x124>)
  412894:	4798      	blx	r3

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
  412896:	68bb      	ldr	r3, [r7, #8]
  412898:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  41289a:	2b00      	cmp	r3, #0
  41289c:	d004      	beq.n	4128a8 <xTaskIncrementTick+0xb8>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
  41289e:	68bb      	ldr	r3, [r7, #8]
  4128a0:	3318      	adds	r3, #24
  4128a2:	4618      	mov	r0, r3
  4128a4:	4b1b      	ldr	r3, [pc, #108]	; (412914 <xTaskIncrementTick+0x124>)
  4128a6:	4798      	blx	r3
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
  4128a8:	68bb      	ldr	r3, [r7, #8]
  4128aa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  4128ac:	2201      	movs	r2, #1
  4128ae:	409a      	lsls	r2, r3
  4128b0:	4b19      	ldr	r3, [pc, #100]	; (412918 <xTaskIncrementTick+0x128>)
  4128b2:	681b      	ldr	r3, [r3, #0]
  4128b4:	4313      	orrs	r3, r2
  4128b6:	4a18      	ldr	r2, [pc, #96]	; (412918 <xTaskIncrementTick+0x128>)
  4128b8:	6013      	str	r3, [r2, #0]
  4128ba:	68bb      	ldr	r3, [r7, #8]
  4128bc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  4128be:	4613      	mov	r3, r2
  4128c0:	009b      	lsls	r3, r3, #2
  4128c2:	4413      	add	r3, r2
  4128c4:	009b      	lsls	r3, r3, #2
  4128c6:	4a15      	ldr	r2, [pc, #84]	; (41291c <xTaskIncrementTick+0x12c>)
  4128c8:	441a      	add	r2, r3
  4128ca:	68bb      	ldr	r3, [r7, #8]
  4128cc:	3304      	adds	r3, #4
  4128ce:	4619      	mov	r1, r3
  4128d0:	4610      	mov	r0, r2
  4128d2:	4b13      	ldr	r3, [pc, #76]	; (412920 <xTaskIncrementTick+0x130>)
  4128d4:	4798      	blx	r3
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
  4128d6:	e7bf      	b.n	412858 <xTaskIncrementTick+0x68>
		}
		#endif /* configUSE_PREEMPTION */
	}
	else
	{
		++xPendedTicks;
  4128d8:	4b12      	ldr	r3, [pc, #72]	; (412924 <xTaskIncrementTick+0x134>)
  4128da:	681b      	ldr	r3, [r3, #0]
  4128dc:	3301      	adds	r3, #1
  4128de:	4a11      	ldr	r2, [pc, #68]	; (412924 <xTaskIncrementTick+0x134>)
  4128e0:	6013      	str	r3, [r2, #0]
			vApplicationTickHook();
		}
		#endif
	}

	return xSwitchRequired;
  4128e2:	697b      	ldr	r3, [r7, #20]
}
  4128e4:	4618      	mov	r0, r3
  4128e6:	3718      	adds	r7, #24
  4128e8:	46bd      	mov	sp, r7
  4128ea:	bd80      	pop	{r7, pc}
  4128ec:	2000b4d8 	.word	0x2000b4d8
  4128f0:	2000b4b4 	.word	0x2000b4b4
  4128f4:	2000b480 	.word	0x2000b480
  4128f8:	0041e1f8 	.word	0x0041e1f8
  4128fc:	0041e230 	.word	0x0041e230
  412900:	00416c7d 	.word	0x00416c7d
  412904:	2000b484 	.word	0x2000b484
  412908:	2000b4c8 	.word	0x2000b4c8
  41290c:	00412ea5 	.word	0x00412ea5
  412910:	2000b4d0 	.word	0x2000b4d0
  412914:	00410df5 	.word	0x00410df5
  412918:	2000b4b8 	.word	0x2000b4b8
  41291c:	2000b408 	.word	0x2000b408
  412920:	00410d3b 	.word	0x00410d3b
  412924:	2000b4c0 	.word	0x2000b4c0

00412928 <vApplicationStackOverflowHook>:
/*-----------------------------------------------------------*/

// HICS
//void taskCHECK_FOR_STACK_OVERFLOW(void)
void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName )
{
  412928:	b580      	push	{r7, lr}
  41292a:	b082      	sub	sp, #8
  41292c:	af00      	add	r7, sp, #0
  41292e:	6078      	str	r0, [r7, #4]
  412930:	6039      	str	r1, [r7, #0]
	printf("\n\nERROR: taskCHECK_FOR_STACK_OVERFLOW() %s\n\n",pcTaskName);
  412932:	6839      	ldr	r1, [r7, #0]
  412934:	4803      	ldr	r0, [pc, #12]	; (412944 <vApplicationStackOverflowHook+0x1c>)
  412936:	4b04      	ldr	r3, [pc, #16]	; (412948 <vApplicationStackOverflowHook+0x20>)
  412938:	4798      	blx	r3
	
}
  41293a:	bf00      	nop
  41293c:	3708      	adds	r7, #8
  41293e:	46bd      	mov	sp, r7
  412940:	bd80      	pop	{r7, pc}
  412942:	bf00      	nop
  412944:	0041e248 	.word	0x0041e248
  412948:	00416c7d 	.word	0x00416c7d

0041294c <vTaskSwitchContext>:


void vTaskSwitchContext( void )
{
  41294c:	b580      	push	{r7, lr}
  41294e:	b084      	sub	sp, #16
  412950:	af00      	add	r7, sp, #0
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
  412952:	4b2c      	ldr	r3, [pc, #176]	; (412a04 <vTaskSwitchContext+0xb8>)
  412954:	681b      	ldr	r3, [r3, #0]
  412956:	2b00      	cmp	r3, #0
  412958:	d003      	beq.n	412962 <vTaskSwitchContext+0x16>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
  41295a:	4b2b      	ldr	r3, [pc, #172]	; (412a08 <vTaskSwitchContext+0xbc>)
  41295c:	2201      	movs	r2, #1
  41295e:	601a      	str	r2, [r3, #0]
			for additional information. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
  412960:	e04b      	b.n	4129fa <vTaskSwitchContext+0xae>
		xYieldPending = pdFALSE;
  412962:	4b29      	ldr	r3, [pc, #164]	; (412a08 <vTaskSwitchContext+0xbc>)
  412964:	2200      	movs	r2, #0
  412966:	601a      	str	r2, [r3, #0]
		taskCHECK_FOR_STACK_OVERFLOW();
  412968:	4b28      	ldr	r3, [pc, #160]	; (412a0c <vTaskSwitchContext+0xc0>)
  41296a:	681b      	ldr	r3, [r3, #0]
  41296c:	681a      	ldr	r2, [r3, #0]
  41296e:	4b27      	ldr	r3, [pc, #156]	; (412a0c <vTaskSwitchContext+0xc0>)
  412970:	681b      	ldr	r3, [r3, #0]
  412972:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  412974:	429a      	cmp	r2, r3
  412976:	d808      	bhi.n	41298a <vTaskSwitchContext+0x3e>
  412978:	4b24      	ldr	r3, [pc, #144]	; (412a0c <vTaskSwitchContext+0xc0>)
  41297a:	681a      	ldr	r2, [r3, #0]
  41297c:	4b23      	ldr	r3, [pc, #140]	; (412a0c <vTaskSwitchContext+0xc0>)
  41297e:	681b      	ldr	r3, [r3, #0]
  412980:	3334      	adds	r3, #52	; 0x34
  412982:	4619      	mov	r1, r3
  412984:	4610      	mov	r0, r2
  412986:	4b22      	ldr	r3, [pc, #136]	; (412a10 <vTaskSwitchContext+0xc4>)
  412988:	4798      	blx	r3
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
  41298a:	4b22      	ldr	r3, [pc, #136]	; (412a14 <vTaskSwitchContext+0xc8>)
  41298c:	681b      	ldr	r3, [r3, #0]
  41298e:	607b      	str	r3, [r7, #4]
		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
  412990:	687b      	ldr	r3, [r7, #4]
  412992:	fab3 f383 	clz	r3, r3
  412996:	70fb      	strb	r3, [r7, #3]
		return ucReturn;
  412998:	78fb      	ldrb	r3, [r7, #3]
  41299a:	f1c3 031f 	rsb	r3, r3, #31
  41299e:	60fb      	str	r3, [r7, #12]
  4129a0:	491d      	ldr	r1, [pc, #116]	; (412a18 <vTaskSwitchContext+0xcc>)
  4129a2:	68fa      	ldr	r2, [r7, #12]
  4129a4:	4613      	mov	r3, r2
  4129a6:	009b      	lsls	r3, r3, #2
  4129a8:	4413      	add	r3, r2
  4129aa:	009b      	lsls	r3, r3, #2
  4129ac:	440b      	add	r3, r1
  4129ae:	681b      	ldr	r3, [r3, #0]
  4129b0:	2b00      	cmp	r3, #0
  4129b2:	d105      	bne.n	4129c0 <vTaskSwitchContext+0x74>
  4129b4:	f640 32ea 	movw	r2, #3050	; 0xbea
  4129b8:	4918      	ldr	r1, [pc, #96]	; (412a1c <vTaskSwitchContext+0xd0>)
  4129ba:	4819      	ldr	r0, [pc, #100]	; (412a20 <vTaskSwitchContext+0xd4>)
  4129bc:	4b19      	ldr	r3, [pc, #100]	; (412a24 <vTaskSwitchContext+0xd8>)
  4129be:	4798      	blx	r3
  4129c0:	68fa      	ldr	r2, [r7, #12]
  4129c2:	4613      	mov	r3, r2
  4129c4:	009b      	lsls	r3, r3, #2
  4129c6:	4413      	add	r3, r2
  4129c8:	009b      	lsls	r3, r3, #2
  4129ca:	4a13      	ldr	r2, [pc, #76]	; (412a18 <vTaskSwitchContext+0xcc>)
  4129cc:	4413      	add	r3, r2
  4129ce:	60bb      	str	r3, [r7, #8]
  4129d0:	68bb      	ldr	r3, [r7, #8]
  4129d2:	685b      	ldr	r3, [r3, #4]
  4129d4:	685a      	ldr	r2, [r3, #4]
  4129d6:	68bb      	ldr	r3, [r7, #8]
  4129d8:	605a      	str	r2, [r3, #4]
  4129da:	68bb      	ldr	r3, [r7, #8]
  4129dc:	685a      	ldr	r2, [r3, #4]
  4129de:	68bb      	ldr	r3, [r7, #8]
  4129e0:	3308      	adds	r3, #8
  4129e2:	429a      	cmp	r2, r3
  4129e4:	d104      	bne.n	4129f0 <vTaskSwitchContext+0xa4>
  4129e6:	68bb      	ldr	r3, [r7, #8]
  4129e8:	685b      	ldr	r3, [r3, #4]
  4129ea:	685a      	ldr	r2, [r3, #4]
  4129ec:	68bb      	ldr	r3, [r7, #8]
  4129ee:	605a      	str	r2, [r3, #4]
  4129f0:	68bb      	ldr	r3, [r7, #8]
  4129f2:	685b      	ldr	r3, [r3, #4]
  4129f4:	68db      	ldr	r3, [r3, #12]
  4129f6:	4a05      	ldr	r2, [pc, #20]	; (412a0c <vTaskSwitchContext+0xc0>)
  4129f8:	6013      	str	r3, [r2, #0]
}
  4129fa:	bf00      	nop
  4129fc:	3710      	adds	r7, #16
  4129fe:	46bd      	mov	sp, r7
  412a00:	bd80      	pop	{r7, pc}
  412a02:	bf00      	nop
  412a04:	2000b4d8 	.word	0x2000b4d8
  412a08:	2000b4c4 	.word	0x2000b4c4
  412a0c:	2000b404 	.word	0x2000b404
  412a10:	00412929 	.word	0x00412929
  412a14:	2000b4b8 	.word	0x2000b4b8
  412a18:	2000b408 	.word	0x2000b408
  412a1c:	0041e1f8 	.word	0x0041e1f8
  412a20:	0041e230 	.word	0x0041e230
  412a24:	00416c7d 	.word	0x00416c7d

00412a28 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
  412a28:	b580      	push	{r7, lr}
  412a2a:	b082      	sub	sp, #8
  412a2c:	af00      	add	r7, sp, #0
  412a2e:	6078      	str	r0, [r7, #4]
  412a30:	6039      	str	r1, [r7, #0]
	configASSERT( pxEventList );
  412a32:	687b      	ldr	r3, [r7, #4]
  412a34:	2b00      	cmp	r3, #0
  412a36:	d105      	bne.n	412a44 <vTaskPlaceOnEventList+0x1c>
  412a38:	f640 4203 	movw	r2, #3075	; 0xc03
  412a3c:	4909      	ldr	r1, [pc, #36]	; (412a64 <vTaskPlaceOnEventList+0x3c>)
  412a3e:	480a      	ldr	r0, [pc, #40]	; (412a68 <vTaskPlaceOnEventList+0x40>)
  412a40:	4b0a      	ldr	r3, [pc, #40]	; (412a6c <vTaskPlaceOnEventList+0x44>)
  412a42:	4798      	blx	r3

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
  412a44:	4b0a      	ldr	r3, [pc, #40]	; (412a70 <vTaskPlaceOnEventList+0x48>)
  412a46:	681b      	ldr	r3, [r3, #0]
  412a48:	3318      	adds	r3, #24
  412a4a:	4619      	mov	r1, r3
  412a4c:	6878      	ldr	r0, [r7, #4]
  412a4e:	4b09      	ldr	r3, [pc, #36]	; (412a74 <vTaskPlaceOnEventList+0x4c>)
  412a50:	4798      	blx	r3

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
  412a52:	2101      	movs	r1, #1
  412a54:	6838      	ldr	r0, [r7, #0]
  412a56:	4b08      	ldr	r3, [pc, #32]	; (412a78 <vTaskPlaceOnEventList+0x50>)
  412a58:	4798      	blx	r3
}
  412a5a:	bf00      	nop
  412a5c:	3708      	adds	r7, #8
  412a5e:	46bd      	mov	sp, r7
  412a60:	bd80      	pop	{r7, pc}
  412a62:	bf00      	nop
  412a64:	0041e1f8 	.word	0x0041e1f8
  412a68:	0041e230 	.word	0x0041e230
  412a6c:	00416c7d 	.word	0x00416c7d
  412a70:	2000b404 	.word	0x2000b404
  412a74:	00410d83 	.word	0x00410d83
  412a78:	00413431 	.word	0x00413431

00412a7c <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
  412a7c:	b580      	push	{r7, lr}
  412a7e:	b084      	sub	sp, #16
  412a80:	af00      	add	r7, sp, #0
  412a82:	60f8      	str	r0, [r7, #12]
  412a84:	60b9      	str	r1, [r7, #8]
  412a86:	607a      	str	r2, [r7, #4]
	configASSERT( pxEventList );
  412a88:	68fb      	ldr	r3, [r7, #12]
  412a8a:	2b00      	cmp	r3, #0
  412a8c:	d105      	bne.n	412a9a <vTaskPlaceOnUnorderedEventList+0x1e>
  412a8e:	f640 4214 	movw	r2, #3092	; 0xc14
  412a92:	4911      	ldr	r1, [pc, #68]	; (412ad8 <vTaskPlaceOnUnorderedEventList+0x5c>)
  412a94:	4811      	ldr	r0, [pc, #68]	; (412adc <vTaskPlaceOnUnorderedEventList+0x60>)
  412a96:	4b12      	ldr	r3, [pc, #72]	; (412ae0 <vTaskPlaceOnUnorderedEventList+0x64>)
  412a98:	4798      	blx	r3

	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event groups implementation. */
	configASSERT( uxSchedulerSuspended != 0 );
  412a9a:	4b12      	ldr	r3, [pc, #72]	; (412ae4 <vTaskPlaceOnUnorderedEventList+0x68>)
  412a9c:	681b      	ldr	r3, [r3, #0]
  412a9e:	2b00      	cmp	r3, #0
  412aa0:	d105      	bne.n	412aae <vTaskPlaceOnUnorderedEventList+0x32>
  412aa2:	f640 4218 	movw	r2, #3096	; 0xc18
  412aa6:	490c      	ldr	r1, [pc, #48]	; (412ad8 <vTaskPlaceOnUnorderedEventList+0x5c>)
  412aa8:	480c      	ldr	r0, [pc, #48]	; (412adc <vTaskPlaceOnUnorderedEventList+0x60>)
  412aaa:	4b0d      	ldr	r3, [pc, #52]	; (412ae0 <vTaskPlaceOnUnorderedEventList+0x64>)
  412aac:	4798      	blx	r3

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
  412aae:	4b0e      	ldr	r3, [pc, #56]	; (412ae8 <vTaskPlaceOnUnorderedEventList+0x6c>)
  412ab0:	681b      	ldr	r3, [r3, #0]
  412ab2:	68ba      	ldr	r2, [r7, #8]
  412ab4:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
  412ab8:	619a      	str	r2, [r3, #24]
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
  412aba:	4b0b      	ldr	r3, [pc, #44]	; (412ae8 <vTaskPlaceOnUnorderedEventList+0x6c>)
  412abc:	681b      	ldr	r3, [r3, #0]
  412abe:	3318      	adds	r3, #24
  412ac0:	4619      	mov	r1, r3
  412ac2:	68f8      	ldr	r0, [r7, #12]
  412ac4:	4b09      	ldr	r3, [pc, #36]	; (412aec <vTaskPlaceOnUnorderedEventList+0x70>)
  412ac6:	4798      	blx	r3

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
  412ac8:	2101      	movs	r1, #1
  412aca:	6878      	ldr	r0, [r7, #4]
  412acc:	4b08      	ldr	r3, [pc, #32]	; (412af0 <vTaskPlaceOnUnorderedEventList+0x74>)
  412ace:	4798      	blx	r3
}
  412ad0:	bf00      	nop
  412ad2:	3710      	adds	r7, #16
  412ad4:	46bd      	mov	sp, r7
  412ad6:	bd80      	pop	{r7, pc}
  412ad8:	0041e1f8 	.word	0x0041e1f8
  412adc:	0041e230 	.word	0x0041e230
  412ae0:	00416c7d 	.word	0x00416c7d
  412ae4:	2000b4d8 	.word	0x2000b4d8
  412ae8:	2000b404 	.word	0x2000b404
  412aec:	00410d3b 	.word	0x00410d3b
  412af0:	00413431 	.word	0x00413431

00412af4 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
  412af4:	b580      	push	{r7, lr}
  412af6:	b084      	sub	sp, #16
  412af8:	af00      	add	r7, sp, #0
  412afa:	6078      	str	r0, [r7, #4]
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
  412afc:	687b      	ldr	r3, [r7, #4]
  412afe:	68db      	ldr	r3, [r3, #12]
  412b00:	68db      	ldr	r3, [r3, #12]
  412b02:	60bb      	str	r3, [r7, #8]
	configASSERT( pxUnblockedTCB );
  412b04:	68bb      	ldr	r3, [r7, #8]
  412b06:	2b00      	cmp	r3, #0
  412b08:	d105      	bne.n	412b16 <xTaskRemoveFromEventList+0x22>
  412b0a:	f640 425e 	movw	r2, #3166	; 0xc5e
  412b0e:	4922      	ldr	r1, [pc, #136]	; (412b98 <xTaskRemoveFromEventList+0xa4>)
  412b10:	4822      	ldr	r0, [pc, #136]	; (412b9c <xTaskRemoveFromEventList+0xa8>)
  412b12:	4b23      	ldr	r3, [pc, #140]	; (412ba0 <xTaskRemoveFromEventList+0xac>)
  412b14:	4798      	blx	r3
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
  412b16:	68bb      	ldr	r3, [r7, #8]
  412b18:	3318      	adds	r3, #24
  412b1a:	4618      	mov	r0, r3
  412b1c:	4b21      	ldr	r3, [pc, #132]	; (412ba4 <xTaskRemoveFromEventList+0xb0>)
  412b1e:	4798      	blx	r3

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
  412b20:	4b21      	ldr	r3, [pc, #132]	; (412ba8 <xTaskRemoveFromEventList+0xb4>)
  412b22:	681b      	ldr	r3, [r3, #0]
  412b24:	2b00      	cmp	r3, #0
  412b26:	d11c      	bne.n	412b62 <xTaskRemoveFromEventList+0x6e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
  412b28:	68bb      	ldr	r3, [r7, #8]
  412b2a:	3304      	adds	r3, #4
  412b2c:	4618      	mov	r0, r3
  412b2e:	4b1d      	ldr	r3, [pc, #116]	; (412ba4 <xTaskRemoveFromEventList+0xb0>)
  412b30:	4798      	blx	r3
		prvAddTaskToReadyList( pxUnblockedTCB );
  412b32:	68bb      	ldr	r3, [r7, #8]
  412b34:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  412b36:	2201      	movs	r2, #1
  412b38:	409a      	lsls	r2, r3
  412b3a:	4b1c      	ldr	r3, [pc, #112]	; (412bac <xTaskRemoveFromEventList+0xb8>)
  412b3c:	681b      	ldr	r3, [r3, #0]
  412b3e:	4313      	orrs	r3, r2
  412b40:	4a1a      	ldr	r2, [pc, #104]	; (412bac <xTaskRemoveFromEventList+0xb8>)
  412b42:	6013      	str	r3, [r2, #0]
  412b44:	68bb      	ldr	r3, [r7, #8]
  412b46:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  412b48:	4613      	mov	r3, r2
  412b4a:	009b      	lsls	r3, r3, #2
  412b4c:	4413      	add	r3, r2
  412b4e:	009b      	lsls	r3, r3, #2
  412b50:	4a17      	ldr	r2, [pc, #92]	; (412bb0 <xTaskRemoveFromEventList+0xbc>)
  412b52:	441a      	add	r2, r3
  412b54:	68bb      	ldr	r3, [r7, #8]
  412b56:	3304      	adds	r3, #4
  412b58:	4619      	mov	r1, r3
  412b5a:	4610      	mov	r0, r2
  412b5c:	4b15      	ldr	r3, [pc, #84]	; (412bb4 <xTaskRemoveFromEventList+0xc0>)
  412b5e:	4798      	blx	r3
  412b60:	e005      	b.n	412b6e <xTaskRemoveFromEventList+0x7a>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
  412b62:	68bb      	ldr	r3, [r7, #8]
  412b64:	3318      	adds	r3, #24
  412b66:	4619      	mov	r1, r3
  412b68:	4813      	ldr	r0, [pc, #76]	; (412bb8 <xTaskRemoveFromEventList+0xc4>)
  412b6a:	4b12      	ldr	r3, [pc, #72]	; (412bb4 <xTaskRemoveFromEventList+0xc0>)
  412b6c:	4798      	blx	r3
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
  412b6e:	68bb      	ldr	r3, [r7, #8]
  412b70:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  412b72:	4b12      	ldr	r3, [pc, #72]	; (412bbc <xTaskRemoveFromEventList+0xc8>)
  412b74:	681b      	ldr	r3, [r3, #0]
  412b76:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  412b78:	429a      	cmp	r2, r3
  412b7a:	d905      	bls.n	412b88 <xTaskRemoveFromEventList+0x94>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
  412b7c:	2301      	movs	r3, #1
  412b7e:	60fb      	str	r3, [r7, #12]

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
  412b80:	4b0f      	ldr	r3, [pc, #60]	; (412bc0 <xTaskRemoveFromEventList+0xcc>)
  412b82:	2201      	movs	r2, #1
  412b84:	601a      	str	r2, [r3, #0]
  412b86:	e001      	b.n	412b8c <xTaskRemoveFromEventList+0x98>
	}
	else
	{
		xReturn = pdFALSE;
  412b88:	2300      	movs	r3, #0
  412b8a:	60fb      	str	r3, [r7, #12]
	}

	return xReturn;
  412b8c:	68fb      	ldr	r3, [r7, #12]
}
  412b8e:	4618      	mov	r0, r3
  412b90:	3710      	adds	r7, #16
  412b92:	46bd      	mov	sp, r7
  412b94:	bd80      	pop	{r7, pc}
  412b96:	bf00      	nop
  412b98:	0041e1f8 	.word	0x0041e1f8
  412b9c:	0041e230 	.word	0x0041e230
  412ba0:	00416c7d 	.word	0x00416c7d
  412ba4:	00410df5 	.word	0x00410df5
  412ba8:	2000b4d8 	.word	0x2000b4d8
  412bac:	2000b4b8 	.word	0x2000b4b8
  412bb0:	2000b408 	.word	0x2000b408
  412bb4:	00410d3b 	.word	0x00410d3b
  412bb8:	2000b488 	.word	0x2000b488
  412bbc:	2000b404 	.word	0x2000b404
  412bc0:	2000b4c4 	.word	0x2000b4c4

00412bc4 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
  412bc4:	b580      	push	{r7, lr}
  412bc6:	b084      	sub	sp, #16
  412bc8:	af00      	add	r7, sp, #0
  412bca:	6078      	str	r0, [r7, #4]
  412bcc:	6039      	str	r1, [r7, #0]
TCB_t *pxUnblockedTCB;

	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );
  412bce:	4b24      	ldr	r3, [pc, #144]	; (412c60 <vTaskRemoveFromUnorderedEventList+0x9c>)
  412bd0:	681b      	ldr	r3, [r3, #0]
  412bd2:	2b00      	cmp	r3, #0
  412bd4:	d105      	bne.n	412be2 <vTaskRemoveFromUnorderedEventList+0x1e>
  412bd6:	f640 4295 	movw	r2, #3221	; 0xc95
  412bda:	4922      	ldr	r1, [pc, #136]	; (412c64 <vTaskRemoveFromUnorderedEventList+0xa0>)
  412bdc:	4822      	ldr	r0, [pc, #136]	; (412c68 <vTaskRemoveFromUnorderedEventList+0xa4>)
  412bde:	4b23      	ldr	r3, [pc, #140]	; (412c6c <vTaskRemoveFromUnorderedEventList+0xa8>)
  412be0:	4798      	blx	r3

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
  412be2:	683b      	ldr	r3, [r7, #0]
  412be4:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
  412be8:	687b      	ldr	r3, [r7, #4]
  412bea:	601a      	str	r2, [r3, #0]

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
  412bec:	687b      	ldr	r3, [r7, #4]
  412bee:	68db      	ldr	r3, [r3, #12]
  412bf0:	60fb      	str	r3, [r7, #12]
	configASSERT( pxUnblockedTCB );
  412bf2:	68fb      	ldr	r3, [r7, #12]
  412bf4:	2b00      	cmp	r3, #0
  412bf6:	d105      	bne.n	412c04 <vTaskRemoveFromUnorderedEventList+0x40>
  412bf8:	f640 429d 	movw	r2, #3229	; 0xc9d
  412bfc:	4919      	ldr	r1, [pc, #100]	; (412c64 <vTaskRemoveFromUnorderedEventList+0xa0>)
  412bfe:	481a      	ldr	r0, [pc, #104]	; (412c68 <vTaskRemoveFromUnorderedEventList+0xa4>)
  412c00:	4b1a      	ldr	r3, [pc, #104]	; (412c6c <vTaskRemoveFromUnorderedEventList+0xa8>)
  412c02:	4798      	blx	r3
	( void ) uxListRemove( pxEventListItem );
  412c04:	6878      	ldr	r0, [r7, #4]
  412c06:	4b1a      	ldr	r3, [pc, #104]	; (412c70 <vTaskRemoveFromUnorderedEventList+0xac>)
  412c08:	4798      	blx	r3
	#endif

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
  412c0a:	68fb      	ldr	r3, [r7, #12]
  412c0c:	3304      	adds	r3, #4
  412c0e:	4618      	mov	r0, r3
  412c10:	4b17      	ldr	r3, [pc, #92]	; (412c70 <vTaskRemoveFromUnorderedEventList+0xac>)
  412c12:	4798      	blx	r3
	prvAddTaskToReadyList( pxUnblockedTCB );
  412c14:	68fb      	ldr	r3, [r7, #12]
  412c16:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  412c18:	2201      	movs	r2, #1
  412c1a:	409a      	lsls	r2, r3
  412c1c:	4b15      	ldr	r3, [pc, #84]	; (412c74 <vTaskRemoveFromUnorderedEventList+0xb0>)
  412c1e:	681b      	ldr	r3, [r3, #0]
  412c20:	4313      	orrs	r3, r2
  412c22:	4a14      	ldr	r2, [pc, #80]	; (412c74 <vTaskRemoveFromUnorderedEventList+0xb0>)
  412c24:	6013      	str	r3, [r2, #0]
  412c26:	68fb      	ldr	r3, [r7, #12]
  412c28:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  412c2a:	4613      	mov	r3, r2
  412c2c:	009b      	lsls	r3, r3, #2
  412c2e:	4413      	add	r3, r2
  412c30:	009b      	lsls	r3, r3, #2
  412c32:	4a11      	ldr	r2, [pc, #68]	; (412c78 <vTaskRemoveFromUnorderedEventList+0xb4>)
  412c34:	441a      	add	r2, r3
  412c36:	68fb      	ldr	r3, [r7, #12]
  412c38:	3304      	adds	r3, #4
  412c3a:	4619      	mov	r1, r3
  412c3c:	4610      	mov	r0, r2
  412c3e:	4b0f      	ldr	r3, [pc, #60]	; (412c7c <vTaskRemoveFromUnorderedEventList+0xb8>)
  412c40:	4798      	blx	r3

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
  412c42:	68fb      	ldr	r3, [r7, #12]
  412c44:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  412c46:	4b0e      	ldr	r3, [pc, #56]	; (412c80 <vTaskRemoveFromUnorderedEventList+0xbc>)
  412c48:	681b      	ldr	r3, [r3, #0]
  412c4a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  412c4c:	429a      	cmp	r2, r3
  412c4e:	d902      	bls.n	412c56 <vTaskRemoveFromUnorderedEventList+0x92>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
  412c50:	4b0c      	ldr	r3, [pc, #48]	; (412c84 <vTaskRemoveFromUnorderedEventList+0xc0>)
  412c52:	2201      	movs	r2, #1
  412c54:	601a      	str	r2, [r3, #0]
	}
}
  412c56:	bf00      	nop
  412c58:	3710      	adds	r7, #16
  412c5a:	46bd      	mov	sp, r7
  412c5c:	bd80      	pop	{r7, pc}
  412c5e:	bf00      	nop
  412c60:	2000b4d8 	.word	0x2000b4d8
  412c64:	0041e1f8 	.word	0x0041e1f8
  412c68:	0041e230 	.word	0x0041e230
  412c6c:	00416c7d 	.word	0x00416c7d
  412c70:	00410df5 	.word	0x00410df5
  412c74:	2000b4b8 	.word	0x2000b4b8
  412c78:	2000b408 	.word	0x2000b408
  412c7c:	00410d3b 	.word	0x00410d3b
  412c80:	2000b404 	.word	0x2000b404
  412c84:	2000b4c4 	.word	0x2000b4c4

00412c88 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
  412c88:	b580      	push	{r7, lr}
  412c8a:	b082      	sub	sp, #8
  412c8c:	af00      	add	r7, sp, #0
  412c8e:	6078      	str	r0, [r7, #4]
	configASSERT( pxTimeOut );
  412c90:	687b      	ldr	r3, [r7, #4]
  412c92:	2b00      	cmp	r3, #0
  412c94:	d105      	bne.n	412ca2 <vTaskSetTimeOutState+0x1a>
  412c96:	f640 42c1 	movw	r2, #3265	; 0xcc1
  412c9a:	490a      	ldr	r1, [pc, #40]	; (412cc4 <vTaskSetTimeOutState+0x3c>)
  412c9c:	480a      	ldr	r0, [pc, #40]	; (412cc8 <vTaskSetTimeOutState+0x40>)
  412c9e:	4b0b      	ldr	r3, [pc, #44]	; (412ccc <vTaskSetTimeOutState+0x44>)
  412ca0:	4798      	blx	r3
	taskENTER_CRITICAL();
  412ca2:	4b0b      	ldr	r3, [pc, #44]	; (412cd0 <vTaskSetTimeOutState+0x48>)
  412ca4:	4798      	blx	r3
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
  412ca6:	4b0b      	ldr	r3, [pc, #44]	; (412cd4 <vTaskSetTimeOutState+0x4c>)
  412ca8:	681a      	ldr	r2, [r3, #0]
  412caa:	687b      	ldr	r3, [r7, #4]
  412cac:	601a      	str	r2, [r3, #0]
		pxTimeOut->xTimeOnEntering = xTickCount;
  412cae:	4b0a      	ldr	r3, [pc, #40]	; (412cd8 <vTaskSetTimeOutState+0x50>)
  412cb0:	681a      	ldr	r2, [r3, #0]
  412cb2:	687b      	ldr	r3, [r7, #4]
  412cb4:	605a      	str	r2, [r3, #4]
	}
	taskEXIT_CRITICAL();
  412cb6:	4b09      	ldr	r3, [pc, #36]	; (412cdc <vTaskSetTimeOutState+0x54>)
  412cb8:	4798      	blx	r3
}
  412cba:	bf00      	nop
  412cbc:	3708      	adds	r7, #8
  412cbe:	46bd      	mov	sp, r7
  412cc0:	bd80      	pop	{r7, pc}
  412cc2:	bf00      	nop
  412cc4:	0041e1f8 	.word	0x0041e1f8
  412cc8:	0041e230 	.word	0x0041e230
  412ccc:	00416c7d 	.word	0x00416c7d
  412cd0:	0041103d 	.word	0x0041103d
  412cd4:	2000b4c8 	.word	0x2000b4c8
  412cd8:	2000b4b4 	.word	0x2000b4b4
  412cdc:	00411099 	.word	0x00411099

00412ce0 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
  412ce0:	b480      	push	{r7}
  412ce2:	b083      	sub	sp, #12
  412ce4:	af00      	add	r7, sp, #0
  412ce6:	6078      	str	r0, [r7, #4]
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
  412ce8:	4b06      	ldr	r3, [pc, #24]	; (412d04 <vTaskInternalSetTimeOutState+0x24>)
  412cea:	681a      	ldr	r2, [r3, #0]
  412cec:	687b      	ldr	r3, [r7, #4]
  412cee:	601a      	str	r2, [r3, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
  412cf0:	4b05      	ldr	r3, [pc, #20]	; (412d08 <vTaskInternalSetTimeOutState+0x28>)
  412cf2:	681a      	ldr	r2, [r3, #0]
  412cf4:	687b      	ldr	r3, [r7, #4]
  412cf6:	605a      	str	r2, [r3, #4]
}
  412cf8:	bf00      	nop
  412cfa:	370c      	adds	r7, #12
  412cfc:	46bd      	mov	sp, r7
  412cfe:	f85d 7b04 	ldr.w	r7, [sp], #4
  412d02:	4770      	bx	lr
  412d04:	2000b4c8 	.word	0x2000b4c8
  412d08:	2000b4b4 	.word	0x2000b4b4

00412d0c <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
  412d0c:	b580      	push	{r7, lr}
  412d0e:	b086      	sub	sp, #24
  412d10:	af00      	add	r7, sp, #0
  412d12:	6078      	str	r0, [r7, #4]
  412d14:	6039      	str	r1, [r7, #0]
BaseType_t xReturn;

	configASSERT( pxTimeOut );
  412d16:	687b      	ldr	r3, [r7, #4]
  412d18:	2b00      	cmp	r3, #0
  412d1a:	d105      	bne.n	412d28 <xTaskCheckForTimeOut+0x1c>
  412d1c:	f640 42d7 	movw	r2, #3287	; 0xcd7
  412d20:	4924      	ldr	r1, [pc, #144]	; (412db4 <xTaskCheckForTimeOut+0xa8>)
  412d22:	4825      	ldr	r0, [pc, #148]	; (412db8 <xTaskCheckForTimeOut+0xac>)
  412d24:	4b25      	ldr	r3, [pc, #148]	; (412dbc <xTaskCheckForTimeOut+0xb0>)
  412d26:	4798      	blx	r3
	configASSERT( pxTicksToWait );
  412d28:	683b      	ldr	r3, [r7, #0]
  412d2a:	2b00      	cmp	r3, #0
  412d2c:	d105      	bne.n	412d3a <xTaskCheckForTimeOut+0x2e>
  412d2e:	f640 42d8 	movw	r2, #3288	; 0xcd8
  412d32:	4920      	ldr	r1, [pc, #128]	; (412db4 <xTaskCheckForTimeOut+0xa8>)
  412d34:	4820      	ldr	r0, [pc, #128]	; (412db8 <xTaskCheckForTimeOut+0xac>)
  412d36:	4b21      	ldr	r3, [pc, #132]	; (412dbc <xTaskCheckForTimeOut+0xb0>)
  412d38:	4798      	blx	r3

	taskENTER_CRITICAL();
  412d3a:	4b21      	ldr	r3, [pc, #132]	; (412dc0 <xTaskCheckForTimeOut+0xb4>)
  412d3c:	4798      	blx	r3
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
  412d3e:	4b21      	ldr	r3, [pc, #132]	; (412dc4 <xTaskCheckForTimeOut+0xb8>)
  412d40:	681b      	ldr	r3, [r3, #0]
  412d42:	613b      	str	r3, [r7, #16]
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
  412d44:	687b      	ldr	r3, [r7, #4]
  412d46:	685b      	ldr	r3, [r3, #4]
  412d48:	693a      	ldr	r2, [r7, #16]
  412d4a:	1ad3      	subs	r3, r2, r3
  412d4c:	60fb      	str	r3, [r7, #12]
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
  412d4e:	683b      	ldr	r3, [r7, #0]
  412d50:	681b      	ldr	r3, [r3, #0]
  412d52:	f1b3 3fff 	cmp.w	r3, #4294967295
  412d56:	d102      	bne.n	412d5e <xTaskCheckForTimeOut+0x52>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
  412d58:	2300      	movs	r3, #0
  412d5a:	617b      	str	r3, [r7, #20]
  412d5c:	e023      	b.n	412da6 <xTaskCheckForTimeOut+0x9a>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
  412d5e:	687b      	ldr	r3, [r7, #4]
  412d60:	681a      	ldr	r2, [r3, #0]
  412d62:	4b19      	ldr	r3, [pc, #100]	; (412dc8 <xTaskCheckForTimeOut+0xbc>)
  412d64:	681b      	ldr	r3, [r3, #0]
  412d66:	429a      	cmp	r2, r3
  412d68:	d007      	beq.n	412d7a <xTaskCheckForTimeOut+0x6e>
  412d6a:	687b      	ldr	r3, [r7, #4]
  412d6c:	685a      	ldr	r2, [r3, #4]
  412d6e:	693b      	ldr	r3, [r7, #16]
  412d70:	429a      	cmp	r2, r3
  412d72:	d802      	bhi.n	412d7a <xTaskCheckForTimeOut+0x6e>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
  412d74:	2301      	movs	r3, #1
  412d76:	617b      	str	r3, [r7, #20]
  412d78:	e015      	b.n	412da6 <xTaskCheckForTimeOut+0x9a>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
  412d7a:	683b      	ldr	r3, [r7, #0]
  412d7c:	681a      	ldr	r2, [r3, #0]
  412d7e:	68fb      	ldr	r3, [r7, #12]
  412d80:	429a      	cmp	r2, r3
  412d82:	d90b      	bls.n	412d9c <xTaskCheckForTimeOut+0x90>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
  412d84:	683b      	ldr	r3, [r7, #0]
  412d86:	681a      	ldr	r2, [r3, #0]
  412d88:	68fb      	ldr	r3, [r7, #12]
  412d8a:	1ad2      	subs	r2, r2, r3
  412d8c:	683b      	ldr	r3, [r7, #0]
  412d8e:	601a      	str	r2, [r3, #0]
			vTaskInternalSetTimeOutState( pxTimeOut );
  412d90:	6878      	ldr	r0, [r7, #4]
  412d92:	4b0e      	ldr	r3, [pc, #56]	; (412dcc <xTaskCheckForTimeOut+0xc0>)
  412d94:	4798      	blx	r3
			xReturn = pdFALSE;
  412d96:	2300      	movs	r3, #0
  412d98:	617b      	str	r3, [r7, #20]
  412d9a:	e004      	b.n	412da6 <xTaskCheckForTimeOut+0x9a>
		}
		else
		{
			*pxTicksToWait = 0;
  412d9c:	683b      	ldr	r3, [r7, #0]
  412d9e:	2200      	movs	r2, #0
  412da0:	601a      	str	r2, [r3, #0]
			xReturn = pdTRUE;
  412da2:	2301      	movs	r3, #1
  412da4:	617b      	str	r3, [r7, #20]
		}
	}
	taskEXIT_CRITICAL();
  412da6:	4b0a      	ldr	r3, [pc, #40]	; (412dd0 <xTaskCheckForTimeOut+0xc4>)
  412da8:	4798      	blx	r3

	return xReturn;
  412daa:	697b      	ldr	r3, [r7, #20]
}
  412dac:	4618      	mov	r0, r3
  412dae:	3718      	adds	r7, #24
  412db0:	46bd      	mov	sp, r7
  412db2:	bd80      	pop	{r7, pc}
  412db4:	0041e1f8 	.word	0x0041e1f8
  412db8:	0041e230 	.word	0x0041e230
  412dbc:	00416c7d 	.word	0x00416c7d
  412dc0:	0041103d 	.word	0x0041103d
  412dc4:	2000b4b4 	.word	0x2000b4b4
  412dc8:	2000b4c8 	.word	0x2000b4c8
  412dcc:	00412ce1 	.word	0x00412ce1
  412dd0:	00411099 	.word	0x00411099

00412dd4 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
  412dd4:	b480      	push	{r7}
  412dd6:	af00      	add	r7, sp, #0
	xYieldPending = pdTRUE;
  412dd8:	4b03      	ldr	r3, [pc, #12]	; (412de8 <vTaskMissedYield+0x14>)
  412dda:	2201      	movs	r2, #1
  412ddc:	601a      	str	r2, [r3, #0]
}
  412dde:	bf00      	nop
  412de0:	46bd      	mov	sp, r7
  412de2:	f85d 7b04 	ldr.w	r7, [sp], #4
  412de6:	4770      	bx	lr
  412de8:	2000b4c4 	.word	0x2000b4c4

00412dec <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
  412dec:	b580      	push	{r7, lr}
  412dee:	b082      	sub	sp, #8
  412df0:	af00      	add	r7, sp, #0
  412df2:	6078      	str	r0, [r7, #4]

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
  412df4:	4b06      	ldr	r3, [pc, #24]	; (412e10 <prvIdleTask+0x24>)
  412df6:	4798      	blx	r3
		{
			/* If we are not using preemption we keep forcing a task switch to
			see if any other task has become available.  If we are using
			preemption we don't need to do this as any task becoming available
			will automatically get the processor anyway. */
			taskYIELD();
  412df8:	4b06      	ldr	r3, [pc, #24]	; (412e14 <prvIdleTask+0x28>)
  412dfa:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  412dfe:	601a      	str	r2, [r3, #0]
  412e00:	f3bf 8f4f 	dsb	sy
  412e04:	f3bf 8f6f 	isb	sy
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
  412e08:	4b03      	ldr	r3, [pc, #12]	; (412e18 <prvIdleTask+0x2c>)
  412e0a:	4798      	blx	r3
		prvCheckTasksWaitingTermination();
  412e0c:	e7f2      	b.n	412df4 <prvIdleTask+0x8>
  412e0e:	bf00      	nop
  412e10:	00412e95 	.word	0x00412e95
  412e14:	e000ed04 	.word	0xe000ed04
  412e18:	00416289 	.word	0x00416289

00412e1c <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
  412e1c:	b580      	push	{r7, lr}
  412e1e:	b082      	sub	sp, #8
  412e20:	af00      	add	r7, sp, #0
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
  412e22:	2300      	movs	r3, #0
  412e24:	607b      	str	r3, [r7, #4]
  412e26:	e00c      	b.n	412e42 <prvInitialiseTaskLists+0x26>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
  412e28:	687a      	ldr	r2, [r7, #4]
  412e2a:	4613      	mov	r3, r2
  412e2c:	009b      	lsls	r3, r3, #2
  412e2e:	4413      	add	r3, r2
  412e30:	009b      	lsls	r3, r3, #2
  412e32:	4a10      	ldr	r2, [pc, #64]	; (412e74 <prvInitialiseTaskLists+0x58>)
  412e34:	4413      	add	r3, r2
  412e36:	4618      	mov	r0, r3
  412e38:	4b0f      	ldr	r3, [pc, #60]	; (412e78 <prvInitialiseTaskLists+0x5c>)
  412e3a:	4798      	blx	r3
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
  412e3c:	687b      	ldr	r3, [r7, #4]
  412e3e:	3301      	adds	r3, #1
  412e40:	607b      	str	r3, [r7, #4]
  412e42:	687b      	ldr	r3, [r7, #4]
  412e44:	2b03      	cmp	r3, #3
  412e46:	d9ef      	bls.n	412e28 <prvInitialiseTaskLists+0xc>
	}

	vListInitialise( &xDelayedTaskList1 );
  412e48:	480c      	ldr	r0, [pc, #48]	; (412e7c <prvInitialiseTaskLists+0x60>)
  412e4a:	4b0b      	ldr	r3, [pc, #44]	; (412e78 <prvInitialiseTaskLists+0x5c>)
  412e4c:	4798      	blx	r3
	vListInitialise( &xDelayedTaskList2 );
  412e4e:	480c      	ldr	r0, [pc, #48]	; (412e80 <prvInitialiseTaskLists+0x64>)
  412e50:	4b09      	ldr	r3, [pc, #36]	; (412e78 <prvInitialiseTaskLists+0x5c>)
  412e52:	4798      	blx	r3
	vListInitialise( &xPendingReadyList );
  412e54:	480b      	ldr	r0, [pc, #44]	; (412e84 <prvInitialiseTaskLists+0x68>)
  412e56:	4b08      	ldr	r3, [pc, #32]	; (412e78 <prvInitialiseTaskLists+0x5c>)
  412e58:	4798      	blx	r3
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
  412e5a:	480b      	ldr	r0, [pc, #44]	; (412e88 <prvInitialiseTaskLists+0x6c>)
  412e5c:	4b06      	ldr	r3, [pc, #24]	; (412e78 <prvInitialiseTaskLists+0x5c>)
  412e5e:	4798      	blx	r3
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
  412e60:	4b0a      	ldr	r3, [pc, #40]	; (412e8c <prvInitialiseTaskLists+0x70>)
  412e62:	4a06      	ldr	r2, [pc, #24]	; (412e7c <prvInitialiseTaskLists+0x60>)
  412e64:	601a      	str	r2, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
  412e66:	4b0a      	ldr	r3, [pc, #40]	; (412e90 <prvInitialiseTaskLists+0x74>)
  412e68:	4a05      	ldr	r2, [pc, #20]	; (412e80 <prvInitialiseTaskLists+0x64>)
  412e6a:	601a      	str	r2, [r3, #0]
}
  412e6c:	bf00      	nop
  412e6e:	3708      	adds	r7, #8
  412e70:	46bd      	mov	sp, r7
  412e72:	bd80      	pop	{r7, pc}
  412e74:	2000b408 	.word	0x2000b408
  412e78:	00410ce1 	.word	0x00410ce1
  412e7c:	2000b458 	.word	0x2000b458
  412e80:	2000b46c 	.word	0x2000b46c
  412e84:	2000b488 	.word	0x2000b488
  412e88:	2000b49c 	.word	0x2000b49c
  412e8c:	2000b480 	.word	0x2000b480
  412e90:	2000b484 	.word	0x2000b484

00412e94 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
  412e94:	b480      	push	{r7}
  412e96:	af00      	add	r7, sp, #0

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
  412e98:	bf00      	nop
  412e9a:	46bd      	mov	sp, r7
  412e9c:	f85d 7b04 	ldr.w	r7, [sp], #4
  412ea0:	4770      	bx	lr
	...

00412ea4 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
  412ea4:	b480      	push	{r7}
  412ea6:	b083      	sub	sp, #12
  412ea8:	af00      	add	r7, sp, #0
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
  412eaa:	4b0c      	ldr	r3, [pc, #48]	; (412edc <prvResetNextTaskUnblockTime+0x38>)
  412eac:	681b      	ldr	r3, [r3, #0]
  412eae:	681b      	ldr	r3, [r3, #0]
  412eb0:	2b00      	cmp	r3, #0
  412eb2:	d104      	bne.n	412ebe <prvResetNextTaskUnblockTime+0x1a>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
  412eb4:	4b0a      	ldr	r3, [pc, #40]	; (412ee0 <prvResetNextTaskUnblockTime+0x3c>)
  412eb6:	f04f 32ff 	mov.w	r2, #4294967295
  412eba:	601a      	str	r2, [r3, #0]
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
	}
}
  412ebc:	e008      	b.n	412ed0 <prvResetNextTaskUnblockTime+0x2c>
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
  412ebe:	4b07      	ldr	r3, [pc, #28]	; (412edc <prvResetNextTaskUnblockTime+0x38>)
  412ec0:	681b      	ldr	r3, [r3, #0]
  412ec2:	68db      	ldr	r3, [r3, #12]
  412ec4:	68db      	ldr	r3, [r3, #12]
  412ec6:	607b      	str	r3, [r7, #4]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
  412ec8:	687b      	ldr	r3, [r7, #4]
  412eca:	685b      	ldr	r3, [r3, #4]
  412ecc:	4a04      	ldr	r2, [pc, #16]	; (412ee0 <prvResetNextTaskUnblockTime+0x3c>)
  412ece:	6013      	str	r3, [r2, #0]
}
  412ed0:	bf00      	nop
  412ed2:	370c      	adds	r7, #12
  412ed4:	46bd      	mov	sp, r7
  412ed6:	f85d 7b04 	ldr.w	r7, [sp], #4
  412eda:	4770      	bx	lr
  412edc:	2000b480 	.word	0x2000b480
  412ee0:	2000b4d0 	.word	0x2000b4d0

00412ee4 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
  412ee4:	b480      	push	{r7}
  412ee6:	b083      	sub	sp, #12
  412ee8:	af00      	add	r7, sp, #0
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
  412eea:	4b05      	ldr	r3, [pc, #20]	; (412f00 <xTaskGetCurrentTaskHandle+0x1c>)
  412eec:	681b      	ldr	r3, [r3, #0]
  412eee:	607b      	str	r3, [r7, #4]

		return xReturn;
  412ef0:	687b      	ldr	r3, [r7, #4]
	}
  412ef2:	4618      	mov	r0, r3
  412ef4:	370c      	adds	r7, #12
  412ef6:	46bd      	mov	sp, r7
  412ef8:	f85d 7b04 	ldr.w	r7, [sp], #4
  412efc:	4770      	bx	lr
  412efe:	bf00      	nop
  412f00:	2000b404 	.word	0x2000b404

00412f04 <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
  412f04:	b580      	push	{r7, lr}
  412f06:	b084      	sub	sp, #16
  412f08:	af00      	add	r7, sp, #0
  412f0a:	6078      	str	r0, [r7, #4]
	TCB_t * const pxMutexHolderTCB = pxMutexHolder;
  412f0c:	687b      	ldr	r3, [r7, #4]
  412f0e:	60bb      	str	r3, [r7, #8]
	BaseType_t xReturn = pdFALSE;
  412f10:	2300      	movs	r3, #0
  412f12:	60fb      	str	r3, [r7, #12]

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL.  _RB_ Is this still
		needed as interrupts can no longer use mutexes? */
		if( pxMutexHolder != NULL )
  412f14:	687b      	ldr	r3, [r7, #4]
  412f16:	2b00      	cmp	r3, #0
  412f18:	d05e      	beq.n	412fd8 <xTaskPriorityInherit+0xd4>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
  412f1a:	68bb      	ldr	r3, [r7, #8]
  412f1c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  412f1e:	4b31      	ldr	r3, [pc, #196]	; (412fe4 <xTaskPriorityInherit+0xe0>)
  412f20:	681b      	ldr	r3, [r3, #0]
  412f22:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  412f24:	429a      	cmp	r2, r3
  412f26:	d24e      	bcs.n	412fc6 <xTaskPriorityInherit+0xc2>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
  412f28:	68bb      	ldr	r3, [r7, #8]
  412f2a:	699b      	ldr	r3, [r3, #24]
  412f2c:	2b00      	cmp	r3, #0
  412f2e:	db06      	blt.n	412f3e <xTaskPriorityInherit+0x3a>
				{
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  412f30:	4b2c      	ldr	r3, [pc, #176]	; (412fe4 <xTaskPriorityInherit+0xe0>)
  412f32:	681b      	ldr	r3, [r3, #0]
  412f34:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  412f36:	f1c3 0204 	rsb	r2, r3, #4
  412f3a:	68bb      	ldr	r3, [r7, #8]
  412f3c:	619a      	str	r2, [r3, #24]
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
  412f3e:	68bb      	ldr	r3, [r7, #8]
  412f40:	6959      	ldr	r1, [r3, #20]
  412f42:	68bb      	ldr	r3, [r7, #8]
  412f44:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  412f46:	4613      	mov	r3, r2
  412f48:	009b      	lsls	r3, r3, #2
  412f4a:	4413      	add	r3, r2
  412f4c:	009b      	lsls	r3, r3, #2
  412f4e:	4a26      	ldr	r2, [pc, #152]	; (412fe8 <xTaskPriorityInherit+0xe4>)
  412f50:	4413      	add	r3, r2
  412f52:	4299      	cmp	r1, r3
  412f54:	d12f      	bne.n	412fb6 <xTaskPriorityInherit+0xb2>
				{
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  412f56:	68bb      	ldr	r3, [r7, #8]
  412f58:	3304      	adds	r3, #4
  412f5a:	4618      	mov	r0, r3
  412f5c:	4b23      	ldr	r3, [pc, #140]	; (412fec <xTaskPriorityInherit+0xe8>)
  412f5e:	4798      	blx	r3
  412f60:	4603      	mov	r3, r0
  412f62:	2b00      	cmp	r3, #0
  412f64:	d10a      	bne.n	412f7c <xTaskPriorityInherit+0x78>
					{
						/* It is known that the task is in its ready list so
						there is no need to check again and the port level
						reset macro can be called directly. */
						portRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority, uxTopReadyPriority );
  412f66:	68bb      	ldr	r3, [r7, #8]
  412f68:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  412f6a:	2201      	movs	r2, #1
  412f6c:	fa02 f303 	lsl.w	r3, r2, r3
  412f70:	43da      	mvns	r2, r3
  412f72:	4b1f      	ldr	r3, [pc, #124]	; (412ff0 <xTaskPriorityInherit+0xec>)
  412f74:	681b      	ldr	r3, [r3, #0]
  412f76:	4013      	ands	r3, r2
  412f78:	4a1d      	ldr	r2, [pc, #116]	; (412ff0 <xTaskPriorityInherit+0xec>)
  412f7a:	6013      	str	r3, [r2, #0]
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
  412f7c:	4b19      	ldr	r3, [pc, #100]	; (412fe4 <xTaskPriorityInherit+0xe0>)
  412f7e:	681b      	ldr	r3, [r3, #0]
  412f80:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  412f82:	68bb      	ldr	r3, [r7, #8]
  412f84:	62da      	str	r2, [r3, #44]	; 0x2c
					prvAddTaskToReadyList( pxMutexHolderTCB );
  412f86:	68bb      	ldr	r3, [r7, #8]
  412f88:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  412f8a:	2201      	movs	r2, #1
  412f8c:	409a      	lsls	r2, r3
  412f8e:	4b18      	ldr	r3, [pc, #96]	; (412ff0 <xTaskPriorityInherit+0xec>)
  412f90:	681b      	ldr	r3, [r3, #0]
  412f92:	4313      	orrs	r3, r2
  412f94:	4a16      	ldr	r2, [pc, #88]	; (412ff0 <xTaskPriorityInherit+0xec>)
  412f96:	6013      	str	r3, [r2, #0]
  412f98:	68bb      	ldr	r3, [r7, #8]
  412f9a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  412f9c:	4613      	mov	r3, r2
  412f9e:	009b      	lsls	r3, r3, #2
  412fa0:	4413      	add	r3, r2
  412fa2:	009b      	lsls	r3, r3, #2
  412fa4:	4a10      	ldr	r2, [pc, #64]	; (412fe8 <xTaskPriorityInherit+0xe4>)
  412fa6:	441a      	add	r2, r3
  412fa8:	68bb      	ldr	r3, [r7, #8]
  412faa:	3304      	adds	r3, #4
  412fac:	4619      	mov	r1, r3
  412fae:	4610      	mov	r0, r2
  412fb0:	4b10      	ldr	r3, [pc, #64]	; (412ff4 <xTaskPriorityInherit+0xf0>)
  412fb2:	4798      	blx	r3
  412fb4:	e004      	b.n	412fc0 <xTaskPriorityInherit+0xbc>
				}
				else
				{
					/* Just inherit the priority. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
  412fb6:	4b0b      	ldr	r3, [pc, #44]	; (412fe4 <xTaskPriorityInherit+0xe0>)
  412fb8:	681b      	ldr	r3, [r3, #0]
  412fba:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  412fbc:	68bb      	ldr	r3, [r7, #8]
  412fbe:	62da      	str	r2, [r3, #44]	; 0x2c
				}

				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

				/* Inheritance occurred. */
				xReturn = pdTRUE;
  412fc0:	2301      	movs	r3, #1
  412fc2:	60fb      	str	r3, [r7, #12]
  412fc4:	e008      	b.n	412fd8 <xTaskPriorityInherit+0xd4>
			}
			else
			{
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
  412fc6:	68bb      	ldr	r3, [r7, #8]
  412fc8:	6c9a      	ldr	r2, [r3, #72]	; 0x48
  412fca:	4b06      	ldr	r3, [pc, #24]	; (412fe4 <xTaskPriorityInherit+0xe0>)
  412fcc:	681b      	ldr	r3, [r3, #0]
  412fce:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  412fd0:	429a      	cmp	r2, r3
  412fd2:	d201      	bcs.n	412fd8 <xTaskPriorityInherit+0xd4>
					current priority of the mutex holder is not lower than the
					priority of the task attempting to take the mutex.
					Therefore the mutex holder must have already inherited a
					priority, but inheritance would have occurred if that had
					not been the case. */
					xReturn = pdTRUE;
  412fd4:	2301      	movs	r3, #1
  412fd6:	60fb      	str	r3, [r7, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
  412fd8:	68fb      	ldr	r3, [r7, #12]
	}
  412fda:	4618      	mov	r0, r3
  412fdc:	3710      	adds	r7, #16
  412fde:	46bd      	mov	sp, r7
  412fe0:	bd80      	pop	{r7, pc}
  412fe2:	bf00      	nop
  412fe4:	2000b404 	.word	0x2000b404
  412fe8:	2000b408 	.word	0x2000b408
  412fec:	00410df5 	.word	0x00410df5
  412ff0:	2000b4b8 	.word	0x2000b4b8
  412ff4:	00410d3b 	.word	0x00410d3b

00412ff8 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
  412ff8:	b580      	push	{r7, lr}
  412ffa:	b084      	sub	sp, #16
  412ffc:	af00      	add	r7, sp, #0
  412ffe:	6078      	str	r0, [r7, #4]
	TCB_t * const pxTCB = pxMutexHolder;
  413000:	687b      	ldr	r3, [r7, #4]
  413002:	60bb      	str	r3, [r7, #8]
	BaseType_t xReturn = pdFALSE;
  413004:	2300      	movs	r3, #0
  413006:	60fb      	str	r3, [r7, #12]

		if( pxMutexHolder != NULL )
  413008:	687b      	ldr	r3, [r7, #4]
  41300a:	2b00      	cmp	r3, #0
  41300c:	d064      	beq.n	4130d8 <xTaskPriorityDisinherit+0xe0>
		{
			/* A task can only have an inherited priority if it holds the mutex.
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
  41300e:	4b35      	ldr	r3, [pc, #212]	; (4130e4 <xTaskPriorityDisinherit+0xec>)
  413010:	681b      	ldr	r3, [r3, #0]
  413012:	68ba      	ldr	r2, [r7, #8]
  413014:	429a      	cmp	r2, r3
  413016:	d005      	beq.n	413024 <xTaskPriorityDisinherit+0x2c>
  413018:	f241 021c 	movw	r2, #4124	; 0x101c
  41301c:	4932      	ldr	r1, [pc, #200]	; (4130e8 <xTaskPriorityDisinherit+0xf0>)
  41301e:	4833      	ldr	r0, [pc, #204]	; (4130ec <xTaskPriorityDisinherit+0xf4>)
  413020:	4b33      	ldr	r3, [pc, #204]	; (4130f0 <xTaskPriorityDisinherit+0xf8>)
  413022:	4798      	blx	r3
			configASSERT( pxTCB->uxMutexesHeld );
  413024:	68bb      	ldr	r3, [r7, #8]
  413026:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
  413028:	2b00      	cmp	r3, #0
  41302a:	d105      	bne.n	413038 <xTaskPriorityDisinherit+0x40>
  41302c:	f241 021d 	movw	r2, #4125	; 0x101d
  413030:	492d      	ldr	r1, [pc, #180]	; (4130e8 <xTaskPriorityDisinherit+0xf0>)
  413032:	482e      	ldr	r0, [pc, #184]	; (4130ec <xTaskPriorityDisinherit+0xf4>)
  413034:	4b2e      	ldr	r3, [pc, #184]	; (4130f0 <xTaskPriorityDisinherit+0xf8>)
  413036:	4798      	blx	r3
			( pxTCB->uxMutexesHeld )--;
  413038:	68bb      	ldr	r3, [r7, #8]
  41303a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
  41303c:	1e5a      	subs	r2, r3, #1
  41303e:	68bb      	ldr	r3, [r7, #8]
  413040:	64da      	str	r2, [r3, #76]	; 0x4c

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
  413042:	68bb      	ldr	r3, [r7, #8]
  413044:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  413046:	68bb      	ldr	r3, [r7, #8]
  413048:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  41304a:	429a      	cmp	r2, r3
  41304c:	d044      	beq.n	4130d8 <xTaskPriorityDisinherit+0xe0>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
  41304e:	68bb      	ldr	r3, [r7, #8]
  413050:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
  413052:	2b00      	cmp	r3, #0
  413054:	d140      	bne.n	4130d8 <xTaskPriorityDisinherit+0xe0>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding task then it must be the running state task.  Remove
					the holding task from the ready/delayed list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  413056:	68bb      	ldr	r3, [r7, #8]
  413058:	3304      	adds	r3, #4
  41305a:	4618      	mov	r0, r3
  41305c:	4b25      	ldr	r3, [pc, #148]	; (4130f4 <xTaskPriorityDisinherit+0xfc>)
  41305e:	4798      	blx	r3
  413060:	4603      	mov	r3, r0
  413062:	2b00      	cmp	r3, #0
  413064:	d115      	bne.n	413092 <xTaskPriorityDisinherit+0x9a>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
  413066:	68bb      	ldr	r3, [r7, #8]
  413068:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  41306a:	4923      	ldr	r1, [pc, #140]	; (4130f8 <xTaskPriorityDisinherit+0x100>)
  41306c:	4613      	mov	r3, r2
  41306e:	009b      	lsls	r3, r3, #2
  413070:	4413      	add	r3, r2
  413072:	009b      	lsls	r3, r3, #2
  413074:	440b      	add	r3, r1
  413076:	681b      	ldr	r3, [r3, #0]
  413078:	2b00      	cmp	r3, #0
  41307a:	d10a      	bne.n	413092 <xTaskPriorityDisinherit+0x9a>
  41307c:	68bb      	ldr	r3, [r7, #8]
  41307e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  413080:	2201      	movs	r2, #1
  413082:	fa02 f303 	lsl.w	r3, r2, r3
  413086:	43da      	mvns	r2, r3
  413088:	4b1c      	ldr	r3, [pc, #112]	; (4130fc <xTaskPriorityDisinherit+0x104>)
  41308a:	681b      	ldr	r3, [r3, #0]
  41308c:	4013      	ands	r3, r2
  41308e:	4a1b      	ldr	r2, [pc, #108]	; (4130fc <xTaskPriorityDisinherit+0x104>)
  413090:	6013      	str	r3, [r2, #0]
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
  413092:	68bb      	ldr	r3, [r7, #8]
  413094:	6c9a      	ldr	r2, [r3, #72]	; 0x48
  413096:	68bb      	ldr	r3, [r7, #8]
  413098:	62da      	str	r2, [r3, #44]	; 0x2c

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  41309a:	68bb      	ldr	r3, [r7, #8]
  41309c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  41309e:	f1c3 0204 	rsb	r2, r3, #4
  4130a2:	68bb      	ldr	r3, [r7, #8]
  4130a4:	619a      	str	r2, [r3, #24]
					prvAddTaskToReadyList( pxTCB );
  4130a6:	68bb      	ldr	r3, [r7, #8]
  4130a8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  4130aa:	2201      	movs	r2, #1
  4130ac:	409a      	lsls	r2, r3
  4130ae:	4b13      	ldr	r3, [pc, #76]	; (4130fc <xTaskPriorityDisinherit+0x104>)
  4130b0:	681b      	ldr	r3, [r3, #0]
  4130b2:	4313      	orrs	r3, r2
  4130b4:	4a11      	ldr	r2, [pc, #68]	; (4130fc <xTaskPriorityDisinherit+0x104>)
  4130b6:	6013      	str	r3, [r2, #0]
  4130b8:	68bb      	ldr	r3, [r7, #8]
  4130ba:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  4130bc:	4613      	mov	r3, r2
  4130be:	009b      	lsls	r3, r3, #2
  4130c0:	4413      	add	r3, r2
  4130c2:	009b      	lsls	r3, r3, #2
  4130c4:	4a0c      	ldr	r2, [pc, #48]	; (4130f8 <xTaskPriorityDisinherit+0x100>)
  4130c6:	441a      	add	r2, r3
  4130c8:	68bb      	ldr	r3, [r7, #8]
  4130ca:	3304      	adds	r3, #4
  4130cc:	4619      	mov	r1, r3
  4130ce:	4610      	mov	r0, r2
  4130d0:	4b0b      	ldr	r3, [pc, #44]	; (413100 <xTaskPriorityDisinherit+0x108>)
  4130d2:	4798      	blx	r3
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
  4130d4:	2301      	movs	r3, #1
  4130d6:	60fb      	str	r3, [r7, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
  4130d8:	68fb      	ldr	r3, [r7, #12]
	}
  4130da:	4618      	mov	r0, r3
  4130dc:	3710      	adds	r7, #16
  4130de:	46bd      	mov	sp, r7
  4130e0:	bd80      	pop	{r7, pc}
  4130e2:	bf00      	nop
  4130e4:	2000b404 	.word	0x2000b404
  4130e8:	0041e1f8 	.word	0x0041e1f8
  4130ec:	0041e230 	.word	0x0041e230
  4130f0:	00416c7d 	.word	0x00416c7d
  4130f4:	00410df5 	.word	0x00410df5
  4130f8:	2000b408 	.word	0x2000b408
  4130fc:	2000b4b8 	.word	0x2000b4b8
  413100:	00410d3b 	.word	0x00410d3b

00413104 <vTaskPriorityDisinheritAfterTimeout>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask )
	{
  413104:	b580      	push	{r7, lr}
  413106:	b086      	sub	sp, #24
  413108:	af00      	add	r7, sp, #0
  41310a:	6078      	str	r0, [r7, #4]
  41310c:	6039      	str	r1, [r7, #0]
	TCB_t * const pxTCB = pxMutexHolder;
  41310e:	687b      	ldr	r3, [r7, #4]
  413110:	613b      	str	r3, [r7, #16]
	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
  413112:	2301      	movs	r3, #1
  413114:	60fb      	str	r3, [r7, #12]

		if( pxMutexHolder != NULL )
  413116:	687b      	ldr	r3, [r7, #4]
  413118:	2b00      	cmp	r3, #0
  41311a:	d06d      	beq.n	4131f8 <vTaskPriorityDisinheritAfterTimeout+0xf4>
		{
			/* If pxMutexHolder is not NULL then the holder must hold at least
			one mutex. */
			configASSERT( pxTCB->uxMutexesHeld );
  41311c:	693b      	ldr	r3, [r7, #16]
  41311e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
  413120:	2b00      	cmp	r3, #0
  413122:	d105      	bne.n	413130 <vTaskPriorityDisinheritAfterTimeout+0x2c>
  413124:	f241 026b 	movw	r2, #4203	; 0x106b
  413128:	4935      	ldr	r1, [pc, #212]	; (413200 <vTaskPriorityDisinheritAfterTimeout+0xfc>)
  41312a:	4836      	ldr	r0, [pc, #216]	; (413204 <vTaskPriorityDisinheritAfterTimeout+0x100>)
  41312c:	4b36      	ldr	r3, [pc, #216]	; (413208 <vTaskPriorityDisinheritAfterTimeout+0x104>)
  41312e:	4798      	blx	r3

			/* Determine the priority to which the priority of the task that
			holds the mutex should be set.  This will be the greater of the
			holding task's base priority and the priority of the highest
			priority task that is waiting to obtain the mutex. */
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
  413130:	693b      	ldr	r3, [r7, #16]
  413132:	6c9a      	ldr	r2, [r3, #72]	; 0x48
  413134:	683b      	ldr	r3, [r7, #0]
  413136:	429a      	cmp	r2, r3
  413138:	d202      	bcs.n	413140 <vTaskPriorityDisinheritAfterTimeout+0x3c>
			{
				uxPriorityToUse = uxHighestPriorityWaitingTask;
  41313a:	683b      	ldr	r3, [r7, #0]
  41313c:	617b      	str	r3, [r7, #20]
  41313e:	e002      	b.n	413146 <vTaskPriorityDisinheritAfterTimeout+0x42>
			}
			else
			{
				uxPriorityToUse = pxTCB->uxBasePriority;
  413140:	693b      	ldr	r3, [r7, #16]
  413142:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  413144:	617b      	str	r3, [r7, #20]
			}

			/* Does the priority need to change? */
			if( pxTCB->uxPriority != uxPriorityToUse )
  413146:	693b      	ldr	r3, [r7, #16]
  413148:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  41314a:	697b      	ldr	r3, [r7, #20]
  41314c:	429a      	cmp	r2, r3
  41314e:	d053      	beq.n	4131f8 <vTaskPriorityDisinheritAfterTimeout+0xf4>
			{
				/* Only disinherit if no other mutexes are held.  This is a
				simplification in the priority inheritance implementation.  If
				the task that holds the mutex is also holding other mutexes then
				the other mutexes may have caused the priority inheritance. */
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
  413150:	693b      	ldr	r3, [r7, #16]
  413152:	6cda      	ldr	r2, [r3, #76]	; 0x4c
  413154:	68fb      	ldr	r3, [r7, #12]
  413156:	429a      	cmp	r2, r3
  413158:	d14e      	bne.n	4131f8 <vTaskPriorityDisinheritAfterTimeout+0xf4>
				{
					/* If a task has timed out because it already holds the
					mutex it was trying to obtain then it cannot of inherited
					its own priority. */
					configASSERT( pxTCB != pxCurrentTCB );
  41315a:	4b2c      	ldr	r3, [pc, #176]	; (41320c <vTaskPriorityDisinheritAfterTimeout+0x108>)
  41315c:	681b      	ldr	r3, [r3, #0]
  41315e:	693a      	ldr	r2, [r7, #16]
  413160:	429a      	cmp	r2, r3
  413162:	d105      	bne.n	413170 <vTaskPriorityDisinheritAfterTimeout+0x6c>
  413164:	f241 0286 	movw	r2, #4230	; 0x1086
  413168:	4925      	ldr	r1, [pc, #148]	; (413200 <vTaskPriorityDisinheritAfterTimeout+0xfc>)
  41316a:	4826      	ldr	r0, [pc, #152]	; (413204 <vTaskPriorityDisinheritAfterTimeout+0x100>)
  41316c:	4b26      	ldr	r3, [pc, #152]	; (413208 <vTaskPriorityDisinheritAfterTimeout+0x104>)
  41316e:	4798      	blx	r3

					/* Disinherit the priority, remembering the previous
					priority to facilitate determining the subject task's
					state. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					uxPriorityUsedOnEntry = pxTCB->uxPriority;
  413170:	693b      	ldr	r3, [r7, #16]
  413172:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  413174:	60bb      	str	r3, [r7, #8]
					pxTCB->uxPriority = uxPriorityToUse;
  413176:	693b      	ldr	r3, [r7, #16]
  413178:	697a      	ldr	r2, [r7, #20]
  41317a:	62da      	str	r2, [r3, #44]	; 0x2c

					/* Only reset the event list item value if the value is not
					being used for anything else. */
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
  41317c:	693b      	ldr	r3, [r7, #16]
  41317e:	699b      	ldr	r3, [r3, #24]
  413180:	2b00      	cmp	r3, #0
  413182:	db04      	blt.n	41318e <vTaskPriorityDisinheritAfterTimeout+0x8a>
					{
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  413184:	697b      	ldr	r3, [r7, #20]
  413186:	f1c3 0204 	rsb	r2, r3, #4
  41318a:	693b      	ldr	r3, [r7, #16]
  41318c:	619a      	str	r2, [r3, #24]
					then the task that holds the mutex could be in either the
					Ready, Blocked or Suspended states.  Only remove the task
					from its current state list if it is in the Ready state as
					the task's priority is going to change and there is one
					Ready list per priority. */
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
  41318e:	693b      	ldr	r3, [r7, #16]
  413190:	6959      	ldr	r1, [r3, #20]
  413192:	68ba      	ldr	r2, [r7, #8]
  413194:	4613      	mov	r3, r2
  413196:	009b      	lsls	r3, r3, #2
  413198:	4413      	add	r3, r2
  41319a:	009b      	lsls	r3, r3, #2
  41319c:	4a1c      	ldr	r2, [pc, #112]	; (413210 <vTaskPriorityDisinheritAfterTimeout+0x10c>)
  41319e:	4413      	add	r3, r2
  4131a0:	4299      	cmp	r1, r3
  4131a2:	d129      	bne.n	4131f8 <vTaskPriorityDisinheritAfterTimeout+0xf4>
					{
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  4131a4:	693b      	ldr	r3, [r7, #16]
  4131a6:	3304      	adds	r3, #4
  4131a8:	4618      	mov	r0, r3
  4131aa:	4b1a      	ldr	r3, [pc, #104]	; (413214 <vTaskPriorityDisinheritAfterTimeout+0x110>)
  4131ac:	4798      	blx	r3
  4131ae:	4603      	mov	r3, r0
  4131b0:	2b00      	cmp	r3, #0
  4131b2:	d10a      	bne.n	4131ca <vTaskPriorityDisinheritAfterTimeout+0xc6>
						{
							/* It is known that the task is in its ready list so
							there is no need to check again and the port level
							reset macro can be called directly. */
							portRESET_READY_PRIORITY( pxTCB->uxPriority, uxTopReadyPriority );
  4131b4:	693b      	ldr	r3, [r7, #16]
  4131b6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  4131b8:	2201      	movs	r2, #1
  4131ba:	fa02 f303 	lsl.w	r3, r2, r3
  4131be:	43da      	mvns	r2, r3
  4131c0:	4b15      	ldr	r3, [pc, #84]	; (413218 <vTaskPriorityDisinheritAfterTimeout+0x114>)
  4131c2:	681b      	ldr	r3, [r3, #0]
  4131c4:	4013      	ands	r3, r2
  4131c6:	4a14      	ldr	r2, [pc, #80]	; (413218 <vTaskPriorityDisinheritAfterTimeout+0x114>)
  4131c8:	6013      	str	r3, [r2, #0]
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}

						prvAddTaskToReadyList( pxTCB );
  4131ca:	693b      	ldr	r3, [r7, #16]
  4131cc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  4131ce:	2201      	movs	r2, #1
  4131d0:	409a      	lsls	r2, r3
  4131d2:	4b11      	ldr	r3, [pc, #68]	; (413218 <vTaskPriorityDisinheritAfterTimeout+0x114>)
  4131d4:	681b      	ldr	r3, [r3, #0]
  4131d6:	4313      	orrs	r3, r2
  4131d8:	4a0f      	ldr	r2, [pc, #60]	; (413218 <vTaskPriorityDisinheritAfterTimeout+0x114>)
  4131da:	6013      	str	r3, [r2, #0]
  4131dc:	693b      	ldr	r3, [r7, #16]
  4131de:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  4131e0:	4613      	mov	r3, r2
  4131e2:	009b      	lsls	r3, r3, #2
  4131e4:	4413      	add	r3, r2
  4131e6:	009b      	lsls	r3, r3, #2
  4131e8:	4a09      	ldr	r2, [pc, #36]	; (413210 <vTaskPriorityDisinheritAfterTimeout+0x10c>)
  4131ea:	441a      	add	r2, r3
  4131ec:	693b      	ldr	r3, [r7, #16]
  4131ee:	3304      	adds	r3, #4
  4131f0:	4619      	mov	r1, r3
  4131f2:	4610      	mov	r0, r2
  4131f4:	4b09      	ldr	r3, [pc, #36]	; (41321c <vTaskPriorityDisinheritAfterTimeout+0x118>)
  4131f6:	4798      	blx	r3
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
  4131f8:	bf00      	nop
  4131fa:	3718      	adds	r7, #24
  4131fc:	46bd      	mov	sp, r7
  4131fe:	bd80      	pop	{r7, pc}
  413200:	0041e1f8 	.word	0x0041e1f8
  413204:	0041e230 	.word	0x0041e230
  413208:	00416c7d 	.word	0x00416c7d
  41320c:	2000b404 	.word	0x2000b404
  413210:	2000b408 	.word	0x2000b408
  413214:	00410df5 	.word	0x00410df5
  413218:	2000b4b8 	.word	0x2000b4b8
  41321c:	00410d3b 	.word	0x00410d3b

00413220 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
  413220:	b480      	push	{r7}
  413222:	b083      	sub	sp, #12
  413224:	af00      	add	r7, sp, #0
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
  413226:	4b09      	ldr	r3, [pc, #36]	; (41324c <uxTaskResetEventItemValue+0x2c>)
  413228:	681b      	ldr	r3, [r3, #0]
  41322a:	699b      	ldr	r3, [r3, #24]
  41322c:	607b      	str	r3, [r7, #4]

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  41322e:	4b07      	ldr	r3, [pc, #28]	; (41324c <uxTaskResetEventItemValue+0x2c>)
  413230:	681b      	ldr	r3, [r3, #0]
  413232:	4a06      	ldr	r2, [pc, #24]	; (41324c <uxTaskResetEventItemValue+0x2c>)
  413234:	6812      	ldr	r2, [r2, #0]
  413236:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
  413238:	f1c2 0204 	rsb	r2, r2, #4
  41323c:	619a      	str	r2, [r3, #24]

	return uxReturn;
  41323e:	687b      	ldr	r3, [r7, #4]
}
  413240:	4618      	mov	r0, r3
  413242:	370c      	adds	r7, #12
  413244:	46bd      	mov	sp, r7
  413246:	f85d 7b04 	ldr.w	r7, [sp], #4
  41324a:	4770      	bx	lr
  41324c:	2000b404 	.word	0x2000b404

00413250 <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	TaskHandle_t pvTaskIncrementMutexHeldCount( void )
	{
  413250:	b480      	push	{r7}
  413252:	af00      	add	r7, sp, #0
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
  413254:	4b07      	ldr	r3, [pc, #28]	; (413274 <pvTaskIncrementMutexHeldCount+0x24>)
  413256:	681b      	ldr	r3, [r3, #0]
  413258:	2b00      	cmp	r3, #0
  41325a:	d004      	beq.n	413266 <pvTaskIncrementMutexHeldCount+0x16>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
  41325c:	4b05      	ldr	r3, [pc, #20]	; (413274 <pvTaskIncrementMutexHeldCount+0x24>)
  41325e:	681b      	ldr	r3, [r3, #0]
  413260:	6cda      	ldr	r2, [r3, #76]	; 0x4c
  413262:	3201      	adds	r2, #1
  413264:	64da      	str	r2, [r3, #76]	; 0x4c
		}

		return pxCurrentTCB;
  413266:	4b03      	ldr	r3, [pc, #12]	; (413274 <pvTaskIncrementMutexHeldCount+0x24>)
  413268:	681b      	ldr	r3, [r3, #0]
	}
  41326a:	4618      	mov	r0, r3
  41326c:	46bd      	mov	sp, r7
  41326e:	f85d 7b04 	ldr.w	r7, [sp], #4
  413272:	4770      	bx	lr
  413274:	2000b404 	.word	0x2000b404

00413278 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
  413278:	b580      	push	{r7, lr}
  41327a:	b084      	sub	sp, #16
  41327c:	af00      	add	r7, sp, #0
  41327e:	6078      	str	r0, [r7, #4]
  413280:	6039      	str	r1, [r7, #0]
	uint32_t ulReturn;

		taskENTER_CRITICAL();
  413282:	4b1f      	ldr	r3, [pc, #124]	; (413300 <ulTaskNotifyTake+0x88>)
  413284:	4798      	blx	r3
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
  413286:	4b1f      	ldr	r3, [pc, #124]	; (413304 <ulTaskNotifyTake+0x8c>)
  413288:	681b      	ldr	r3, [r3, #0]
  41328a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
  41328c:	2b00      	cmp	r3, #0
  41328e:	d113      	bne.n	4132b8 <ulTaskNotifyTake+0x40>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
  413290:	4b1c      	ldr	r3, [pc, #112]	; (413304 <ulTaskNotifyTake+0x8c>)
  413292:	681b      	ldr	r3, [r3, #0]
  413294:	2201      	movs	r2, #1
  413296:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54

				if( xTicksToWait > ( TickType_t ) 0 )
  41329a:	683b      	ldr	r3, [r7, #0]
  41329c:	2b00      	cmp	r3, #0
  41329e:	d00b      	beq.n	4132b8 <ulTaskNotifyTake+0x40>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
  4132a0:	2101      	movs	r1, #1
  4132a2:	6838      	ldr	r0, [r7, #0]
  4132a4:	4b18      	ldr	r3, [pc, #96]	; (413308 <ulTaskNotifyTake+0x90>)
  4132a6:	4798      	blx	r3

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
  4132a8:	4b18      	ldr	r3, [pc, #96]	; (41330c <ulTaskNotifyTake+0x94>)
  4132aa:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  4132ae:	601a      	str	r2, [r3, #0]
  4132b0:	f3bf 8f4f 	dsb	sy
  4132b4:	f3bf 8f6f 	isb	sy
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
  4132b8:	4b15      	ldr	r3, [pc, #84]	; (413310 <ulTaskNotifyTake+0x98>)
  4132ba:	4798      	blx	r3

		taskENTER_CRITICAL();
  4132bc:	4b10      	ldr	r3, [pc, #64]	; (413300 <ulTaskNotifyTake+0x88>)
  4132be:	4798      	blx	r3
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
  4132c0:	4b10      	ldr	r3, [pc, #64]	; (413304 <ulTaskNotifyTake+0x8c>)
  4132c2:	681b      	ldr	r3, [r3, #0]
  4132c4:	6d1b      	ldr	r3, [r3, #80]	; 0x50
  4132c6:	60fb      	str	r3, [r7, #12]

			if( ulReturn != 0UL )
  4132c8:	68fb      	ldr	r3, [r7, #12]
  4132ca:	2b00      	cmp	r3, #0
  4132cc:	d00c      	beq.n	4132e8 <ulTaskNotifyTake+0x70>
			{
				if( xClearCountOnExit != pdFALSE )
  4132ce:	687b      	ldr	r3, [r7, #4]
  4132d0:	2b00      	cmp	r3, #0
  4132d2:	d004      	beq.n	4132de <ulTaskNotifyTake+0x66>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
  4132d4:	4b0b      	ldr	r3, [pc, #44]	; (413304 <ulTaskNotifyTake+0x8c>)
  4132d6:	681b      	ldr	r3, [r3, #0]
  4132d8:	2200      	movs	r2, #0
  4132da:	651a      	str	r2, [r3, #80]	; 0x50
  4132dc:	e004      	b.n	4132e8 <ulTaskNotifyTake+0x70>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
  4132de:	4b09      	ldr	r3, [pc, #36]	; (413304 <ulTaskNotifyTake+0x8c>)
  4132e0:	681b      	ldr	r3, [r3, #0]
  4132e2:	68fa      	ldr	r2, [r7, #12]
  4132e4:	3a01      	subs	r2, #1
  4132e6:	651a      	str	r2, [r3, #80]	; 0x50
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
  4132e8:	4b06      	ldr	r3, [pc, #24]	; (413304 <ulTaskNotifyTake+0x8c>)
  4132ea:	681b      	ldr	r3, [r3, #0]
  4132ec:	2200      	movs	r2, #0
  4132ee:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
		}
		taskEXIT_CRITICAL();
  4132f2:	4b07      	ldr	r3, [pc, #28]	; (413310 <ulTaskNotifyTake+0x98>)
  4132f4:	4798      	blx	r3

		return ulReturn;
  4132f6:	68fb      	ldr	r3, [r7, #12]
	}
  4132f8:	4618      	mov	r0, r3
  4132fa:	3710      	adds	r7, #16
  4132fc:	46bd      	mov	sp, r7
  4132fe:	bd80      	pop	{r7, pc}
  413300:	0041103d 	.word	0x0041103d
  413304:	2000b404 	.word	0x2000b404
  413308:	00413431 	.word	0x00413431
  41330c:	e000ed04 	.word	0xe000ed04
  413310:	00411099 	.word	0x00411099

00413314 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
  413314:	b580      	push	{r7, lr}
  413316:	b088      	sub	sp, #32
  413318:	af00      	add	r7, sp, #0
  41331a:	6078      	str	r0, [r7, #4]
  41331c:	6039      	str	r1, [r7, #0]
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	UBaseType_t uxSavedInterruptStatus;

		configASSERT( xTaskToNotify );
  41331e:	687b      	ldr	r3, [r7, #4]
  413320:	2b00      	cmp	r3, #0
  413322:	d105      	bne.n	413330 <vTaskNotifyGiveFromISR+0x1c>
  413324:	f241 32b1 	movw	r2, #5041	; 0x13b1
  413328:	4936      	ldr	r1, [pc, #216]	; (413404 <vTaskNotifyGiveFromISR+0xf0>)
  41332a:	4837      	ldr	r0, [pc, #220]	; (413408 <vTaskNotifyGiveFromISR+0xf4>)
  41332c:	4b37      	ldr	r3, [pc, #220]	; (41340c <vTaskNotifyGiveFromISR+0xf8>)
  41332e:	4798      	blx	r3
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
  413330:	687b      	ldr	r3, [r7, #4]
  413332:	61fb      	str	r3, [r7, #28]
	__asm volatile
  413334:	f3ef 8211 	mrs	r2, BASEPRI
  413338:	f04f 0350 	mov.w	r3, #80	; 0x50
  41333c:	f383 8811 	msr	BASEPRI, r3
  413340:	f3bf 8f6f 	isb	sy
  413344:	f3bf 8f4f 	dsb	sy
  413348:	613a      	str	r2, [r7, #16]
  41334a:	60fb      	str	r3, [r7, #12]
	return ulOriginalBASEPRI;
  41334c:	693b      	ldr	r3, [r7, #16]

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  41334e:	61bb      	str	r3, [r7, #24]
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
  413350:	69fb      	ldr	r3, [r7, #28]
  413352:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
  413356:	75fb      	strb	r3, [r7, #23]
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
  413358:	69fb      	ldr	r3, [r7, #28]
  41335a:	2202      	movs	r2, #2
  41335c:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
  413360:	69fb      	ldr	r3, [r7, #28]
  413362:	6d1b      	ldr	r3, [r3, #80]	; 0x50
  413364:	1c5a      	adds	r2, r3, #1
  413366:	69fb      	ldr	r3, [r7, #28]
  413368:	651a      	str	r2, [r3, #80]	; 0x50

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
  41336a:	7dfb      	ldrb	r3, [r7, #23]
  41336c:	2b01      	cmp	r3, #1
  41336e:	d140      	bne.n	4133f2 <vTaskNotifyGiveFromISR+0xde>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
  413370:	69fb      	ldr	r3, [r7, #28]
  413372:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  413374:	2b00      	cmp	r3, #0
  413376:	d005      	beq.n	413384 <vTaskNotifyGiveFromISR+0x70>
  413378:	f241 32d7 	movw	r2, #5079	; 0x13d7
  41337c:	4921      	ldr	r1, [pc, #132]	; (413404 <vTaskNotifyGiveFromISR+0xf0>)
  41337e:	4822      	ldr	r0, [pc, #136]	; (413408 <vTaskNotifyGiveFromISR+0xf4>)
  413380:	4b22      	ldr	r3, [pc, #136]	; (41340c <vTaskNotifyGiveFromISR+0xf8>)
  413382:	4798      	blx	r3

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
  413384:	4b22      	ldr	r3, [pc, #136]	; (413410 <vTaskNotifyGiveFromISR+0xfc>)
  413386:	681b      	ldr	r3, [r3, #0]
  413388:	2b00      	cmp	r3, #0
  41338a:	d11c      	bne.n	4133c6 <vTaskNotifyGiveFromISR+0xb2>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
  41338c:	69fb      	ldr	r3, [r7, #28]
  41338e:	3304      	adds	r3, #4
  413390:	4618      	mov	r0, r3
  413392:	4b20      	ldr	r3, [pc, #128]	; (413414 <vTaskNotifyGiveFromISR+0x100>)
  413394:	4798      	blx	r3
					prvAddTaskToReadyList( pxTCB );
  413396:	69fb      	ldr	r3, [r7, #28]
  413398:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  41339a:	2201      	movs	r2, #1
  41339c:	409a      	lsls	r2, r3
  41339e:	4b1e      	ldr	r3, [pc, #120]	; (413418 <vTaskNotifyGiveFromISR+0x104>)
  4133a0:	681b      	ldr	r3, [r3, #0]
  4133a2:	4313      	orrs	r3, r2
  4133a4:	4a1c      	ldr	r2, [pc, #112]	; (413418 <vTaskNotifyGiveFromISR+0x104>)
  4133a6:	6013      	str	r3, [r2, #0]
  4133a8:	69fb      	ldr	r3, [r7, #28]
  4133aa:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  4133ac:	4613      	mov	r3, r2
  4133ae:	009b      	lsls	r3, r3, #2
  4133b0:	4413      	add	r3, r2
  4133b2:	009b      	lsls	r3, r3, #2
  4133b4:	4a19      	ldr	r2, [pc, #100]	; (41341c <vTaskNotifyGiveFromISR+0x108>)
  4133b6:	441a      	add	r2, r3
  4133b8:	69fb      	ldr	r3, [r7, #28]
  4133ba:	3304      	adds	r3, #4
  4133bc:	4619      	mov	r1, r3
  4133be:	4610      	mov	r0, r2
  4133c0:	4b17      	ldr	r3, [pc, #92]	; (413420 <vTaskNotifyGiveFromISR+0x10c>)
  4133c2:	4798      	blx	r3
  4133c4:	e005      	b.n	4133d2 <vTaskNotifyGiveFromISR+0xbe>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
  4133c6:	69fb      	ldr	r3, [r7, #28]
  4133c8:	3318      	adds	r3, #24
  4133ca:	4619      	mov	r1, r3
  4133cc:	4815      	ldr	r0, [pc, #84]	; (413424 <vTaskNotifyGiveFromISR+0x110>)
  4133ce:	4b14      	ldr	r3, [pc, #80]	; (413420 <vTaskNotifyGiveFromISR+0x10c>)
  4133d0:	4798      	blx	r3
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
  4133d2:	69fb      	ldr	r3, [r7, #28]
  4133d4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  4133d6:	4b14      	ldr	r3, [pc, #80]	; (413428 <vTaskNotifyGiveFromISR+0x114>)
  4133d8:	681b      	ldr	r3, [r3, #0]
  4133da:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  4133dc:	429a      	cmp	r2, r3
  4133de:	d908      	bls.n	4133f2 <vTaskNotifyGiveFromISR+0xde>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
  4133e0:	683b      	ldr	r3, [r7, #0]
  4133e2:	2b00      	cmp	r3, #0
  4133e4:	d002      	beq.n	4133ec <vTaskNotifyGiveFromISR+0xd8>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
  4133e6:	683b      	ldr	r3, [r7, #0]
  4133e8:	2201      	movs	r2, #1
  4133ea:	601a      	str	r2, [r3, #0]
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
  4133ec:	4b0f      	ldr	r3, [pc, #60]	; (41342c <vTaskNotifyGiveFromISR+0x118>)
  4133ee:	2201      	movs	r2, #1
  4133f0:	601a      	str	r2, [r3, #0]
  4133f2:	69bb      	ldr	r3, [r7, #24]
  4133f4:	60bb      	str	r3, [r7, #8]
	__asm volatile
  4133f6:	68bb      	ldr	r3, [r7, #8]
  4133f8:	f383 8811 	msr	BASEPRI, r3
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
  4133fc:	bf00      	nop
  4133fe:	3720      	adds	r7, #32
  413400:	46bd      	mov	sp, r7
  413402:	bd80      	pop	{r7, pc}
  413404:	0041e1f8 	.word	0x0041e1f8
  413408:	0041e230 	.word	0x0041e230
  41340c:	00416c7d 	.word	0x00416c7d
  413410:	2000b4d8 	.word	0x2000b4d8
  413414:	00410df5 	.word	0x00410df5
  413418:	2000b4b8 	.word	0x2000b4b8
  41341c:	2000b408 	.word	0x2000b408
  413420:	00410d3b 	.word	0x00410d3b
  413424:	2000b488 	.word	0x2000b488
  413428:	2000b404 	.word	0x2000b404
  41342c:	2000b4c4 	.word	0x2000b4c4

00413430 <prvAddCurrentTaskToDelayedList>:

#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
  413430:	b580      	push	{r7, lr}
  413432:	b084      	sub	sp, #16
  413434:	af00      	add	r7, sp, #0
  413436:	6078      	str	r0, [r7, #4]
  413438:	6039      	str	r1, [r7, #0]
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
  41343a:	4b29      	ldr	r3, [pc, #164]	; (4134e0 <prvAddCurrentTaskToDelayedList+0xb0>)
  41343c:	681b      	ldr	r3, [r3, #0]
  41343e:	60fb      	str	r3, [r7, #12]
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  413440:	4b28      	ldr	r3, [pc, #160]	; (4134e4 <prvAddCurrentTaskToDelayedList+0xb4>)
  413442:	681b      	ldr	r3, [r3, #0]
  413444:	3304      	adds	r3, #4
  413446:	4618      	mov	r0, r3
  413448:	4b27      	ldr	r3, [pc, #156]	; (4134e8 <prvAddCurrentTaskToDelayedList+0xb8>)
  41344a:	4798      	blx	r3
  41344c:	4603      	mov	r3, r0
  41344e:	2b00      	cmp	r3, #0
  413450:	d10b      	bne.n	41346a <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority ); /*lint !e931 pxCurrentTCB cannot change as it is the calling task.  pxCurrentTCB->uxPriority and uxTopReadyPriority cannot change as called with scheduler suspended or in a critical section. */
  413452:	4b24      	ldr	r3, [pc, #144]	; (4134e4 <prvAddCurrentTaskToDelayedList+0xb4>)
  413454:	681b      	ldr	r3, [r3, #0]
  413456:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  413458:	2201      	movs	r2, #1
  41345a:	fa02 f303 	lsl.w	r3, r2, r3
  41345e:	43da      	mvns	r2, r3
  413460:	4b22      	ldr	r3, [pc, #136]	; (4134ec <prvAddCurrentTaskToDelayedList+0xbc>)
  413462:	681b      	ldr	r3, [r3, #0]
  413464:	4013      	ands	r3, r2
  413466:	4a21      	ldr	r2, [pc, #132]	; (4134ec <prvAddCurrentTaskToDelayedList+0xbc>)
  413468:	6013      	str	r3, [r2, #0]
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
  41346a:	687b      	ldr	r3, [r7, #4]
  41346c:	f1b3 3fff 	cmp.w	r3, #4294967295
  413470:	d10a      	bne.n	413488 <prvAddCurrentTaskToDelayedList+0x58>
  413472:	683b      	ldr	r3, [r7, #0]
  413474:	2b00      	cmp	r3, #0
  413476:	d007      	beq.n	413488 <prvAddCurrentTaskToDelayedList+0x58>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
  413478:	4b1a      	ldr	r3, [pc, #104]	; (4134e4 <prvAddCurrentTaskToDelayedList+0xb4>)
  41347a:	681b      	ldr	r3, [r3, #0]
  41347c:	3304      	adds	r3, #4
  41347e:	4619      	mov	r1, r3
  413480:	481b      	ldr	r0, [pc, #108]	; (4134f0 <prvAddCurrentTaskToDelayedList+0xc0>)
  413482:	4b1c      	ldr	r3, [pc, #112]	; (4134f4 <prvAddCurrentTaskToDelayedList+0xc4>)
  413484:	4798      	blx	r3

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
  413486:	e026      	b.n	4134d6 <prvAddCurrentTaskToDelayedList+0xa6>
			xTimeToWake = xConstTickCount + xTicksToWait;
  413488:	68fa      	ldr	r2, [r7, #12]
  41348a:	687b      	ldr	r3, [r7, #4]
  41348c:	4413      	add	r3, r2
  41348e:	60bb      	str	r3, [r7, #8]
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
  413490:	4b14      	ldr	r3, [pc, #80]	; (4134e4 <prvAddCurrentTaskToDelayedList+0xb4>)
  413492:	681b      	ldr	r3, [r3, #0]
  413494:	68ba      	ldr	r2, [r7, #8]
  413496:	605a      	str	r2, [r3, #4]
			if( xTimeToWake < xConstTickCount )
  413498:	68ba      	ldr	r2, [r7, #8]
  41349a:	68fb      	ldr	r3, [r7, #12]
  41349c:	429a      	cmp	r2, r3
  41349e:	d209      	bcs.n	4134b4 <prvAddCurrentTaskToDelayedList+0x84>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
  4134a0:	4b15      	ldr	r3, [pc, #84]	; (4134f8 <prvAddCurrentTaskToDelayedList+0xc8>)
  4134a2:	681a      	ldr	r2, [r3, #0]
  4134a4:	4b0f      	ldr	r3, [pc, #60]	; (4134e4 <prvAddCurrentTaskToDelayedList+0xb4>)
  4134a6:	681b      	ldr	r3, [r3, #0]
  4134a8:	3304      	adds	r3, #4
  4134aa:	4619      	mov	r1, r3
  4134ac:	4610      	mov	r0, r2
  4134ae:	4b13      	ldr	r3, [pc, #76]	; (4134fc <prvAddCurrentTaskToDelayedList+0xcc>)
  4134b0:	4798      	blx	r3
}
  4134b2:	e010      	b.n	4134d6 <prvAddCurrentTaskToDelayedList+0xa6>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
  4134b4:	4b12      	ldr	r3, [pc, #72]	; (413500 <prvAddCurrentTaskToDelayedList+0xd0>)
  4134b6:	681a      	ldr	r2, [r3, #0]
  4134b8:	4b0a      	ldr	r3, [pc, #40]	; (4134e4 <prvAddCurrentTaskToDelayedList+0xb4>)
  4134ba:	681b      	ldr	r3, [r3, #0]
  4134bc:	3304      	adds	r3, #4
  4134be:	4619      	mov	r1, r3
  4134c0:	4610      	mov	r0, r2
  4134c2:	4b0e      	ldr	r3, [pc, #56]	; (4134fc <prvAddCurrentTaskToDelayedList+0xcc>)
  4134c4:	4798      	blx	r3
				if( xTimeToWake < xNextTaskUnblockTime )
  4134c6:	4b0f      	ldr	r3, [pc, #60]	; (413504 <prvAddCurrentTaskToDelayedList+0xd4>)
  4134c8:	681b      	ldr	r3, [r3, #0]
  4134ca:	68ba      	ldr	r2, [r7, #8]
  4134cc:	429a      	cmp	r2, r3
  4134ce:	d202      	bcs.n	4134d6 <prvAddCurrentTaskToDelayedList+0xa6>
					xNextTaskUnblockTime = xTimeToWake;
  4134d0:	4a0c      	ldr	r2, [pc, #48]	; (413504 <prvAddCurrentTaskToDelayedList+0xd4>)
  4134d2:	68bb      	ldr	r3, [r7, #8]
  4134d4:	6013      	str	r3, [r2, #0]
}
  4134d6:	bf00      	nop
  4134d8:	3710      	adds	r7, #16
  4134da:	46bd      	mov	sp, r7
  4134dc:	bd80      	pop	{r7, pc}
  4134de:	bf00      	nop
  4134e0:	2000b4b4 	.word	0x2000b4b4
  4134e4:	2000b404 	.word	0x2000b404
  4134e8:	00410df5 	.word	0x00410df5
  4134ec:	2000b4b8 	.word	0x2000b4b8
  4134f0:	2000b49c 	.word	0x2000b49c
  4134f4:	00410d3b 	.word	0x00410d3b
  4134f8:	2000b484 	.word	0x2000b484
  4134fc:	00410d83 	.word	0x00410d83
  413500:	2000b480 	.word	0x2000b480
  413504:	2000b4d0 	.word	0x2000b4d0

00413508 <HICS_Debug_phantomISR>:
}
#endif

// HICS: debug phanthom ISR
void HICS_Debug_phantomISR(uint32_t phantomISR)
{	
  413508:	b580      	push	{r7, lr}
  41350a:	b082      	sub	sp, #8
  41350c:	af00      	add	r7, sp, #0
  41350e:	6078      	str	r0, [r7, #4]
	printf("\n\nERROR: Dummy_Handler() - phantomISR = %d\n", phantomISR);
  413510:	6879      	ldr	r1, [r7, #4]
  413512:	4805      	ldr	r0, [pc, #20]	; (413528 <HICS_Debug_phantomISR+0x20>)
  413514:	4b05      	ldr	r3, [pc, #20]	; (41352c <HICS_Debug_phantomISR+0x24>)
  413516:	4798      	blx	r3

	// HICS debug error and reset
	WDT_Debug_printf_state(1);	// Print status e reset por watchdog
  413518:	2001      	movs	r0, #1
  41351a:	4b05      	ldr	r3, [pc, #20]	; (413530 <HICS_Debug_phantomISR+0x28>)
  41351c:	4798      	blx	r3

}
  41351e:	bf00      	nop
  413520:	3708      	adds	r7, #8
  413522:	46bd      	mov	sp, r7
  413524:	bd80      	pop	{r7, pc}
  413526:	bf00      	nop
  413528:	0041e278 	.word	0x0041e278
  41352c:	00416c7d 	.word	0x00416c7d
  413530:	004158d9 	.word	0x004158d9

00413534 <NVIC_EnableIRQ>:
{
  413534:	b480      	push	{r7}
  413536:	b083      	sub	sp, #12
  413538:	af00      	add	r7, sp, #0
  41353a:	4603      	mov	r3, r0
  41353c:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
  41353e:	4909      	ldr	r1, [pc, #36]	; (413564 <NVIC_EnableIRQ+0x30>)
  413540:	f997 3007 	ldrsb.w	r3, [r7, #7]
  413544:	095b      	lsrs	r3, r3, #5
  413546:	79fa      	ldrb	r2, [r7, #7]
  413548:	f002 021f 	and.w	r2, r2, #31
  41354c:	2001      	movs	r0, #1
  41354e:	fa00 f202 	lsl.w	r2, r0, r2
  413552:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
  413556:	bf00      	nop
  413558:	370c      	adds	r7, #12
  41355a:	46bd      	mov	sp, r7
  41355c:	f85d 7b04 	ldr.w	r7, [sp], #4
  413560:	4770      	bx	lr
  413562:	bf00      	nop
  413564:	e000e100 	.word	0xe000e100

00413568 <NVIC_SetPriority>:
{
  413568:	b480      	push	{r7}
  41356a:	b083      	sub	sp, #12
  41356c:	af00      	add	r7, sp, #0
  41356e:	4603      	mov	r3, r0
  413570:	6039      	str	r1, [r7, #0]
  413572:	71fb      	strb	r3, [r7, #7]
  if(IRQn < 0) {
  413574:	f997 3007 	ldrsb.w	r3, [r7, #7]
  413578:	2b00      	cmp	r3, #0
  41357a:	da0b      	bge.n	413594 <NVIC_SetPriority+0x2c>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
  41357c:	490d      	ldr	r1, [pc, #52]	; (4135b4 <NVIC_SetPriority+0x4c>)
  41357e:	79fb      	ldrb	r3, [r7, #7]
  413580:	f003 030f 	and.w	r3, r3, #15
  413584:	3b04      	subs	r3, #4
  413586:	683a      	ldr	r2, [r7, #0]
  413588:	b2d2      	uxtb	r2, r2
  41358a:	0112      	lsls	r2, r2, #4
  41358c:	b2d2      	uxtb	r2, r2
  41358e:	440b      	add	r3, r1
  413590:	761a      	strb	r2, [r3, #24]
}
  413592:	e009      	b.n	4135a8 <NVIC_SetPriority+0x40>
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
  413594:	4908      	ldr	r1, [pc, #32]	; (4135b8 <NVIC_SetPriority+0x50>)
  413596:	f997 3007 	ldrsb.w	r3, [r7, #7]
  41359a:	683a      	ldr	r2, [r7, #0]
  41359c:	b2d2      	uxtb	r2, r2
  41359e:	0112      	lsls	r2, r2, #4
  4135a0:	b2d2      	uxtb	r2, r2
  4135a2:	440b      	add	r3, r1
  4135a4:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
  4135a8:	bf00      	nop
  4135aa:	370c      	adds	r7, #12
  4135ac:	46bd      	mov	sp, r7
  4135ae:	f85d 7b04 	ldr.w	r7, [sp], #4
  4135b2:	4770      	bx	lr
  4135b4:	e000ed00 	.word	0xe000ed00
  4135b8:	e000e100 	.word	0xe000e100

004135bc <ioport_set_pin_mode>:
{
  4135bc:	b480      	push	{r7}
  4135be:	b08d      	sub	sp, #52	; 0x34
  4135c0:	af00      	add	r7, sp, #0
  4135c2:	6078      	str	r0, [r7, #4]
  4135c4:	6039      	str	r1, [r7, #0]
  4135c6:	687b      	ldr	r3, [r7, #4]
  4135c8:	62fb      	str	r3, [r7, #44]	; 0x2c
  4135ca:	683b      	ldr	r3, [r7, #0]
  4135cc:	62bb      	str	r3, [r7, #40]	; 0x28
  4135ce:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  4135d0:	627b      	str	r3, [r7, #36]	; 0x24
	return pin >> 5;
  4135d2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4135d4:	095a      	lsrs	r2, r3, #5
  4135d6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  4135d8:	623b      	str	r3, [r7, #32]
	return 1U << (pin & 0x1F);
  4135da:	6a3b      	ldr	r3, [r7, #32]
  4135dc:	f003 031f 	and.w	r3, r3, #31
  4135e0:	2101      	movs	r1, #1
  4135e2:	fa01 f303 	lsl.w	r3, r1, r3
  4135e6:	61fa      	str	r2, [r7, #28]
  4135e8:	61bb      	str	r3, [r7, #24]
  4135ea:	6abb      	ldr	r3, [r7, #40]	; 0x28
  4135ec:	617b      	str	r3, [r7, #20]
  4135ee:	69fb      	ldr	r3, [r7, #28]
  4135f0:	613b      	str	r3, [r7, #16]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  4135f2:	693b      	ldr	r3, [r7, #16]
  4135f4:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  4135f8:	f203 7307 	addw	r3, r3, #1799	; 0x707
  4135fc:	025b      	lsls	r3, r3, #9
	Pio *base = arch_ioport_port_to_base(port);
  4135fe:	60fb      	str	r3, [r7, #12]
	if (mode & IOPORT_MODE_PULLUP) {
  413600:	697b      	ldr	r3, [r7, #20]
  413602:	f003 0308 	and.w	r3, r3, #8
  413606:	2b00      	cmp	r3, #0
  413608:	d003      	beq.n	413612 <ioport_set_pin_mode+0x56>
		base->PIO_PUER = mask;
  41360a:	68fb      	ldr	r3, [r7, #12]
  41360c:	69ba      	ldr	r2, [r7, #24]
  41360e:	665a      	str	r2, [r3, #100]	; 0x64
  413610:	e002      	b.n	413618 <ioport_set_pin_mode+0x5c>
		base->PIO_PUDR = mask;
  413612:	68fb      	ldr	r3, [r7, #12]
  413614:	69ba      	ldr	r2, [r7, #24]
  413616:	661a      	str	r2, [r3, #96]	; 0x60
	if (mode & IOPORT_MODE_PULLDOWN) {
  413618:	697b      	ldr	r3, [r7, #20]
  41361a:	f003 0310 	and.w	r3, r3, #16
  41361e:	2b00      	cmp	r3, #0
  413620:	d004      	beq.n	41362c <ioport_set_pin_mode+0x70>
		base->PIO_PPDER = mask;
  413622:	68fb      	ldr	r3, [r7, #12]
  413624:	69ba      	ldr	r2, [r7, #24]
  413626:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  41362a:	e003      	b.n	413634 <ioport_set_pin_mode+0x78>
		base->PIO_PPDDR = mask;
  41362c:	68fb      	ldr	r3, [r7, #12]
  41362e:	69ba      	ldr	r2, [r7, #24]
  413630:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
	if (mode & IOPORT_MODE_OPEN_DRAIN) {
  413634:	697b      	ldr	r3, [r7, #20]
  413636:	f003 0320 	and.w	r3, r3, #32
  41363a:	2b00      	cmp	r3, #0
  41363c:	d003      	beq.n	413646 <ioport_set_pin_mode+0x8a>
		base->PIO_MDER = mask;
  41363e:	68fb      	ldr	r3, [r7, #12]
  413640:	69ba      	ldr	r2, [r7, #24]
  413642:	651a      	str	r2, [r3, #80]	; 0x50
  413644:	e002      	b.n	41364c <ioport_set_pin_mode+0x90>
		base->PIO_MDDR = mask;
  413646:	68fb      	ldr	r3, [r7, #12]
  413648:	69ba      	ldr	r2, [r7, #24]
  41364a:	655a      	str	r2, [r3, #84]	; 0x54
	if (mode & (IOPORT_MODE_GLITCH_FILTER | IOPORT_MODE_DEBOUNCE)) {
  41364c:	697b      	ldr	r3, [r7, #20]
  41364e:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
  413652:	2b00      	cmp	r3, #0
  413654:	d003      	beq.n	41365e <ioport_set_pin_mode+0xa2>
		base->PIO_IFER = mask;
  413656:	68fb      	ldr	r3, [r7, #12]
  413658:	69ba      	ldr	r2, [r7, #24]
  41365a:	621a      	str	r2, [r3, #32]
  41365c:	e002      	b.n	413664 <ioport_set_pin_mode+0xa8>
		base->PIO_IFDR = mask;
  41365e:	68fb      	ldr	r3, [r7, #12]
  413660:	69ba      	ldr	r2, [r7, #24]
  413662:	625a      	str	r2, [r3, #36]	; 0x24
	if (mode & IOPORT_MODE_DEBOUNCE) {
  413664:	697b      	ldr	r3, [r7, #20]
  413666:	f003 0380 	and.w	r3, r3, #128	; 0x80
  41366a:	2b00      	cmp	r3, #0
  41366c:	d004      	beq.n	413678 <ioport_set_pin_mode+0xbc>
		base->PIO_IFSCER = mask;
  41366e:	68fb      	ldr	r3, [r7, #12]
  413670:	69ba      	ldr	r2, [r7, #24]
  413672:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  413676:	e003      	b.n	413680 <ioport_set_pin_mode+0xc4>
		base->PIO_IFSCDR = mask;
  413678:	68fb      	ldr	r3, [r7, #12]
  41367a:	69ba      	ldr	r2, [r7, #24]
  41367c:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	if (mode & IOPORT_MODE_MUX_BIT0) {
  413680:	697b      	ldr	r3, [r7, #20]
  413682:	f003 0301 	and.w	r3, r3, #1
  413686:	2b00      	cmp	r3, #0
  413688:	d006      	beq.n	413698 <ioport_set_pin_mode+0xdc>
		base->PIO_ABCDSR[0] |= mask;
  41368a:	68fb      	ldr	r3, [r7, #12]
  41368c:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  41368e:	69bb      	ldr	r3, [r7, #24]
  413690:	431a      	orrs	r2, r3
  413692:	68fb      	ldr	r3, [r7, #12]
  413694:	671a      	str	r2, [r3, #112]	; 0x70
  413696:	e006      	b.n	4136a6 <ioport_set_pin_mode+0xea>
		base->PIO_ABCDSR[0] &= ~mask;
  413698:	68fb      	ldr	r3, [r7, #12]
  41369a:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  41369c:	69bb      	ldr	r3, [r7, #24]
  41369e:	43db      	mvns	r3, r3
  4136a0:	401a      	ands	r2, r3
  4136a2:	68fb      	ldr	r3, [r7, #12]
  4136a4:	671a      	str	r2, [r3, #112]	; 0x70
	if (mode & IOPORT_MODE_MUX_BIT1) {
  4136a6:	697b      	ldr	r3, [r7, #20]
  4136a8:	f003 0302 	and.w	r3, r3, #2
  4136ac:	2b00      	cmp	r3, #0
  4136ae:	d006      	beq.n	4136be <ioport_set_pin_mode+0x102>
		base->PIO_ABCDSR[1] |= mask;
  4136b0:	68fb      	ldr	r3, [r7, #12]
  4136b2:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  4136b4:	69bb      	ldr	r3, [r7, #24]
  4136b6:	431a      	orrs	r2, r3
  4136b8:	68fb      	ldr	r3, [r7, #12]
  4136ba:	675a      	str	r2, [r3, #116]	; 0x74
}
  4136bc:	e006      	b.n	4136cc <ioport_set_pin_mode+0x110>
		base->PIO_ABCDSR[1] &= ~mask;
  4136be:	68fb      	ldr	r3, [r7, #12]
  4136c0:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  4136c2:	69bb      	ldr	r3, [r7, #24]
  4136c4:	43db      	mvns	r3, r3
  4136c6:	401a      	ands	r2, r3
  4136c8:	68fb      	ldr	r3, [r7, #12]
  4136ca:	675a      	str	r2, [r3, #116]	; 0x74
  4136cc:	bf00      	nop
  4136ce:	3734      	adds	r7, #52	; 0x34
  4136d0:	46bd      	mov	sp, r7
  4136d2:	f85d 7b04 	ldr.w	r7, [sp], #4
  4136d6:	4770      	bx	lr

004136d8 <ioport_set_pin_dir>:
{
  4136d8:	b480      	push	{r7}
  4136da:	b08d      	sub	sp, #52	; 0x34
  4136dc:	af00      	add	r7, sp, #0
  4136de:	6078      	str	r0, [r7, #4]
  4136e0:	460b      	mov	r3, r1
  4136e2:	70fb      	strb	r3, [r7, #3]
  4136e4:	687b      	ldr	r3, [r7, #4]
  4136e6:	62fb      	str	r3, [r7, #44]	; 0x2c
  4136e8:	78fb      	ldrb	r3, [r7, #3]
  4136ea:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
  4136ee:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  4136f0:	627b      	str	r3, [r7, #36]	; 0x24
  4136f2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4136f4:	623b      	str	r3, [r7, #32]
	return pin >> 5;
  4136f6:	6a3b      	ldr	r3, [r7, #32]
  4136f8:	095b      	lsrs	r3, r3, #5
  4136fa:	61fb      	str	r3, [r7, #28]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  4136fc:	69fb      	ldr	r3, [r7, #28]
  4136fe:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  413702:	f203 7307 	addw	r3, r3, #1799	; 0x707
  413706:	025b      	lsls	r3, r3, #9
	Pio *base = arch_ioport_pin_to_base(pin);
  413708:	61bb      	str	r3, [r7, #24]
	if (dir == IOPORT_DIR_OUTPUT) {
  41370a:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
  41370e:	2b01      	cmp	r3, #1
  413710:	d109      	bne.n	413726 <ioport_set_pin_dir+0x4e>
  413712:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  413714:	617b      	str	r3, [r7, #20]
	return 1U << (pin & 0x1F);
  413716:	697b      	ldr	r3, [r7, #20]
  413718:	f003 031f 	and.w	r3, r3, #31
  41371c:	2201      	movs	r2, #1
  41371e:	409a      	lsls	r2, r3
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
  413720:	69bb      	ldr	r3, [r7, #24]
  413722:	611a      	str	r2, [r3, #16]
  413724:	e00c      	b.n	413740 <ioport_set_pin_dir+0x68>
	} else if (dir == IOPORT_DIR_INPUT) {
  413726:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
  41372a:	2b00      	cmp	r3, #0
  41372c:	d108      	bne.n	413740 <ioport_set_pin_dir+0x68>
  41372e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  413730:	613b      	str	r3, [r7, #16]
	return 1U << (pin & 0x1F);
  413732:	693b      	ldr	r3, [r7, #16]
  413734:	f003 031f 	and.w	r3, r3, #31
  413738:	2201      	movs	r2, #1
  41373a:	409a      	lsls	r2, r3
		base->PIO_ODR = arch_ioport_pin_to_mask(pin);
  41373c:	69bb      	ldr	r3, [r7, #24]
  41373e:	615a      	str	r2, [r3, #20]
  413740:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  413742:	60fb      	str	r3, [r7, #12]
	return 1U << (pin & 0x1F);
  413744:	68fb      	ldr	r3, [r7, #12]
  413746:	f003 031f 	and.w	r3, r3, #31
  41374a:	2201      	movs	r2, #1
  41374c:	409a      	lsls	r2, r3
	base->PIO_OWER = arch_ioport_pin_to_mask(pin);
  41374e:	69bb      	ldr	r3, [r7, #24]
  413750:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
}
  413754:	bf00      	nop
  413756:	3734      	adds	r7, #52	; 0x34
  413758:	46bd      	mov	sp, r7
  41375a:	f85d 7b04 	ldr.w	r7, [sp], #4
  41375e:	4770      	bx	lr

00413760 <ioport_set_pin_level>:
{
  413760:	b480      	push	{r7}
  413762:	b08b      	sub	sp, #44	; 0x2c
  413764:	af00      	add	r7, sp, #0
  413766:	6078      	str	r0, [r7, #4]
  413768:	460b      	mov	r3, r1
  41376a:	70fb      	strb	r3, [r7, #3]
  41376c:	687b      	ldr	r3, [r7, #4]
  41376e:	627b      	str	r3, [r7, #36]	; 0x24
  413770:	78fb      	ldrb	r3, [r7, #3]
  413772:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
  413776:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  413778:	61fb      	str	r3, [r7, #28]
  41377a:	69fb      	ldr	r3, [r7, #28]
  41377c:	61bb      	str	r3, [r7, #24]
	return pin >> 5;
  41377e:	69bb      	ldr	r3, [r7, #24]
  413780:	095b      	lsrs	r3, r3, #5
  413782:	617b      	str	r3, [r7, #20]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  413784:	697b      	ldr	r3, [r7, #20]
  413786:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  41378a:	f203 7307 	addw	r3, r3, #1799	; 0x707
  41378e:	025b      	lsls	r3, r3, #9
	Pio *base = arch_ioport_pin_to_base(pin);
  413790:	613b      	str	r3, [r7, #16]
	if (level) {
  413792:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
  413796:	2b00      	cmp	r3, #0
  413798:	d009      	beq.n	4137ae <ioport_set_pin_level+0x4e>
  41379a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  41379c:	60fb      	str	r3, [r7, #12]
	return 1U << (pin & 0x1F);
  41379e:	68fb      	ldr	r3, [r7, #12]
  4137a0:	f003 031f 	and.w	r3, r3, #31
  4137a4:	2201      	movs	r2, #1
  4137a6:	409a      	lsls	r2, r3
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  4137a8:	693b      	ldr	r3, [r7, #16]
  4137aa:	631a      	str	r2, [r3, #48]	; 0x30
}
  4137ac:	e008      	b.n	4137c0 <ioport_set_pin_level+0x60>
  4137ae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4137b0:	60bb      	str	r3, [r7, #8]
	return 1U << (pin & 0x1F);
  4137b2:	68bb      	ldr	r3, [r7, #8]
  4137b4:	f003 031f 	and.w	r3, r3, #31
  4137b8:	2201      	movs	r2, #1
  4137ba:	409a      	lsls	r2, r3
		base->PIO_CODR = arch_ioport_pin_to_mask(pin);
  4137bc:	693b      	ldr	r3, [r7, #16]
  4137be:	635a      	str	r2, [r3, #52]	; 0x34
  4137c0:	bf00      	nop
  4137c2:	372c      	adds	r7, #44	; 0x2c
  4137c4:	46bd      	mov	sp, r7
  4137c6:	f85d 7b04 	ldr.w	r7, [sp], #4
  4137ca:	4770      	bx	lr

004137cc <ioport_set_pin_sense_mode>:
{
  4137cc:	b480      	push	{r7}
  4137ce:	b08d      	sub	sp, #52	; 0x34
  4137d0:	af00      	add	r7, sp, #0
  4137d2:	6078      	str	r0, [r7, #4]
  4137d4:	460b      	mov	r3, r1
  4137d6:	70fb      	strb	r3, [r7, #3]
  4137d8:	687b      	ldr	r3, [r7, #4]
  4137da:	62fb      	str	r3, [r7, #44]	; 0x2c
  4137dc:	78fb      	ldrb	r3, [r7, #3]
  4137de:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
  4137e2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  4137e4:	627b      	str	r3, [r7, #36]	; 0x24
	return pin >> 5;
  4137e6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4137e8:	095a      	lsrs	r2, r3, #5
  4137ea:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  4137ec:	623b      	str	r3, [r7, #32]
	return 1U << (pin & 0x1F);
  4137ee:	6a3b      	ldr	r3, [r7, #32]
  4137f0:	f003 031f 	and.w	r3, r3, #31
  4137f4:	2101      	movs	r1, #1
  4137f6:	fa01 f303 	lsl.w	r3, r1, r3
  4137fa:	61fa      	str	r2, [r7, #28]
  4137fc:	61bb      	str	r3, [r7, #24]
  4137fe:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
  413802:	75fb      	strb	r3, [r7, #23]
  413804:	69fb      	ldr	r3, [r7, #28]
  413806:	613b      	str	r3, [r7, #16]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  413808:	693b      	ldr	r3, [r7, #16]
  41380a:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  41380e:	f203 7307 	addw	r3, r3, #1799	; 0x707
  413812:	025b      	lsls	r3, r3, #9
	Pio *base = arch_ioport_port_to_base(port);
  413814:	60fb      	str	r3, [r7, #12]
	switch(pin_sense) {
  413816:	7dfb      	ldrb	r3, [r7, #23]
  413818:	3b01      	subs	r3, #1
  41381a:	2b03      	cmp	r3, #3
  41381c:	d82e      	bhi.n	41387c <ioport_set_pin_sense_mode+0xb0>
  41381e:	a201      	add	r2, pc, #4	; (adr r2, 413824 <ioport_set_pin_sense_mode+0x58>)
  413820:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  413824:	00413859 	.word	0x00413859
  413828:	0041386b 	.word	0x0041386b
  41382c:	00413835 	.word	0x00413835
  413830:	00413847 	.word	0x00413847
		base->PIO_LSR = mask;
  413834:	68fb      	ldr	r3, [r7, #12]
  413836:	69ba      	ldr	r2, [r7, #24]
  413838:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
		base->PIO_FELLSR = mask;
  41383c:	68fb      	ldr	r3, [r7, #12]
  41383e:	69ba      	ldr	r2, [r7, #24]
  413840:	f8c3 20d0 	str.w	r2, [r3, #208]	; 0xd0
  413844:	e01f      	b.n	413886 <ioport_set_pin_sense_mode+0xba>
		base->PIO_LSR = mask;
  413846:	68fb      	ldr	r3, [r7, #12]
  413848:	69ba      	ldr	r2, [r7, #24]
  41384a:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
		base->PIO_REHLSR = mask;
  41384e:	68fb      	ldr	r3, [r7, #12]
  413850:	69ba      	ldr	r2, [r7, #24]
  413852:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
  413856:	e016      	b.n	413886 <ioport_set_pin_sense_mode+0xba>
		base->PIO_ESR = mask;
  413858:	68fb      	ldr	r3, [r7, #12]
  41385a:	69ba      	ldr	r2, [r7, #24]
  41385c:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
		base->PIO_FELLSR = mask;
  413860:	68fb      	ldr	r3, [r7, #12]
  413862:	69ba      	ldr	r2, [r7, #24]
  413864:	f8c3 20d0 	str.w	r2, [r3, #208]	; 0xd0
  413868:	e00d      	b.n	413886 <ioport_set_pin_sense_mode+0xba>
		base->PIO_ESR = mask;
  41386a:	68fb      	ldr	r3, [r7, #12]
  41386c:	69ba      	ldr	r2, [r7, #24]
  41386e:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
		base->PIO_REHLSR = mask;
  413872:	68fb      	ldr	r3, [r7, #12]
  413874:	69ba      	ldr	r2, [r7, #24]
  413876:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
  41387a:	e004      	b.n	413886 <ioport_set_pin_sense_mode+0xba>
		base->PIO_AIMDR = mask;
  41387c:	68fb      	ldr	r3, [r7, #12]
  41387e:	69ba      	ldr	r2, [r7, #24]
  413880:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
}
  413884:	e003      	b.n	41388e <ioport_set_pin_sense_mode+0xc2>
	base->PIO_AIMER = mask;
  413886:	68fb      	ldr	r3, [r7, #12]
  413888:	69ba      	ldr	r2, [r7, #24]
  41388a:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
  41388e:	bf00      	nop
  413890:	3734      	adds	r7, #52	; 0x34
  413892:	46bd      	mov	sp, r7
  413894:	f85d 7b04 	ldr.w	r7, [sp], #4
  413898:	4770      	bx	lr
  41389a:	bf00      	nop

0041389c <spi_enable>:
{
  41389c:	b480      	push	{r7}
  41389e:	b083      	sub	sp, #12
  4138a0:	af00      	add	r7, sp, #0
  4138a2:	6078      	str	r0, [r7, #4]
	p_spi->SPI_CR = SPI_CR_SPIEN;
  4138a4:	687b      	ldr	r3, [r7, #4]
  4138a6:	2201      	movs	r2, #1
  4138a8:	601a      	str	r2, [r3, #0]
}
  4138aa:	bf00      	nop
  4138ac:	370c      	adds	r7, #12
  4138ae:	46bd      	mov	sp, r7
  4138b0:	f85d 7b04 	ldr.w	r7, [sp], #4
  4138b4:	4770      	bx	lr

004138b6 <BinToAsciiHex>:
	//.id = 00 // SPI_NPCS0_GPIO (PA11) (Conector EXT1)
	.id = 03		// Conector EXT3
};

void BinToAsciiHex(U8 byValue, U8 *pbyCharLSB, U8 *pbyCharMSB)
{
  4138b6:	b480      	push	{r7}
  4138b8:	b085      	sub	sp, #20
  4138ba:	af00      	add	r7, sp, #0
  4138bc:	4603      	mov	r3, r0
  4138be:	60b9      	str	r1, [r7, #8]
  4138c0:	607a      	str	r2, [r7, #4]
  4138c2:	73fb      	strb	r3, [r7, #15]
	// Extrai o nibble mais significativo
	*pbyCharMSB = byValue & 0xF0;
  4138c4:	7bfb      	ldrb	r3, [r7, #15]
  4138c6:	f023 030f 	bic.w	r3, r3, #15
  4138ca:	b2da      	uxtb	r2, r3
  4138cc:	687b      	ldr	r3, [r7, #4]
  4138ce:	701a      	strb	r2, [r3, #0]
	*pbyCharMSB = *pbyCharMSB >> 4;
  4138d0:	687b      	ldr	r3, [r7, #4]
  4138d2:	781b      	ldrb	r3, [r3, #0]
  4138d4:	091b      	lsrs	r3, r3, #4
  4138d6:	b2da      	uxtb	r2, r3
  4138d8:	687b      	ldr	r3, [r7, #4]
  4138da:	701a      	strb	r2, [r3, #0]

	// Extrai o nibble menos significativo
	*pbyCharLSB = byValue & 0x0F;
  4138dc:	7bfb      	ldrb	r3, [r7, #15]
  4138de:	f003 030f 	and.w	r3, r3, #15
  4138e2:	b2da      	uxtb	r2, r3
  4138e4:	68bb      	ldr	r3, [r7, #8]
  4138e6:	701a      	strb	r2, [r3, #0]

	if(*pbyCharMSB < 0x0A)  *pbyCharMSB = *pbyCharMSB + 0x30;
  4138e8:	687b      	ldr	r3, [r7, #4]
  4138ea:	781b      	ldrb	r3, [r3, #0]
  4138ec:	2b09      	cmp	r3, #9
  4138ee:	d806      	bhi.n	4138fe <BinToAsciiHex+0x48>
  4138f0:	687b      	ldr	r3, [r7, #4]
  4138f2:	781b      	ldrb	r3, [r3, #0]
  4138f4:	3330      	adds	r3, #48	; 0x30
  4138f6:	b2da      	uxtb	r2, r3
  4138f8:	687b      	ldr	r3, [r7, #4]
  4138fa:	701a      	strb	r2, [r3, #0]
  4138fc:	e005      	b.n	41390a <BinToAsciiHex+0x54>
	else                    *pbyCharMSB = *pbyCharMSB + 0x37;
  4138fe:	687b      	ldr	r3, [r7, #4]
  413900:	781b      	ldrb	r3, [r3, #0]
  413902:	3337      	adds	r3, #55	; 0x37
  413904:	b2da      	uxtb	r2, r3
  413906:	687b      	ldr	r3, [r7, #4]
  413908:	701a      	strb	r2, [r3, #0]

	if(*pbyCharLSB < 0x0A)  *pbyCharLSB = *pbyCharLSB + 0x30;
  41390a:	68bb      	ldr	r3, [r7, #8]
  41390c:	781b      	ldrb	r3, [r3, #0]
  41390e:	2b09      	cmp	r3, #9
  413910:	d806      	bhi.n	413920 <BinToAsciiHex+0x6a>
  413912:	68bb      	ldr	r3, [r7, #8]
  413914:	781b      	ldrb	r3, [r3, #0]
  413916:	3330      	adds	r3, #48	; 0x30
  413918:	b2da      	uxtb	r2, r3
  41391a:	68bb      	ldr	r3, [r7, #8]
  41391c:	701a      	strb	r2, [r3, #0]
	else                    *pbyCharLSB = *pbyCharLSB + 0x37;
}
  41391e:	e005      	b.n	41392c <BinToAsciiHex+0x76>
	else                    *pbyCharLSB = *pbyCharLSB + 0x37;
  413920:	68bb      	ldr	r3, [r7, #8]
  413922:	781b      	ldrb	r3, [r3, #0]
  413924:	3337      	adds	r3, #55	; 0x37
  413926:	b2da      	uxtb	r2, r3
  413928:	68bb      	ldr	r3, [r7, #8]
  41392a:	701a      	strb	r2, [r3, #0]
}
  41392c:	bf00      	nop
  41392e:	3714      	adds	r7, #20
  413930:	46bd      	mov	sp, r7
  413932:	f85d 7b04 	ldr.w	r7, [sp], #4
  413936:	4770      	bx	lr

00413938 <ADC_CBUF_Init>:


// https://embedjournal.com/implementing-circular-buffer-embedded-c/
void ADC_CBUF_Init(void)
{
  413938:	b480      	push	{r7}
  41393a:	af00      	add	r7, sp, #0
	adc_cbuff.pchbuf = 	&chcbuf_data[0];
  41393c:	4b08      	ldr	r3, [pc, #32]	; (413960 <ADC_CBUF_Init+0x28>)
  41393e:	4a09      	ldr	r2, [pc, #36]	; (413964 <ADC_CBUF_Init+0x2c>)
  413940:	601a      	str	r2, [r3, #0]
	adc_cbuff.head = 0;
  413942:	4b07      	ldr	r3, [pc, #28]	; (413960 <ADC_CBUF_Init+0x28>)
  413944:	2200      	movs	r2, #0
  413946:	605a      	str	r2, [r3, #4]
	adc_cbuff.tail = 0;
  413948:	4b05      	ldr	r3, [pc, #20]	; (413960 <ADC_CBUF_Init+0x28>)
  41394a:	2200      	movs	r2, #0
  41394c:	609a      	str	r2, [r3, #8]
	adc_cbuff.maxlen = ADC_BUFFER_LINES;
  41394e:	4b04      	ldr	r3, [pc, #16]	; (413960 <ADC_CBUF_Init+0x28>)
  413950:	f242 7210 	movw	r2, #10000	; 0x2710
  413954:	60da      	str	r2, [r3, #12]
}
  413956:	bf00      	nop
  413958:	46bd      	mov	sp, r7
  41395a:	f85d 7b04 	ldr.w	r7, [sp], #4
  41395e:	4770      	bx	lr
  413960:	2000b6ec 	.word	0x2000b6ec
  413964:	63000000 	.word	0x63000000

00413968 <ADC_CBUF_push>:


int ADC_CBUF_push(CHBUF_DATA *data)
{
  413968:	b490      	push	{r4, r7}
  41396a:	b084      	sub	sp, #16
  41396c:	af00      	add	r7, sp, #0
  41396e:	6078      	str	r0, [r7, #4]
	uint32_t next;
	uint32_t size;

	next = adc_cbuff.head + 1;  // next is where head will point to after this write.
  413970:	4b58      	ldr	r3, [pc, #352]	; (413ad4 <ADC_CBUF_push+0x16c>)
  413972:	685b      	ldr	r3, [r3, #4]
  413974:	3301      	adds	r3, #1
  413976:	60fb      	str	r3, [r7, #12]

	if (next >= adc_cbuff.maxlen)
  413978:	4b56      	ldr	r3, [pc, #344]	; (413ad4 <ADC_CBUF_push+0x16c>)
  41397a:	68da      	ldr	r2, [r3, #12]
  41397c:	68fb      	ldr	r3, [r7, #12]
  41397e:	429a      	cmp	r2, r3
  413980:	d801      	bhi.n	413986 <ADC_CBUF_push+0x1e>
		next = 0;
  413982:	2300      	movs	r3, #0
  413984:	60fb      	str	r3, [r7, #12]

	if (next == adc_cbuff.tail)  // if the head + 1 == tail, circular buffer is full
  413986:	4b53      	ldr	r3, [pc, #332]	; (413ad4 <ADC_CBUF_push+0x16c>)
  413988:	689a      	ldr	r2, [r3, #8]
  41398a:	68fb      	ldr	r3, [r7, #12]
  41398c:	429a      	cmp	r2, r3
  41398e:	d102      	bne.n	413996 <ADC_CBUF_push+0x2e>
		return -1;
  413990:	f04f 33ff 	mov.w	r3, #4294967295
  413994:	e098      	b.n	413ac8 <ADC_CBUF_push+0x160>

	// Load data
	adc_cbuff.pchbuf[adc_cbuff.head].ulSample	     = data->ulSample;		
  413996:	4b4f      	ldr	r3, [pc, #316]	; (413ad4 <ADC_CBUF_push+0x16c>)
  413998:	681a      	ldr	r2, [r3, #0]
  41399a:	4b4e      	ldr	r3, [pc, #312]	; (413ad4 <ADC_CBUF_push+0x16c>)
  41399c:	685b      	ldr	r3, [r3, #4]
  41399e:	015b      	lsls	r3, r3, #5
  4139a0:	4413      	add	r3, r2
  4139a2:	687a      	ldr	r2, [r7, #4]
  4139a4:	6812      	ldr	r2, [r2, #0]
  4139a6:	601a      	str	r2, [r3, #0]
	adc_cbuff.pchbuf[adc_cbuff.head].ulTimestamp_sec = data->ulTimestamp_sec;
  4139a8:	4b4a      	ldr	r3, [pc, #296]	; (413ad4 <ADC_CBUF_push+0x16c>)
  4139aa:	681a      	ldr	r2, [r3, #0]
  4139ac:	4b49      	ldr	r3, [pc, #292]	; (413ad4 <ADC_CBUF_push+0x16c>)
  4139ae:	685b      	ldr	r3, [r3, #4]
  4139b0:	015b      	lsls	r3, r3, #5
  4139b2:	4413      	add	r3, r2
  4139b4:	687a      	ldr	r2, [r7, #4]
  4139b6:	6852      	ldr	r2, [r2, #4]
  4139b8:	605a      	str	r2, [r3, #4]
	adc_cbuff.pchbuf[adc_cbuff.head].usTimestamp_ms  = data->usTimestamp_ms;
  4139ba:	4b46      	ldr	r3, [pc, #280]	; (413ad4 <ADC_CBUF_push+0x16c>)
  4139bc:	681a      	ldr	r2, [r3, #0]
  4139be:	4b45      	ldr	r3, [pc, #276]	; (413ad4 <ADC_CBUF_push+0x16c>)
  4139c0:	685b      	ldr	r3, [r3, #4]
  4139c2:	015b      	lsls	r3, r3, #5
  4139c4:	4413      	add	r3, r2
  4139c6:	687a      	ldr	r2, [r7, #4]
  4139c8:	8912      	ldrh	r2, [r2, #8]
  4139ca:	811a      	strh	r2, [r3, #8]
	adc_cbuff.pchbuf[adc_cbuff.head].u64husec		 = data->u64husec;
  4139cc:	4b41      	ldr	r3, [pc, #260]	; (413ad4 <ADC_CBUF_push+0x16c>)
  4139ce:	681a      	ldr	r2, [r3, #0]
  4139d0:	4b40      	ldr	r3, [pc, #256]	; (413ad4 <ADC_CBUF_push+0x16c>)
  4139d2:	685b      	ldr	r3, [r3, #4]
  4139d4:	015b      	lsls	r3, r3, #5
  4139d6:	441a      	add	r2, r3
  4139d8:	687b      	ldr	r3, [r7, #4]
  4139da:	e9d3 3404 	ldrd	r3, r4, [r3, #16]
  4139de:	e9c2 3404 	strd	r3, r4, [r2, #16]

	adc_cbuff.pchbuf[adc_cbuff.head].rawGolay[0]	 = data->rawGolay[0];
  4139e2:	4b3c      	ldr	r3, [pc, #240]	; (413ad4 <ADC_CBUF_push+0x16c>)
  4139e4:	681a      	ldr	r2, [r3, #0]
  4139e6:	4b3b      	ldr	r3, [pc, #236]	; (413ad4 <ADC_CBUF_push+0x16c>)
  4139e8:	685b      	ldr	r3, [r3, #4]
  4139ea:	015b      	lsls	r3, r3, #5
  4139ec:	4413      	add	r3, r2
  4139ee:	687a      	ldr	r2, [r7, #4]
  4139f0:	7e12      	ldrb	r2, [r2, #24]
  4139f2:	761a      	strb	r2, [r3, #24]
	adc_cbuff.pchbuf[adc_cbuff.head].rawGolay[1]	 = data->rawGolay[1];
  4139f4:	4b37      	ldr	r3, [pc, #220]	; (413ad4 <ADC_CBUF_push+0x16c>)
  4139f6:	681a      	ldr	r2, [r3, #0]
  4139f8:	4b36      	ldr	r3, [pc, #216]	; (413ad4 <ADC_CBUF_push+0x16c>)
  4139fa:	685b      	ldr	r3, [r3, #4]
  4139fc:	015b      	lsls	r3, r3, #5
  4139fe:	4413      	add	r3, r2
  413a00:	687a      	ldr	r2, [r7, #4]
  413a02:	7e52      	ldrb	r2, [r2, #25]
  413a04:	765a      	strb	r2, [r3, #25]
	adc_cbuff.pchbuf[adc_cbuff.head].rawGolay[2]	 = data->rawGolay[2];
  413a06:	4b33      	ldr	r3, [pc, #204]	; (413ad4 <ADC_CBUF_push+0x16c>)
  413a08:	681a      	ldr	r2, [r3, #0]
  413a0a:	4b32      	ldr	r3, [pc, #200]	; (413ad4 <ADC_CBUF_push+0x16c>)
  413a0c:	685b      	ldr	r3, [r3, #4]
  413a0e:	015b      	lsls	r3, r3, #5
  413a10:	4413      	add	r3, r2
  413a12:	687a      	ldr	r2, [r7, #4]
  413a14:	7e92      	ldrb	r2, [r2, #26]
  413a16:	769a      	strb	r2, [r3, #26]
	adc_cbuff.pchbuf[adc_cbuff.head].rawGolay[3]	 = data->rawGolay[3];
  413a18:	4b2e      	ldr	r3, [pc, #184]	; (413ad4 <ADC_CBUF_push+0x16c>)
  413a1a:	681a      	ldr	r2, [r3, #0]
  413a1c:	4b2d      	ldr	r3, [pc, #180]	; (413ad4 <ADC_CBUF_push+0x16c>)
  413a1e:	685b      	ldr	r3, [r3, #4]
  413a20:	015b      	lsls	r3, r3, #5
  413a22:	4413      	add	r3, r2
  413a24:	687a      	ldr	r2, [r7, #4]
  413a26:	7ed2      	ldrb	r2, [r2, #27]
  413a28:	76da      	strb	r2, [r3, #27]

	adc_cbuff.pchbuf[adc_cbuff.head].rawPS[0]		= data->rawPS[0];
  413a2a:	4b2a      	ldr	r3, [pc, #168]	; (413ad4 <ADC_CBUF_push+0x16c>)
  413a2c:	681a      	ldr	r2, [r3, #0]
  413a2e:	4b29      	ldr	r3, [pc, #164]	; (413ad4 <ADC_CBUF_push+0x16c>)
  413a30:	685b      	ldr	r3, [r3, #4]
  413a32:	015b      	lsls	r3, r3, #5
  413a34:	4413      	add	r3, r2
  413a36:	687a      	ldr	r2, [r7, #4]
  413a38:	7f12      	ldrb	r2, [r2, #28]
  413a3a:	771a      	strb	r2, [r3, #28]
	adc_cbuff.pchbuf[adc_cbuff.head].rawPS[1]		= data->rawPS[1];
  413a3c:	4b25      	ldr	r3, [pc, #148]	; (413ad4 <ADC_CBUF_push+0x16c>)
  413a3e:	681a      	ldr	r2, [r3, #0]
  413a40:	4b24      	ldr	r3, [pc, #144]	; (413ad4 <ADC_CBUF_push+0x16c>)
  413a42:	685b      	ldr	r3, [r3, #4]
  413a44:	015b      	lsls	r3, r3, #5
  413a46:	4413      	add	r3, r2
  413a48:	687a      	ldr	r2, [r7, #4]
  413a4a:	7f52      	ldrb	r2, [r2, #29]
  413a4c:	775a      	strb	r2, [r3, #29]
	adc_cbuff.pchbuf[adc_cbuff.head].rawPS[2]		= data->rawPS[2];
  413a4e:	4b21      	ldr	r3, [pc, #132]	; (413ad4 <ADC_CBUF_push+0x16c>)
  413a50:	681a      	ldr	r2, [r3, #0]
  413a52:	4b20      	ldr	r3, [pc, #128]	; (413ad4 <ADC_CBUF_push+0x16c>)
  413a54:	685b      	ldr	r3, [r3, #4]
  413a56:	015b      	lsls	r3, r3, #5
  413a58:	4413      	add	r3, r2
  413a5a:	687a      	ldr	r2, [r7, #4]
  413a5c:	7f92      	ldrb	r2, [r2, #30]
  413a5e:	779a      	strb	r2, [r3, #30]
	adc_cbuff.pchbuf[adc_cbuff.head].rawPS[3]		= data->rawPS[3];
  413a60:	4b1c      	ldr	r3, [pc, #112]	; (413ad4 <ADC_CBUF_push+0x16c>)
  413a62:	681a      	ldr	r2, [r3, #0]
  413a64:	4b1b      	ldr	r3, [pc, #108]	; (413ad4 <ADC_CBUF_push+0x16c>)
  413a66:	685b      	ldr	r3, [r3, #4]
  413a68:	015b      	lsls	r3, r3, #5
  413a6a:	4413      	add	r3, r2
  413a6c:	687a      	ldr	r2, [r7, #4]
  413a6e:	7fd2      	ldrb	r2, [r2, #31]
  413a70:	77da      	strb	r2, [r3, #31]

	adc_cbuff.head = next;             // head to next data offset.
  413a72:	4a18      	ldr	r2, [pc, #96]	; (413ad4 <ADC_CBUF_push+0x16c>)
  413a74:	68fb      	ldr	r3, [r7, #12]
  413a76:	6053      	str	r3, [r2, #4]
	
	// Debug: registra FREE minimum ever
	if( adc_cbuff.head >= adc_cbuff.tail )
  413a78:	4b16      	ldr	r3, [pc, #88]	; (413ad4 <ADC_CBUF_push+0x16c>)
  413a7a:	685a      	ldr	r2, [r3, #4]
  413a7c:	4b15      	ldr	r3, [pc, #84]	; (413ad4 <ADC_CBUF_push+0x16c>)
  413a7e:	689b      	ldr	r3, [r3, #8]
  413a80:	429a      	cmp	r2, r3
  413a82:	d306      	bcc.n	413a92 <ADC_CBUF_push+0x12a>
	{	size = (adc_cbuff.head - adc_cbuff.tail);
  413a84:	4b13      	ldr	r3, [pc, #76]	; (413ad4 <ADC_CBUF_push+0x16c>)
  413a86:	685a      	ldr	r2, [r3, #4]
  413a88:	4b12      	ldr	r3, [pc, #72]	; (413ad4 <ADC_CBUF_push+0x16c>)
  413a8a:	689b      	ldr	r3, [r3, #8]
  413a8c:	1ad3      	subs	r3, r2, r3
  413a8e:	60bb      	str	r3, [r7, #8]
  413a90:	e008      	b.n	413aa4 <ADC_CBUF_push+0x13c>
	}
	else
	{	size = (adc_cbuff.maxlen + adc_cbuff.head - adc_cbuff.tail);
  413a92:	4b10      	ldr	r3, [pc, #64]	; (413ad4 <ADC_CBUF_push+0x16c>)
  413a94:	68da      	ldr	r2, [r3, #12]
  413a96:	4b0f      	ldr	r3, [pc, #60]	; (413ad4 <ADC_CBUF_push+0x16c>)
  413a98:	685b      	ldr	r3, [r3, #4]
  413a9a:	441a      	add	r2, r3
  413a9c:	4b0d      	ldr	r3, [pc, #52]	; (413ad4 <ADC_CBUF_push+0x16c>)
  413a9e:	689b      	ldr	r3, [r3, #8]
  413aa0:	1ad3      	subs	r3, r2, r3
  413aa2:	60bb      	str	r3, [r7, #8]
	}
	dwADCcbuff_sizeact = size;
  413aa4:	4a0c      	ldr	r2, [pc, #48]	; (413ad8 <ADC_CBUF_push+0x170>)
  413aa6:	68bb      	ldr	r3, [r7, #8]
  413aa8:	6013      	str	r3, [r2, #0]
	if (dwADCcbuff_sizefme > (adc_cbuff.maxlen-size) )
  413aaa:	4b0a      	ldr	r3, [pc, #40]	; (413ad4 <ADC_CBUF_push+0x16c>)
  413aac:	68da      	ldr	r2, [r3, #12]
  413aae:	68bb      	ldr	r3, [r7, #8]
  413ab0:	1ad2      	subs	r2, r2, r3
  413ab2:	4b0a      	ldr	r3, [pc, #40]	; (413adc <ADC_CBUF_push+0x174>)
  413ab4:	681b      	ldr	r3, [r3, #0]
  413ab6:	429a      	cmp	r2, r3
  413ab8:	d205      	bcs.n	413ac6 <ADC_CBUF_push+0x15e>
	{	dwADCcbuff_sizefme = adc_cbuff.maxlen-size;
  413aba:	4b06      	ldr	r3, [pc, #24]	; (413ad4 <ADC_CBUF_push+0x16c>)
  413abc:	68da      	ldr	r2, [r3, #12]
  413abe:	68bb      	ldr	r3, [r7, #8]
  413ac0:	1ad3      	subs	r3, r2, r3
  413ac2:	4a06      	ldr	r2, [pc, #24]	; (413adc <ADC_CBUF_push+0x174>)
  413ac4:	6013      	str	r3, [r2, #0]
	}
	
	return 0;  // return success to indicate successful push.
  413ac6:	2300      	movs	r3, #0
}
  413ac8:	4618      	mov	r0, r3
  413aca:	3710      	adds	r7, #16
  413acc:	46bd      	mov	sp, r7
  413ace:	bc90      	pop	{r4, r7}
  413ad0:	4770      	bx	lr
  413ad2:	bf00      	nop
  413ad4:	2000b6ec 	.word	0x2000b6ec
  413ad8:	2000b4e4 	.word	0x2000b4e4
  413adc:	2000012c 	.word	0x2000012c

00413ae0 <ADC_CBUF_pop>:


int ADC_CBUF_pop(CHBUF_DATA *data)
{
  413ae0:	b490      	push	{r4, r7}
  413ae2:	b084      	sub	sp, #16
  413ae4:	af00      	add	r7, sp, #0
  413ae6:	6078      	str	r0, [r7, #4]
	int next;

	if (adc_cbuff.head == adc_cbuff.tail)  // if the head == tail, we don't have any data
  413ae8:	4b45      	ldr	r3, [pc, #276]	; (413c00 <ADC_CBUF_pop+0x120>)
  413aea:	685a      	ldr	r2, [r3, #4]
  413aec:	4b44      	ldr	r3, [pc, #272]	; (413c00 <ADC_CBUF_pop+0x120>)
  413aee:	689b      	ldr	r3, [r3, #8]
  413af0:	429a      	cmp	r2, r3
  413af2:	d102      	bne.n	413afa <ADC_CBUF_pop+0x1a>
		return -1;
  413af4:	f04f 33ff 	mov.w	r3, #4294967295
  413af8:	e07c      	b.n	413bf4 <ADC_CBUF_pop+0x114>

	next = adc_cbuff.tail + 1;  // next is where tail will point to after this read.
  413afa:	4b41      	ldr	r3, [pc, #260]	; (413c00 <ADC_CBUF_pop+0x120>)
  413afc:	689b      	ldr	r3, [r3, #8]
  413afe:	3301      	adds	r3, #1
  413b00:	60fb      	str	r3, [r7, #12]

	if(next >= adc_cbuff.maxlen)
  413b02:	4b3f      	ldr	r3, [pc, #252]	; (413c00 <ADC_CBUF_pop+0x120>)
  413b04:	68da      	ldr	r2, [r3, #12]
  413b06:	68fb      	ldr	r3, [r7, #12]
  413b08:	429a      	cmp	r2, r3
  413b0a:	d801      	bhi.n	413b10 <ADC_CBUF_pop+0x30>
		next = 0;
  413b0c:	2300      	movs	r3, #0
  413b0e:	60fb      	str	r3, [r7, #12]

	// Read data
	data->ulSample			= adc_cbuff.pchbuf[adc_cbuff.tail].ulSample;	     
  413b10:	4b3b      	ldr	r3, [pc, #236]	; (413c00 <ADC_CBUF_pop+0x120>)
  413b12:	681a      	ldr	r2, [r3, #0]
  413b14:	4b3a      	ldr	r3, [pc, #232]	; (413c00 <ADC_CBUF_pop+0x120>)
  413b16:	689b      	ldr	r3, [r3, #8]
  413b18:	015b      	lsls	r3, r3, #5
  413b1a:	4413      	add	r3, r2
  413b1c:	681a      	ldr	r2, [r3, #0]
  413b1e:	687b      	ldr	r3, [r7, #4]
  413b20:	601a      	str	r2, [r3, #0]
	data->ulTimestamp_sec	= adc_cbuff.pchbuf[adc_cbuff.tail].ulTimestamp_sec;
  413b22:	4b37      	ldr	r3, [pc, #220]	; (413c00 <ADC_CBUF_pop+0x120>)
  413b24:	681a      	ldr	r2, [r3, #0]
  413b26:	4b36      	ldr	r3, [pc, #216]	; (413c00 <ADC_CBUF_pop+0x120>)
  413b28:	689b      	ldr	r3, [r3, #8]
  413b2a:	015b      	lsls	r3, r3, #5
  413b2c:	4413      	add	r3, r2
  413b2e:	685a      	ldr	r2, [r3, #4]
  413b30:	687b      	ldr	r3, [r7, #4]
  413b32:	605a      	str	r2, [r3, #4]
	data->usTimestamp_ms	= adc_cbuff.pchbuf[adc_cbuff.tail].usTimestamp_ms;
  413b34:	4b32      	ldr	r3, [pc, #200]	; (413c00 <ADC_CBUF_pop+0x120>)
  413b36:	681a      	ldr	r2, [r3, #0]
  413b38:	4b31      	ldr	r3, [pc, #196]	; (413c00 <ADC_CBUF_pop+0x120>)
  413b3a:	689b      	ldr	r3, [r3, #8]
  413b3c:	015b      	lsls	r3, r3, #5
  413b3e:	4413      	add	r3, r2
  413b40:	891a      	ldrh	r2, [r3, #8]
  413b42:	687b      	ldr	r3, [r7, #4]
  413b44:	811a      	strh	r2, [r3, #8]
	data->u64husec			= adc_cbuff.pchbuf[adc_cbuff.tail].u64husec;
  413b46:	4b2e      	ldr	r3, [pc, #184]	; (413c00 <ADC_CBUF_pop+0x120>)
  413b48:	681a      	ldr	r2, [r3, #0]
  413b4a:	4b2d      	ldr	r3, [pc, #180]	; (413c00 <ADC_CBUF_pop+0x120>)
  413b4c:	689b      	ldr	r3, [r3, #8]
  413b4e:	015b      	lsls	r3, r3, #5
  413b50:	4413      	add	r3, r2
  413b52:	e9d3 3404 	ldrd	r3, r4, [r3, #16]
  413b56:	687a      	ldr	r2, [r7, #4]
  413b58:	e9c2 3404 	strd	r3, r4, [r2, #16]
	
	data->rawGolay[0]		= adc_cbuff.pchbuf[adc_cbuff.tail].rawGolay[0];
  413b5c:	4b28      	ldr	r3, [pc, #160]	; (413c00 <ADC_CBUF_pop+0x120>)
  413b5e:	681a      	ldr	r2, [r3, #0]
  413b60:	4b27      	ldr	r3, [pc, #156]	; (413c00 <ADC_CBUF_pop+0x120>)
  413b62:	689b      	ldr	r3, [r3, #8]
  413b64:	015b      	lsls	r3, r3, #5
  413b66:	4413      	add	r3, r2
  413b68:	7e1a      	ldrb	r2, [r3, #24]
  413b6a:	687b      	ldr	r3, [r7, #4]
  413b6c:	761a      	strb	r2, [r3, #24]
	data->rawGolay[1]		= adc_cbuff.pchbuf[adc_cbuff.tail].rawGolay[1];
  413b6e:	4b24      	ldr	r3, [pc, #144]	; (413c00 <ADC_CBUF_pop+0x120>)
  413b70:	681a      	ldr	r2, [r3, #0]
  413b72:	4b23      	ldr	r3, [pc, #140]	; (413c00 <ADC_CBUF_pop+0x120>)
  413b74:	689b      	ldr	r3, [r3, #8]
  413b76:	015b      	lsls	r3, r3, #5
  413b78:	4413      	add	r3, r2
  413b7a:	7e5a      	ldrb	r2, [r3, #25]
  413b7c:	687b      	ldr	r3, [r7, #4]
  413b7e:	765a      	strb	r2, [r3, #25]
	data->rawGolay[2]		= adc_cbuff.pchbuf[adc_cbuff.tail].rawGolay[2];
  413b80:	4b1f      	ldr	r3, [pc, #124]	; (413c00 <ADC_CBUF_pop+0x120>)
  413b82:	681a      	ldr	r2, [r3, #0]
  413b84:	4b1e      	ldr	r3, [pc, #120]	; (413c00 <ADC_CBUF_pop+0x120>)
  413b86:	689b      	ldr	r3, [r3, #8]
  413b88:	015b      	lsls	r3, r3, #5
  413b8a:	4413      	add	r3, r2
  413b8c:	7e9a      	ldrb	r2, [r3, #26]
  413b8e:	687b      	ldr	r3, [r7, #4]
  413b90:	769a      	strb	r2, [r3, #26]
	data->rawGolay[3]		= adc_cbuff.pchbuf[adc_cbuff.tail].rawGolay[3];
  413b92:	4b1b      	ldr	r3, [pc, #108]	; (413c00 <ADC_CBUF_pop+0x120>)
  413b94:	681a      	ldr	r2, [r3, #0]
  413b96:	4b1a      	ldr	r3, [pc, #104]	; (413c00 <ADC_CBUF_pop+0x120>)
  413b98:	689b      	ldr	r3, [r3, #8]
  413b9a:	015b      	lsls	r3, r3, #5
  413b9c:	4413      	add	r3, r2
  413b9e:	7eda      	ldrb	r2, [r3, #27]
  413ba0:	687b      	ldr	r3, [r7, #4]
  413ba2:	76da      	strb	r2, [r3, #27]

	data->rawPS[0]			= adc_cbuff.pchbuf[adc_cbuff.tail].rawPS[0];
  413ba4:	4b16      	ldr	r3, [pc, #88]	; (413c00 <ADC_CBUF_pop+0x120>)
  413ba6:	681a      	ldr	r2, [r3, #0]
  413ba8:	4b15      	ldr	r3, [pc, #84]	; (413c00 <ADC_CBUF_pop+0x120>)
  413baa:	689b      	ldr	r3, [r3, #8]
  413bac:	015b      	lsls	r3, r3, #5
  413bae:	4413      	add	r3, r2
  413bb0:	7f1a      	ldrb	r2, [r3, #28]
  413bb2:	687b      	ldr	r3, [r7, #4]
  413bb4:	771a      	strb	r2, [r3, #28]
	data->rawPS[1]			= adc_cbuff.pchbuf[adc_cbuff.tail].rawPS[1];
  413bb6:	4b12      	ldr	r3, [pc, #72]	; (413c00 <ADC_CBUF_pop+0x120>)
  413bb8:	681a      	ldr	r2, [r3, #0]
  413bba:	4b11      	ldr	r3, [pc, #68]	; (413c00 <ADC_CBUF_pop+0x120>)
  413bbc:	689b      	ldr	r3, [r3, #8]
  413bbe:	015b      	lsls	r3, r3, #5
  413bc0:	4413      	add	r3, r2
  413bc2:	7f5a      	ldrb	r2, [r3, #29]
  413bc4:	687b      	ldr	r3, [r7, #4]
  413bc6:	775a      	strb	r2, [r3, #29]
	data->rawPS[2]			= adc_cbuff.pchbuf[adc_cbuff.tail].rawPS[2];
  413bc8:	4b0d      	ldr	r3, [pc, #52]	; (413c00 <ADC_CBUF_pop+0x120>)
  413bca:	681a      	ldr	r2, [r3, #0]
  413bcc:	4b0c      	ldr	r3, [pc, #48]	; (413c00 <ADC_CBUF_pop+0x120>)
  413bce:	689b      	ldr	r3, [r3, #8]
  413bd0:	015b      	lsls	r3, r3, #5
  413bd2:	4413      	add	r3, r2
  413bd4:	7f9a      	ldrb	r2, [r3, #30]
  413bd6:	687b      	ldr	r3, [r7, #4]
  413bd8:	779a      	strb	r2, [r3, #30]
	data->rawPS[3]			= adc_cbuff.pchbuf[adc_cbuff.tail].rawPS[3];
  413bda:	4b09      	ldr	r3, [pc, #36]	; (413c00 <ADC_CBUF_pop+0x120>)
  413bdc:	681a      	ldr	r2, [r3, #0]
  413bde:	4b08      	ldr	r3, [pc, #32]	; (413c00 <ADC_CBUF_pop+0x120>)
  413be0:	689b      	ldr	r3, [r3, #8]
  413be2:	015b      	lsls	r3, r3, #5
  413be4:	4413      	add	r3, r2
  413be6:	7fda      	ldrb	r2, [r3, #31]
  413be8:	687b      	ldr	r3, [r7, #4]
  413bea:	77da      	strb	r2, [r3, #31]

	adc_cbuff.tail = next;              // tail to next offset.
  413bec:	68fb      	ldr	r3, [r7, #12]
  413bee:	4a04      	ldr	r2, [pc, #16]	; (413c00 <ADC_CBUF_pop+0x120>)
  413bf0:	6093      	str	r3, [r2, #8]

	return 0;  // return success to indicate successful push.
  413bf2:	2300      	movs	r3, #0
}
  413bf4:	4618      	mov	r0, r3
  413bf6:	3710      	adds	r7, #16
  413bf8:	46bd      	mov	sp, r7
  413bfa:	bc90      	pop	{r4, r7}
  413bfc:	4770      	bx	lr
  413bfe:	bf00      	nop
  413c00:	2000b6ec 	.word	0x2000b6ec

00413c04 <ADC_CBUF_size>:

uint32_t ADC_CBUF_size(void)
{
  413c04:	b480      	push	{r7}
  413c06:	b083      	sub	sp, #12
  413c08:	af00      	add	r7, sp, #0
	uint32_t size;
	
	// HICS: AQUI TEM QUE SER ATOMICO
	if( adc_cbuff.head >= adc_cbuff.tail )
  413c0a:	4b0e      	ldr	r3, [pc, #56]	; (413c44 <ADC_CBUF_size+0x40>)
  413c0c:	685a      	ldr	r2, [r3, #4]
  413c0e:	4b0d      	ldr	r3, [pc, #52]	; (413c44 <ADC_CBUF_size+0x40>)
  413c10:	689b      	ldr	r3, [r3, #8]
  413c12:	429a      	cmp	r2, r3
  413c14:	d306      	bcc.n	413c24 <ADC_CBUF_size+0x20>
	{	size = (adc_cbuff.head - adc_cbuff.tail);
  413c16:	4b0b      	ldr	r3, [pc, #44]	; (413c44 <ADC_CBUF_size+0x40>)
  413c18:	685a      	ldr	r2, [r3, #4]
  413c1a:	4b0a      	ldr	r3, [pc, #40]	; (413c44 <ADC_CBUF_size+0x40>)
  413c1c:	689b      	ldr	r3, [r3, #8]
  413c1e:	1ad3      	subs	r3, r2, r3
  413c20:	607b      	str	r3, [r7, #4]
  413c22:	e008      	b.n	413c36 <ADC_CBUF_size+0x32>
	}
	else
	{	size = (adc_cbuff.maxlen + adc_cbuff.head - adc_cbuff.tail);
  413c24:	4b07      	ldr	r3, [pc, #28]	; (413c44 <ADC_CBUF_size+0x40>)
  413c26:	68da      	ldr	r2, [r3, #12]
  413c28:	4b06      	ldr	r3, [pc, #24]	; (413c44 <ADC_CBUF_size+0x40>)
  413c2a:	685b      	ldr	r3, [r3, #4]
  413c2c:	441a      	add	r2, r3
  413c2e:	4b05      	ldr	r3, [pc, #20]	; (413c44 <ADC_CBUF_size+0x40>)
  413c30:	689b      	ldr	r3, [r3, #8]
  413c32:	1ad3      	subs	r3, r2, r3
  413c34:	607b      	str	r3, [r7, #4]
	}
	
	return size;
  413c36:	687b      	ldr	r3, [r7, #4]
}
  413c38:	4618      	mov	r0, r3
  413c3a:	370c      	adds	r7, #12
  413c3c:	46bd      	mov	sp, r7
  413c3e:	f85d 7b04 	ldr.w	r7, [sp], #4
  413c42:	4770      	bx	lr
  413c44:	2000b6ec 	.word	0x2000b6ec

00413c48 <ADC_Init>:

void ADC_Init(void)
{
  413c48:	b590      	push	{r4, r7, lr}
  413c4a:	b083      	sub	sp, #12
  413c4c:	af02      	add	r7, sp, #8
	// Inicializa buffer circular
	ADC_CBUF_Init();
  413c4e:	4b1b      	ldr	r3, [pc, #108]	; (413cbc <ADC_Init+0x74>)
  413c50:	4798      	blx	r3
	
	// Init ADC
	ADC_Reset();				// Reset ADC
  413c52:	4b1b      	ldr	r3, [pc, #108]	; (413cc0 <ADC_Init+0x78>)
  413c54:	4798      	blx	r3
	ADC_SPI_init();				// Inicializa SPI para comunicar com ADC
  413c56:	4b1b      	ldr	r3, [pc, #108]	; (413cc4 <ADC_Init+0x7c>)
  413c58:	4798      	blx	r3
	ADC_ReadAllRegisters();		// Le e print registros de configuracao
  413c5a:	4b1b      	ldr	r3, [pc, #108]	; (413cc8 <ADC_Init+0x80>)
  413c5c:	4798      	blx	r3
	ADC_Config();				// Configura AD
  413c5e:	4b1b      	ldr	r3, [pc, #108]	; (413ccc <ADC_Init+0x84>)
  413c60:	4798      	blx	r3
	ADC_ReadAllRegisters();		// Le novamente e print registros para verificar se houve alteracoes
  413c62:	4b19      	ldr	r3, [pc, #100]	; (413cc8 <ADC_Init+0x80>)
  413c64:	4798      	blx	r3
	ADC_EnableReadADConSDO();	// Libera leitura amostras via SPI
  413c66:	4b1a      	ldr	r3, [pc, #104]	; (413cd0 <ADC_Init+0x88>)
  413c68:	4798      	blx	r3
	// Configure AD7770 DRDY signal trigger an interrupt on rising edge
	// DRDY vai gerar int a cada 1ms (ver DECIMATION RATE = 2048 (ODR = 1KHz) em AD7770_Config())
	// ANALISAR: Configuar PIN para gerar uma int ou um evento (ver exemplo 32-02-GPIO_ISR_EXAMPLE_SAM4L) ???

	//pmc_enable_periph_clk(ID_PIOA);	// Conector EXT1
	pmc_enable_periph_clk(ID_PIOD);	// Conector EXT3
  413c6a:	200c      	movs	r0, #12
  413c6c:	4b19      	ldr	r3, [pc, #100]	; (413cd4 <ADC_Init+0x8c>)
  413c6e:	4798      	blx	r3

	ioport_set_pin_dir(AD7770_DRDY_PIN, IOPORT_DIR_INPUT);  // DRDY
  413c70:	2100      	movs	r1, #0
  413c72:	2071      	movs	r0, #113	; 0x71
  413c74:	4b18      	ldr	r3, [pc, #96]	; (413cd8 <ADC_Init+0x90>)
  413c76:	4798      	blx	r3
	ioport_set_pin_mode(AD7770_DRDY_PIN, IOPORT_MODE_GLITCH_FILTER); // 
  413c78:	2140      	movs	r1, #64	; 0x40
  413c7a:	2071      	movs	r0, #113	; 0x71
  413c7c:	4b17      	ldr	r3, [pc, #92]	; (413cdc <ADC_Init+0x94>)
  413c7e:	4798      	blx	r3
	ioport_set_pin_sense_mode(AD7770_DRDY_PIN, IOPORT_SENSE_RISING);
  413c80:	2102      	movs	r1, #2
  413c82:	2071      	movs	r0, #113	; 0x71
  413c84:	4b16      	ldr	r3, [pc, #88]	; (413ce0 <ADC_Init+0x98>)
  413c86:	4798      	blx	r3

	pio_handler_set(PIOD, ID_PIOD, PIO_PD17, PIO_IT_RISE_EDGE, ADC_ReadADC_isr);	// Conector EXT3
  413c88:	4b16      	ldr	r3, [pc, #88]	; (413ce4 <ADC_Init+0x9c>)
  413c8a:	9300      	str	r3, [sp, #0]
  413c8c:	2370      	movs	r3, #112	; 0x70
  413c8e:	f44f 3200 	mov.w	r2, #131072	; 0x20000
  413c92:	210c      	movs	r1, #12
  413c94:	4814      	ldr	r0, [pc, #80]	; (413ce8 <ADC_Init+0xa0>)
  413c96:	4c15      	ldr	r4, [pc, #84]	; (413cec <ADC_Init+0xa4>)
  413c98:	47a0      	blx	r4
	
	NVIC_SetPriority(PIOD_IRQn,7);	
  413c9a:	2107      	movs	r1, #7
  413c9c:	200c      	movs	r0, #12
  413c9e:	4b14      	ldr	r3, [pc, #80]	; (413cf0 <ADC_Init+0xa8>)
  413ca0:	4798      	blx	r3

	pio_enable_interrupt(PIOD, PIO_PD17);		// Conector EXT3
  413ca2:	f44f 3100 	mov.w	r1, #131072	; 0x20000
  413ca6:	4810      	ldr	r0, [pc, #64]	; (413ce8 <ADC_Init+0xa0>)
  413ca8:	4b12      	ldr	r3, [pc, #72]	; (413cf4 <ADC_Init+0xac>)
  413caa:	4798      	blx	r3

	NVIC_EnableIRQ(PIOD_IRQn);		// Conector EXT3
  413cac:	200c      	movs	r0, #12
  413cae:	4b12      	ldr	r3, [pc, #72]	; (413cf8 <ADC_Init+0xb0>)
  413cb0:	4798      	blx	r3
	
}
  413cb2:	bf00      	nop
  413cb4:	3704      	adds	r7, #4
  413cb6:	46bd      	mov	sp, r7
  413cb8:	bd90      	pop	{r4, r7, pc}
  413cba:	bf00      	nop
  413cbc:	00413939 	.word	0x00413939
  413cc0:	00413cfd 	.word	0x00413cfd
  413cc4:	00413d5d 	.word	0x00413d5d
  413cc8:	00413da9 	.word	0x00413da9
  413ccc:	00413e89 	.word	0x00413e89
  413cd0:	00413f69 	.word	0x00413f69
  413cd4:	0040433d 	.word	0x0040433d
  413cd8:	004136d9 	.word	0x004136d9
  413cdc:	004135bd 	.word	0x004135bd
  413ce0:	004137cd 	.word	0x004137cd
  413ce4:	00413ff9 	.word	0x00413ff9
  413ce8:	400e1400 	.word	0x400e1400
  413cec:	00403ff9 	.word	0x00403ff9
  413cf0:	00413569 	.word	0x00413569
  413cf4:	00403d91 	.word	0x00403d91
  413cf8:	00413535 	.word	0x00413535

00413cfc <ADC_Reset>:


void ADC_Reset(void)
{
  413cfc:	b580      	push	{r7, lr}
  413cfe:	b082      	sub	sp, #8
  413d00:	af00      	add	r7, sp, #0
	const TickType_t x2ms = 2UL / portTICK_PERIOD_MS;	// Delay de 2ms
  413d02:	2302      	movs	r3, #2
  413d04:	607b      	str	r3, [r7, #4]
	//ioport_set_pin_level(PIO_PD25_IDX, IOPORT_PIN_LEVEL_HIGH);

	// Gera um pulso no RESET do AD7770 (pulso minimo de 2MCLK ns)
	// Atencao: pino reset do AD7770 nao pode ficar aberto
	// Conector EXT3
	ioport_set_pin_dir(PIO_PD26_IDX, IOPORT_DIR_OUTPUT);
  413d06:	2101      	movs	r1, #1
  413d08:	207a      	movs	r0, #122	; 0x7a
  413d0a:	4b0f      	ldr	r3, [pc, #60]	; (413d48 <ADC_Reset+0x4c>)
  413d0c:	4798      	blx	r3
	ioport_set_pin_level(PIO_PD26_IDX, IOPORT_PIN_LEVEL_HIGH);
  413d0e:	2101      	movs	r1, #1
  413d10:	207a      	movs	r0, #122	; 0x7a
  413d12:	4b0e      	ldr	r3, [pc, #56]	; (413d4c <ADC_Reset+0x50>)
  413d14:	4798      	blx	r3
	vTaskDelay( x2ms );	// Delay 2ms
  413d16:	6878      	ldr	r0, [r7, #4]
  413d18:	4b0d      	ldr	r3, [pc, #52]	; (413d50 <ADC_Reset+0x54>)
  413d1a:	4798      	blx	r3
	ioport_set_pin_level(PIO_PD26_IDX, IOPORT_PIN_LEVEL_LOW); 	
  413d1c:	2100      	movs	r1, #0
  413d1e:	207a      	movs	r0, #122	; 0x7a
  413d20:	4b0a      	ldr	r3, [pc, #40]	; (413d4c <ADC_Reset+0x50>)
  413d22:	4798      	blx	r3
	vTaskDelay( x2ms );	// Delay 2ms
  413d24:	6878      	ldr	r0, [r7, #4]
  413d26:	4b0a      	ldr	r3, [pc, #40]	; (413d50 <ADC_Reset+0x54>)
  413d28:	4798      	blx	r3
	ioport_set_pin_level(PIO_PD26_IDX, IOPORT_PIN_LEVEL_HIGH);
  413d2a:	2101      	movs	r1, #1
  413d2c:	207a      	movs	r0, #122	; 0x7a
  413d2e:	4b07      	ldr	r3, [pc, #28]	; (413d4c <ADC_Reset+0x50>)
  413d30:	4798      	blx	r3
	
	
	
	// tINIT_RESET RESET rising edge to first DRDY 16 kSPS, high resolution mode 225us
	vTaskDelay( x2ms );	// Delay 2ms
  413d32:	6878      	ldr	r0, [r7, #4]
  413d34:	4b06      	ldr	r3, [pc, #24]	; (413d50 <ADC_Reset+0x54>)
  413d36:	4798      	blx	r3

	printf ("\nAD7770_tINIT_RESET_delay!\n"); 
  413d38:	4806      	ldr	r0, [pc, #24]	; (413d54 <ADC_Reset+0x58>)
  413d3a:	4b07      	ldr	r3, [pc, #28]	; (413d58 <ADC_Reset+0x5c>)
  413d3c:	4798      	blx	r3

}
  413d3e:	bf00      	nop
  413d40:	3708      	adds	r7, #8
  413d42:	46bd      	mov	sp, r7
  413d44:	bd80      	pop	{r7, pc}
  413d46:	bf00      	nop
  413d48:	004136d9 	.word	0x004136d9
  413d4c:	00413761 	.word	0x00413761
  413d50:	0041256d 	.word	0x0041256d
  413d54:	0041e2a4 	.word	0x0041e2a4
  413d58:	00416c7d 	.word	0x00416c7d

00413d5c <ADC_SPI_init>:


void ADC_SPI_init(void)
{
  413d5c:	b590      	push	{r4, r7, lr}
  413d5e:	b083      	sub	sp, #12
  413d60:	af02      	add	r7, sp, #8
	spi_enable_clock(SPI);  
  413d62:	480a      	ldr	r0, [pc, #40]	; (413d8c <ADC_SPI_init+0x30>)
  413d64:	4b0a      	ldr	r3, [pc, #40]	; (413d90 <ADC_SPI_init+0x34>)
  413d66:	4798      	blx	r3
	
	// uC SAM4E is master
	spi_master_init(SPI);
  413d68:	4808      	ldr	r0, [pc, #32]	; (413d8c <ADC_SPI_init+0x30>)
  413d6a:	4b0a      	ldr	r3, [pc, #40]	; (413d94 <ADC_SPI_init+0x38>)
  413d6c:	4798      	blx	r3
	// - EVAL-AD7770 configured as SPI CONTROL MODE (FORMAT0 and FORMAT1 pins to logic high => jumpers SL5 and SL6 positon A)
	// - SPI operates in Mode 0 and Mode 3: CPOL = 0, CPHA = 0 (Mode 0) or CPOL = 1, CPHA = 1 (Mode 3)
	// - CLK period up to 30MHz
	//spi_master_setup_device(SPI, &spi_device_conf, SPI_MODE_0, 1000000, 0); // 1MHz (1us per bit)   (256bits = 256us)
	//spi_master_setup_device(SPI, &spi_device_conf, SPI_MODE_0, 10000000, 0); // 10MHz (0.1us per bit) (256bits = 25.6us)
	spi_master_setup_device(SPI, &spi_device_conf, SPI_MODE_0, 20000000, 0); // 20MHz (0.05us per bit) (256bits = 12.8us) => HICS_HFchanges
  413d6e:	2300      	movs	r3, #0
  413d70:	9300      	str	r3, [sp, #0]
  413d72:	4b09      	ldr	r3, [pc, #36]	; (413d98 <ADC_SPI_init+0x3c>)
  413d74:	2200      	movs	r2, #0
  413d76:	4909      	ldr	r1, [pc, #36]	; (413d9c <ADC_SPI_init+0x40>)
  413d78:	4804      	ldr	r0, [pc, #16]	; (413d8c <ADC_SPI_init+0x30>)
  413d7a:	4c09      	ldr	r4, [pc, #36]	; (413da0 <ADC_SPI_init+0x44>)
  413d7c:	47a0      	blx	r4
	
	spi_enable(SPI);
  413d7e:	4803      	ldr	r0, [pc, #12]	; (413d8c <ADC_SPI_init+0x30>)
  413d80:	4b08      	ldr	r3, [pc, #32]	; (413da4 <ADC_SPI_init+0x48>)
  413d82:	4798      	blx	r3
}
  413d84:	bf00      	nop
  413d86:	3704      	adds	r7, #4
  413d88:	46bd      	mov	sp, r7
  413d8a:	bd90      	pop	{r4, r7, pc}
  413d8c:	40088000 	.word	0x40088000
  413d90:	00404491 	.word	0x00404491
  413d94:	004003f9 	.word	0x004003f9
  413d98:	01312d00 	.word	0x01312d00
  413d9c:	20000130 	.word	0x20000130
  413da0:	00400469 	.word	0x00400469
  413da4:	0041389d 	.word	0x0041389d

00413da8 <ADC_ReadAllRegisters>:

void ADC_ReadAllRegisters(void)
{
  413da8:	b580      	push	{r7, lr}
  413daa:	b09c      	sub	sp, #112	; 0x70
  413dac:	af00      	add	r7, sp, #0
	uint8_t wr_buff[1];
	uint8_t rd_buff[AD7770_NUMBER_OF_REGISTERS];
	uint8_t by;
	
	// Read all registers
	spi_select_device(SPI, &spi_device_conf);
  413dae:	492c      	ldr	r1, [pc, #176]	; (413e60 <ADC_ReadAllRegisters+0xb8>)
  413db0:	482c      	ldr	r0, [pc, #176]	; (413e64 <ADC_ReadAllRegisters+0xbc>)
  413db2:	4b2d      	ldr	r3, [pc, #180]	; (413e68 <ADC_ReadAllRegisters+0xc0>)
  413db4:	4798      	blx	r3
	for (by=0; by<AD7770_NUMBER_OF_REGISTERS; by++)
  413db6:	2300      	movs	r3, #0
  413db8:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
  413dbc:	e01b      	b.n	413df6 <ADC_ReadAllRegisters+0x4e>
	{	wr_buff[0] = 0x80 | by;	// For read operation MSB must be equal to 1
  413dbe:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
  413dc2:	f063 037f 	orn	r3, r3, #127	; 0x7f
  413dc6:	b2db      	uxtb	r3, r3
  413dc8:	f887 306c 	strb.w	r3, [r7, #108]	; 0x6c
		spi_write_packet(SPI, wr_buff, 1);
  413dcc:	f107 036c 	add.w	r3, r7, #108	; 0x6c
  413dd0:	2201      	movs	r2, #1
  413dd2:	4619      	mov	r1, r3
  413dd4:	4823      	ldr	r0, [pc, #140]	; (413e64 <ADC_ReadAllRegisters+0xbc>)
  413dd6:	4b25      	ldr	r3, [pc, #148]	; (413e6c <ADC_ReadAllRegisters+0xc4>)
  413dd8:	4798      	blx	r3
		spi_read_packet (SPI, &rd_buff[by], 1);
  413dda:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
  413dde:	1d3a      	adds	r2, r7, #4
  413de0:	4413      	add	r3, r2
  413de2:	2201      	movs	r2, #1
  413de4:	4619      	mov	r1, r3
  413de6:	481f      	ldr	r0, [pc, #124]	; (413e64 <ADC_ReadAllRegisters+0xbc>)
  413de8:	4b21      	ldr	r3, [pc, #132]	; (413e70 <ADC_ReadAllRegisters+0xc8>)
  413dea:	4798      	blx	r3
	for (by=0; by<AD7770_NUMBER_OF_REGISTERS; by++)
  413dec:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
  413df0:	3301      	adds	r3, #1
  413df2:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
  413df6:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
  413dfa:	2b64      	cmp	r3, #100	; 0x64
  413dfc:	d9df      	bls.n	413dbe <ADC_ReadAllRegisters+0x16>
	}
	spi_deselect_device(SPI, &spi_device_conf);
  413dfe:	4918      	ldr	r1, [pc, #96]	; (413e60 <ADC_ReadAllRegisters+0xb8>)
  413e00:	4818      	ldr	r0, [pc, #96]	; (413e64 <ADC_ReadAllRegisters+0xbc>)
  413e02:	4b1c      	ldr	r3, [pc, #112]	; (413e74 <ADC_ReadAllRegisters+0xcc>)
  413e04:	4798      	blx	r3

	// Print all registers
	printf ("\nAD7770 Registers data from 0x00 to %02X:\n",AD7770_NUMBER_OF_REGISTERS-1);
  413e06:	2164      	movs	r1, #100	; 0x64
  413e08:	481b      	ldr	r0, [pc, #108]	; (413e78 <ADC_ReadAllRegisters+0xd0>)
  413e0a:	4b1c      	ldr	r3, [pc, #112]	; (413e7c <ADC_ReadAllRegisters+0xd4>)
  413e0c:	4798      	blx	r3
	for (by=0; by<AD7770_NUMBER_OF_REGISTERS; by++)
  413e0e:	2300      	movs	r3, #0
  413e10:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
  413e14:	e019      	b.n	413e4a <ADC_ReadAllRegisters+0xa2>
	{	printf ("%02X ",rd_buff[by]);
  413e16:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
  413e1a:	f107 0270 	add.w	r2, r7, #112	; 0x70
  413e1e:	4413      	add	r3, r2
  413e20:	f813 3c6c 	ldrb.w	r3, [r3, #-108]
  413e24:	4619      	mov	r1, r3
  413e26:	4816      	ldr	r0, [pc, #88]	; (413e80 <ADC_ReadAllRegisters+0xd8>)
  413e28:	4b14      	ldr	r3, [pc, #80]	; (413e7c <ADC_ReadAllRegisters+0xd4>)
  413e2a:	4798      	blx	r3
		if ((by+1)%16 == 0)
  413e2c:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
  413e30:	3301      	adds	r3, #1
  413e32:	f003 030f 	and.w	r3, r3, #15
  413e36:	2b00      	cmp	r3, #0
  413e38:	d102      	bne.n	413e40 <ADC_ReadAllRegisters+0x98>
			printf ("\n");
  413e3a:	4812      	ldr	r0, [pc, #72]	; (413e84 <ADC_ReadAllRegisters+0xdc>)
  413e3c:	4b0f      	ldr	r3, [pc, #60]	; (413e7c <ADC_ReadAllRegisters+0xd4>)
  413e3e:	4798      	blx	r3
	for (by=0; by<AD7770_NUMBER_OF_REGISTERS; by++)
  413e40:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
  413e44:	3301      	adds	r3, #1
  413e46:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
  413e4a:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
  413e4e:	2b64      	cmp	r3, #100	; 0x64
  413e50:	d9e1      	bls.n	413e16 <ADC_ReadAllRegisters+0x6e>
	}
	printf ("\n");
  413e52:	480c      	ldr	r0, [pc, #48]	; (413e84 <ADC_ReadAllRegisters+0xdc>)
  413e54:	4b09      	ldr	r3, [pc, #36]	; (413e7c <ADC_ReadAllRegisters+0xd4>)
  413e56:	4798      	blx	r3


}
  413e58:	bf00      	nop
  413e5a:	3770      	adds	r7, #112	; 0x70
  413e5c:	46bd      	mov	sp, r7
  413e5e:	bd80      	pop	{r7, pc}
  413e60:	20000130 	.word	0x20000130
  413e64:	40088000 	.word	0x40088000
  413e68:	0040051d 	.word	0x0040051d
  413e6c:	004005b1 	.word	0x004005b1
  413e70:	00400625 	.word	0x00400625
  413e74:	00400575 	.word	0x00400575
  413e78:	0041e2c0 	.word	0x0041e2c0
  413e7c:	00416c7d 	.word	0x00416c7d
  413e80:	0041e2ec 	.word	0x0041e2ec
  413e84:	0041e2f4 	.word	0x0041e2f4

00413e88 <ADC_Config>:

void ADC_Config(void)
{
  413e88:	b580      	push	{r7, lr}
  413e8a:	b082      	sub	sp, #8
  413e8c:	af00      	add	r7, sp, #0
	uint8_t buff[2];

	printf ("\nAD7770 config main registers:\n");
  413e8e:	482c      	ldr	r0, [pc, #176]	; (413f40 <ADC_Config+0xb8>)
  413e90:	4b2c      	ldr	r3, [pc, #176]	; (413f44 <ADC_Config+0xbc>)
  413e92:	4798      	blx	r3

	// POWERMODE = High resolution
	printf ("=> POWERMODE = High resolution (reg 0x11 bit6=1)\n");
  413e94:	482c      	ldr	r0, [pc, #176]	; (413f48 <ADC_Config+0xc0>)
  413e96:	4b2b      	ldr	r3, [pc, #172]	; (413f44 <ADC_Config+0xbc>)
  413e98:	4798      	blx	r3
	buff[0] = 0x11;	// Operation: write GENERAL_USER_CONFIG_1 register (address: 0x11)
  413e9a:	2311      	movs	r3, #17
  413e9c:	713b      	strb	r3, [r7, #4]
	buff[1] = 0x64;	// bit 6 = 1 (POWERMODE = High resolution)
  413e9e:	2364      	movs	r3, #100	; 0x64
  413ea0:	717b      	strb	r3, [r7, #5]
	spi_select_device(SPI, &spi_device_conf);
  413ea2:	492a      	ldr	r1, [pc, #168]	; (413f4c <ADC_Config+0xc4>)
  413ea4:	482a      	ldr	r0, [pc, #168]	; (413f50 <ADC_Config+0xc8>)
  413ea6:	4b2b      	ldr	r3, [pc, #172]	; (413f54 <ADC_Config+0xcc>)
  413ea8:	4798      	blx	r3
	spi_write_packet(SPI, &buff[0], 2);
  413eaa:	1d3b      	adds	r3, r7, #4
  413eac:	2202      	movs	r2, #2
  413eae:	4619      	mov	r1, r3
  413eb0:	4827      	ldr	r0, [pc, #156]	; (413f50 <ADC_Config+0xc8>)
  413eb2:	4b29      	ldr	r3, [pc, #164]	; (413f58 <ADC_Config+0xd0>)
  413eb4:	4798      	blx	r3
	spi_deselect_device(SPI, &spi_device_conf);
  413eb6:	4925      	ldr	r1, [pc, #148]	; (413f4c <ADC_Config+0xc4>)
  413eb8:	4825      	ldr	r0, [pc, #148]	; (413f50 <ADC_Config+0xc8>)
  413eba:	4b28      	ldr	r3, [pc, #160]	; (413f5c <ADC_Config+0xd4>)
  413ebc:	4798      	blx	r3
	
	// Config DECIMATION RATE = 2048 (0x0800) (e consequentemente ODR (output data rate) sera igual a 1KHz)
	printf ("=> DECIMATION RATE = 2048 (ODR = 1KHz) (reg 0x60=0x08 and reg 0x61=00)\n");
  413ebe:	4828      	ldr	r0, [pc, #160]	; (413f60 <ADC_Config+0xd8>)
  413ec0:	4b20      	ldr	r3, [pc, #128]	; (413f44 <ADC_Config+0xbc>)
  413ec2:	4798      	blx	r3
	buff[0] = 0x60;	// Operation: write SRC_N_MSB register (address: 0x60)
  413ec4:	2360      	movs	r3, #96	; 0x60
  413ec6:	713b      	strb	r3, [r7, #4]
	buff[1] = 0x08;	// MSB of 0x0800 
  413ec8:	2308      	movs	r3, #8
  413eca:	717b      	strb	r3, [r7, #5]
	spi_select_device(SPI, &spi_device_conf);
  413ecc:	491f      	ldr	r1, [pc, #124]	; (413f4c <ADC_Config+0xc4>)
  413ece:	4820      	ldr	r0, [pc, #128]	; (413f50 <ADC_Config+0xc8>)
  413ed0:	4b20      	ldr	r3, [pc, #128]	; (413f54 <ADC_Config+0xcc>)
  413ed2:	4798      	blx	r3
	spi_write_packet(SPI, &buff[0], 2);
  413ed4:	1d3b      	adds	r3, r7, #4
  413ed6:	2202      	movs	r2, #2
  413ed8:	4619      	mov	r1, r3
  413eda:	481d      	ldr	r0, [pc, #116]	; (413f50 <ADC_Config+0xc8>)
  413edc:	4b1e      	ldr	r3, [pc, #120]	; (413f58 <ADC_Config+0xd0>)
  413ede:	4798      	blx	r3
	spi_deselect_device(SPI, &spi_device_conf);
  413ee0:	491a      	ldr	r1, [pc, #104]	; (413f4c <ADC_Config+0xc4>)
  413ee2:	481b      	ldr	r0, [pc, #108]	; (413f50 <ADC_Config+0xc8>)
  413ee4:	4b1d      	ldr	r3, [pc, #116]	; (413f5c <ADC_Config+0xd4>)
  413ee6:	4798      	blx	r3
	buff[0] = 0x61;	// Operation: write SRC_N_LSB register (address: 0x61)
  413ee8:	2361      	movs	r3, #97	; 0x61
  413eea:	713b      	strb	r3, [r7, #4]
	buff[1] = 0x00;	// LSB of 0x0800
  413eec:	2300      	movs	r3, #0
  413eee:	717b      	strb	r3, [r7, #5]
	spi_select_device(SPI, &spi_device_conf);
  413ef0:	4916      	ldr	r1, [pc, #88]	; (413f4c <ADC_Config+0xc4>)
  413ef2:	4817      	ldr	r0, [pc, #92]	; (413f50 <ADC_Config+0xc8>)
  413ef4:	4b17      	ldr	r3, [pc, #92]	; (413f54 <ADC_Config+0xcc>)
  413ef6:	4798      	blx	r3
	spi_write_packet(SPI, &buff[0], 2);
  413ef8:	1d3b      	adds	r3, r7, #4
  413efa:	2202      	movs	r2, #2
  413efc:	4619      	mov	r1, r3
  413efe:	4814      	ldr	r0, [pc, #80]	; (413f50 <ADC_Config+0xc8>)
  413f00:	4b15      	ldr	r3, [pc, #84]	; (413f58 <ADC_Config+0xd0>)
  413f02:	4798      	blx	r3
	spi_deselect_device(SPI, &spi_device_conf);
  413f04:	4911      	ldr	r1, [pc, #68]	; (413f4c <ADC_Config+0xc4>)
  413f06:	4812      	ldr	r0, [pc, #72]	; (413f50 <ADC_Config+0xc8>)
  413f08:	4b14      	ldr	r3, [pc, #80]	; (413f5c <ADC_Config+0xd4>)
  413f0a:	4798      	blx	r3
	// New ODR value is updated by setting the SRC_LOAD_UPDATE bit to 1
	// There are two different ways to change the ODR after a new value is written in the SRC registers: via software or via hardware,
	// depending on SRC_LOAD_SOURCE (SRC_UPDATE register, Bit 7).
	// If the SRC_LOAD_SOURCE bit is clear, the new ODR value is updated by setting the SRC_LOAD_UPDATE bit to 1. This bit must be held high
	// for at least two MLCK periods; return the bit to 0 before attempting another update.
	printf ("=> New ODR value is updated by setting the SRC_LOAD_UPDATE bit to 1\n");
  413f0c:	4815      	ldr	r0, [pc, #84]	; (413f64 <ADC_Config+0xdc>)
  413f0e:	4b0d      	ldr	r3, [pc, #52]	; (413f44 <ADC_Config+0xbc>)
  413f10:	4798      	blx	r3
	buff[0] = 0x64;	// Operation: write SRC_UPDATE register (address: 0x64)
  413f12:	2364      	movs	r3, #100	; 0x64
  413f14:	713b      	strb	r3, [r7, #4]
	buff[1] = 0x01;	// SRC_LOAD_UPDATE bit = 1
  413f16:	2301      	movs	r3, #1
  413f18:	717b      	strb	r3, [r7, #5]
	spi_select_device(SPI, &spi_device_conf);
  413f1a:	490c      	ldr	r1, [pc, #48]	; (413f4c <ADC_Config+0xc4>)
  413f1c:	480c      	ldr	r0, [pc, #48]	; (413f50 <ADC_Config+0xc8>)
  413f1e:	4b0d      	ldr	r3, [pc, #52]	; (413f54 <ADC_Config+0xcc>)
  413f20:	4798      	blx	r3
	spi_write_packet(SPI, &buff[0], 2);
  413f22:	1d3b      	adds	r3, r7, #4
  413f24:	2202      	movs	r2, #2
  413f26:	4619      	mov	r1, r3
  413f28:	4809      	ldr	r0, [pc, #36]	; (413f50 <ADC_Config+0xc8>)
  413f2a:	4b0b      	ldr	r3, [pc, #44]	; (413f58 <ADC_Config+0xd0>)
  413f2c:	4798      	blx	r3
	spi_deselect_device(SPI, &spi_device_conf);
  413f2e:	4907      	ldr	r1, [pc, #28]	; (413f4c <ADC_Config+0xc4>)
  413f30:	4807      	ldr	r0, [pc, #28]	; (413f50 <ADC_Config+0xc8>)
  413f32:	4b0a      	ldr	r3, [pc, #40]	; (413f5c <ADC_Config+0xd4>)
  413f34:	4798      	blx	r3

	
}
  413f36:	bf00      	nop
  413f38:	3708      	adds	r7, #8
  413f3a:	46bd      	mov	sp, r7
  413f3c:	bd80      	pop	{r7, pc}
  413f3e:	bf00      	nop
  413f40:	0041e2f8 	.word	0x0041e2f8
  413f44:	00416c7d 	.word	0x00416c7d
  413f48:	0041e318 	.word	0x0041e318
  413f4c:	20000130 	.word	0x20000130
  413f50:	40088000 	.word	0x40088000
  413f54:	0040051d 	.word	0x0040051d
  413f58:	004005b1 	.word	0x004005b1
  413f5c:	00400575 	.word	0x00400575
  413f60:	0041e34c 	.word	0x0041e34c
  413f64:	0041e394 	.word	0x0041e394

00413f68 <ADC_EnableReadADConSDO>:


void ADC_EnableReadADConSDO(void)
{
  413f68:	b580      	push	{r7, lr}
  413f6a:	b082      	sub	sp, #8
  413f6c:	af00      	add	r7, sp, #0
	uint8_t buff[2];

	printf ("\nAD7770 ENABLE SPI slave mode to read back ADC on SDO!\n\n");
  413f6e:	4819      	ldr	r0, [pc, #100]	; (413fd4 <ADC_EnableReadADConSDO+0x6c>)
  413f70:	4b19      	ldr	r3, [pc, #100]	; (413fd8 <ADC_EnableReadADConSDO+0x70>)
  413f72:	4798      	blx	r3
	
	// Enable to SPI slave mode to read back ADC on SDO
	// 0x013	GENERAL_USER_CONFIG_3	[7:0]	CONVST_ DEGLITCH_DIS	RESERVED	SPI_SLAVE_MODE_EN	RESERVED 	CLK_QUAL_DIS	0x80

	buff[0] = 0x80 | 0x13;	// Operation: read GENERAL_USER_CONFIG_3 register (For read operation MSB must be equal to 1)
  413f74:	2393      	movs	r3, #147	; 0x93
  413f76:	713b      	strb	r3, [r7, #4]
	spi_select_device(SPI, &spi_device_conf);
  413f78:	4918      	ldr	r1, [pc, #96]	; (413fdc <ADC_EnableReadADConSDO+0x74>)
  413f7a:	4819      	ldr	r0, [pc, #100]	; (413fe0 <ADC_EnableReadADConSDO+0x78>)
  413f7c:	4b19      	ldr	r3, [pc, #100]	; (413fe4 <ADC_EnableReadADConSDO+0x7c>)
  413f7e:	4798      	blx	r3
	spi_write_packet(SPI, &buff[0], 1);
  413f80:	1d3b      	adds	r3, r7, #4
  413f82:	2201      	movs	r2, #1
  413f84:	4619      	mov	r1, r3
  413f86:	4816      	ldr	r0, [pc, #88]	; (413fe0 <ADC_EnableReadADConSDO+0x78>)
  413f88:	4b17      	ldr	r3, [pc, #92]	; (413fe8 <ADC_EnableReadADConSDO+0x80>)
  413f8a:	4798      	blx	r3
	spi_read_packet (SPI, &buff[1], 1);
  413f8c:	1d3b      	adds	r3, r7, #4
  413f8e:	3301      	adds	r3, #1
  413f90:	2201      	movs	r2, #1
  413f92:	4619      	mov	r1, r3
  413f94:	4812      	ldr	r0, [pc, #72]	; (413fe0 <ADC_EnableReadADConSDO+0x78>)
  413f96:	4b15      	ldr	r3, [pc, #84]	; (413fec <ADC_EnableReadADConSDO+0x84>)
  413f98:	4798      	blx	r3
	spi_deselect_device(SPI, &spi_device_conf);
  413f9a:	4910      	ldr	r1, [pc, #64]	; (413fdc <ADC_EnableReadADConSDO+0x74>)
  413f9c:	4810      	ldr	r0, [pc, #64]	; (413fe0 <ADC_EnableReadADConSDO+0x78>)
  413f9e:	4b14      	ldr	r3, [pc, #80]	; (413ff0 <ADC_EnableReadADConSDO+0x88>)
  413fa0:	4798      	blx	r3
	
	buff[0] =  0x13;	// Operation: write GENERAL_USER_CONFIG_3 register
  413fa2:	2313      	movs	r3, #19
  413fa4:	713b      	strb	r3, [r7, #4]
	buff[1] |= 0x10;	// Set SPI_SLAVE_MODE_EN bit
  413fa6:	797b      	ldrb	r3, [r7, #5]
  413fa8:	f043 0310 	orr.w	r3, r3, #16
  413fac:	b2db      	uxtb	r3, r3
  413fae:	717b      	strb	r3, [r7, #5]
	spi_select_device(SPI, &spi_device_conf);
  413fb0:	490a      	ldr	r1, [pc, #40]	; (413fdc <ADC_EnableReadADConSDO+0x74>)
  413fb2:	480b      	ldr	r0, [pc, #44]	; (413fe0 <ADC_EnableReadADConSDO+0x78>)
  413fb4:	4b0b      	ldr	r3, [pc, #44]	; (413fe4 <ADC_EnableReadADConSDO+0x7c>)
  413fb6:	4798      	blx	r3
	spi_write_packet(SPI, &buff[0], 2);
  413fb8:	1d3b      	adds	r3, r7, #4
  413fba:	2202      	movs	r2, #2
  413fbc:	4619      	mov	r1, r3
  413fbe:	4808      	ldr	r0, [pc, #32]	; (413fe0 <ADC_EnableReadADConSDO+0x78>)
  413fc0:	4b09      	ldr	r3, [pc, #36]	; (413fe8 <ADC_EnableReadADConSDO+0x80>)
  413fc2:	4798      	blx	r3
	spi_deselect_device(SPI, &spi_device_conf);
  413fc4:	4905      	ldr	r1, [pc, #20]	; (413fdc <ADC_EnableReadADConSDO+0x74>)
  413fc6:	4806      	ldr	r0, [pc, #24]	; (413fe0 <ADC_EnableReadADConSDO+0x78>)
  413fc8:	4b09      	ldr	r3, [pc, #36]	; (413ff0 <ADC_EnableReadADConSDO+0x88>)
  413fca:	4798      	blx	r3

}
  413fcc:	bf00      	nop
  413fce:	3708      	adds	r7, #8
  413fd0:	46bd      	mov	sp, r7
  413fd2:	bd80      	pop	{r7, pc}
  413fd4:	0041e3dc 	.word	0x0041e3dc
  413fd8:	00416c7d 	.word	0x00416c7d
  413fdc:	20000130 	.word	0x20000130
  413fe0:	40088000 	.word	0x40088000
  413fe4:	0040051d 	.word	0x0040051d
  413fe8:	004005b1 	.word	0x004005b1
  413fec:	00400625 	.word	0x00400625
  413ff0:	00400575 	.word	0x00400575
  413ff4:	00000000 	.word	0x00000000

00413ff8 <ADC_ReadADC_isr>:
	
}

// Sinal DRDY vai gerar int a cada 1ms (ver DECIMATION RATE = 2048 (ODR = 1KHz) em AD7770_Config())
void ADC_ReadADC_isr(const uint32_t id, const uint32_t index)
{
  413ff8:	b590      	push	{r4, r7, lr}
  413ffa:	b099      	sub	sp, #100	; 0x64
  413ffc:	af00      	add	r7, sp, #0
  413ffe:	6078      	str	r0, [r7, #4]
  414000:	6039      	str	r1, [r7, #0]
	uint8_t	by;
	
	UBaseType_t uxSavedInterruptStatus;
	
	//if ((id == ID_PIOA) && (index == PIO_PA25))	// Conector EXT1
	if ((id == ID_PIOD) && (index == PIO_PD17))	// Conector EXT3
  414002:	687b      	ldr	r3, [r7, #4]
  414004:	2b0c      	cmp	r3, #12
  414006:	f040 80cf 	bne.w	4141a8 <ADC_ReadADC_isr+0x1b0>
  41400a:	683b      	ldr	r3, [r7, #0]
  41400c:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
  414010:	f040 80ca 	bne.w	4141a8 <ADC_ReadADC_isr+0x1b0>
	{

		ioport_set_pin_level(PIO_PA24_IDX, IOPORT_PIN_LEVEL_HIGH);	// HICS debug: Utiliza PA24 (conector EXT1-5) como sinal de teste da ISR ADC
  414014:	2101      	movs	r1, #1
  414016:	2018      	movs	r0, #24
  414018:	4b67      	ldr	r3, [pc, #412]	; (4141b8 <ADC_ReadADC_isr+0x1c0>)
  41401a:	4798      	blx	r3
	__asm volatile
  41401c:	f3ef 8211 	mrs	r2, BASEPRI
  414020:	f04f 0350 	mov.w	r3, #80	; 0x50
  414024:	f383 8811 	msr	BASEPRI, r3
  414028:	f3bf 8f6f 	isb	sy
  41402c:	f3bf 8f4f 	dsb	sy
  414030:	657a      	str	r2, [r7, #84]	; 0x54
  414032:	653b      	str	r3, [r7, #80]	; 0x50
	return ulOriginalBASEPRI;
  414034:	6d7b      	ldr	r3, [r7, #84]	; 0x54

		//taskDISABLE_INTERRUPTS();	// Leitura tem que ser atomica
		uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();	
  414036:	65bb      	str	r3, [r7, #88]	; 0x58
		//taskENTER_CRITICAL();
		//portDISABLE_INTERRUPTS();

		byWDT_adcisr_ok=1;	// Sinaliza ISR ADC ok
  414038:	4b60      	ldr	r3, [pc, #384]	; (4141bc <ADC_ReadADC_isr+0x1c4>)
  41403a:	2201      	movs	r2, #1
  41403c:	701a      	strb	r2, [r3, #0]

		dwDRDYpulse++;
  41403e:	4b60      	ldr	r3, [pc, #384]	; (4141c0 <ADC_ReadADC_isr+0x1c8>)
  414040:	681b      	ldr	r3, [r3, #0]
  414042:	3301      	adds	r3, #1
  414044:	4a5e      	ldr	r2, [pc, #376]	; (4141c0 <ADC_ReadADC_isr+0x1c8>)
  414046:	6013      	str	r3, [r2, #0]
		
		// Incrementa timestamp do HICS (seconds and ms)
		// Utiliza ISR 1ms do sinal DRDY como tick de tempo para as amostras
		if (++hts.usMs > 999)
  414048:	4b5e      	ldr	r3, [pc, #376]	; (4141c4 <ADC_ReadADC_isr+0x1cc>)
  41404a:	889b      	ldrh	r3, [r3, #4]
  41404c:	3301      	adds	r3, #1
  41404e:	b29a      	uxth	r2, r3
  414050:	4b5c      	ldr	r3, [pc, #368]	; (4141c4 <ADC_ReadADC_isr+0x1cc>)
  414052:	809a      	strh	r2, [r3, #4]
  414054:	4b5b      	ldr	r3, [pc, #364]	; (4141c4 <ADC_ReadADC_isr+0x1cc>)
  414056:	889b      	ldrh	r3, [r3, #4]
  414058:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
  41405c:	d307      	bcc.n	41406e <ADC_ReadADC_isr+0x76>
		{	hts.usMs=0;
  41405e:	4b59      	ldr	r3, [pc, #356]	; (4141c4 <ADC_ReadADC_isr+0x1cc>)
  414060:	2200      	movs	r2, #0
  414062:	809a      	strh	r2, [r3, #4]
			hts.ulSec++;
  414064:	4b57      	ldr	r3, [pc, #348]	; (4141c4 <ADC_ReadADC_isr+0x1cc>)
  414066:	681b      	ldr	r3, [r3, #0]
  414068:	3301      	adds	r3, #1
  41406a:	4a56      	ldr	r2, [pc, #344]	; (4141c4 <ADC_ReadADC_isr+0x1cc>)
  41406c:	6013      	str	r3, [r2, #0]
		}
		
		// Incrementa timestamp do HICS (husecs)
		hts.u64husec+=10;	 // Incrementa o milesegundo do husec (nmero de centenas de microsegundos (=0,1 milisegundos))
  41406e:	4b55      	ldr	r3, [pc, #340]	; (4141c4 <ADC_ReadADC_isr+0x1cc>)
  414070:	e9d3 3402 	ldrd	r3, r4, [r3, #8]
  414074:	330a      	adds	r3, #10
  414076:	f144 0400 	adc.w	r4, r4, #0
  41407a:	4a52      	ldr	r2, [pc, #328]	; (4141c4 <ADC_ReadADC_isr+0x1cc>)
  41407c:	e9c2 3402 	strd	r3, r4, [r2, #8]
		if (hts.u64husec >= HUSEC_ONEDAY_HUSECS)
  414080:	4b50      	ldr	r3, [pc, #320]	; (4141c4 <ADC_ReadADC_isr+0x1cc>)
  414082:	e9d3 3402 	ldrd	r3, r4, [r3, #8]
  414086:	a24a      	add	r2, pc, #296	; (adr r2, 4141b0 <ADC_ReadADC_isr+0x1b8>)
  414088:	e9d2 1200 	ldrd	r1, r2, [r2]
  41408c:	42a2      	cmp	r2, r4
  41408e:	bf08      	it	eq
  414090:	4299      	cmpeq	r1, r3
  414092:	d206      	bcs.n	4140a2 <ADC_ReadADC_isr+0xaa>
		{	hts.u64husec=0;
  414094:	4a4b      	ldr	r2, [pc, #300]	; (4141c4 <ADC_ReadADC_isr+0x1cc>)
  414096:	f04f 0300 	mov.w	r3, #0
  41409a:	f04f 0400 	mov.w	r4, #0
  41409e:	e9c2 3402 	strd	r3, r4, [r2, #8]
		}

		// Incrementa tick schedulers		
		if (hsched.ps_rst==0) 
  4140a2:	4b49      	ldr	r3, [pc, #292]	; (4141c8 <ADC_ReadADC_isr+0x1d0>)
  4140a4:	7b1b      	ldrb	r3, [r3, #12]
  4140a6:	2b00      	cmp	r3, #0
  4140a8:	d105      	bne.n	4140b6 <ADC_ReadADC_isr+0xbe>
		{	hsched.ps++;
  4140aa:	4b47      	ldr	r3, [pc, #284]	; (4141c8 <ADC_ReadADC_isr+0x1d0>)
  4140ac:	689b      	ldr	r3, [r3, #8]
  4140ae:	3301      	adds	r3, #1
  4140b0:	4a45      	ldr	r2, [pc, #276]	; (4141c8 <ADC_ReadADC_isr+0x1d0>)
  4140b2:	6093      	str	r3, [r2, #8]
  4140b4:	e005      	b.n	4140c2 <ADC_ReadADC_isr+0xca>
		}
		else 
		{	hsched.ps=0; 
  4140b6:	4b44      	ldr	r3, [pc, #272]	; (4141c8 <ADC_ReadADC_isr+0x1d0>)
  4140b8:	2200      	movs	r2, #0
  4140ba:	609a      	str	r2, [r3, #8]
			hsched.ps_rst=0; 
  4140bc:	4b42      	ldr	r3, [pc, #264]	; (4141c8 <ADC_ReadADC_isr+0x1d0>)
  4140be:	2200      	movs	r2, #0
  4140c0:	731a      	strb	r2, [r3, #12]
		}

		if (hsched.sntp_rst==0)
  4140c2:	4b41      	ldr	r3, [pc, #260]	; (4141c8 <ADC_ReadADC_isr+0x1d0>)
  4140c4:	791b      	ldrb	r3, [r3, #4]
  4140c6:	2b00      	cmp	r3, #0
  4140c8:	d105      	bne.n	4140d6 <ADC_ReadADC_isr+0xde>
		{	hsched.sntp++;
  4140ca:	4b3f      	ldr	r3, [pc, #252]	; (4141c8 <ADC_ReadADC_isr+0x1d0>)
  4140cc:	681b      	ldr	r3, [r3, #0]
  4140ce:	3301      	adds	r3, #1
  4140d0:	4a3d      	ldr	r2, [pc, #244]	; (4141c8 <ADC_ReadADC_isr+0x1d0>)
  4140d2:	6013      	str	r3, [r2, #0]
  4140d4:	e005      	b.n	4140e2 <ADC_ReadADC_isr+0xea>
		}
		else
		{	hsched.sntp=0;
  4140d6:	4b3c      	ldr	r3, [pc, #240]	; (4141c8 <ADC_ReadADC_isr+0x1d0>)
  4140d8:	2200      	movs	r2, #0
  4140da:	601a      	str	r2, [r3, #0]
			hsched.sntp_rst=0;
  4140dc:	4b3a      	ldr	r3, [pc, #232]	; (4141c8 <ADC_ReadADC_isr+0x1d0>)
  4140de:	2200      	movs	r2, #0
  4140e0:	711a      	strb	r2, [r3, #4]
		}
		
		
		// "clear" buffer
		for (by=0; by<ADC_8CH_BUFFER_SIZEOF; by++)
  4140e2:	2300      	movs	r3, #0
  4140e4:	f887 305f 	strb.w	r3, [r7, #95]	; 0x5f
  4140e8:	e00c      	b.n	414104 <ADC_ReadADC_isr+0x10c>
			adc_buff[by] = 0x55; 
  4140ea:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
  4140ee:	f107 0260 	add.w	r2, r7, #96	; 0x60
  4140f2:	4413      	add	r3, r2
  4140f4:	2255      	movs	r2, #85	; 0x55
  4140f6:	f803 2c58 	strb.w	r2, [r3, #-88]
		for (by=0; by<ADC_8CH_BUFFER_SIZEOF; by++)
  4140fa:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
  4140fe:	3301      	adds	r3, #1
  414100:	f887 305f 	strb.w	r3, [r7, #95]	; 0x5f
  414104:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
  414108:	2b1f      	cmp	r3, #31
  41410a:	d9ee      	bls.n	4140ea <ADC_ReadADC_isr+0xf2>
	
		// Read all 8 channels (each channel => header 8-bit + adc 24-bit)
		spi_select_device(SPI, &spi_device_conf);
  41410c:	492f      	ldr	r1, [pc, #188]	; (4141cc <ADC_ReadADC_isr+0x1d4>)
  41410e:	4830      	ldr	r0, [pc, #192]	; (4141d0 <ADC_ReadADC_isr+0x1d8>)
  414110:	4b30      	ldr	r3, [pc, #192]	; (4141d4 <ADC_ReadADC_isr+0x1dc>)
  414112:	4798      	blx	r3
		spi_read_packet (SPI, &adc_buff, ADC_8CH_BUFFER_SIZEOF);
  414114:	f107 0308 	add.w	r3, r7, #8
  414118:	2220      	movs	r2, #32
  41411a:	4619      	mov	r1, r3
  41411c:	482c      	ldr	r0, [pc, #176]	; (4141d0 <ADC_ReadADC_isr+0x1d8>)
  41411e:	4b2e      	ldr	r3, [pc, #184]	; (4141d8 <ADC_ReadADC_isr+0x1e0>)
  414120:	4798      	blx	r3
		spi_deselect_device(SPI, &spi_device_conf);
  414122:	492a      	ldr	r1, [pc, #168]	; (4141cc <ADC_ReadADC_isr+0x1d4>)
  414124:	482a      	ldr	r0, [pc, #168]	; (4141d0 <ADC_ReadADC_isr+0x1d8>)
  414126:	4b2d      	ldr	r3, [pc, #180]	; (4141dc <ADC_ReadADC_isr+0x1e4>)
  414128:	4798      	blx	r3

		// Copia conteudo raw do canal 0 (POWER SUPPLY) para a struct
		chdata.rawPS[0] = adc_buff[0];
  41412a:	7a3b      	ldrb	r3, [r7, #8]
  41412c:	f887 3044 	strb.w	r3, [r7, #68]	; 0x44
		chdata.rawPS[1] = adc_buff[1];
  414130:	7a7b      	ldrb	r3, [r7, #9]
  414132:	f887 3045 	strb.w	r3, [r7, #69]	; 0x45
		chdata.rawPS[2] = adc_buff[2];
  414136:	7abb      	ldrb	r3, [r7, #10]
  414138:	f887 3046 	strb.w	r3, [r7, #70]	; 0x46
		chdata.rawPS[3] = adc_buff[3];
  41413c:	7afb      	ldrb	r3, [r7, #11]
  41413e:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
		
		// Copia conteudo raw do canal 3 (CELULA DE GOLAY) para a struct
		chdata.rawGolay[0] = adc_buff[12];
  414142:	7d3b      	ldrb	r3, [r7, #20]
  414144:	f887 3040 	strb.w	r3, [r7, #64]	; 0x40
		chdata.rawGolay[1] = adc_buff[13];
  414148:	7d7b      	ldrb	r3, [r7, #21]
  41414a:	f887 3041 	strb.w	r3, [r7, #65]	; 0x41
		chdata.rawGolay[2] = adc_buff[14];
  41414e:	7dbb      	ldrb	r3, [r7, #22]
  414150:	f887 3042 	strb.w	r3, [r7, #66]	; 0x42
		chdata.rawGolay[3] = adc_buff[15];
  414154:	7dfb      	ldrb	r3, [r7, #23]
  414156:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43

		// Copia numero da amostra e timestamp
		chdata.ulSample			= dwDRDYpulse;
  41415a:	4b19      	ldr	r3, [pc, #100]	; (4141c0 <ADC_ReadADC_isr+0x1c8>)
  41415c:	681b      	ldr	r3, [r3, #0]
  41415e:	62bb      	str	r3, [r7, #40]	; 0x28
		chdata.ulTimestamp_sec  = hts.ulSec;
  414160:	4b18      	ldr	r3, [pc, #96]	; (4141c4 <ADC_ReadADC_isr+0x1cc>)
  414162:	681b      	ldr	r3, [r3, #0]
  414164:	62fb      	str	r3, [r7, #44]	; 0x2c
		chdata.usTimestamp_ms   = hts.usMs;
  414166:	4b17      	ldr	r3, [pc, #92]	; (4141c4 <ADC_ReadADC_isr+0x1cc>)
  414168:	889b      	ldrh	r3, [r3, #4]
  41416a:	863b      	strh	r3, [r7, #48]	; 0x30
		chdata.u64husec			= hts.u64husec;
  41416c:	4b15      	ldr	r3, [pc, #84]	; (4141c4 <ADC_ReadADC_isr+0x1cc>)
  41416e:	e9d3 3402 	ldrd	r3, r4, [r3, #8]
  414172:	e9c7 340e 	strd	r3, r4, [r7, #56]	; 0x38

		// Adiciona dados da amostragem no buffer circular
		if (ADC_CBUF_push(&chdata)==-1)
  414176:	f107 0328 	add.w	r3, r7, #40	; 0x28
  41417a:	4618      	mov	r0, r3
  41417c:	4b18      	ldr	r3, [pc, #96]	; (4141e0 <ADC_ReadADC_isr+0x1e8>)
  41417e:	4798      	blx	r3
  414180:	4603      	mov	r3, r0
  414182:	f1b3 3fff 	cmp.w	r3, #4294967295
  414186:	d106      	bne.n	414196 <ADC_ReadADC_isr+0x19e>
		{	wADCcbuff_sizefulln++;
  414188:	4b16      	ldr	r3, [pc, #88]	; (4141e4 <ADC_ReadADC_isr+0x1ec>)
  41418a:	881b      	ldrh	r3, [r3, #0]
  41418c:	b29b      	uxth	r3, r3
  41418e:	3301      	adds	r3, #1
  414190:	b29a      	uxth	r2, r3
  414192:	4b14      	ldr	r3, [pc, #80]	; (4141e4 <ADC_ReadADC_isr+0x1ec>)
  414194:	801a      	strh	r2, [r3, #0]
  414196:	6dbb      	ldr	r3, [r7, #88]	; 0x58
  414198:	64fb      	str	r3, [r7, #76]	; 0x4c
	__asm volatile
  41419a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  41419c:	f383 8811 	msr	BASEPRI, r3
		//portENABLE_INTERRUPTS();
		//taskEXIT_CRITICAL();
		taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus ); 
		//taskENABLE_INTERRUPTS();
	
		ioport_set_pin_level(PIO_PA24_IDX, IOPORT_PIN_LEVEL_LOW);	// HICS debug
  4141a0:	2100      	movs	r1, #0
  4141a2:	2018      	movs	r0, #24
  4141a4:	4b04      	ldr	r3, [pc, #16]	; (4141b8 <ADC_ReadADC_isr+0x1c0>)
  4141a6:	4798      	blx	r3

	}
	
}
  4141a8:	bf00      	nop
  4141aa:	3764      	adds	r7, #100	; 0x64
  4141ac:	46bd      	mov	sp, r7
  4141ae:	bd90      	pop	{r4, r7, pc}
  4141b0:	337f97ff 	.word	0x337f97ff
  4141b4:	00000000 	.word	0x00000000
  4141b8:	00413761 	.word	0x00413761
  4141bc:	2000b536 	.word	0x2000b536
  4141c0:	2000b4dc 	.word	0x2000b4dc
  4141c4:	2000bc90 	.word	0x2000bc90
  4141c8:	2000bc7c 	.word	0x2000bc7c
  4141cc:	20000130 	.word	0x20000130
  4141d0:	40088000 	.word	0x40088000
  4141d4:	0040051d 	.word	0x0040051d
  4141d8:	00400625 	.word	0x00400625
  4141dc:	00400575 	.word	0x00400575
  4141e0:	00413969 	.word	0x00413969
  4141e4:	2000b4e0 	.word	0x2000b4e0

004141e8 <ADC_task_steps>:
volatile uint32_t dwLostSamples_lost_o=0;
volatile uint32_t dwLostSamples_lost_n=0;


void ADC_task_steps(void)
{
  4141e8:	b580      	push	{r7, lr}
  4141ea:	b094      	sub	sp, #80	; 0x50
  4141ec:	af00      	add	r7, sp, #0
	CHBUF_DATA  chdata;
	uint32_t	dwCBuffSize;
	uint8_t		*pby, by, byBuff[32];
	int8_t		i;

	switch (byADC_Task_step)
  4141ee:	4bc5      	ldr	r3, [pc, #788]	; (414504 <ADC_task_steps+0x31c>)
  4141f0:	781b      	ldrb	r3, [r3, #0]
  4141f2:	2b04      	cmp	r3, #4
  4141f4:	f200 832d 	bhi.w	414852 <ADC_task_steps+0x66a>
  4141f8:	a201      	add	r2, pc, #4	; (adr r2, 414200 <ADC_task_steps+0x18>)
  4141fa:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  4141fe:	bf00      	nop
  414200:	00414215 	.word	0x00414215
  414204:	00414227 	.word	0x00414227
  414208:	0041423b 	.word	0x0041423b
  41420c:	00414819 	.word	0x00414819
  414210:	0041483d 	.word	0x0041483d
	{
		case ADC_TASK_STEP_WAIT_FOR_NETWORK:
			if( stSocket_ADC.can_create != pdFALSE )
  414214:	4bbc      	ldr	r3, [pc, #752]	; (414508 <ADC_task_steps+0x320>)
  414216:	7b1b      	ldrb	r3, [r3, #12]
  414218:	2b00      	cmp	r3, #0
  41421a:	f000 8315 	beq.w	414848 <ADC_task_steps+0x660>
			{	byADC_Task_step = ADC_TASK_STEP_OPEN_SOCKET;
  41421e:	4bb9      	ldr	r3, [pc, #740]	; (414504 <ADC_task_steps+0x31c>)
  414220:	2201      	movs	r2, #1
  414222:	701a      	strb	r2, [r3, #0]
			}
			break;
  414224:	e310      	b.n	414848 <ADC_task_steps+0x660>

		case ADC_TASK_STEP_OPEN_SOCKET:
			if (vSocket_ADC_tcp_create() == pdPASS)
  414226:	4bb9      	ldr	r3, [pc, #740]	; (41450c <ADC_task_steps+0x324>)
  414228:	4798      	blx	r3
  41422a:	4603      	mov	r3, r0
  41422c:	2b01      	cmp	r3, #1
  41422e:	f040 830d 	bne.w	41484c <ADC_task_steps+0x664>
			{	byADC_Task_step = ADC_TASK_STEP_POP_DATA;
  414232:	4bb4      	ldr	r3, [pc, #720]	; (414504 <ADC_task_steps+0x31c>)
  414234:	2202      	movs	r2, #2
  414236:	701a      	strb	r2, [r3, #0]
			}
			break;
  414238:	e308      	b.n	41484c <ADC_task_steps+0x664>
		
		
		 case ADC_TASK_STEP_POP_DATA:
			dwCBuffSize=ADC_CBUF_size();
  41423a:	4bb5      	ldr	r3, [pc, #724]	; (414510 <ADC_task_steps+0x328>)
  41423c:	4798      	blx	r3
  41423e:	6478      	str	r0, [r7, #68]	; 0x44
			if (dwCBuffSize >= 20)
  414240:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  414242:	2b13      	cmp	r3, #19
  414244:	f240 8304 	bls.w	414850 <ADC_task_steps+0x668>
			{	
				wADCtx_mtu_n=0;
  414248:	4bb2      	ldr	r3, [pc, #712]	; (414514 <ADC_task_steps+0x32c>)
  41424a:	2200      	movs	r2, #0
  41424c:	801a      	strh	r2, [r3, #0]
				do
				{
					if (ADC_CBUF_pop(&chdata) == -1)
  41424e:	f107 0320 	add.w	r3, r7, #32
  414252:	4618      	mov	r0, r3
  414254:	4bb0      	ldr	r3, [pc, #704]	; (414518 <ADC_task_steps+0x330>)
  414256:	4798      	blx	r3
  414258:	4603      	mov	r3, r0
  41425a:	f1b3 3fff 	cmp.w	r3, #4294967295
  41425e:	f000 82d1 	beq.w	414804 <ADC_task_steps+0x61c>
						break;	// Buffer esvaziou


					// Monta buffer ASCII-HEX
					byADCtx_sprintf_n=0;
  414262:	4bae      	ldr	r3, [pc, #696]	; (41451c <ADC_task_steps+0x334>)
  414264:	2200      	movs	r2, #0
  414266:	701a      	strb	r2, [r3, #0]
				
					pby = &chdata.ulSample;	// 4 bytes
  414268:	f107 0320 	add.w	r3, r7, #32
  41426c:	64fb      	str	r3, [r7, #76]	; 0x4c
					for (by=0, i=0; by < sizeof(chdata.ulSample); by++, i+=2)
  41426e:	2300      	movs	r3, #0
  414270:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b
  414274:	2300      	movs	r3, #0
  414276:	f887 304a 	strb.w	r3, [r7, #74]	; 0x4a
  41427a:	e01a      	b.n	4142b2 <ADC_task_steps+0xca>
					{	BinToAsciiHex(*pby++, &byBuff[i], &byBuff[i+1]);
  41427c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  41427e:	1c5a      	adds	r2, r3, #1
  414280:	64fa      	str	r2, [r7, #76]	; 0x4c
  414282:	7818      	ldrb	r0, [r3, #0]
  414284:	f997 304a 	ldrsb.w	r3, [r7, #74]	; 0x4a
  414288:	463a      	mov	r2, r7
  41428a:	18d1      	adds	r1, r2, r3
  41428c:	f997 304a 	ldrsb.w	r3, [r7, #74]	; 0x4a
  414290:	3301      	adds	r3, #1
  414292:	463a      	mov	r2, r7
  414294:	4413      	add	r3, r2
  414296:	461a      	mov	r2, r3
  414298:	4ba1      	ldr	r3, [pc, #644]	; (414520 <ADC_task_steps+0x338>)
  41429a:	4798      	blx	r3
					for (by=0, i=0; by < sizeof(chdata.ulSample); by++, i+=2)
  41429c:	f897 304b 	ldrb.w	r3, [r7, #75]	; 0x4b
  4142a0:	3301      	adds	r3, #1
  4142a2:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b
  4142a6:	f897 304a 	ldrb.w	r3, [r7, #74]	; 0x4a
  4142aa:	3302      	adds	r3, #2
  4142ac:	b2db      	uxtb	r3, r3
  4142ae:	f887 304a 	strb.w	r3, [r7, #74]	; 0x4a
  4142b2:	f897 304b 	ldrb.w	r3, [r7, #75]	; 0x4b
  4142b6:	2b03      	cmp	r3, #3
  4142b8:	d9e0      	bls.n	41427c <ADC_task_steps+0x94>
					}
					while ( (--i) >= 0)
  4142ba:	e010      	b.n	4142de <ADC_task_steps+0xf6>
					{	byADCtx_sprintf_buff[byADCtx_sprintf_n++] = byBuff[i];	// MSB First
  4142bc:	4b97      	ldr	r3, [pc, #604]	; (41451c <ADC_task_steps+0x334>)
  4142be:	781b      	ldrb	r3, [r3, #0]
  4142c0:	b2db      	uxtb	r3, r3
  4142c2:	1c5a      	adds	r2, r3, #1
  4142c4:	b2d1      	uxtb	r1, r2
  4142c6:	4a95      	ldr	r2, [pc, #596]	; (41451c <ADC_task_steps+0x334>)
  4142c8:	7011      	strb	r1, [r2, #0]
  4142ca:	461a      	mov	r2, r3
  4142cc:	f997 304a 	ldrsb.w	r3, [r7, #74]	; 0x4a
  4142d0:	f107 0150 	add.w	r1, r7, #80	; 0x50
  4142d4:	440b      	add	r3, r1
  4142d6:	f813 1c50 	ldrb.w	r1, [r3, #-80]
  4142da:	4b92      	ldr	r3, [pc, #584]	; (414524 <ADC_task_steps+0x33c>)
  4142dc:	5499      	strb	r1, [r3, r2]
					while ( (--i) >= 0)
  4142de:	f897 304a 	ldrb.w	r3, [r7, #74]	; 0x4a
  4142e2:	3b01      	subs	r3, #1
  4142e4:	b2db      	uxtb	r3, r3
  4142e6:	f887 304a 	strb.w	r3, [r7, #74]	; 0x4a
  4142ea:	f997 304a 	ldrsb.w	r3, [r7, #74]	; 0x4a
  4142ee:	2b00      	cmp	r3, #0
  4142f0:	dae4      	bge.n	4142bc <ADC_task_steps+0xd4>
					}
					
					byADCtx_sprintf_buff[byADCtx_sprintf_n++] = 0x20; // Space
  4142f2:	4b8a      	ldr	r3, [pc, #552]	; (41451c <ADC_task_steps+0x334>)
  4142f4:	781b      	ldrb	r3, [r3, #0]
  4142f6:	b2db      	uxtb	r3, r3
  4142f8:	1c5a      	adds	r2, r3, #1
  4142fa:	b2d1      	uxtb	r1, r2
  4142fc:	4a87      	ldr	r2, [pc, #540]	; (41451c <ADC_task_steps+0x334>)
  4142fe:	7011      	strb	r1, [r2, #0]
  414300:	461a      	mov	r2, r3
  414302:	4b88      	ldr	r3, [pc, #544]	; (414524 <ADC_task_steps+0x33c>)
  414304:	2120      	movs	r1, #32
  414306:	5499      	strb	r1, [r3, r2]
					
					pby = &chdata.ulTimestamp_sec;
  414308:	f107 0320 	add.w	r3, r7, #32
  41430c:	3304      	adds	r3, #4
  41430e:	64fb      	str	r3, [r7, #76]	; 0x4c
					for (by=0, i=0; by < sizeof(chdata.ulTimestamp_sec); by++, i+=2)
  414310:	2300      	movs	r3, #0
  414312:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b
  414316:	2300      	movs	r3, #0
  414318:	f887 304a 	strb.w	r3, [r7, #74]	; 0x4a
  41431c:	e01a      	b.n	414354 <ADC_task_steps+0x16c>
					{	BinToAsciiHex(*pby++, &byBuff[i], &byBuff[i+1]);
  41431e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  414320:	1c5a      	adds	r2, r3, #1
  414322:	64fa      	str	r2, [r7, #76]	; 0x4c
  414324:	7818      	ldrb	r0, [r3, #0]
  414326:	f997 304a 	ldrsb.w	r3, [r7, #74]	; 0x4a
  41432a:	463a      	mov	r2, r7
  41432c:	18d1      	adds	r1, r2, r3
  41432e:	f997 304a 	ldrsb.w	r3, [r7, #74]	; 0x4a
  414332:	3301      	adds	r3, #1
  414334:	463a      	mov	r2, r7
  414336:	4413      	add	r3, r2
  414338:	461a      	mov	r2, r3
  41433a:	4b79      	ldr	r3, [pc, #484]	; (414520 <ADC_task_steps+0x338>)
  41433c:	4798      	blx	r3
					for (by=0, i=0; by < sizeof(chdata.ulTimestamp_sec); by++, i+=2)
  41433e:	f897 304b 	ldrb.w	r3, [r7, #75]	; 0x4b
  414342:	3301      	adds	r3, #1
  414344:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b
  414348:	f897 304a 	ldrb.w	r3, [r7, #74]	; 0x4a
  41434c:	3302      	adds	r3, #2
  41434e:	b2db      	uxtb	r3, r3
  414350:	f887 304a 	strb.w	r3, [r7, #74]	; 0x4a
  414354:	f897 304b 	ldrb.w	r3, [r7, #75]	; 0x4b
  414358:	2b03      	cmp	r3, #3
  41435a:	d9e0      	bls.n	41431e <ADC_task_steps+0x136>
					}
					while ( (--i) >= 0)
  41435c:	e010      	b.n	414380 <ADC_task_steps+0x198>
					{	byADCtx_sprintf_buff[byADCtx_sprintf_n++] = byBuff[i];	// MSB First					
  41435e:	4b6f      	ldr	r3, [pc, #444]	; (41451c <ADC_task_steps+0x334>)
  414360:	781b      	ldrb	r3, [r3, #0]
  414362:	b2db      	uxtb	r3, r3
  414364:	1c5a      	adds	r2, r3, #1
  414366:	b2d1      	uxtb	r1, r2
  414368:	4a6c      	ldr	r2, [pc, #432]	; (41451c <ADC_task_steps+0x334>)
  41436a:	7011      	strb	r1, [r2, #0]
  41436c:	461a      	mov	r2, r3
  41436e:	f997 304a 	ldrsb.w	r3, [r7, #74]	; 0x4a
  414372:	f107 0150 	add.w	r1, r7, #80	; 0x50
  414376:	440b      	add	r3, r1
  414378:	f813 1c50 	ldrb.w	r1, [r3, #-80]
  41437c:	4b69      	ldr	r3, [pc, #420]	; (414524 <ADC_task_steps+0x33c>)
  41437e:	5499      	strb	r1, [r3, r2]
					while ( (--i) >= 0)
  414380:	f897 304a 	ldrb.w	r3, [r7, #74]	; 0x4a
  414384:	3b01      	subs	r3, #1
  414386:	b2db      	uxtb	r3, r3
  414388:	f887 304a 	strb.w	r3, [r7, #74]	; 0x4a
  41438c:	f997 304a 	ldrsb.w	r3, [r7, #74]	; 0x4a
  414390:	2b00      	cmp	r3, #0
  414392:	dae4      	bge.n	41435e <ADC_task_steps+0x176>
					}

					byADCtx_sprintf_buff[byADCtx_sprintf_n++] = 0x20; // Space
  414394:	4b61      	ldr	r3, [pc, #388]	; (41451c <ADC_task_steps+0x334>)
  414396:	781b      	ldrb	r3, [r3, #0]
  414398:	b2db      	uxtb	r3, r3
  41439a:	1c5a      	adds	r2, r3, #1
  41439c:	b2d1      	uxtb	r1, r2
  41439e:	4a5f      	ldr	r2, [pc, #380]	; (41451c <ADC_task_steps+0x334>)
  4143a0:	7011      	strb	r1, [r2, #0]
  4143a2:	461a      	mov	r2, r3
  4143a4:	4b5f      	ldr	r3, [pc, #380]	; (414524 <ADC_task_steps+0x33c>)
  4143a6:	2120      	movs	r1, #32
  4143a8:	5499      	strb	r1, [r3, r2]

					pby = &chdata.usTimestamp_ms;
  4143aa:	f107 0320 	add.w	r3, r7, #32
  4143ae:	3308      	adds	r3, #8
  4143b0:	64fb      	str	r3, [r7, #76]	; 0x4c
					for (by=0, i=0; by < sizeof(chdata.usTimestamp_ms); by++, i+=2)
  4143b2:	2300      	movs	r3, #0
  4143b4:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b
  4143b8:	2300      	movs	r3, #0
  4143ba:	f887 304a 	strb.w	r3, [r7, #74]	; 0x4a
  4143be:	e01a      	b.n	4143f6 <ADC_task_steps+0x20e>
					{	BinToAsciiHex(*pby++, &byBuff[i], &byBuff[i+1]);
  4143c0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  4143c2:	1c5a      	adds	r2, r3, #1
  4143c4:	64fa      	str	r2, [r7, #76]	; 0x4c
  4143c6:	7818      	ldrb	r0, [r3, #0]
  4143c8:	f997 304a 	ldrsb.w	r3, [r7, #74]	; 0x4a
  4143cc:	463a      	mov	r2, r7
  4143ce:	18d1      	adds	r1, r2, r3
  4143d0:	f997 304a 	ldrsb.w	r3, [r7, #74]	; 0x4a
  4143d4:	3301      	adds	r3, #1
  4143d6:	463a      	mov	r2, r7
  4143d8:	4413      	add	r3, r2
  4143da:	461a      	mov	r2, r3
  4143dc:	4b50      	ldr	r3, [pc, #320]	; (414520 <ADC_task_steps+0x338>)
  4143de:	4798      	blx	r3
					for (by=0, i=0; by < sizeof(chdata.usTimestamp_ms); by++, i+=2)
  4143e0:	f897 304b 	ldrb.w	r3, [r7, #75]	; 0x4b
  4143e4:	3301      	adds	r3, #1
  4143e6:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b
  4143ea:	f897 304a 	ldrb.w	r3, [r7, #74]	; 0x4a
  4143ee:	3302      	adds	r3, #2
  4143f0:	b2db      	uxtb	r3, r3
  4143f2:	f887 304a 	strb.w	r3, [r7, #74]	; 0x4a
  4143f6:	f897 304b 	ldrb.w	r3, [r7, #75]	; 0x4b
  4143fa:	2b01      	cmp	r3, #1
  4143fc:	d9e0      	bls.n	4143c0 <ADC_task_steps+0x1d8>
					}
					while ( (--i) >= 0)
  4143fe:	e010      	b.n	414422 <ADC_task_steps+0x23a>
					{	byADCtx_sprintf_buff[byADCtx_sprintf_n++] = byBuff[i];	// MSB First					
  414400:	4b46      	ldr	r3, [pc, #280]	; (41451c <ADC_task_steps+0x334>)
  414402:	781b      	ldrb	r3, [r3, #0]
  414404:	b2db      	uxtb	r3, r3
  414406:	1c5a      	adds	r2, r3, #1
  414408:	b2d1      	uxtb	r1, r2
  41440a:	4a44      	ldr	r2, [pc, #272]	; (41451c <ADC_task_steps+0x334>)
  41440c:	7011      	strb	r1, [r2, #0]
  41440e:	461a      	mov	r2, r3
  414410:	f997 304a 	ldrsb.w	r3, [r7, #74]	; 0x4a
  414414:	f107 0150 	add.w	r1, r7, #80	; 0x50
  414418:	440b      	add	r3, r1
  41441a:	f813 1c50 	ldrb.w	r1, [r3, #-80]
  41441e:	4b41      	ldr	r3, [pc, #260]	; (414524 <ADC_task_steps+0x33c>)
  414420:	5499      	strb	r1, [r3, r2]
					while ( (--i) >= 0)
  414422:	f897 304a 	ldrb.w	r3, [r7, #74]	; 0x4a
  414426:	3b01      	subs	r3, #1
  414428:	b2db      	uxtb	r3, r3
  41442a:	f887 304a 	strb.w	r3, [r7, #74]	; 0x4a
  41442e:	f997 304a 	ldrsb.w	r3, [r7, #74]	; 0x4a
  414432:	2b00      	cmp	r3, #0
  414434:	dae4      	bge.n	414400 <ADC_task_steps+0x218>
					}

					byADCtx_sprintf_buff[byADCtx_sprintf_n++] = 0x20; // Space
  414436:	4b39      	ldr	r3, [pc, #228]	; (41451c <ADC_task_steps+0x334>)
  414438:	781b      	ldrb	r3, [r3, #0]
  41443a:	b2db      	uxtb	r3, r3
  41443c:	1c5a      	adds	r2, r3, #1
  41443e:	b2d1      	uxtb	r1, r2
  414440:	4a36      	ldr	r2, [pc, #216]	; (41451c <ADC_task_steps+0x334>)
  414442:	7011      	strb	r1, [r2, #0]
  414444:	461a      	mov	r2, r3
  414446:	4b37      	ldr	r3, [pc, #220]	; (414524 <ADC_task_steps+0x33c>)
  414448:	2120      	movs	r1, #32
  41444a:	5499      	strb	r1, [r3, r2]

					pby = &chdata.u64husec;
  41444c:	f107 0320 	add.w	r3, r7, #32
  414450:	3310      	adds	r3, #16
  414452:	64fb      	str	r3, [r7, #76]	; 0x4c
					for (by=0, i=0; by < sizeof(chdata.u64husec); by++, i+=2)
  414454:	2300      	movs	r3, #0
  414456:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b
  41445a:	2300      	movs	r3, #0
  41445c:	f887 304a 	strb.w	r3, [r7, #74]	; 0x4a
  414460:	e01a      	b.n	414498 <ADC_task_steps+0x2b0>
					{	BinToAsciiHex(*pby++, &byBuff[i], &byBuff[i+1]);
  414462:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  414464:	1c5a      	adds	r2, r3, #1
  414466:	64fa      	str	r2, [r7, #76]	; 0x4c
  414468:	7818      	ldrb	r0, [r3, #0]
  41446a:	f997 304a 	ldrsb.w	r3, [r7, #74]	; 0x4a
  41446e:	463a      	mov	r2, r7
  414470:	18d1      	adds	r1, r2, r3
  414472:	f997 304a 	ldrsb.w	r3, [r7, #74]	; 0x4a
  414476:	3301      	adds	r3, #1
  414478:	463a      	mov	r2, r7
  41447a:	4413      	add	r3, r2
  41447c:	461a      	mov	r2, r3
  41447e:	4b28      	ldr	r3, [pc, #160]	; (414520 <ADC_task_steps+0x338>)
  414480:	4798      	blx	r3
					for (by=0, i=0; by < sizeof(chdata.u64husec); by++, i+=2)
  414482:	f897 304b 	ldrb.w	r3, [r7, #75]	; 0x4b
  414486:	3301      	adds	r3, #1
  414488:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b
  41448c:	f897 304a 	ldrb.w	r3, [r7, #74]	; 0x4a
  414490:	3302      	adds	r3, #2
  414492:	b2db      	uxtb	r3, r3
  414494:	f887 304a 	strb.w	r3, [r7, #74]	; 0x4a
  414498:	f897 304b 	ldrb.w	r3, [r7, #75]	; 0x4b
  41449c:	2b07      	cmp	r3, #7
  41449e:	d9e0      	bls.n	414462 <ADC_task_steps+0x27a>
					}
					while ( (--i) >= 0)
  4144a0:	e010      	b.n	4144c4 <ADC_task_steps+0x2dc>
					{	byADCtx_sprintf_buff[byADCtx_sprintf_n++] = byBuff[i];	// MSB First					
  4144a2:	4b1e      	ldr	r3, [pc, #120]	; (41451c <ADC_task_steps+0x334>)
  4144a4:	781b      	ldrb	r3, [r3, #0]
  4144a6:	b2db      	uxtb	r3, r3
  4144a8:	1c5a      	adds	r2, r3, #1
  4144aa:	b2d1      	uxtb	r1, r2
  4144ac:	4a1b      	ldr	r2, [pc, #108]	; (41451c <ADC_task_steps+0x334>)
  4144ae:	7011      	strb	r1, [r2, #0]
  4144b0:	461a      	mov	r2, r3
  4144b2:	f997 304a 	ldrsb.w	r3, [r7, #74]	; 0x4a
  4144b6:	f107 0150 	add.w	r1, r7, #80	; 0x50
  4144ba:	440b      	add	r3, r1
  4144bc:	f813 1c50 	ldrb.w	r1, [r3, #-80]
  4144c0:	4b18      	ldr	r3, [pc, #96]	; (414524 <ADC_task_steps+0x33c>)
  4144c2:	5499      	strb	r1, [r3, r2]
					while ( (--i) >= 0)
  4144c4:	f897 304a 	ldrb.w	r3, [r7, #74]	; 0x4a
  4144c8:	3b01      	subs	r3, #1
  4144ca:	b2db      	uxtb	r3, r3
  4144cc:	f887 304a 	strb.w	r3, [r7, #74]	; 0x4a
  4144d0:	f997 304a 	ldrsb.w	r3, [r7, #74]	; 0x4a
  4144d4:	2b00      	cmp	r3, #0
  4144d6:	dae4      	bge.n	4144a2 <ADC_task_steps+0x2ba>
					}

					byADCtx_sprintf_buff[byADCtx_sprintf_n++] = 0x20; // Space
  4144d8:	4b10      	ldr	r3, [pc, #64]	; (41451c <ADC_task_steps+0x334>)
  4144da:	781b      	ldrb	r3, [r3, #0]
  4144dc:	b2db      	uxtb	r3, r3
  4144de:	1c5a      	adds	r2, r3, #1
  4144e0:	b2d1      	uxtb	r1, r2
  4144e2:	4a0e      	ldr	r2, [pc, #56]	; (41451c <ADC_task_steps+0x334>)
  4144e4:	7011      	strb	r1, [r2, #0]
  4144e6:	461a      	mov	r2, r3
  4144e8:	4b0e      	ldr	r3, [pc, #56]	; (414524 <ADC_task_steps+0x33c>)
  4144ea:	2120      	movs	r1, #32
  4144ec:	5499      	strb	r1, [r3, r2]

					pby = &chdata.rawGolay[0];
  4144ee:	f107 0320 	add.w	r3, r7, #32
  4144f2:	3318      	adds	r3, #24
  4144f4:	64fb      	str	r3, [r7, #76]	; 0x4c
					for (by=0, i=0; by < sizeof(chdata.rawGolay); by++, i+=2)
  4144f6:	2300      	movs	r3, #0
  4144f8:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b
  4144fc:	2300      	movs	r3, #0
  4144fe:	f887 304a 	strb.w	r3, [r7, #74]	; 0x4a
  414502:	e02c      	b.n	41455e <ADC_task_steps+0x376>
  414504:	2000b4e8 	.word	0x2000b4e8
  414508:	2000bcb0 	.word	0x2000bcb0
  41450c:	004154cd 	.word	0x004154cd
  414510:	00413c05 	.word	0x00413c05
  414514:	2000b6fc 	.word	0x2000b6fc
  414518:	00413ae1 	.word	0x00413ae1
  41451c:	2000b6fe 	.word	0x2000b6fe
  414520:	004138b7 	.word	0x004138b7
  414524:	2000b5e8 	.word	0x2000b5e8
					{	BinToAsciiHex(*pby++, &byBuff[i], &byBuff[i+1]);
  414528:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  41452a:	1c5a      	adds	r2, r3, #1
  41452c:	64fa      	str	r2, [r7, #76]	; 0x4c
  41452e:	7818      	ldrb	r0, [r3, #0]
  414530:	f997 304a 	ldrsb.w	r3, [r7, #74]	; 0x4a
  414534:	463a      	mov	r2, r7
  414536:	18d1      	adds	r1, r2, r3
  414538:	f997 304a 	ldrsb.w	r3, [r7, #74]	; 0x4a
  41453c:	3301      	adds	r3, #1
  41453e:	463a      	mov	r2, r7
  414540:	4413      	add	r3, r2
  414542:	461a      	mov	r2, r3
  414544:	4ba6      	ldr	r3, [pc, #664]	; (4147e0 <ADC_task_steps+0x5f8>)
  414546:	4798      	blx	r3
					for (by=0, i=0; by < sizeof(chdata.rawGolay); by++, i+=2)
  414548:	f897 304b 	ldrb.w	r3, [r7, #75]	; 0x4b
  41454c:	3301      	adds	r3, #1
  41454e:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b
  414552:	f897 304a 	ldrb.w	r3, [r7, #74]	; 0x4a
  414556:	3302      	adds	r3, #2
  414558:	b2db      	uxtb	r3, r3
  41455a:	f887 304a 	strb.w	r3, [r7, #74]	; 0x4a
  41455e:	f897 304b 	ldrb.w	r3, [r7, #75]	; 0x4b
  414562:	2b03      	cmp	r3, #3
  414564:	d9e0      	bls.n	414528 <ADC_task_steps+0x340>
					}
					byADCtx_sprintf_buff[byADCtx_sprintf_n++] = byBuff[1];	// MSB First
  414566:	4b9f      	ldr	r3, [pc, #636]	; (4147e4 <ADC_task_steps+0x5fc>)
  414568:	781b      	ldrb	r3, [r3, #0]
  41456a:	b2db      	uxtb	r3, r3
  41456c:	1c5a      	adds	r2, r3, #1
  41456e:	b2d1      	uxtb	r1, r2
  414570:	4a9c      	ldr	r2, [pc, #624]	; (4147e4 <ADC_task_steps+0x5fc>)
  414572:	7011      	strb	r1, [r2, #0]
  414574:	461a      	mov	r2, r3
  414576:	7879      	ldrb	r1, [r7, #1]
  414578:	4b9b      	ldr	r3, [pc, #620]	; (4147e8 <ADC_task_steps+0x600>)
  41457a:	5499      	strb	r1, [r3, r2]
					byADCtx_sprintf_buff[byADCtx_sprintf_n++] = byBuff[0];
  41457c:	4b99      	ldr	r3, [pc, #612]	; (4147e4 <ADC_task_steps+0x5fc>)
  41457e:	781b      	ldrb	r3, [r3, #0]
  414580:	b2db      	uxtb	r3, r3
  414582:	1c5a      	adds	r2, r3, #1
  414584:	b2d1      	uxtb	r1, r2
  414586:	4a97      	ldr	r2, [pc, #604]	; (4147e4 <ADC_task_steps+0x5fc>)
  414588:	7011      	strb	r1, [r2, #0]
  41458a:	461a      	mov	r2, r3
  41458c:	7839      	ldrb	r1, [r7, #0]
  41458e:	4b96      	ldr	r3, [pc, #600]	; (4147e8 <ADC_task_steps+0x600>)
  414590:	5499      	strb	r1, [r3, r2]
					byADCtx_sprintf_buff[byADCtx_sprintf_n++] = byBuff[3];
  414592:	4b94      	ldr	r3, [pc, #592]	; (4147e4 <ADC_task_steps+0x5fc>)
  414594:	781b      	ldrb	r3, [r3, #0]
  414596:	b2db      	uxtb	r3, r3
  414598:	1c5a      	adds	r2, r3, #1
  41459a:	b2d1      	uxtb	r1, r2
  41459c:	4a91      	ldr	r2, [pc, #580]	; (4147e4 <ADC_task_steps+0x5fc>)
  41459e:	7011      	strb	r1, [r2, #0]
  4145a0:	461a      	mov	r2, r3
  4145a2:	78f9      	ldrb	r1, [r7, #3]
  4145a4:	4b90      	ldr	r3, [pc, #576]	; (4147e8 <ADC_task_steps+0x600>)
  4145a6:	5499      	strb	r1, [r3, r2]
					byADCtx_sprintf_buff[byADCtx_sprintf_n++] = byBuff[2];
  4145a8:	4b8e      	ldr	r3, [pc, #568]	; (4147e4 <ADC_task_steps+0x5fc>)
  4145aa:	781b      	ldrb	r3, [r3, #0]
  4145ac:	b2db      	uxtb	r3, r3
  4145ae:	1c5a      	adds	r2, r3, #1
  4145b0:	b2d1      	uxtb	r1, r2
  4145b2:	4a8c      	ldr	r2, [pc, #560]	; (4147e4 <ADC_task_steps+0x5fc>)
  4145b4:	7011      	strb	r1, [r2, #0]
  4145b6:	461a      	mov	r2, r3
  4145b8:	78b9      	ldrb	r1, [r7, #2]
  4145ba:	4b8b      	ldr	r3, [pc, #556]	; (4147e8 <ADC_task_steps+0x600>)
  4145bc:	5499      	strb	r1, [r3, r2]
					byADCtx_sprintf_buff[byADCtx_sprintf_n++] = byBuff[5];
  4145be:	4b89      	ldr	r3, [pc, #548]	; (4147e4 <ADC_task_steps+0x5fc>)
  4145c0:	781b      	ldrb	r3, [r3, #0]
  4145c2:	b2db      	uxtb	r3, r3
  4145c4:	1c5a      	adds	r2, r3, #1
  4145c6:	b2d1      	uxtb	r1, r2
  4145c8:	4a86      	ldr	r2, [pc, #536]	; (4147e4 <ADC_task_steps+0x5fc>)
  4145ca:	7011      	strb	r1, [r2, #0]
  4145cc:	461a      	mov	r2, r3
  4145ce:	7979      	ldrb	r1, [r7, #5]
  4145d0:	4b85      	ldr	r3, [pc, #532]	; (4147e8 <ADC_task_steps+0x600>)
  4145d2:	5499      	strb	r1, [r3, r2]
					byADCtx_sprintf_buff[byADCtx_sprintf_n++] = byBuff[4];
  4145d4:	4b83      	ldr	r3, [pc, #524]	; (4147e4 <ADC_task_steps+0x5fc>)
  4145d6:	781b      	ldrb	r3, [r3, #0]
  4145d8:	b2db      	uxtb	r3, r3
  4145da:	1c5a      	adds	r2, r3, #1
  4145dc:	b2d1      	uxtb	r1, r2
  4145de:	4a81      	ldr	r2, [pc, #516]	; (4147e4 <ADC_task_steps+0x5fc>)
  4145e0:	7011      	strb	r1, [r2, #0]
  4145e2:	461a      	mov	r2, r3
  4145e4:	7939      	ldrb	r1, [r7, #4]
  4145e6:	4b80      	ldr	r3, [pc, #512]	; (4147e8 <ADC_task_steps+0x600>)
  4145e8:	5499      	strb	r1, [r3, r2]
					byADCtx_sprintf_buff[byADCtx_sprintf_n++] = byBuff[7];
  4145ea:	4b7e      	ldr	r3, [pc, #504]	; (4147e4 <ADC_task_steps+0x5fc>)
  4145ec:	781b      	ldrb	r3, [r3, #0]
  4145ee:	b2db      	uxtb	r3, r3
  4145f0:	1c5a      	adds	r2, r3, #1
  4145f2:	b2d1      	uxtb	r1, r2
  4145f4:	4a7b      	ldr	r2, [pc, #492]	; (4147e4 <ADC_task_steps+0x5fc>)
  4145f6:	7011      	strb	r1, [r2, #0]
  4145f8:	461a      	mov	r2, r3
  4145fa:	79f9      	ldrb	r1, [r7, #7]
  4145fc:	4b7a      	ldr	r3, [pc, #488]	; (4147e8 <ADC_task_steps+0x600>)
  4145fe:	5499      	strb	r1, [r3, r2]
					byADCtx_sprintf_buff[byADCtx_sprintf_n++] = byBuff[6];
  414600:	4b78      	ldr	r3, [pc, #480]	; (4147e4 <ADC_task_steps+0x5fc>)
  414602:	781b      	ldrb	r3, [r3, #0]
  414604:	b2db      	uxtb	r3, r3
  414606:	1c5a      	adds	r2, r3, #1
  414608:	b2d1      	uxtb	r1, r2
  41460a:	4a76      	ldr	r2, [pc, #472]	; (4147e4 <ADC_task_steps+0x5fc>)
  41460c:	7011      	strb	r1, [r2, #0]
  41460e:	461a      	mov	r2, r3
  414610:	79b9      	ldrb	r1, [r7, #6]
  414612:	4b75      	ldr	r3, [pc, #468]	; (4147e8 <ADC_task_steps+0x600>)
  414614:	5499      	strb	r1, [r3, r2]

					byADCtx_sprintf_buff[byADCtx_sprintf_n++] = 0x20; // Space
  414616:	4b73      	ldr	r3, [pc, #460]	; (4147e4 <ADC_task_steps+0x5fc>)
  414618:	781b      	ldrb	r3, [r3, #0]
  41461a:	b2db      	uxtb	r3, r3
  41461c:	1c5a      	adds	r2, r3, #1
  41461e:	b2d1      	uxtb	r1, r2
  414620:	4a70      	ldr	r2, [pc, #448]	; (4147e4 <ADC_task_steps+0x5fc>)
  414622:	7011      	strb	r1, [r2, #0]
  414624:	461a      	mov	r2, r3
  414626:	4b70      	ldr	r3, [pc, #448]	; (4147e8 <ADC_task_steps+0x600>)
  414628:	2120      	movs	r1, #32
  41462a:	5499      	strb	r1, [r3, r2]

					pby = &chdata.rawPS[0];
  41462c:	f107 0320 	add.w	r3, r7, #32
  414630:	331c      	adds	r3, #28
  414632:	64fb      	str	r3, [r7, #76]	; 0x4c
					for (by=0, i=0; by < sizeof(chdata.rawPS); by++, i+=2)
  414634:	2300      	movs	r3, #0
  414636:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b
  41463a:	2300      	movs	r3, #0
  41463c:	f887 304a 	strb.w	r3, [r7, #74]	; 0x4a
  414640:	e01a      	b.n	414678 <ADC_task_steps+0x490>
					{	BinToAsciiHex(*pby++, &byBuff[i], &byBuff[i+1]);
  414642:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  414644:	1c5a      	adds	r2, r3, #1
  414646:	64fa      	str	r2, [r7, #76]	; 0x4c
  414648:	7818      	ldrb	r0, [r3, #0]
  41464a:	f997 304a 	ldrsb.w	r3, [r7, #74]	; 0x4a
  41464e:	463a      	mov	r2, r7
  414650:	18d1      	adds	r1, r2, r3
  414652:	f997 304a 	ldrsb.w	r3, [r7, #74]	; 0x4a
  414656:	3301      	adds	r3, #1
  414658:	463a      	mov	r2, r7
  41465a:	4413      	add	r3, r2
  41465c:	461a      	mov	r2, r3
  41465e:	4b60      	ldr	r3, [pc, #384]	; (4147e0 <ADC_task_steps+0x5f8>)
  414660:	4798      	blx	r3
					for (by=0, i=0; by < sizeof(chdata.rawPS); by++, i+=2)
  414662:	f897 304b 	ldrb.w	r3, [r7, #75]	; 0x4b
  414666:	3301      	adds	r3, #1
  414668:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b
  41466c:	f897 304a 	ldrb.w	r3, [r7, #74]	; 0x4a
  414670:	3302      	adds	r3, #2
  414672:	b2db      	uxtb	r3, r3
  414674:	f887 304a 	strb.w	r3, [r7, #74]	; 0x4a
  414678:	f897 304b 	ldrb.w	r3, [r7, #75]	; 0x4b
  41467c:	2b03      	cmp	r3, #3
  41467e:	d9e0      	bls.n	414642 <ADC_task_steps+0x45a>
					}
					byADCtx_sprintf_buff[byADCtx_sprintf_n++] = byBuff[1];	// MSB First
  414680:	4b58      	ldr	r3, [pc, #352]	; (4147e4 <ADC_task_steps+0x5fc>)
  414682:	781b      	ldrb	r3, [r3, #0]
  414684:	b2db      	uxtb	r3, r3
  414686:	1c5a      	adds	r2, r3, #1
  414688:	b2d1      	uxtb	r1, r2
  41468a:	4a56      	ldr	r2, [pc, #344]	; (4147e4 <ADC_task_steps+0x5fc>)
  41468c:	7011      	strb	r1, [r2, #0]
  41468e:	461a      	mov	r2, r3
  414690:	7879      	ldrb	r1, [r7, #1]
  414692:	4b55      	ldr	r3, [pc, #340]	; (4147e8 <ADC_task_steps+0x600>)
  414694:	5499      	strb	r1, [r3, r2]
					byADCtx_sprintf_buff[byADCtx_sprintf_n++] = byBuff[0];
  414696:	4b53      	ldr	r3, [pc, #332]	; (4147e4 <ADC_task_steps+0x5fc>)
  414698:	781b      	ldrb	r3, [r3, #0]
  41469a:	b2db      	uxtb	r3, r3
  41469c:	1c5a      	adds	r2, r3, #1
  41469e:	b2d1      	uxtb	r1, r2
  4146a0:	4a50      	ldr	r2, [pc, #320]	; (4147e4 <ADC_task_steps+0x5fc>)
  4146a2:	7011      	strb	r1, [r2, #0]
  4146a4:	461a      	mov	r2, r3
  4146a6:	7839      	ldrb	r1, [r7, #0]
  4146a8:	4b4f      	ldr	r3, [pc, #316]	; (4147e8 <ADC_task_steps+0x600>)
  4146aa:	5499      	strb	r1, [r3, r2]
					byADCtx_sprintf_buff[byADCtx_sprintf_n++] = byBuff[3];
  4146ac:	4b4d      	ldr	r3, [pc, #308]	; (4147e4 <ADC_task_steps+0x5fc>)
  4146ae:	781b      	ldrb	r3, [r3, #0]
  4146b0:	b2db      	uxtb	r3, r3
  4146b2:	1c5a      	adds	r2, r3, #1
  4146b4:	b2d1      	uxtb	r1, r2
  4146b6:	4a4b      	ldr	r2, [pc, #300]	; (4147e4 <ADC_task_steps+0x5fc>)
  4146b8:	7011      	strb	r1, [r2, #0]
  4146ba:	461a      	mov	r2, r3
  4146bc:	78f9      	ldrb	r1, [r7, #3]
  4146be:	4b4a      	ldr	r3, [pc, #296]	; (4147e8 <ADC_task_steps+0x600>)
  4146c0:	5499      	strb	r1, [r3, r2]
					byADCtx_sprintf_buff[byADCtx_sprintf_n++] = byBuff[2];
  4146c2:	4b48      	ldr	r3, [pc, #288]	; (4147e4 <ADC_task_steps+0x5fc>)
  4146c4:	781b      	ldrb	r3, [r3, #0]
  4146c6:	b2db      	uxtb	r3, r3
  4146c8:	1c5a      	adds	r2, r3, #1
  4146ca:	b2d1      	uxtb	r1, r2
  4146cc:	4a45      	ldr	r2, [pc, #276]	; (4147e4 <ADC_task_steps+0x5fc>)
  4146ce:	7011      	strb	r1, [r2, #0]
  4146d0:	461a      	mov	r2, r3
  4146d2:	78b9      	ldrb	r1, [r7, #2]
  4146d4:	4b44      	ldr	r3, [pc, #272]	; (4147e8 <ADC_task_steps+0x600>)
  4146d6:	5499      	strb	r1, [r3, r2]
					byADCtx_sprintf_buff[byADCtx_sprintf_n++] = byBuff[5];
  4146d8:	4b42      	ldr	r3, [pc, #264]	; (4147e4 <ADC_task_steps+0x5fc>)
  4146da:	781b      	ldrb	r3, [r3, #0]
  4146dc:	b2db      	uxtb	r3, r3
  4146de:	1c5a      	adds	r2, r3, #1
  4146e0:	b2d1      	uxtb	r1, r2
  4146e2:	4a40      	ldr	r2, [pc, #256]	; (4147e4 <ADC_task_steps+0x5fc>)
  4146e4:	7011      	strb	r1, [r2, #0]
  4146e6:	461a      	mov	r2, r3
  4146e8:	7979      	ldrb	r1, [r7, #5]
  4146ea:	4b3f      	ldr	r3, [pc, #252]	; (4147e8 <ADC_task_steps+0x600>)
  4146ec:	5499      	strb	r1, [r3, r2]
					byADCtx_sprintf_buff[byADCtx_sprintf_n++] = byBuff[4];
  4146ee:	4b3d      	ldr	r3, [pc, #244]	; (4147e4 <ADC_task_steps+0x5fc>)
  4146f0:	781b      	ldrb	r3, [r3, #0]
  4146f2:	b2db      	uxtb	r3, r3
  4146f4:	1c5a      	adds	r2, r3, #1
  4146f6:	b2d1      	uxtb	r1, r2
  4146f8:	4a3a      	ldr	r2, [pc, #232]	; (4147e4 <ADC_task_steps+0x5fc>)
  4146fa:	7011      	strb	r1, [r2, #0]
  4146fc:	461a      	mov	r2, r3
  4146fe:	7939      	ldrb	r1, [r7, #4]
  414700:	4b39      	ldr	r3, [pc, #228]	; (4147e8 <ADC_task_steps+0x600>)
  414702:	5499      	strb	r1, [r3, r2]
					byADCtx_sprintf_buff[byADCtx_sprintf_n++] = byBuff[7];
  414704:	4b37      	ldr	r3, [pc, #220]	; (4147e4 <ADC_task_steps+0x5fc>)
  414706:	781b      	ldrb	r3, [r3, #0]
  414708:	b2db      	uxtb	r3, r3
  41470a:	1c5a      	adds	r2, r3, #1
  41470c:	b2d1      	uxtb	r1, r2
  41470e:	4a35      	ldr	r2, [pc, #212]	; (4147e4 <ADC_task_steps+0x5fc>)
  414710:	7011      	strb	r1, [r2, #0]
  414712:	461a      	mov	r2, r3
  414714:	79f9      	ldrb	r1, [r7, #7]
  414716:	4b34      	ldr	r3, [pc, #208]	; (4147e8 <ADC_task_steps+0x600>)
  414718:	5499      	strb	r1, [r3, r2]
					byADCtx_sprintf_buff[byADCtx_sprintf_n++] = byBuff[6];
  41471a:	4b32      	ldr	r3, [pc, #200]	; (4147e4 <ADC_task_steps+0x5fc>)
  41471c:	781b      	ldrb	r3, [r3, #0]
  41471e:	b2db      	uxtb	r3, r3
  414720:	1c5a      	adds	r2, r3, #1
  414722:	b2d1      	uxtb	r1, r2
  414724:	4a2f      	ldr	r2, [pc, #188]	; (4147e4 <ADC_task_steps+0x5fc>)
  414726:	7011      	strb	r1, [r2, #0]
  414728:	461a      	mov	r2, r3
  41472a:	79b9      	ldrb	r1, [r7, #6]
  41472c:	4b2e      	ldr	r3, [pc, #184]	; (4147e8 <ADC_task_steps+0x600>)
  41472e:	5499      	strb	r1, [r3, r2]
					
					byADCtx_sprintf_buff[byADCtx_sprintf_n++] = 0x0D; // CR
  414730:	4b2c      	ldr	r3, [pc, #176]	; (4147e4 <ADC_task_steps+0x5fc>)
  414732:	781b      	ldrb	r3, [r3, #0]
  414734:	b2db      	uxtb	r3, r3
  414736:	1c5a      	adds	r2, r3, #1
  414738:	b2d1      	uxtb	r1, r2
  41473a:	4a2a      	ldr	r2, [pc, #168]	; (4147e4 <ADC_task_steps+0x5fc>)
  41473c:	7011      	strb	r1, [r2, #0]
  41473e:	461a      	mov	r2, r3
  414740:	4b29      	ldr	r3, [pc, #164]	; (4147e8 <ADC_task_steps+0x600>)
  414742:	210d      	movs	r1, #13
  414744:	5499      	strb	r1, [r3, r2]
					byADCtx_sprintf_buff[byADCtx_sprintf_n++] = 0x0A; // LF
  414746:	4b27      	ldr	r3, [pc, #156]	; (4147e4 <ADC_task_steps+0x5fc>)
  414748:	781b      	ldrb	r3, [r3, #0]
  41474a:	b2db      	uxtb	r3, r3
  41474c:	1c5a      	adds	r2, r3, #1
  41474e:	b2d1      	uxtb	r1, r2
  414750:	4a24      	ldr	r2, [pc, #144]	; (4147e4 <ADC_task_steps+0x5fc>)
  414752:	7011      	strb	r1, [r2, #0]
  414754:	461a      	mov	r2, r3
  414756:	4b24      	ldr	r3, [pc, #144]	; (4147e8 <ADC_task_steps+0x600>)
  414758:	210a      	movs	r1, #10
  41475a:	5499      	strb	r1, [r3, r2]

					for (by=0; by < byADCtx_sprintf_n; by++)
  41475c:	2300      	movs	r3, #0
  41475e:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b
  414762:	e016      	b.n	414792 <ADC_task_steps+0x5aa>
					{   byADCtx_mtu_buff[wADCtx_mtu_n] = byADCtx_sprintf_buff[by];
  414764:	4b21      	ldr	r3, [pc, #132]	; (4147ec <ADC_task_steps+0x604>)
  414766:	881b      	ldrh	r3, [r3, #0]
  414768:	b29b      	uxth	r3, r3
  41476a:	4619      	mov	r1, r3
  41476c:	f897 304b 	ldrb.w	r3, [r7, #75]	; 0x4b
  414770:	4a1d      	ldr	r2, [pc, #116]	; (4147e8 <ADC_task_steps+0x600>)
  414772:	5cd3      	ldrb	r3, [r2, r3]
  414774:	b2da      	uxtb	r2, r3
  414776:	4b1e      	ldr	r3, [pc, #120]	; (4147f0 <ADC_task_steps+0x608>)
  414778:	545a      	strb	r2, [r3, r1]
						wADCtx_mtu_n++;
  41477a:	4b1c      	ldr	r3, [pc, #112]	; (4147ec <ADC_task_steps+0x604>)
  41477c:	881b      	ldrh	r3, [r3, #0]
  41477e:	b29b      	uxth	r3, r3
  414780:	3301      	adds	r3, #1
  414782:	b29a      	uxth	r2, r3
  414784:	4b19      	ldr	r3, [pc, #100]	; (4147ec <ADC_task_steps+0x604>)
  414786:	801a      	strh	r2, [r3, #0]
					for (by=0; by < byADCtx_sprintf_n; by++)
  414788:	f897 304b 	ldrb.w	r3, [r7, #75]	; 0x4b
  41478c:	3301      	adds	r3, #1
  41478e:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b
  414792:	4b14      	ldr	r3, [pc, #80]	; (4147e4 <ADC_task_steps+0x5fc>)
  414794:	781b      	ldrb	r3, [r3, #0]
  414796:	b2db      	uxtb	r3, r3
  414798:	f897 204b 	ldrb.w	r2, [r7, #75]	; 0x4b
  41479c:	429a      	cmp	r2, r3
  41479e:	d3e1      	bcc.n	414764 <ADC_task_steps+0x57c>
					}
						
					// Checking lost samples
					if ( (++dwLostSamples_old) != chdata.ulSample)
  4147a0:	4b14      	ldr	r3, [pc, #80]	; (4147f4 <ADC_task_steps+0x60c>)
  4147a2:	681b      	ldr	r3, [r3, #0]
  4147a4:	3301      	adds	r3, #1
  4147a6:	4a13      	ldr	r2, [pc, #76]	; (4147f4 <ADC_task_steps+0x60c>)
  4147a8:	6013      	str	r3, [r2, #0]
  4147aa:	6a3a      	ldr	r2, [r7, #32]
  4147ac:	4293      	cmp	r3, r2
  4147ae:	d00e      	beq.n	4147ce <ADC_task_steps+0x5e6>
					{	dwLostSamples_lost_n = chdata.ulSample;
  4147b0:	6a3b      	ldr	r3, [r7, #32]
  4147b2:	4a11      	ldr	r2, [pc, #68]	; (4147f8 <ADC_task_steps+0x610>)
  4147b4:	6013      	str	r3, [r2, #0]
						dwLostSamples_lost_o = dwLostSamples_old;
  4147b6:	4b0f      	ldr	r3, [pc, #60]	; (4147f4 <ADC_task_steps+0x60c>)
  4147b8:	681b      	ldr	r3, [r3, #0]
  4147ba:	4a10      	ldr	r2, [pc, #64]	; (4147fc <ADC_task_steps+0x614>)
  4147bc:	6013      	str	r3, [r2, #0]
						dwLostSamples_cx++;
  4147be:	4b10      	ldr	r3, [pc, #64]	; (414800 <ADC_task_steps+0x618>)
  4147c0:	681b      	ldr	r3, [r3, #0]
  4147c2:	3301      	adds	r3, #1
  4147c4:	4a0e      	ldr	r2, [pc, #56]	; (414800 <ADC_task_steps+0x618>)
  4147c6:	6013      	str	r3, [r2, #0]
						dwLostSamples_old  = chdata.ulSample;
  4147c8:	6a3b      	ldr	r3, [r7, #32]
  4147ca:	4a0a      	ldr	r2, [pc, #40]	; (4147f4 <ADC_task_steps+0x60c>)
  4147cc:	6013      	str	r3, [r2, #0]
					}

				} while (wADCtx_mtu_n < 1200);	// (MTU=1400)
  4147ce:	4b07      	ldr	r3, [pc, #28]	; (4147ec <ADC_task_steps+0x604>)
  4147d0:	881b      	ldrh	r3, [r3, #0]
  4147d2:	b29b      	uxth	r3, r3
  4147d4:	f5b3 6f96 	cmp.w	r3, #1200	; 0x4b0
  4147d8:	f4ff ad39 	bcc.w	41424e <ADC_task_steps+0x66>
  4147dc:	e013      	b.n	414806 <ADC_task_steps+0x61e>
  4147de:	bf00      	nop
  4147e0:	004138b7 	.word	0x004138b7
  4147e4:	2000b6fe 	.word	0x2000b6fe
  4147e8:	2000b5e8 	.word	0x2000b5e8
  4147ec:	2000b6fc 	.word	0x2000b6fc
  4147f0:	2000b700 	.word	0x2000b700
  4147f4:	2000b4f0 	.word	0x2000b4f0
  4147f8:	2000b4f8 	.word	0x2000b4f8
  4147fc:	2000b4f4 	.word	0x2000b4f4
  414800:	2000b4ec 	.word	0x2000b4ec
						break;	// Buffer esvaziou
  414804:	bf00      	nop

				if (wADCtx_mtu_n != 0 )
  414806:	4b15      	ldr	r3, [pc, #84]	; (41485c <ADC_task_steps+0x674>)
  414808:	881b      	ldrh	r3, [r3, #0]
  41480a:	b29b      	uxth	r3, r3
  41480c:	2b00      	cmp	r3, #0
  41480e:	d01f      	beq.n	414850 <ADC_task_steps+0x668>
				{	byADC_Task_step = ADC_TASK_STEP_TX_DATA;
  414810:	4b13      	ldr	r3, [pc, #76]	; (414860 <ADC_task_steps+0x678>)
  414812:	2203      	movs	r2, #3
  414814:	701a      	strb	r2, [r3, #0]
				}
			}
			break;
  414816:	e01b      	b.n	414850 <ADC_task_steps+0x668>
			
		case ADC_TASK_STEP_TX_DATA:
			if (vSocket_ADC_tcp_sendto(byADCtx_mtu_buff,wADCtx_mtu_n) > 0)
  414818:	4b10      	ldr	r3, [pc, #64]	; (41485c <ADC_task_steps+0x674>)
  41481a:	881b      	ldrh	r3, [r3, #0]
  41481c:	b29b      	uxth	r3, r3
  41481e:	4619      	mov	r1, r3
  414820:	4810      	ldr	r0, [pc, #64]	; (414864 <ADC_task_steps+0x67c>)
  414822:	4b11      	ldr	r3, [pc, #68]	; (414868 <ADC_task_steps+0x680>)
  414824:	4798      	blx	r3
  414826:	4603      	mov	r3, r0
  414828:	2b00      	cmp	r3, #0
  41482a:	dd03      	ble.n	414834 <ADC_task_steps+0x64c>
			{	byADC_Task_step = ADC_TASK_STEP_POP_DATA;
  41482c:	4b0c      	ldr	r3, [pc, #48]	; (414860 <ADC_task_steps+0x678>)
  41482e:	2202      	movs	r2, #2
  414830:	701a      	strb	r2, [r3, #0]
			}
			else
			{	byADC_Task_step = ADC_TASK_STEP_CLOSE_SOCKET;
			}	
			break;
  414832:	e00e      	b.n	414852 <ADC_task_steps+0x66a>
			{	byADC_Task_step = ADC_TASK_STEP_CLOSE_SOCKET;
  414834:	4b0a      	ldr	r3, [pc, #40]	; (414860 <ADC_task_steps+0x678>)
  414836:	2204      	movs	r2, #4
  414838:	701a      	strb	r2, [r3, #0]
			break;
  41483a:	e00a      	b.n	414852 <ADC_task_steps+0x66a>

		case ADC_TASK_STEP_CLOSE_SOCKET:
			vSocket_ADC_tcp_close();
  41483c:	4b0b      	ldr	r3, [pc, #44]	; (41486c <ADC_task_steps+0x684>)
  41483e:	4798      	blx	r3
			byADC_Task_step = ADC_TASK_STEP_OPEN_SOCKET;
  414840:	4b07      	ldr	r3, [pc, #28]	; (414860 <ADC_task_steps+0x678>)
  414842:	2201      	movs	r2, #1
  414844:	701a      	strb	r2, [r3, #0]
			break;
  414846:	e004      	b.n	414852 <ADC_task_steps+0x66a>
			break;
  414848:	bf00      	nop
  41484a:	e002      	b.n	414852 <ADC_task_steps+0x66a>
			break;
  41484c:	bf00      	nop
  41484e:	e000      	b.n	414852 <ADC_task_steps+0x66a>
			break;
  414850:	bf00      	nop
	
	}

}
  414852:	bf00      	nop
  414854:	3750      	adds	r7, #80	; 0x50
  414856:	46bd      	mov	sp, r7
  414858:	bd80      	pop	{r7, pc}
  41485a:	bf00      	nop
  41485c:	2000b6fc 	.word	0x2000b6fc
  414860:	2000b4e8 	.word	0x2000b4e8
  414864:	2000b700 	.word	0x2000b700
  414868:	00415579 	.word	0x00415579
  41486c:	004155a5 	.word	0x004155a5

00414870 <NVIC_DisableIRQ>:
{
  414870:	b480      	push	{r7}
  414872:	b083      	sub	sp, #12
  414874:	af00      	add	r7, sp, #0
  414876:	4603      	mov	r3, r0
  414878:	71fb      	strb	r3, [r7, #7]
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
  41487a:	4909      	ldr	r1, [pc, #36]	; (4148a0 <NVIC_DisableIRQ+0x30>)
  41487c:	f997 3007 	ldrsb.w	r3, [r7, #7]
  414880:	095b      	lsrs	r3, r3, #5
  414882:	79fa      	ldrb	r2, [r7, #7]
  414884:	f002 021f 	and.w	r2, r2, #31
  414888:	2001      	movs	r0, #1
  41488a:	fa00 f202 	lsl.w	r2, r0, r2
  41488e:	3320      	adds	r3, #32
  414890:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
  414894:	bf00      	nop
  414896:	370c      	adds	r7, #12
  414898:	46bd      	mov	sp, r7
  41489a:	f85d 7b04 	ldr.w	r7, [sp], #4
  41489e:	4770      	bx	lr
  4148a0:	e000e100 	.word	0xe000e100

004148a4 <ioport_set_pin_mode>:
{
  4148a4:	b480      	push	{r7}
  4148a6:	b08d      	sub	sp, #52	; 0x34
  4148a8:	af00      	add	r7, sp, #0
  4148aa:	6078      	str	r0, [r7, #4]
  4148ac:	6039      	str	r1, [r7, #0]
  4148ae:	687b      	ldr	r3, [r7, #4]
  4148b0:	62fb      	str	r3, [r7, #44]	; 0x2c
  4148b2:	683b      	ldr	r3, [r7, #0]
  4148b4:	62bb      	str	r3, [r7, #40]	; 0x28
  4148b6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  4148b8:	627b      	str	r3, [r7, #36]	; 0x24
	return pin >> 5;
  4148ba:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4148bc:	095a      	lsrs	r2, r3, #5
  4148be:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  4148c0:	623b      	str	r3, [r7, #32]
	return 1U << (pin & 0x1F);
  4148c2:	6a3b      	ldr	r3, [r7, #32]
  4148c4:	f003 031f 	and.w	r3, r3, #31
  4148c8:	2101      	movs	r1, #1
  4148ca:	fa01 f303 	lsl.w	r3, r1, r3
  4148ce:	61fa      	str	r2, [r7, #28]
  4148d0:	61bb      	str	r3, [r7, #24]
  4148d2:	6abb      	ldr	r3, [r7, #40]	; 0x28
  4148d4:	617b      	str	r3, [r7, #20]
  4148d6:	69fb      	ldr	r3, [r7, #28]
  4148d8:	613b      	str	r3, [r7, #16]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  4148da:	693b      	ldr	r3, [r7, #16]
  4148dc:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  4148e0:	f203 7307 	addw	r3, r3, #1799	; 0x707
  4148e4:	025b      	lsls	r3, r3, #9
	Pio *base = arch_ioport_port_to_base(port);
  4148e6:	60fb      	str	r3, [r7, #12]
	if (mode & IOPORT_MODE_PULLUP) {
  4148e8:	697b      	ldr	r3, [r7, #20]
  4148ea:	f003 0308 	and.w	r3, r3, #8
  4148ee:	2b00      	cmp	r3, #0
  4148f0:	d003      	beq.n	4148fa <ioport_set_pin_mode+0x56>
		base->PIO_PUER = mask;
  4148f2:	68fb      	ldr	r3, [r7, #12]
  4148f4:	69ba      	ldr	r2, [r7, #24]
  4148f6:	665a      	str	r2, [r3, #100]	; 0x64
  4148f8:	e002      	b.n	414900 <ioport_set_pin_mode+0x5c>
		base->PIO_PUDR = mask;
  4148fa:	68fb      	ldr	r3, [r7, #12]
  4148fc:	69ba      	ldr	r2, [r7, #24]
  4148fe:	661a      	str	r2, [r3, #96]	; 0x60
	if (mode & IOPORT_MODE_PULLDOWN) {
  414900:	697b      	ldr	r3, [r7, #20]
  414902:	f003 0310 	and.w	r3, r3, #16
  414906:	2b00      	cmp	r3, #0
  414908:	d004      	beq.n	414914 <ioport_set_pin_mode+0x70>
		base->PIO_PPDER = mask;
  41490a:	68fb      	ldr	r3, [r7, #12]
  41490c:	69ba      	ldr	r2, [r7, #24]
  41490e:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  414912:	e003      	b.n	41491c <ioport_set_pin_mode+0x78>
		base->PIO_PPDDR = mask;
  414914:	68fb      	ldr	r3, [r7, #12]
  414916:	69ba      	ldr	r2, [r7, #24]
  414918:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
	if (mode & IOPORT_MODE_OPEN_DRAIN) {
  41491c:	697b      	ldr	r3, [r7, #20]
  41491e:	f003 0320 	and.w	r3, r3, #32
  414922:	2b00      	cmp	r3, #0
  414924:	d003      	beq.n	41492e <ioport_set_pin_mode+0x8a>
		base->PIO_MDER = mask;
  414926:	68fb      	ldr	r3, [r7, #12]
  414928:	69ba      	ldr	r2, [r7, #24]
  41492a:	651a      	str	r2, [r3, #80]	; 0x50
  41492c:	e002      	b.n	414934 <ioport_set_pin_mode+0x90>
		base->PIO_MDDR = mask;
  41492e:	68fb      	ldr	r3, [r7, #12]
  414930:	69ba      	ldr	r2, [r7, #24]
  414932:	655a      	str	r2, [r3, #84]	; 0x54
	if (mode & (IOPORT_MODE_GLITCH_FILTER | IOPORT_MODE_DEBOUNCE)) {
  414934:	697b      	ldr	r3, [r7, #20]
  414936:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
  41493a:	2b00      	cmp	r3, #0
  41493c:	d003      	beq.n	414946 <ioport_set_pin_mode+0xa2>
		base->PIO_IFER = mask;
  41493e:	68fb      	ldr	r3, [r7, #12]
  414940:	69ba      	ldr	r2, [r7, #24]
  414942:	621a      	str	r2, [r3, #32]
  414944:	e002      	b.n	41494c <ioport_set_pin_mode+0xa8>
		base->PIO_IFDR = mask;
  414946:	68fb      	ldr	r3, [r7, #12]
  414948:	69ba      	ldr	r2, [r7, #24]
  41494a:	625a      	str	r2, [r3, #36]	; 0x24
	if (mode & IOPORT_MODE_DEBOUNCE) {
  41494c:	697b      	ldr	r3, [r7, #20]
  41494e:	f003 0380 	and.w	r3, r3, #128	; 0x80
  414952:	2b00      	cmp	r3, #0
  414954:	d004      	beq.n	414960 <ioport_set_pin_mode+0xbc>
		base->PIO_IFSCER = mask;
  414956:	68fb      	ldr	r3, [r7, #12]
  414958:	69ba      	ldr	r2, [r7, #24]
  41495a:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  41495e:	e003      	b.n	414968 <ioport_set_pin_mode+0xc4>
		base->PIO_IFSCDR = mask;
  414960:	68fb      	ldr	r3, [r7, #12]
  414962:	69ba      	ldr	r2, [r7, #24]
  414964:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	if (mode & IOPORT_MODE_MUX_BIT0) {
  414968:	697b      	ldr	r3, [r7, #20]
  41496a:	f003 0301 	and.w	r3, r3, #1
  41496e:	2b00      	cmp	r3, #0
  414970:	d006      	beq.n	414980 <ioport_set_pin_mode+0xdc>
		base->PIO_ABCDSR[0] |= mask;
  414972:	68fb      	ldr	r3, [r7, #12]
  414974:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  414976:	69bb      	ldr	r3, [r7, #24]
  414978:	431a      	orrs	r2, r3
  41497a:	68fb      	ldr	r3, [r7, #12]
  41497c:	671a      	str	r2, [r3, #112]	; 0x70
  41497e:	e006      	b.n	41498e <ioport_set_pin_mode+0xea>
		base->PIO_ABCDSR[0] &= ~mask;
  414980:	68fb      	ldr	r3, [r7, #12]
  414982:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  414984:	69bb      	ldr	r3, [r7, #24]
  414986:	43db      	mvns	r3, r3
  414988:	401a      	ands	r2, r3
  41498a:	68fb      	ldr	r3, [r7, #12]
  41498c:	671a      	str	r2, [r3, #112]	; 0x70
	if (mode & IOPORT_MODE_MUX_BIT1) {
  41498e:	697b      	ldr	r3, [r7, #20]
  414990:	f003 0302 	and.w	r3, r3, #2
  414994:	2b00      	cmp	r3, #0
  414996:	d006      	beq.n	4149a6 <ioport_set_pin_mode+0x102>
		base->PIO_ABCDSR[1] |= mask;
  414998:	68fb      	ldr	r3, [r7, #12]
  41499a:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  41499c:	69bb      	ldr	r3, [r7, #24]
  41499e:	431a      	orrs	r2, r3
  4149a0:	68fb      	ldr	r3, [r7, #12]
  4149a2:	675a      	str	r2, [r3, #116]	; 0x74
}
  4149a4:	e006      	b.n	4149b4 <ioport_set_pin_mode+0x110>
		base->PIO_ABCDSR[1] &= ~mask;
  4149a6:	68fb      	ldr	r3, [r7, #12]
  4149a8:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  4149aa:	69bb      	ldr	r3, [r7, #24]
  4149ac:	43db      	mvns	r3, r3
  4149ae:	401a      	ands	r2, r3
  4149b0:	68fb      	ldr	r3, [r7, #12]
  4149b2:	675a      	str	r2, [r3, #116]	; 0x74
  4149b4:	bf00      	nop
  4149b6:	3734      	adds	r7, #52	; 0x34
  4149b8:	46bd      	mov	sp, r7
  4149ba:	f85d 7b04 	ldr.w	r7, [sp], #4
  4149be:	4770      	bx	lr

004149c0 <ioport_set_pin_dir>:
{
  4149c0:	b480      	push	{r7}
  4149c2:	b08d      	sub	sp, #52	; 0x34
  4149c4:	af00      	add	r7, sp, #0
  4149c6:	6078      	str	r0, [r7, #4]
  4149c8:	460b      	mov	r3, r1
  4149ca:	70fb      	strb	r3, [r7, #3]
  4149cc:	687b      	ldr	r3, [r7, #4]
  4149ce:	62fb      	str	r3, [r7, #44]	; 0x2c
  4149d0:	78fb      	ldrb	r3, [r7, #3]
  4149d2:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
  4149d6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  4149d8:	627b      	str	r3, [r7, #36]	; 0x24
  4149da:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4149dc:	623b      	str	r3, [r7, #32]
	return pin >> 5;
  4149de:	6a3b      	ldr	r3, [r7, #32]
  4149e0:	095b      	lsrs	r3, r3, #5
  4149e2:	61fb      	str	r3, [r7, #28]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  4149e4:	69fb      	ldr	r3, [r7, #28]
  4149e6:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  4149ea:	f203 7307 	addw	r3, r3, #1799	; 0x707
  4149ee:	025b      	lsls	r3, r3, #9
	Pio *base = arch_ioport_pin_to_base(pin);
  4149f0:	61bb      	str	r3, [r7, #24]
	if (dir == IOPORT_DIR_OUTPUT) {
  4149f2:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
  4149f6:	2b01      	cmp	r3, #1
  4149f8:	d109      	bne.n	414a0e <ioport_set_pin_dir+0x4e>
  4149fa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  4149fc:	617b      	str	r3, [r7, #20]
	return 1U << (pin & 0x1F);
  4149fe:	697b      	ldr	r3, [r7, #20]
  414a00:	f003 031f 	and.w	r3, r3, #31
  414a04:	2201      	movs	r2, #1
  414a06:	409a      	lsls	r2, r3
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
  414a08:	69bb      	ldr	r3, [r7, #24]
  414a0a:	611a      	str	r2, [r3, #16]
  414a0c:	e00c      	b.n	414a28 <ioport_set_pin_dir+0x68>
	} else if (dir == IOPORT_DIR_INPUT) {
  414a0e:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
  414a12:	2b00      	cmp	r3, #0
  414a14:	d108      	bne.n	414a28 <ioport_set_pin_dir+0x68>
  414a16:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  414a18:	613b      	str	r3, [r7, #16]
	return 1U << (pin & 0x1F);
  414a1a:	693b      	ldr	r3, [r7, #16]
  414a1c:	f003 031f 	and.w	r3, r3, #31
  414a20:	2201      	movs	r2, #1
  414a22:	409a      	lsls	r2, r3
		base->PIO_ODR = arch_ioport_pin_to_mask(pin);
  414a24:	69bb      	ldr	r3, [r7, #24]
  414a26:	615a      	str	r2, [r3, #20]
  414a28:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  414a2a:	60fb      	str	r3, [r7, #12]
	return 1U << (pin & 0x1F);
  414a2c:	68fb      	ldr	r3, [r7, #12]
  414a2e:	f003 031f 	and.w	r3, r3, #31
  414a32:	2201      	movs	r2, #1
  414a34:	409a      	lsls	r2, r3
	base->PIO_OWER = arch_ioport_pin_to_mask(pin);
  414a36:	69bb      	ldr	r3, [r7, #24]
  414a38:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
}
  414a3c:	bf00      	nop
  414a3e:	3734      	adds	r7, #52	; 0x34
  414a40:	46bd      	mov	sp, r7
  414a42:	f85d 7b04 	ldr.w	r7, [sp], #4
  414a46:	4770      	bx	lr

00414a48 <ioport_set_pin_level>:
{
  414a48:	b480      	push	{r7}
  414a4a:	b08b      	sub	sp, #44	; 0x2c
  414a4c:	af00      	add	r7, sp, #0
  414a4e:	6078      	str	r0, [r7, #4]
  414a50:	460b      	mov	r3, r1
  414a52:	70fb      	strb	r3, [r7, #3]
  414a54:	687b      	ldr	r3, [r7, #4]
  414a56:	627b      	str	r3, [r7, #36]	; 0x24
  414a58:	78fb      	ldrb	r3, [r7, #3]
  414a5a:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
  414a5e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  414a60:	61fb      	str	r3, [r7, #28]
  414a62:	69fb      	ldr	r3, [r7, #28]
  414a64:	61bb      	str	r3, [r7, #24]
	return pin >> 5;
  414a66:	69bb      	ldr	r3, [r7, #24]
  414a68:	095b      	lsrs	r3, r3, #5
  414a6a:	617b      	str	r3, [r7, #20]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  414a6c:	697b      	ldr	r3, [r7, #20]
  414a6e:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  414a72:	f203 7307 	addw	r3, r3, #1799	; 0x707
  414a76:	025b      	lsls	r3, r3, #9
	Pio *base = arch_ioport_pin_to_base(pin);
  414a78:	613b      	str	r3, [r7, #16]
	if (level) {
  414a7a:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
  414a7e:	2b00      	cmp	r3, #0
  414a80:	d009      	beq.n	414a96 <ioport_set_pin_level+0x4e>
  414a82:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  414a84:	60fb      	str	r3, [r7, #12]
	return 1U << (pin & 0x1F);
  414a86:	68fb      	ldr	r3, [r7, #12]
  414a88:	f003 031f 	and.w	r3, r3, #31
  414a8c:	2201      	movs	r2, #1
  414a8e:	409a      	lsls	r2, r3
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  414a90:	693b      	ldr	r3, [r7, #16]
  414a92:	631a      	str	r2, [r3, #48]	; 0x30
}
  414a94:	e008      	b.n	414aa8 <ioport_set_pin_level+0x60>
  414a96:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  414a98:	60bb      	str	r3, [r7, #8]
	return 1U << (pin & 0x1F);
  414a9a:	68bb      	ldr	r3, [r7, #8]
  414a9c:	f003 031f 	and.w	r3, r3, #31
  414aa0:	2201      	movs	r2, #1
  414aa2:	409a      	lsls	r2, r3
		base->PIO_CODR = arch_ioport_pin_to_mask(pin);
  414aa4:	693b      	ldr	r3, [r7, #16]
  414aa6:	635a      	str	r2, [r3, #52]	; 0x34
  414aa8:	bf00      	nop
  414aaa:	372c      	adds	r7, #44	; 0x2c
  414aac:	46bd      	mov	sp, r7
  414aae:	f85d 7b04 	ldr.w	r7, [sp], #4
  414ab2:	4770      	bx	lr

00414ab4 <ioport_get_pin_level>:
{
  414ab4:	b480      	push	{r7}
  414ab6:	b089      	sub	sp, #36	; 0x24
  414ab8:	af00      	add	r7, sp, #0
  414aba:	6078      	str	r0, [r7, #4]
  414abc:	687b      	ldr	r3, [r7, #4]
  414abe:	61fb      	str	r3, [r7, #28]
  414ac0:	69fb      	ldr	r3, [r7, #28]
  414ac2:	61bb      	str	r3, [r7, #24]
  414ac4:	69bb      	ldr	r3, [r7, #24]
  414ac6:	617b      	str	r3, [r7, #20]
	return pin >> 5;
  414ac8:	697b      	ldr	r3, [r7, #20]
  414aca:	095b      	lsrs	r3, r3, #5
  414acc:	613b      	str	r3, [r7, #16]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  414ace:	693b      	ldr	r3, [r7, #16]
  414ad0:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  414ad4:	f203 7307 	addw	r3, r3, #1799	; 0x707
  414ad8:	025b      	lsls	r3, r3, #9
	return arch_ioport_pin_to_base(pin)->PIO_PDSR & arch_ioport_pin_to_mask(pin);
  414ada:	6bda      	ldr	r2, [r3, #60]	; 0x3c
  414adc:	69fb      	ldr	r3, [r7, #28]
  414ade:	60fb      	str	r3, [r7, #12]
	return 1U << (pin & 0x1F);
  414ae0:	68fb      	ldr	r3, [r7, #12]
  414ae2:	f003 031f 	and.w	r3, r3, #31
  414ae6:	2101      	movs	r1, #1
  414ae8:	fa01 f303 	lsl.w	r3, r1, r3
	return arch_ioport_pin_to_base(pin)->PIO_PDSR & arch_ioport_pin_to_mask(pin);
  414aec:	4013      	ands	r3, r2
  414aee:	2b00      	cmp	r3, #0
  414af0:	bf14      	ite	ne
  414af2:	2301      	movne	r3, #1
  414af4:	2300      	moveq	r3, #0
  414af6:	b2db      	uxtb	r3, r3
}
  414af8:	4618      	mov	r0, r3
  414afa:	3724      	adds	r7, #36	; 0x24
  414afc:	46bd      	mov	sp, r7
  414afe:	f85d 7b04 	ldr.w	r7, [sp], #4
  414b02:	4770      	bx	lr

00414b04 <ioport_set_pin_sense_mode>:
{
  414b04:	b480      	push	{r7}
  414b06:	b08d      	sub	sp, #52	; 0x34
  414b08:	af00      	add	r7, sp, #0
  414b0a:	6078      	str	r0, [r7, #4]
  414b0c:	460b      	mov	r3, r1
  414b0e:	70fb      	strb	r3, [r7, #3]
  414b10:	687b      	ldr	r3, [r7, #4]
  414b12:	62fb      	str	r3, [r7, #44]	; 0x2c
  414b14:	78fb      	ldrb	r3, [r7, #3]
  414b16:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
  414b1a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  414b1c:	627b      	str	r3, [r7, #36]	; 0x24
	return pin >> 5;
  414b1e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  414b20:	095a      	lsrs	r2, r3, #5
  414b22:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  414b24:	623b      	str	r3, [r7, #32]
	return 1U << (pin & 0x1F);
  414b26:	6a3b      	ldr	r3, [r7, #32]
  414b28:	f003 031f 	and.w	r3, r3, #31
  414b2c:	2101      	movs	r1, #1
  414b2e:	fa01 f303 	lsl.w	r3, r1, r3
  414b32:	61fa      	str	r2, [r7, #28]
  414b34:	61bb      	str	r3, [r7, #24]
  414b36:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
  414b3a:	75fb      	strb	r3, [r7, #23]
  414b3c:	69fb      	ldr	r3, [r7, #28]
  414b3e:	613b      	str	r3, [r7, #16]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  414b40:	693b      	ldr	r3, [r7, #16]
  414b42:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  414b46:	f203 7307 	addw	r3, r3, #1799	; 0x707
  414b4a:	025b      	lsls	r3, r3, #9
	Pio *base = arch_ioport_port_to_base(port);
  414b4c:	60fb      	str	r3, [r7, #12]
	switch(pin_sense) {
  414b4e:	7dfb      	ldrb	r3, [r7, #23]
  414b50:	3b01      	subs	r3, #1
  414b52:	2b03      	cmp	r3, #3
  414b54:	d82e      	bhi.n	414bb4 <ioport_set_pin_sense_mode+0xb0>
  414b56:	a201      	add	r2, pc, #4	; (adr r2, 414b5c <ioport_set_pin_sense_mode+0x58>)
  414b58:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  414b5c:	00414b91 	.word	0x00414b91
  414b60:	00414ba3 	.word	0x00414ba3
  414b64:	00414b6d 	.word	0x00414b6d
  414b68:	00414b7f 	.word	0x00414b7f
		base->PIO_LSR = mask;
  414b6c:	68fb      	ldr	r3, [r7, #12]
  414b6e:	69ba      	ldr	r2, [r7, #24]
  414b70:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
		base->PIO_FELLSR = mask;
  414b74:	68fb      	ldr	r3, [r7, #12]
  414b76:	69ba      	ldr	r2, [r7, #24]
  414b78:	f8c3 20d0 	str.w	r2, [r3, #208]	; 0xd0
  414b7c:	e01f      	b.n	414bbe <ioport_set_pin_sense_mode+0xba>
		base->PIO_LSR = mask;
  414b7e:	68fb      	ldr	r3, [r7, #12]
  414b80:	69ba      	ldr	r2, [r7, #24]
  414b82:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
		base->PIO_REHLSR = mask;
  414b86:	68fb      	ldr	r3, [r7, #12]
  414b88:	69ba      	ldr	r2, [r7, #24]
  414b8a:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
  414b8e:	e016      	b.n	414bbe <ioport_set_pin_sense_mode+0xba>
		base->PIO_ESR = mask;
  414b90:	68fb      	ldr	r3, [r7, #12]
  414b92:	69ba      	ldr	r2, [r7, #24]
  414b94:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
		base->PIO_FELLSR = mask;
  414b98:	68fb      	ldr	r3, [r7, #12]
  414b9a:	69ba      	ldr	r2, [r7, #24]
  414b9c:	f8c3 20d0 	str.w	r2, [r3, #208]	; 0xd0
  414ba0:	e00d      	b.n	414bbe <ioport_set_pin_sense_mode+0xba>
		base->PIO_ESR = mask;
  414ba2:	68fb      	ldr	r3, [r7, #12]
  414ba4:	69ba      	ldr	r2, [r7, #24]
  414ba6:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
		base->PIO_REHLSR = mask;
  414baa:	68fb      	ldr	r3, [r7, #12]
  414bac:	69ba      	ldr	r2, [r7, #24]
  414bae:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
  414bb2:	e004      	b.n	414bbe <ioport_set_pin_sense_mode+0xba>
		base->PIO_AIMDR = mask;
  414bb4:	68fb      	ldr	r3, [r7, #12]
  414bb6:	69ba      	ldr	r2, [r7, #24]
  414bb8:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
}
  414bbc:	e003      	b.n	414bc6 <ioport_set_pin_sense_mode+0xc2>
	base->PIO_AIMER = mask;
  414bbe:	68fb      	ldr	r3, [r7, #12]
  414bc0:	69ba      	ldr	r2, [r7, #24]
  414bc2:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
  414bc6:	bf00      	nop
  414bc8:	3734      	adds	r7, #52	; 0x34
  414bca:	46bd      	mov	sp, r7
  414bcc:	f85d 7b04 	ldr.w	r7, [sp], #4
  414bd0:	4770      	bx	lr
  414bd2:	bf00      	nop

00414bd4 <spi_disable>:
{
  414bd4:	b480      	push	{r7}
  414bd6:	b083      	sub	sp, #12
  414bd8:	af00      	add	r7, sp, #0
  414bda:	6078      	str	r0, [r7, #4]
	p_spi->SPI_CR = SPI_CR_SPIDIS;
  414bdc:	687b      	ldr	r3, [r7, #4]
  414bde:	2202      	movs	r2, #2
  414be0:	601a      	str	r2, [r3, #0]
}
  414be2:	bf00      	nop
  414be4:	370c      	adds	r7, #12
  414be6:	46bd      	mov	sp, r7
  414be8:	f85d 7b04 	ldr.w	r7, [sp], #4
  414bec:	4770      	bx	lr
	...

00414bf0 <DESAC_SwicthDebounce>:
uint16_t wDESAC_swdeb = 0;					// Switch debounce

uint8_t wDESAC_enabled = false;

void DESAC_SwicthDebounce(void)
{
  414bf0:	b580      	push	{r7, lr}
  414bf2:	af00      	add	r7, sp, #0
	if (wDESAC_swst==DESAC_SWITCH_OFF)
  414bf4:	4b1e      	ldr	r3, [pc, #120]	; (414c70 <DESAC_SwicthDebounce+0x80>)
  414bf6:	781b      	ldrb	r3, [r3, #0]
  414bf8:	2b01      	cmp	r3, #1
  414bfa:	d120      	bne.n	414c3e <DESAC_SwicthDebounce+0x4e>
	{
		if (ioport_get_pin_level(GPIO_PUSH_BUTTON_1) == DESAC_SWITCH_ON)	
  414bfc:	2002      	movs	r0, #2
  414bfe:	4b1d      	ldr	r3, [pc, #116]	; (414c74 <DESAC_SwicthDebounce+0x84>)
  414c00:	4798      	blx	r3
  414c02:	4603      	mov	r3, r0
  414c04:	f083 0301 	eor.w	r3, r3, #1
  414c08:	b2db      	uxtb	r3, r3
  414c0a:	2b00      	cmp	r3, #0
  414c0c:	d013      	beq.n	414c36 <DESAC_SwicthDebounce+0x46>
		{	if (wDESAC_swdeb++ >= DESAC_SWITCH_DEBOUNCE)
  414c0e:	4b1a      	ldr	r3, [pc, #104]	; (414c78 <DESAC_SwicthDebounce+0x88>)
  414c10:	881b      	ldrh	r3, [r3, #0]
  414c12:	1c5a      	adds	r2, r3, #1
  414c14:	b291      	uxth	r1, r2
  414c16:	4a18      	ldr	r2, [pc, #96]	; (414c78 <DESAC_SwicthDebounce+0x88>)
  414c18:	8011      	strh	r1, [r2, #0]
  414c1a:	f640 32b7 	movw	r2, #2999	; 0xbb7
  414c1e:	4293      	cmp	r3, r2
  414c20:	d924      	bls.n	414c6c <DESAC_SwicthDebounce+0x7c>
			{	wDESAC_swdeb=0;
  414c22:	4b15      	ldr	r3, [pc, #84]	; (414c78 <DESAC_SwicthDebounce+0x88>)
  414c24:	2200      	movs	r2, #0
  414c26:	801a      	strh	r2, [r3, #0]
				wDESAC_swst=DESAC_SWITCH_ON;
  414c28:	4b11      	ldr	r3, [pc, #68]	; (414c70 <DESAC_SwicthDebounce+0x80>)
  414c2a:	2200      	movs	r2, #0
  414c2c:	701a      	strb	r2, [r3, #0]
				wHLED_mode		= HLED_MODE_DESACOPLANDO;
  414c2e:	4b13      	ldr	r3, [pc, #76]	; (414c7c <DESAC_SwicthDebounce+0x8c>)
  414c30:	2201      	movs	r2, #1
  414c32:	701a      	strb	r2, [r3, #0]
		}
		else
		{	wDESAC_swdeb=0;
		}
	}
}
  414c34:	e01a      	b.n	414c6c <DESAC_SwicthDebounce+0x7c>
		{	wDESAC_swdeb=0;	
  414c36:	4b10      	ldr	r3, [pc, #64]	; (414c78 <DESAC_SwicthDebounce+0x88>)
  414c38:	2200      	movs	r2, #0
  414c3a:	801a      	strh	r2, [r3, #0]
}
  414c3c:	e016      	b.n	414c6c <DESAC_SwicthDebounce+0x7c>
		if (ioport_get_pin_level(GPIO_PUSH_BUTTON_1) == DESAC_SWITCH_OFF)
  414c3e:	2002      	movs	r0, #2
  414c40:	4b0c      	ldr	r3, [pc, #48]	; (414c74 <DESAC_SwicthDebounce+0x84>)
  414c42:	4798      	blx	r3
  414c44:	4603      	mov	r3, r0
  414c46:	2b00      	cmp	r3, #0
  414c48:	d00d      	beq.n	414c66 <DESAC_SwicthDebounce+0x76>
		{	if (wDESAC_swdeb++ >= DESAC_SWITCH_DEBOUNCE)
  414c4a:	4b0b      	ldr	r3, [pc, #44]	; (414c78 <DESAC_SwicthDebounce+0x88>)
  414c4c:	881b      	ldrh	r3, [r3, #0]
  414c4e:	1c5a      	adds	r2, r3, #1
  414c50:	b291      	uxth	r1, r2
  414c52:	4a09      	ldr	r2, [pc, #36]	; (414c78 <DESAC_SwicthDebounce+0x88>)
  414c54:	8011      	strh	r1, [r2, #0]
  414c56:	f640 32b7 	movw	r2, #2999	; 0xbb7
  414c5a:	4293      	cmp	r3, r2
  414c5c:	d906      	bls.n	414c6c <DESAC_SwicthDebounce+0x7c>
			{	wDESAC_swdeb=0;
  414c5e:	4b06      	ldr	r3, [pc, #24]	; (414c78 <DESAC_SwicthDebounce+0x88>)
  414c60:	2200      	movs	r2, #0
  414c62:	801a      	strh	r2, [r3, #0]
}
  414c64:	e002      	b.n	414c6c <DESAC_SwicthDebounce+0x7c>
		{	wDESAC_swdeb=0;
  414c66:	4b04      	ldr	r3, [pc, #16]	; (414c78 <DESAC_SwicthDebounce+0x88>)
  414c68:	2200      	movs	r2, #0
  414c6a:	801a      	strh	r2, [r3, #0]
}
  414c6c:	bf00      	nop
  414c6e:	bd80      	pop	{r7, pc}
  414c70:	20000134 	.word	0x20000134
  414c74:	00414ab5 	.word	0x00414ab5
  414c78:	2000b4fc 	.word	0x2000b4fc
  414c7c:	2000b4ff 	.word	0x2000b4ff

00414c80 <DESAC_Check>:


void DESAC_Check(void)
{
  414c80:	b580      	push	{r7, lr}
  414c82:	af00      	add	r7, sp, #0
	if (wDESAC_swst == DESAC_SWITCH_ON)
  414c84:	4b03      	ldr	r3, [pc, #12]	; (414c94 <DESAC_Check+0x14>)
  414c86:	781b      	ldrb	r3, [r3, #0]
  414c88:	2b00      	cmp	r3, #0
  414c8a:	d101      	bne.n	414c90 <DESAC_Check+0x10>
	{
		DESAC_Desacopla();
  414c8c:	4b02      	ldr	r3, [pc, #8]	; (414c98 <DESAC_Check+0x18>)
  414c8e:	4798      	blx	r3
	}
}
  414c90:	bf00      	nop
  414c92:	bd80      	pop	{r7, pc}
  414c94:	20000134 	.word	0x20000134
  414c98:	00414c9d 	.word	0x00414c9d

00414c9c <DESAC_Desacopla>:
} while (0)



void DESAC_Desacopla(void)
{
  414c9c:	b580      	push	{r7, lr}
  414c9e:	af00      	add	r7, sp, #0
	wDESAC_enabled	= true;
  414ca0:	4b23      	ldr	r3, [pc, #140]	; (414d30 <DESAC_Desacopla+0x94>)
  414ca2:	2201      	movs	r2, #1
  414ca4:	701a      	strb	r2, [r3, #0]
	wHLED_mode		= HLED_MODE_DESACOPLADO;
  414ca6:	4b23      	ldr	r3, [pc, #140]	; (414d34 <DESAC_Desacopla+0x98>)
  414ca8:	2202      	movs	r2, #2
  414caa:	701a      	strb	r2, [r3, #0]
	
	// Close socket
	vSocket_ADC_tcp_close();
  414cac:	4b22      	ldr	r3, [pc, #136]	; (414d38 <DESAC_Desacopla+0x9c>)
  414cae:	4798      	blx	r3

	// Desabilita ISR ADC
	NVIC_DisableIRQ(PIOD_IRQn);		// Conector EXT3
  414cb0:	200c      	movs	r0, #12
  414cb2:	4b22      	ldr	r3, [pc, #136]	; (414d3c <DESAC_Desacopla+0xa0>)
  414cb4:	4798      	blx	r3
	
	/// Reset pin (keep ADC reset)
	ioport_set_pin_level(PIO_PD26_IDX, IOPORT_PIN_LEVEL_LOW);
  414cb6:	2100      	movs	r1, #0
  414cb8:	207a      	movs	r0, #122	; 0x7a
  414cba:	4b21      	ldr	r3, [pc, #132]	; (414d40 <DESAC_Desacopla+0xa4>)
  414cbc:	4798      	blx	r3

	// Close SPI (ADC)
	spi_disable(SPI);
  414cbe:	4821      	ldr	r0, [pc, #132]	; (414d44 <DESAC_Desacopla+0xa8>)
  414cc0:	4b21      	ldr	r3, [pc, #132]	; (414d48 <DESAC_Desacopla+0xac>)
  414cc2:	4798      	blx	r3
	ioport_set_pin_input_mode(SPI_MISO_GPIO,IOPORT_MODE_OPEN_DRAIN,0);
  414cc4:	2100      	movs	r1, #0
  414cc6:	200c      	movs	r0, #12
  414cc8:	4b20      	ldr	r3, [pc, #128]	; (414d4c <DESAC_Desacopla+0xb0>)
  414cca:	4798      	blx	r3
  414ccc:	2120      	movs	r1, #32
  414cce:	200c      	movs	r0, #12
  414cd0:	4b1f      	ldr	r3, [pc, #124]	; (414d50 <DESAC_Desacopla+0xb4>)
  414cd2:	4798      	blx	r3
  414cd4:	2100      	movs	r1, #0
  414cd6:	200c      	movs	r0, #12
  414cd8:	4b1e      	ldr	r3, [pc, #120]	; (414d54 <DESAC_Desacopla+0xb8>)
  414cda:	4798      	blx	r3
	ioport_set_pin_input_mode(SPI_MOSI_GPIO,IOPORT_MODE_OPEN_DRAIN,0);
  414cdc:	2100      	movs	r1, #0
  414cde:	200d      	movs	r0, #13
  414ce0:	4b1a      	ldr	r3, [pc, #104]	; (414d4c <DESAC_Desacopla+0xb0>)
  414ce2:	4798      	blx	r3
  414ce4:	2120      	movs	r1, #32
  414ce6:	200d      	movs	r0, #13
  414ce8:	4b19      	ldr	r3, [pc, #100]	; (414d50 <DESAC_Desacopla+0xb4>)
  414cea:	4798      	blx	r3
  414cec:	2100      	movs	r1, #0
  414cee:	200d      	movs	r0, #13
  414cf0:	4b18      	ldr	r3, [pc, #96]	; (414d54 <DESAC_Desacopla+0xb8>)
  414cf2:	4798      	blx	r3
	ioport_set_pin_input_mode(SPI_SPCK_GPIO,IOPORT_MODE_OPEN_DRAIN,0);
  414cf4:	2100      	movs	r1, #0
  414cf6:	200e      	movs	r0, #14
  414cf8:	4b14      	ldr	r3, [pc, #80]	; (414d4c <DESAC_Desacopla+0xb0>)
  414cfa:	4798      	blx	r3
  414cfc:	2120      	movs	r1, #32
  414cfe:	200e      	movs	r0, #14
  414d00:	4b13      	ldr	r3, [pc, #76]	; (414d50 <DESAC_Desacopla+0xb4>)
  414d02:	4798      	blx	r3
  414d04:	2100      	movs	r1, #0
  414d06:	200e      	movs	r0, #14
  414d08:	4b12      	ldr	r3, [pc, #72]	; (414d54 <DESAC_Desacopla+0xb8>)
  414d0a:	4798      	blx	r3
	ioport_set_pin_input_mode(SPI_NPCS3_PA5_GPIO,IOPORT_MODE_OPEN_DRAIN,0);
  414d0c:	2100      	movs	r1, #0
  414d0e:	2005      	movs	r0, #5
  414d10:	4b0e      	ldr	r3, [pc, #56]	; (414d4c <DESAC_Desacopla+0xb0>)
  414d12:	4798      	blx	r3
  414d14:	2120      	movs	r1, #32
  414d16:	2005      	movs	r0, #5
  414d18:	4b0d      	ldr	r3, [pc, #52]	; (414d50 <DESAC_Desacopla+0xb4>)
  414d1a:	4798      	blx	r3
  414d1c:	2100      	movs	r1, #0
  414d1e:	2005      	movs	r0, #5
  414d20:	4b0c      	ldr	r3, [pc, #48]	; (414d54 <DESAC_Desacopla+0xb8>)
  414d22:	4798      	blx	r3
	
	printf ("\n\n*** PLACAS uC e ADC DESACOPLADAS ***\n\n");
  414d24:	480c      	ldr	r0, [pc, #48]	; (414d58 <DESAC_Desacopla+0xbc>)
  414d26:	4b0d      	ldr	r3, [pc, #52]	; (414d5c <DESAC_Desacopla+0xc0>)
  414d28:	4798      	blx	r3

}
  414d2a:	bf00      	nop
  414d2c:	bd80      	pop	{r7, pc}
  414d2e:	bf00      	nop
  414d30:	2000b4fe 	.word	0x2000b4fe
  414d34:	2000b4ff 	.word	0x2000b4ff
  414d38:	004155a5 	.word	0x004155a5
  414d3c:	00414871 	.word	0x00414871
  414d40:	00414a49 	.word	0x00414a49
  414d44:	40088000 	.word	0x40088000
  414d48:	00414bd5 	.word	0x00414bd5
  414d4c:	004149c1 	.word	0x004149c1
  414d50:	004148a5 	.word	0x004148a5
  414d54:	00414b05 	.word	0x00414b05
  414d58:	0041e454 	.word	0x0041e454
  414d5c:	00416c7d 	.word	0x00416c7d

00414d60 <HICS_Task>:
#include "htask.h"

HTASK_TICKS_SCHEDULER hsched;

void HICS_Task(void *pvParameters)
{
  414d60:	b590      	push	{r4, r7, lr}
  414d62:	b083      	sub	sp, #12
  414d64:	af00      	add	r7, sp, #0
  414d66:	6078      	str	r0, [r7, #4]
	UNUSED(pvParameters);

	vTaskDelay(  (5000UL / portTICK_PERIOD_MS) ); // Delay para aguardar o sistema se estabilizar (5000ms)
  414d68:	f241 3088 	movw	r0, #5000	; 0x1388
  414d6c:	4b32      	ldr	r3, [pc, #200]	; (414e38 <HICS_Task+0xd8>)
  414d6e:	4798      	blx	r3

	// Inicializa tick schedulers
	hsched.ps=0;
  414d70:	4b32      	ldr	r3, [pc, #200]	; (414e3c <HICS_Task+0xdc>)
  414d72:	2200      	movs	r2, #0
  414d74:	609a      	str	r2, [r3, #8]
	hsched.ps_rst=0;
  414d76:	4b31      	ldr	r3, [pc, #196]	; (414e3c <HICS_Task+0xdc>)
  414d78:	2200      	movs	r2, #0
  414d7a:	731a      	strb	r2, [r3, #12]
	hsched.sntp=0;
  414d7c:	4b2f      	ldr	r3, [pc, #188]	; (414e3c <HICS_Task+0xdc>)
  414d7e:	2200      	movs	r2, #0
  414d80:	601a      	str	r2, [r3, #0]
	hsched.sntp_rst=0;
  414d82:	4b2e      	ldr	r3, [pc, #184]	; (414e3c <HICS_Task+0xdc>)
  414d84:	2200      	movs	r2, #0
  414d86:	711a      	strb	r2, [r3, #4]

	// Inicializa ADC e ISR
	ADC_Init();
  414d88:	4b2d      	ldr	r3, [pc, #180]	; (414e40 <HICS_Task+0xe0>)
  414d8a:	4798      	blx	r3

	WDT_Init();	// Inicializa WDT
  414d8c:	4b2d      	ldr	r3, [pc, #180]	; (414e44 <HICS_Task+0xe4>)
  414d8e:	4798      	blx	r3

	while (wDESAC_enabled == false)
  414d90:	e047      	b.n	414e22 <HICS_Task+0xc2>
	{
		WDT_Refresh(); // Refresh WDT
  414d92:	4b2d      	ldr	r3, [pc, #180]	; (414e48 <HICS_Task+0xe8>)
  414d94:	4798      	blx	r3

		// Verifica se solicitado desacoplamento
		DESAC_Check();
  414d96:	4b2d      	ldr	r3, [pc, #180]	; (414e4c <HICS_Task+0xec>)
  414d98:	4798      	blx	r3
		
		// ADC Task
		ADC_task_steps();
  414d9a:	4b2d      	ldr	r3, [pc, #180]	; (414e50 <HICS_Task+0xf0>)
  414d9c:	4798      	blx	r3
		
		// HICS print status
		if (hsched.ps > HICS_SCHEDULER_PS)
  414d9e:	4b27      	ldr	r3, [pc, #156]	; (414e3c <HICS_Task+0xdc>)
  414da0:	689b      	ldr	r3, [r3, #8]
  414da2:	f247 5230 	movw	r2, #30000	; 0x7530
  414da6:	4293      	cmp	r3, r2
  414da8:	d933      	bls.n	414e12 <HICS_Task+0xb2>
		{
			hsched.ps_rst=1;
  414daa:	4b24      	ldr	r3, [pc, #144]	; (414e3c <HICS_Task+0xdc>)
  414dac:	2201      	movs	r2, #1
  414dae:	731a      	strb	r2, [r3, #12]

			//vTaskDelay(  (1UL / portTICK_PERIOD_MS) );

			printf ("\nErr=%d\n", wHICS_errorcode);
  414db0:	4b28      	ldr	r3, [pc, #160]	; (414e54 <HICS_Task+0xf4>)
  414db2:	881b      	ldrh	r3, [r3, #0]
  414db4:	b29b      	uxth	r3, r3
  414db6:	4619      	mov	r1, r3
  414db8:	4827      	ldr	r0, [pc, #156]	; (414e58 <HICS_Task+0xf8>)
  414dba:	4b28      	ldr	r3, [pc, #160]	; (414e5c <HICS_Task+0xfc>)
  414dbc:	4798      	blx	r3
			
			//printf   ("DESAC=%d\n", wDESAC_enabled);

			printf ("FHme=%d\n", xPortGetMinimumEverFreeHeapSize());
  414dbe:	4b28      	ldr	r3, [pc, #160]	; (414e60 <HICS_Task+0x100>)
  414dc0:	4798      	blx	r3
  414dc2:	4603      	mov	r3, r0
  414dc4:	4619      	mov	r1, r3
  414dc6:	4827      	ldr	r0, [pc, #156]	; (414e64 <HICS_Task+0x104>)
  414dc8:	4b24      	ldr	r3, [pc, #144]	; (414e5c <HICS_Task+0xfc>)
  414dca:	4798      	blx	r3
			printf ("FH=%d\n", xPortGetFreeHeapSize());
  414dcc:	4b26      	ldr	r3, [pc, #152]	; (414e68 <HICS_Task+0x108>)
  414dce:	4798      	blx	r3
  414dd0:	4603      	mov	r3, r0
  414dd2:	4619      	mov	r1, r3
  414dd4:	4825      	ldr	r0, [pc, #148]	; (414e6c <HICS_Task+0x10c>)
  414dd6:	4b21      	ldr	r3, [pc, #132]	; (414e5c <HICS_Task+0xfc>)
  414dd8:	4798      	blx	r3

			extern volatile uint16_t wADCcbuff_sizefulln;	// Debug contador buffer full
			extern volatile uint32_t dwADCcbuff_sizefme;	// Debug buffer free size minimum ever
			extern volatile uint32_t dwADCcbuff_sizeact;	// Debug buffer size atual

			printf   ("BFme=%d\n", dwADCcbuff_sizefme);	// Debug buffer free size minimum ever
  414dda:	4b25      	ldr	r3, [pc, #148]	; (414e70 <HICS_Task+0x110>)
  414ddc:	681b      	ldr	r3, [r3, #0]
  414dde:	4619      	mov	r1, r3
  414de0:	4824      	ldr	r0, [pc, #144]	; (414e74 <HICS_Task+0x114>)
  414de2:	4b1e      	ldr	r3, [pc, #120]	; (414e5c <HICS_Task+0xfc>)
  414de4:	4798      	blx	r3
			printf   ("BFsz=%d\n", dwADCcbuff_sizeact); // Debug buffer size atual
  414de6:	4b24      	ldr	r3, [pc, #144]	; (414e78 <HICS_Task+0x118>)
  414de8:	681b      	ldr	r3, [r3, #0]
  414dea:	4619      	mov	r1, r3
  414dec:	4823      	ldr	r0, [pc, #140]	; (414e7c <HICS_Task+0x11c>)
  414dee:	4b1b      	ldr	r3, [pc, #108]	; (414e5c <HICS_Task+0xfc>)
  414df0:	4798      	blx	r3
			printf   ("BFn=%d\n", wADCcbuff_sizefulln);	// Debug contador buffer full
  414df2:	4b23      	ldr	r3, [pc, #140]	; (414e80 <HICS_Task+0x120>)
  414df4:	881b      	ldrh	r3, [r3, #0]
  414df6:	b29b      	uxth	r3, r3
  414df8:	4619      	mov	r1, r3
  414dfa:	4822      	ldr	r0, [pc, #136]	; (414e84 <HICS_Task+0x124>)
  414dfc:	4b17      	ldr	r3, [pc, #92]	; (414e5c <HICS_Task+0xfc>)
  414dfe:	4798      	blx	r3

			extern volatile uint32_t dwLostSamples_cx;
			extern volatile uint32_t dwLostSamples_old;
			extern volatile uint32_t dwLostSamples_lost_o;
			extern volatile uint32_t dwLostSamples_lost_n;
			printf   ("Lost=%d  %d  %d\n", dwLostSamples_cx, dwLostSamples_lost_o, dwLostSamples_lost_n );
  414e00:	4b21      	ldr	r3, [pc, #132]	; (414e88 <HICS_Task+0x128>)
  414e02:	6819      	ldr	r1, [r3, #0]
  414e04:	4b21      	ldr	r3, [pc, #132]	; (414e8c <HICS_Task+0x12c>)
  414e06:	681a      	ldr	r2, [r3, #0]
  414e08:	4b21      	ldr	r3, [pc, #132]	; (414e90 <HICS_Task+0x130>)
  414e0a:	681b      	ldr	r3, [r3, #0]
  414e0c:	4821      	ldr	r0, [pc, #132]	; (414e94 <HICS_Task+0x134>)
  414e0e:	4c13      	ldr	r4, [pc, #76]	; (414e5c <HICS_Task+0xfc>)
  414e10:	47a0      	blx	r4
		
		}

		taskYIELD();	// Chaveia tasks
  414e12:	4b21      	ldr	r3, [pc, #132]	; (414e98 <HICS_Task+0x138>)
  414e14:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  414e18:	601a      	str	r2, [r3, #0]
  414e1a:	f3bf 8f4f 	dsb	sy
  414e1e:	f3bf 8f6f 	isb	sy
	while (wDESAC_enabled == false)
  414e22:	4b1e      	ldr	r3, [pc, #120]	; (414e9c <HICS_Task+0x13c>)
  414e24:	781b      	ldrb	r3, [r3, #0]
  414e26:	2b00      	cmp	r3, #0
  414e28:	d0b3      	beq.n	414d92 <HICS_Task+0x32>

	}
	
	// Cai aqui qdo placas desacopladas
	while(1)	
	{	WDT_Refresh();
  414e2a:	4b07      	ldr	r3, [pc, #28]	; (414e48 <HICS_Task+0xe8>)
  414e2c:	4798      	blx	r3
		vTaskDelay(  (100UL / portTICK_PERIOD_MS) );	// 100ms	
  414e2e:	2064      	movs	r0, #100	; 0x64
  414e30:	4b01      	ldr	r3, [pc, #4]	; (414e38 <HICS_Task+0xd8>)
  414e32:	4798      	blx	r3
	{	WDT_Refresh();
  414e34:	e7f9      	b.n	414e2a <HICS_Task+0xca>
  414e36:	bf00      	nop
  414e38:	0041256d 	.word	0x0041256d
  414e3c:	2000bc7c 	.word	0x2000bc7c
  414e40:	00413c49 	.word	0x00413c49
  414e44:	00415801 	.word	0x00415801
  414e48:	00415885 	.word	0x00415885
  414e4c:	00414c81 	.word	0x00414c81
  414e50:	004141e9 	.word	0x004141e9
  414e54:	2000b534 	.word	0x2000b534
  414e58:	0041e480 	.word	0x0041e480
  414e5c:	00416c7d 	.word	0x00416c7d
  414e60:	004114b9 	.word	0x004114b9
  414e64:	0041e48c 	.word	0x0041e48c
  414e68:	004114a1 	.word	0x004114a1
  414e6c:	0041e498 	.word	0x0041e498
  414e70:	2000012c 	.word	0x2000012c
  414e74:	0041e4a0 	.word	0x0041e4a0
  414e78:	2000b4e4 	.word	0x2000b4e4
  414e7c:	0041e4ac 	.word	0x0041e4ac
  414e80:	2000b4e0 	.word	0x2000b4e0
  414e84:	0041e4b8 	.word	0x0041e4b8
  414e88:	2000b4ec 	.word	0x2000b4ec
  414e8c:	2000b4f4 	.word	0x2000b4f4
  414e90:	2000b4f8 	.word	0x2000b4f8
  414e94:	0041e4c0 	.word	0x0041e4c0
  414e98:	e000ed04 	.word	0xe000ed04
  414e9c:	2000b4fe 	.word	0x2000b4fe

00414ea0 <HUSEC_CalcFromNTP>:
#include "h_sntp.h"
#include "husec.h"


uint64_t HUSEC_CalcFromNTP(void)
{
  414ea0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  414ea4:	b08b      	sub	sp, #44	; 0x2c
  414ea6:	af00      	add	r7, sp, #0
	// Obtem os nanosegundos do pacote NTP
	// The NTP fractional part represents the number of fractional units (a unit is 1/((2^32)-1)) in the second.
	// Int32 milliseconds = (Int32)(((Double)fraction / 2^32-1) * 1000);
	// Int32 nanoseconds  = (Int32)(((Double)fraction / 2^32-1) * 1000000000);
	
	fraction = (double) FreeRTOS_ntohl(stNTP_packet_rx.transmit_timestamp_frac); // take care of the endianness
  414ea8:	4b59      	ldr	r3, [pc, #356]	; (415010 <HUSEC_CalcFromNTP+0x170>)
  414eaa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  414eac:	061a      	lsls	r2, r3, #24
  414eae:	4b58      	ldr	r3, [pc, #352]	; (415010 <HUSEC_CalcFromNTP+0x170>)
  414eb0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  414eb2:	021b      	lsls	r3, r3, #8
  414eb4:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
  414eb8:	431a      	orrs	r2, r3
  414eba:	4b55      	ldr	r3, [pc, #340]	; (415010 <HUSEC_CalcFromNTP+0x170>)
  414ebc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  414ebe:	0a1b      	lsrs	r3, r3, #8
  414ec0:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
  414ec4:	431a      	orrs	r2, r3
  414ec6:	4b52      	ldr	r3, [pc, #328]	; (415010 <HUSEC_CalcFromNTP+0x170>)
  414ec8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  414eca:	0e1b      	lsrs	r3, r3, #24
  414ecc:	431a      	orrs	r2, r3
  414ece:	4b51      	ldr	r3, [pc, #324]	; (415014 <HUSEC_CalcFromNTP+0x174>)
  414ed0:	4610      	mov	r0, r2
  414ed2:	4798      	blx	r3
  414ed4:	4603      	mov	r3, r0
  414ed6:	460c      	mov	r4, r1
  414ed8:	e9c7 3402 	strd	r3, r4, [r7, #8]
	fraction = (double) fraction / NTP_MAX_INT_AS_DOUBLE;
  414edc:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
  414ee0:	4c4d      	ldr	r4, [pc, #308]	; (415018 <HUSEC_CalcFromNTP+0x178>)
  414ee2:	a347      	add	r3, pc, #284	; (adr r3, 415000 <HUSEC_CalcFromNTP+0x160>)
  414ee4:	e9d3 2300 	ldrd	r2, r3, [r3]
  414ee8:	47a0      	blx	r4
  414eea:	4603      	mov	r3, r0
  414eec:	460c      	mov	r4, r1
  414eee:	e9c7 3402 	strd	r3, r4, [r7, #8]
	fraction = (double) fraction * 1000000000.0;
  414ef2:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
  414ef6:	4c49      	ldr	r4, [pc, #292]	; (41501c <HUSEC_CalcFromNTP+0x17c>)
  414ef8:	a343      	add	r3, pc, #268	; (adr r3, 415008 <HUSEC_CalcFromNTP+0x168>)
  414efa:	e9d3 2300 	ldrd	r2, r3, [r3]
  414efe:	47a0      	blx	r4
  414f00:	4603      	mov	r3, r0
  414f02:	460c      	mov	r4, r1
  414f04:	e9c7 3402 	strd	r3, r4, [r7, #8]

	ulNanoseconds = (uint32_t) fraction;
  414f08:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
  414f0c:	4a44      	ldr	r2, [pc, #272]	; (415020 <HUSEC_CalcFromNTP+0x180>)
  414f0e:	4618      	mov	r0, r3
  414f10:	4621      	mov	r1, r4
  414f12:	4790      	blx	r2
  414f14:	4603      	mov	r3, r0
  414f16:	61bb      	str	r3, [r7, #24]
	if (ulNanoseconds>=1000000000)	// Checa inconsistencia: Se 1s (ou maior) entao tem que descartar
  414f18:	69bb      	ldr	r3, [r7, #24]
  414f1a:	4a42      	ldr	r2, [pc, #264]	; (415024 <HUSEC_CalcFromNTP+0x184>)
  414f1c:	4293      	cmp	r3, r2
  414f1e:	d901      	bls.n	414f24 <HUSEC_CalcFromNTP+0x84>
	ulNanoseconds=0;
  414f20:	2300      	movs	r3, #0
  414f22:	61bb      	str	r3, [r7, #24]

	// Extrai segundos do pacote NTP
	// NTP trabalha com epoch time de 1900 (quantidade de segundos desde 1900)
	ulSeconds1970 = FreeRTOS_ntohl(stNTP_packet_rx.transmit_timestamp_sec); // take care of the endianness
  414f24:	4b3a      	ldr	r3, [pc, #232]	; (415010 <HUSEC_CalcFromNTP+0x170>)
  414f26:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  414f28:	061a      	lsls	r2, r3, #24
  414f2a:	4b39      	ldr	r3, [pc, #228]	; (415010 <HUSEC_CalcFromNTP+0x170>)
  414f2c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  414f2e:	021b      	lsls	r3, r3, #8
  414f30:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
  414f34:	431a      	orrs	r2, r3
  414f36:	4b36      	ldr	r3, [pc, #216]	; (415010 <HUSEC_CalcFromNTP+0x170>)
  414f38:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  414f3a:	0a1b      	lsrs	r3, r3, #8
  414f3c:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
  414f40:	431a      	orrs	r2, r3
  414f42:	4b33      	ldr	r3, [pc, #204]	; (415010 <HUSEC_CalcFromNTP+0x170>)
  414f44:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  414f46:	0e1b      	lsrs	r3, r3, #24
  414f48:	4313      	orrs	r3, r2
  414f4a:	61fb      	str	r3, [r7, #28]
	ulSeconds1970 = ulSeconds1970 - NTP_TIMESTAMP_DELTA; // Traz o epoch time para 1970 (unix epoch time)
  414f4c:	69fa      	ldr	r2, [r7, #28]
  414f4e:	4b36      	ldr	r3, [pc, #216]	; (415028 <HUSEC_CalcFromNTP+0x188>)
  414f50:	4413      	add	r3, r2
  414f52:	61fb      	str	r3, [r7, #28]

	// HUSEC Convertion Procedure
	u64husec = (uint64_t) (ulSeconds1970 % HUSEC_ONEDAY_SECONDS);	// get the number of seconds of the present day getting
  414f54:	69fa      	ldr	r2, [r7, #28]
  414f56:	4b35      	ldr	r3, [pc, #212]	; (41502c <HUSEC_CalcFromNTP+0x18c>)
  414f58:	fba3 1302 	umull	r1, r3, r3, r2
  414f5c:	0c1b      	lsrs	r3, r3, #16
  414f5e:	4934      	ldr	r1, [pc, #208]	; (415030 <HUSEC_CalcFromNTP+0x190>)
  414f60:	fb01 f303 	mul.w	r3, r1, r3
  414f64:	1ad3      	subs	r3, r2, r3
  414f66:	f04f 0400 	mov.w	r4, #0
  414f6a:	e9c7 3408 	strd	r3, r4, [r7, #32]
																	// the remainder of the division by 86400 (total number of seconds in a day)

	u64husec = u64husec * HUSEC_SEC2HUSEC;	// convert seconds to husecs
  414f6e:	e9d7 1208 	ldrd	r1, r2, [r7, #32]
  414f72:	460b      	mov	r3, r1
  414f74:	4614      	mov	r4, r2
  414f76:	00a0      	lsls	r0, r4, #2
  414f78:	6078      	str	r0, [r7, #4]
  414f7a:	6878      	ldr	r0, [r7, #4]
  414f7c:	ea40 7093 	orr.w	r0, r0, r3, lsr #30
  414f80:	6078      	str	r0, [r7, #4]
  414f82:	009b      	lsls	r3, r3, #2
  414f84:	603b      	str	r3, [r7, #0]
  414f86:	e9d7 3400 	ldrd	r3, r4, [r7]
  414f8a:	185b      	adds	r3, r3, r1
  414f8c:	eb44 0402 	adc.w	r4, r4, r2
  414f90:	ea4f 0bc4 	mov.w	fp, r4, lsl #3
  414f94:	ea4b 7b53 	orr.w	fp, fp, r3, lsr #29
  414f98:	ea4f 0ac3 	mov.w	sl, r3, lsl #3
  414f9c:	4653      	mov	r3, sl
  414f9e:	465c      	mov	r4, fp
  414fa0:	1a5b      	subs	r3, r3, r1
  414fa2:	eb64 0402 	sbc.w	r4, r4, r2
  414fa6:	ea4f 1904 	mov.w	r9, r4, lsl #4
  414faa:	ea49 7913 	orr.w	r9, r9, r3, lsr #28
  414fae:	ea4f 1803 	mov.w	r8, r3, lsl #4
  414fb2:	4643      	mov	r3, r8
  414fb4:	464c      	mov	r4, r9
  414fb6:	185b      	adds	r3, r3, r1
  414fb8:	eb44 0402 	adc.w	r4, r4, r2
  414fbc:	0126      	lsls	r6, r4, #4
  414fbe:	ea46 7613 	orr.w	r6, r6, r3, lsr #28
  414fc2:	011d      	lsls	r5, r3, #4
  414fc4:	462b      	mov	r3, r5
  414fc6:	4634      	mov	r4, r6
  414fc8:	e9c7 3408 	strd	r3, r4, [r7, #32]

	u64husec = u64husec + (uint64_t) (ulNanoseconds/HUSEC_HUSEC2NSEC);	// convert nanoseconds of the present second to husecs and get the total
  414fcc:	69bb      	ldr	r3, [r7, #24]
  414fce:	095b      	lsrs	r3, r3, #5
  414fd0:	4a18      	ldr	r2, [pc, #96]	; (415034 <HUSEC_CalcFromNTP+0x194>)
  414fd2:	fba2 2303 	umull	r2, r3, r2, r3
  414fd6:	09db      	lsrs	r3, r3, #7
  414fd8:	4619      	mov	r1, r3
  414fda:	f04f 0200 	mov.w	r2, #0
  414fde:	e9d7 3408 	ldrd	r3, r4, [r7, #32]
  414fe2:	185b      	adds	r3, r3, r1
  414fe4:	eb44 0402 	adc.w	r4, r4, r2
  414fe8:	e9c7 3408 	strd	r3, r4, [r7, #32]

	return u64husec;
  414fec:	e9d7 3408 	ldrd	r3, r4, [r7, #32]
	
}
  414ff0:	4618      	mov	r0, r3
  414ff2:	4621      	mov	r1, r4
  414ff4:	372c      	adds	r7, #44	; 0x2c
  414ff6:	46bd      	mov	sp, r7
  414ff8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  414ffc:	f3af 8000 	nop.w
  415000:	ffe00000 	.word	0xffe00000
  415004:	41efffff 	.word	0x41efffff
  415008:	00000000 	.word	0x00000000
  41500c:	41cdcd65 	.word	0x41cdcd65
  415010:	2000b504 	.word	0x2000b504
  415014:	004165cd 	.word	0x004165cd
  415018:	0041690d 	.word	0x0041690d
  41501c:	004166b9 	.word	0x004166b9
  415020:	00416bed 	.word	0x00416bed
  415024:	3b9ac9ff 	.word	0x3b9ac9ff
  415028:	7c558180 	.word	0x7c558180
  41502c:	c22e4507 	.word	0xc22e4507
  415030:	00015180 	.word	0x00015180
  415034:	0a7c5ac5 	.word	0x0a7c5ac5

00415038 <ioport_toggle_pin_level>:
{
  415038:	b480      	push	{r7}
  41503a:	b08b      	sub	sp, #44	; 0x2c
  41503c:	af00      	add	r7, sp, #0
  41503e:	6078      	str	r0, [r7, #4]
  415040:	687b      	ldr	r3, [r7, #4]
  415042:	627b      	str	r3, [r7, #36]	; 0x24
  415044:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  415046:	623b      	str	r3, [r7, #32]
  415048:	6a3b      	ldr	r3, [r7, #32]
  41504a:	61fb      	str	r3, [r7, #28]
	return pin >> 5;
  41504c:	69fb      	ldr	r3, [r7, #28]
  41504e:	095b      	lsrs	r3, r3, #5
  415050:	61bb      	str	r3, [r7, #24]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  415052:	69bb      	ldr	r3, [r7, #24]
  415054:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  415058:	f203 7307 	addw	r3, r3, #1799	; 0x707
  41505c:	025b      	lsls	r3, r3, #9
	Pio *port = arch_ioport_pin_to_base(pin);
  41505e:	617b      	str	r3, [r7, #20]
  415060:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  415062:	613b      	str	r3, [r7, #16]
	return 1U << (pin & 0x1F);
  415064:	693b      	ldr	r3, [r7, #16]
  415066:	f003 031f 	and.w	r3, r3, #31
  41506a:	2201      	movs	r2, #1
  41506c:	fa02 f303 	lsl.w	r3, r2, r3
	ioport_port_mask_t mask = arch_ioport_pin_to_mask(pin);
  415070:	60fb      	str	r3, [r7, #12]
	if (port->PIO_PDSR & arch_ioport_pin_to_mask(pin)) {
  415072:	697b      	ldr	r3, [r7, #20]
  415074:	6bda      	ldr	r2, [r3, #60]	; 0x3c
  415076:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  415078:	60bb      	str	r3, [r7, #8]
	return 1U << (pin & 0x1F);
  41507a:	68bb      	ldr	r3, [r7, #8]
  41507c:	f003 031f 	and.w	r3, r3, #31
  415080:	2101      	movs	r1, #1
  415082:	fa01 f303 	lsl.w	r3, r1, r3
	if (port->PIO_PDSR & arch_ioport_pin_to_mask(pin)) {
  415086:	4013      	ands	r3, r2
  415088:	2b00      	cmp	r3, #0
  41508a:	d003      	beq.n	415094 <ioport_toggle_pin_level+0x5c>
		port->PIO_CODR = mask;
  41508c:	697b      	ldr	r3, [r7, #20]
  41508e:	68fa      	ldr	r2, [r7, #12]
  415090:	635a      	str	r2, [r3, #52]	; 0x34
}
  415092:	e002      	b.n	41509a <ioport_toggle_pin_level+0x62>
		port->PIO_SODR = mask;
  415094:	697b      	ldr	r3, [r7, #20]
  415096:	68fa      	ldr	r2, [r7, #12]
  415098:	631a      	str	r2, [r3, #48]	; 0x30
  41509a:	bf00      	nop
  41509c:	372c      	adds	r7, #44	; 0x2c
  41509e:	46bd      	mov	sp, r7
  4150a0:	f85d 7b04 	ldr.w	r7, [sp], #4
  4150a4:	4770      	bx	lr
	...

004150a8 <HICS_LED_Toggle>:

uint8_t  wHLED_mode = HLED_MODE_NORMAL;
uint16_t wHLED_tick=0;

void HICS_LED_Toggle(void)
{	
  4150a8:	b580      	push	{r7, lr}
  4150aa:	af00      	add	r7, sp, #0
	HICS_LED_IncTick();
  4150ac:	4b15      	ldr	r3, [pc, #84]	; (415104 <HICS_LED_Toggle+0x5c>)
  4150ae:	4798      	blx	r3

	if (wHLED_mode == HLED_MODE_DESACOPLANDO)
  4150b0:	4b15      	ldr	r3, [pc, #84]	; (415108 <HICS_LED_Toggle+0x60>)
  4150b2:	781b      	ldrb	r3, [r3, #0]
  4150b4:	2b01      	cmp	r3, #1
  4150b6:	d10b      	bne.n	4150d0 <HICS_LED_Toggle+0x28>
	{
		if (wHLED_tick >= HLED_TICK_750MS)
  4150b8:	4b14      	ldr	r3, [pc, #80]	; (41510c <HICS_LED_Toggle+0x64>)
  4150ba:	881b      	ldrh	r3, [r3, #0]
  4150bc:	f240 22ed 	movw	r2, #749	; 0x2ed
  4150c0:	4293      	cmp	r3, r2
  4150c2:	d91c      	bls.n	4150fe <HICS_LED_Toggle+0x56>
		{	HICS_LED_ClearTick();
  4150c4:	4b12      	ldr	r3, [pc, #72]	; (415110 <HICS_LED_Toggle+0x68>)
  4150c6:	4798      	blx	r3
			LED_Toggle(LED0);
  4150c8:	2076      	movs	r0, #118	; 0x76
  4150ca:	4b12      	ldr	r3, [pc, #72]	; (415114 <HICS_LED_Toggle+0x6c>)
  4150cc:	4798      	blx	r3
		{	HICS_LED_ClearTick();
			LED_Toggle(LED0);
		}
	}

}
  4150ce:	e016      	b.n	4150fe <HICS_LED_Toggle+0x56>
	else if (wHLED_mode == HLED_MODE_DESACOPLADO)
  4150d0:	4b0d      	ldr	r3, [pc, #52]	; (415108 <HICS_LED_Toggle+0x60>)
  4150d2:	781b      	ldrb	r3, [r3, #0]
  4150d4:	2b02      	cmp	r3, #2
  4150d6:	d109      	bne.n	4150ec <HICS_LED_Toggle+0x44>
		if (wHLED_tick >= HLED_TICK_50MS)
  4150d8:	4b0c      	ldr	r3, [pc, #48]	; (41510c <HICS_LED_Toggle+0x64>)
  4150da:	881b      	ldrh	r3, [r3, #0]
  4150dc:	2b31      	cmp	r3, #49	; 0x31
  4150de:	d90e      	bls.n	4150fe <HICS_LED_Toggle+0x56>
		{	HICS_LED_ClearTick();
  4150e0:	4b0b      	ldr	r3, [pc, #44]	; (415110 <HICS_LED_Toggle+0x68>)
  4150e2:	4798      	blx	r3
			LED_Toggle(LED0);
  4150e4:	2076      	movs	r0, #118	; 0x76
  4150e6:	4b0b      	ldr	r3, [pc, #44]	; (415114 <HICS_LED_Toggle+0x6c>)
  4150e8:	4798      	blx	r3
}
  4150ea:	e008      	b.n	4150fe <HICS_LED_Toggle+0x56>
		if (wHLED_tick >= HLED_TICK_250MS)
  4150ec:	4b07      	ldr	r3, [pc, #28]	; (41510c <HICS_LED_Toggle+0x64>)
  4150ee:	881b      	ldrh	r3, [r3, #0]
  4150f0:	2bf9      	cmp	r3, #249	; 0xf9
  4150f2:	d904      	bls.n	4150fe <HICS_LED_Toggle+0x56>
		{	HICS_LED_ClearTick();
  4150f4:	4b06      	ldr	r3, [pc, #24]	; (415110 <HICS_LED_Toggle+0x68>)
  4150f6:	4798      	blx	r3
			LED_Toggle(LED0);
  4150f8:	2076      	movs	r0, #118	; 0x76
  4150fa:	4b06      	ldr	r3, [pc, #24]	; (415114 <HICS_LED_Toggle+0x6c>)
  4150fc:	4798      	blx	r3
}
  4150fe:	bf00      	nop
  415100:	bd80      	pop	{r7, pc}
  415102:	bf00      	nop
  415104:	00415119 	.word	0x00415119
  415108:	2000b4ff 	.word	0x2000b4ff
  41510c:	2000b500 	.word	0x2000b500
  415110:	00415139 	.word	0x00415139
  415114:	00415039 	.word	0x00415039

00415118 <HICS_LED_IncTick>:

void HICS_LED_IncTick(void)
{
  415118:	b480      	push	{r7}
  41511a:	af00      	add	r7, sp, #0
	wHLED_tick++;
  41511c:	4b05      	ldr	r3, [pc, #20]	; (415134 <HICS_LED_IncTick+0x1c>)
  41511e:	881b      	ldrh	r3, [r3, #0]
  415120:	3301      	adds	r3, #1
  415122:	b29a      	uxth	r2, r3
  415124:	4b03      	ldr	r3, [pc, #12]	; (415134 <HICS_LED_IncTick+0x1c>)
  415126:	801a      	strh	r2, [r3, #0]
}
  415128:	bf00      	nop
  41512a:	46bd      	mov	sp, r7
  41512c:	f85d 7b04 	ldr.w	r7, [sp], #4
  415130:	4770      	bx	lr
  415132:	bf00      	nop
  415134:	2000b500 	.word	0x2000b500

00415138 <HICS_LED_ClearTick>:

void HICS_LED_ClearTick(void)
{
  415138:	b480      	push	{r7}
  41513a:	af00      	add	r7, sp, #0
	//taskENTER_CRITICAL();
	wHLED_tick=0;
  41513c:	4b03      	ldr	r3, [pc, #12]	; (41514c <HICS_LED_ClearTick+0x14>)
  41513e:	2200      	movs	r2, #0
  415140:	801a      	strh	r2, [r3, #0]
	//taskEXIT_CRITICAL();
}
  415142:	bf00      	nop
  415144:	46bd      	mov	sp, r7
  415146:	f85d 7b04 	ldr.w	r7, [sp], #4
  41514a:	4770      	bx	lr
  41514c:	2000b500 	.word	0x2000b500

00415150 <SNTP_Task>:
// e incrementado a cada 1ms via interrupcao gerada pelo sinal DRDY do AD7770
HICS_TS hts;

void SNTP_Task(void *pvParameters)
//void SNTP_task(void)
{
  415150:	b5f0      	push	{r4, r5, r6, r7, lr}
  415152:	b0a3      	sub	sp, #140	; 0x8c
  415154:	af00      	add	r7, sp, #0
  415156:	6078      	str	r0, [r7, #4]
	UNUSED(pvParameters);

	int32_t lReturned=0;
  415158:	2300      	movs	r3, #0
  41515a:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84

	// HICS TBD: SE uC RESETAR, O TIMESTAMP VOLTA PARA ZERO (analisar se deve manter o ultimo valor) 
	hts.ulSec		= 0;
  41515e:	4b76      	ldr	r3, [pc, #472]	; (415338 <SNTP_Task+0x1e8>)
  415160:	2200      	movs	r2, #0
  415162:	601a      	str	r2, [r3, #0]
	hts.usMs		= 0;
  415164:	4b74      	ldr	r3, [pc, #464]	; (415338 <SNTP_Task+0x1e8>)
  415166:	2200      	movs	r2, #0
  415168:	809a      	strh	r2, [r3, #4]
	hts.u64husec	= 0;
  41516a:	4a73      	ldr	r2, [pc, #460]	; (415338 <SNTP_Task+0x1e8>)
  41516c:	f04f 0300 	mov.w	r3, #0
  415170:	f04f 0400 	mov.w	r4, #0
  415174:	e9c2 3402 	strd	r3, r4, [r2, #8]
	

	vTaskDelay(  (10000UL / portTICK_PERIOD_MS) );	// Delay 10s para aguardar o sistema se estabilizar (1Kms)
  415178:	f242 7010 	movw	r0, #10000	; 0x2710
  41517c:	4b6f      	ldr	r3, [pc, #444]	; (41533c <SNTP_Task+0x1ec>)
  41517e:	4798      	blx	r3
	
	while (1)
	{
		
		// Verifica se pode criar socket
		if( stSocket_SNTP.can_create != pdFALSE )
  415180:	4b6f      	ldr	r3, [pc, #444]	; (415340 <SNTP_Task+0x1f0>)
  415182:	7b1b      	ldrb	r3, [r3, #12]
  415184:	2b00      	cmp	r3, #0
  415186:	d007      	beq.n	415198 <SNTP_Task+0x48>
		{	if (vSocket_SNTP_create() == pdPASS)
  415188:	4b6e      	ldr	r3, [pc, #440]	; (415344 <SNTP_Task+0x1f4>)
  41518a:	4798      	blx	r3
  41518c:	4603      	mov	r3, r0
  41518e:	2b01      	cmp	r3, #1
  415190:	d102      	bne.n	415198 <SNTP_Task+0x48>
			{	stSocket_SNTP.can_create = pdFALSE;
  415192:	4b6b      	ldr	r3, [pc, #428]	; (415340 <SNTP_Task+0x1f0>)
  415194:	2200      	movs	r2, #0
  415196:	731a      	strb	r2, [r3, #12]
			}
		}

		if (stSocket_SNTP.up == pdTRUE)
  415198:	4b69      	ldr	r3, [pc, #420]	; (415340 <SNTP_Task+0x1f0>)
  41519a:	7b5b      	ldrb	r3, [r3, #13]
  41519c:	2b01      	cmp	r3, #1
  41519e:	d1ef      	bne.n	415180 <SNTP_Task+0x30>
		{
			
			//vTaskDelay(  (1UL / portTICK_PERIOD_MS) );

			vSocket_SNTP_sendto(&stNTP_packet_tx,sizeof(stNTP_packet_tx));
  4151a0:	2130      	movs	r1, #48	; 0x30
  4151a2:	4869      	ldr	r0, [pc, #420]	; (415348 <SNTP_Task+0x1f8>)
  4151a4:	4b69      	ldr	r3, [pc, #420]	; (41534c <SNTP_Task+0x1fc>)
  4151a6:	4798      	blx	r3

			/* Receive into the buffer with ulFlags set to 0, so the FREERTOS_ZERO_COPY bit is clear. */
			lReturned = lSocket_SNTP_recv(&stNTP_packet_rx,sizeof(stNTP_packet_rx));
  4151a8:	2130      	movs	r1, #48	; 0x30
  4151aa:	4869      	ldr	r0, [pc, #420]	; (415350 <SNTP_Task+0x200>)
  4151ac:	4b69      	ldr	r3, [pc, #420]	; (415354 <SNTP_Task+0x204>)
  4151ae:	4798      	blx	r3
  4151b0:	f8c7 0084 	str.w	r0, [r7, #132]	; 0x84

			if( lReturned > 0 )
  4151b4:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
  4151b8:	2b00      	cmp	r3, #0
  4151ba:	f340 8142 	ble.w	415442 <SNTP_Task+0x2f2>

				volatile double fraction;

				volatile uint16_t ushtsMs;
				volatile uint32_t ulhtsSec; 
				volatile uint8_t  bySync=0;
  4151be:	2300      	movs	r3, #0
  4151c0:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f
			
				double fhts, fsts, fdiff;	

				volatile uint64_t u64husec;
			
				fraction = (double) FreeRTOS_ntohl(stNTP_packet_rx.transmit_timestamp_frac); // take care of the endianness
  4151c4:	4b62      	ldr	r3, [pc, #392]	; (415350 <SNTP_Task+0x200>)
  4151c6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  4151c8:	061a      	lsls	r2, r3, #24
  4151ca:	4b61      	ldr	r3, [pc, #388]	; (415350 <SNTP_Task+0x200>)
  4151cc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  4151ce:	021b      	lsls	r3, r3, #8
  4151d0:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
  4151d4:	431a      	orrs	r2, r3
  4151d6:	4b5e      	ldr	r3, [pc, #376]	; (415350 <SNTP_Task+0x200>)
  4151d8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  4151da:	0a1b      	lsrs	r3, r3, #8
  4151dc:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
  4151e0:	431a      	orrs	r2, r3
  4151e2:	4b5b      	ldr	r3, [pc, #364]	; (415350 <SNTP_Task+0x200>)
  4151e4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  4151e6:	0e1b      	lsrs	r3, r3, #24
  4151e8:	431a      	orrs	r2, r3
  4151ea:	4b5b      	ldr	r3, [pc, #364]	; (415358 <SNTP_Task+0x208>)
  4151ec:	4610      	mov	r0, r2
  4151ee:	4798      	blx	r3
  4151f0:	4603      	mov	r3, r0
  4151f2:	460c      	mov	r4, r1
  4151f4:	e9c7 3416 	strd	r3, r4, [r7, #88]	; 0x58
				fraction = (double) fraction / NTP_MAX_INT_AS_DOUBLE;
  4151f8:	e9d7 0116 	ldrd	r0, r1, [r7, #88]	; 0x58
  4151fc:	4c57      	ldr	r4, [pc, #348]	; (41535c <SNTP_Task+0x20c>)
  4151fe:	a34a      	add	r3, pc, #296	; (adr r3, 415328 <SNTP_Task+0x1d8>)
  415200:	e9d3 2300 	ldrd	r2, r3, [r3]
  415204:	47a0      	blx	r4
  415206:	4603      	mov	r3, r0
  415208:	460c      	mov	r4, r1
  41520a:	e9c7 3416 	strd	r3, r4, [r7, #88]	; 0x58
				fraction = (double) fraction * 1000.0; 
  41520e:	e9d7 0116 	ldrd	r0, r1, [r7, #88]	; 0x58
  415212:	4c53      	ldr	r4, [pc, #332]	; (415360 <SNTP_Task+0x210>)
  415214:	f04f 0200 	mov.w	r2, #0
  415218:	4b52      	ldr	r3, [pc, #328]	; (415364 <SNTP_Task+0x214>)
  41521a:	47a0      	blx	r4
  41521c:	4603      	mov	r3, r0
  41521e:	460c      	mov	r4, r1
  415220:	e9c7 3416 	strd	r3, r4, [r7, #88]	; 0x58

				ulMilliseconds = (uint32_t) fraction;
  415224:	e9d7 3416 	ldrd	r3, r4, [r7, #88]	; 0x58
  415228:	4a4f      	ldr	r2, [pc, #316]	; (415368 <SNTP_Task+0x218>)
  41522a:	4618      	mov	r0, r3
  41522c:	4621      	mov	r1, r4
  41522e:	4790      	blx	r2
  415230:	4603      	mov	r3, r0
  415232:	663b      	str	r3, [r7, #96]	; 0x60
				if (ulMilliseconds>=1000)	// Se 1s (ou maior) entao tem que descartar
  415234:	6e3b      	ldr	r3, [r7, #96]	; 0x60
  415236:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
  41523a:	d301      	bcc.n	415240 <SNTP_Task+0xf0>
					ulMilliseconds=0;
  41523c:	2300      	movs	r3, #0
  41523e:	663b      	str	r3, [r7, #96]	; 0x60

				// Extrai segundos do pacote NTP
				ulSeconds = FreeRTOS_ntohl(stNTP_packet_rx.transmit_timestamp_sec); // take care of the endianness
  415240:	4b43      	ldr	r3, [pc, #268]	; (415350 <SNTP_Task+0x200>)
  415242:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  415244:	061a      	lsls	r2, r3, #24
  415246:	4b42      	ldr	r3, [pc, #264]	; (415350 <SNTP_Task+0x200>)
  415248:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  41524a:	021b      	lsls	r3, r3, #8
  41524c:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
  415250:	431a      	orrs	r2, r3
  415252:	4b3f      	ldr	r3, [pc, #252]	; (415350 <SNTP_Task+0x200>)
  415254:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  415256:	0a1b      	lsrs	r3, r3, #8
  415258:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
  41525c:	431a      	orrs	r2, r3
  41525e:	4b3c      	ldr	r3, [pc, #240]	; (415350 <SNTP_Task+0x200>)
  415260:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  415262:	0e1b      	lsrs	r3, r3, #24
  415264:	4313      	orrs	r3, r2
  415266:	667b      	str	r3, [r7, #100]	; 0x64

				// NTP trabalha com epoch time de 1900 (quantidade de segundos desde 1900)
				// Traz o epoch time para 1970 (unix epoch time)
				ulSeconds = ulSeconds - NTP_TIMESTAMP_DELTA;
  415268:	6e7a      	ldr	r2, [r7, #100]	; 0x64
  41526a:	4b40      	ldr	r3, [pc, #256]	; (41536c <SNTP_Task+0x21c>)
  41526c:	4413      	add	r3, r2
  41526e:	667b      	str	r3, [r7, #100]	; 0x64

				// Obtem timestamp atual do HICS para comparacao e print 
				taskENTER_CRITICAL();
  415270:	4b3f      	ldr	r3, [pc, #252]	; (415370 <SNTP_Task+0x220>)
  415272:	4798      	blx	r3
				ushtsMs  = hts.usMs;
  415274:	4b30      	ldr	r3, [pc, #192]	; (415338 <SNTP_Task+0x1e8>)
  415276:	889b      	ldrh	r3, [r3, #4]
  415278:	f8a7 3056 	strh.w	r3, [r7, #86]	; 0x56
				ulhtsSec = hts.ulSec;
  41527c:	4b2e      	ldr	r3, [pc, #184]	; (415338 <SNTP_Task+0x1e8>)
  41527e:	681b      	ldr	r3, [r3, #0]
  415280:	653b      	str	r3, [r7, #80]	; 0x50
				taskEXIT_CRITICAL();
  415282:	4b3c      	ldr	r3, [pc, #240]	; (415374 <SNTP_Task+0x224>)
  415284:	4798      	blx	r3

				// Verifica se deve atualizar timestamp do HICS
				//if (ulSeconds > NTP_TIMESTAMP_DELTA )	// Apenas p checar se ha alguma consistencia do valor recebido
				//{
					// Se diferena em milesegundos  maior que +-100 atualiza
					fhts = (double)((double)ulhtsSec  + (double)(((double)ushtsMs)/1000.0));
  415286:	6d3a      	ldr	r2, [r7, #80]	; 0x50
  415288:	4b33      	ldr	r3, [pc, #204]	; (415358 <SNTP_Task+0x208>)
  41528a:	4610      	mov	r0, r2
  41528c:	4798      	blx	r3
  41528e:	4605      	mov	r5, r0
  415290:	460e      	mov	r6, r1
  415292:	f8b7 3056 	ldrh.w	r3, [r7, #86]	; 0x56
  415296:	b29a      	uxth	r2, r3
  415298:	4b2f      	ldr	r3, [pc, #188]	; (415358 <SNTP_Task+0x208>)
  41529a:	4610      	mov	r0, r2
  41529c:	4798      	blx	r3
  41529e:	4c2f      	ldr	r4, [pc, #188]	; (41535c <SNTP_Task+0x20c>)
  4152a0:	f04f 0200 	mov.w	r2, #0
  4152a4:	4b2f      	ldr	r3, [pc, #188]	; (415364 <SNTP_Task+0x214>)
  4152a6:	47a0      	blx	r4
  4152a8:	4603      	mov	r3, r0
  4152aa:	460c      	mov	r4, r1
  4152ac:	461a      	mov	r2, r3
  4152ae:	4623      	mov	r3, r4
  4152b0:	4c31      	ldr	r4, [pc, #196]	; (415378 <SNTP_Task+0x228>)
  4152b2:	4628      	mov	r0, r5
  4152b4:	4631      	mov	r1, r6
  4152b6:	47a0      	blx	r4
  4152b8:	4603      	mov	r3, r0
  4152ba:	460c      	mov	r4, r1
  4152bc:	e9c7 341e 	strd	r3, r4, [r7, #120]	; 0x78
					fsts = (double)((double)ulSeconds + (double)(((double)ulMilliseconds)/1000.0));
  4152c0:	6e7a      	ldr	r2, [r7, #100]	; 0x64
  4152c2:	4b25      	ldr	r3, [pc, #148]	; (415358 <SNTP_Task+0x208>)
  4152c4:	4610      	mov	r0, r2
  4152c6:	4798      	blx	r3
  4152c8:	4605      	mov	r5, r0
  4152ca:	460e      	mov	r6, r1
  4152cc:	6e3a      	ldr	r2, [r7, #96]	; 0x60
  4152ce:	4b22      	ldr	r3, [pc, #136]	; (415358 <SNTP_Task+0x208>)
  4152d0:	4610      	mov	r0, r2
  4152d2:	4798      	blx	r3
  4152d4:	4c21      	ldr	r4, [pc, #132]	; (41535c <SNTP_Task+0x20c>)
  4152d6:	f04f 0200 	mov.w	r2, #0
  4152da:	4b22      	ldr	r3, [pc, #136]	; (415364 <SNTP_Task+0x214>)
  4152dc:	47a0      	blx	r4
  4152de:	4603      	mov	r3, r0
  4152e0:	460c      	mov	r4, r1
  4152e2:	461a      	mov	r2, r3
  4152e4:	4623      	mov	r3, r4
  4152e6:	4c24      	ldr	r4, [pc, #144]	; (415378 <SNTP_Task+0x228>)
  4152e8:	4628      	mov	r0, r5
  4152ea:	4631      	mov	r1, r6
  4152ec:	47a0      	blx	r4
  4152ee:	4603      	mov	r3, r0
  4152f0:	460c      	mov	r4, r1
  4152f2:	e9c7 341c 	strd	r3, r4, [r7, #112]	; 0x70
				
					fdiff = fhts - fsts;
  4152f6:	4c21      	ldr	r4, [pc, #132]	; (41537c <SNTP_Task+0x22c>)
  4152f8:	e9d7 231c 	ldrd	r2, r3, [r7, #112]	; 0x70
  4152fc:	e9d7 011e 	ldrd	r0, r1, [r7, #120]	; 0x78
  415300:	47a0      	blx	r4
  415302:	4603      	mov	r3, r0
  415304:	460c      	mov	r4, r1
  415306:	e9c7 341a 	strd	r3, r4, [r7, #104]	; 0x68
					if      ( fdiff > 0.100 )	{bySync=1;} 
  41530a:	4c1d      	ldr	r4, [pc, #116]	; (415380 <SNTP_Task+0x230>)
  41530c:	a308      	add	r3, pc, #32	; (adr r3, 415330 <SNTP_Task+0x1e0>)
  41530e:	e9d3 2300 	ldrd	r2, r3, [r3]
  415312:	e9d7 011a 	ldrd	r0, r1, [r7, #104]	; 0x68
  415316:	47a0      	blx	r4
  415318:	4603      	mov	r3, r0
  41531a:	2b00      	cmp	r3, #0
  41531c:	d032      	beq.n	415384 <SNTP_Task+0x234>
  41531e:	2301      	movs	r3, #1
  415320:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f
  415324:	e03b      	b.n	41539e <SNTP_Task+0x24e>
  415326:	bf00      	nop
  415328:	ffe00000 	.word	0xffe00000
  41532c:	41efffff 	.word	0x41efffff
  415330:	9999999a 	.word	0x9999999a
  415334:	3fb99999 	.word	0x3fb99999
  415338:	2000bc90 	.word	0x2000bc90
  41533c:	0041256d 	.word	0x0041256d
  415340:	2000bca0 	.word	0x2000bca0
  415344:	00415621 	.word	0x00415621
  415348:	20000138 	.word	0x20000138
  41534c:	0041569d 	.word	0x0041569d
  415350:	2000b504 	.word	0x2000b504
  415354:	004156d5 	.word	0x004156d5
  415358:	004165cd 	.word	0x004165cd
  41535c:	0041690d 	.word	0x0041690d
  415360:	004166b9 	.word	0x004166b9
  415364:	408f4000 	.word	0x408f4000
  415368:	00416bed 	.word	0x00416bed
  41536c:	7c558180 	.word	0x7c558180
  415370:	0041103d 	.word	0x0041103d
  415374:	00411099 	.word	0x00411099
  415378:	00416355 	.word	0x00416355
  41537c:	00416351 	.word	0x00416351
  415380:	00416bd9 	.word	0x00416bd9
					else if ( fdiff < -0.100 )	{bySync=1;} 
  415384:	4c34      	ldr	r4, [pc, #208]	; (415458 <SNTP_Task+0x308>)
  415386:	a332      	add	r3, pc, #200	; (adr r3, 415450 <SNTP_Task+0x300>)
  415388:	e9d3 2300 	ldrd	r2, r3, [r3]
  41538c:	e9d7 011a 	ldrd	r0, r1, [r7, #104]	; 0x68
  415390:	47a0      	blx	r4
  415392:	4603      	mov	r3, r0
  415394:	2b00      	cmp	r3, #0
  415396:	d002      	beq.n	41539e <SNTP_Task+0x24e>
  415398:	2301      	movs	r3, #1
  41539a:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f
				
				//}

				// Calcula HUSEC do pacote NTP
				u64husec = HUSEC_CalcFromNTP();
  41539e:	4b2f      	ldr	r3, [pc, #188]	; (41545c <SNTP_Task+0x30c>)
  4153a0:	4798      	blx	r3
  4153a2:	4603      	mov	r3, r0
  4153a4:	460c      	mov	r4, r1
  4153a6:	e9c7 3410 	strd	r3, r4, [r7, #64]	; 0x40

				if (bySync==1)
  4153aa:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
  4153ae:	b2db      	uxtb	r3, r3
  4153b0:	2b01      	cmp	r3, #1
  4153b2:	d10f      	bne.n	4153d4 <SNTP_Task+0x284>
				{	
					// ATENCAO, TEM QUE SER ATOMICO
					taskENTER_CRITICAL();	
  4153b4:	4b2a      	ldr	r3, [pc, #168]	; (415460 <SNTP_Task+0x310>)
  4153b6:	4798      	blx	r3
					hts.usMs     = (uint16_t) ulMilliseconds; 
  4153b8:	6e3b      	ldr	r3, [r7, #96]	; 0x60
  4153ba:	b29a      	uxth	r2, r3
  4153bc:	4b29      	ldr	r3, [pc, #164]	; (415464 <SNTP_Task+0x314>)
  4153be:	809a      	strh	r2, [r3, #4]
					hts.ulSec    = ulSeconds; 
  4153c0:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  4153c2:	4a28      	ldr	r2, [pc, #160]	; (415464 <SNTP_Task+0x314>)
  4153c4:	6013      	str	r3, [r2, #0]
					hts.u64husec = u64husec;	
  4153c6:	e9d7 3410 	ldrd	r3, r4, [r7, #64]	; 0x40
  4153ca:	4a26      	ldr	r2, [pc, #152]	; (415464 <SNTP_Task+0x314>)
  4153cc:	e9c2 3402 	strd	r3, r4, [r2, #8]
					taskEXIT_CRITICAL();
  4153d0:	4b25      	ldr	r3, [pc, #148]	; (415468 <SNTP_Task+0x318>)
  4153d2:	4798      	blx	r3
					// FIM DO ATENCAO
		
				}
			
				// ATENCAO: printf apenas apos sincronizar timers senao vai sincronizar com atraso			
				printf("\nTs:\n");
  4153d4:	4825      	ldr	r0, [pc, #148]	; (41546c <SNTP_Task+0x31c>)
  4153d6:	4b26      	ldr	r3, [pc, #152]	; (415470 <SNTP_Task+0x320>)
  4153d8:	4798      	blx	r3
				printf("Hs=%d ms=%d\n",ulhtsSec,ushtsMs);				// Timestamp HICS antes de atualizar
  4153da:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  4153dc:	f8b7 2056 	ldrh.w	r2, [r7, #86]	; 0x56
  4153e0:	b292      	uxth	r2, r2
  4153e2:	4619      	mov	r1, r3
  4153e4:	4823      	ldr	r0, [pc, #140]	; (415474 <SNTP_Task+0x324>)
  4153e6:	4b22      	ldr	r3, [pc, #136]	; (415470 <SNTP_Task+0x320>)
  4153e8:	4798      	blx	r3
				printf("Ns=%d ms=%d\n",ulSeconds,ulMilliseconds);		// Timestamp NTP
  4153ea:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  4153ec:	6e3a      	ldr	r2, [r7, #96]	; 0x60
  4153ee:	4619      	mov	r1, r3
  4153f0:	4821      	ldr	r0, [pc, #132]	; (415478 <SNTP_Task+0x328>)
  4153f2:	4b1f      	ldr	r3, [pc, #124]	; (415470 <SNTP_Task+0x320>)
  4153f4:	4798      	blx	r3
				printf("Nh=%" PRIu64 "\n",u64husec);
  4153f6:	e9d7 3410 	ldrd	r3, r4, [r7, #64]	; 0x40
  4153fa:	461a      	mov	r2, r3
  4153fc:	4623      	mov	r3, r4
  4153fe:	481f      	ldr	r0, [pc, #124]	; (41547c <SNTP_Task+0x32c>)
  415400:	491b      	ldr	r1, [pc, #108]	; (415470 <SNTP_Task+0x320>)
  415402:	4788      	blx	r1

				// FreeRTOS version of printf doesnt support them print float 
				// (https://www.freertos.org/FreeRTOS_Support_Forum_Archive/April_2018/freertos_How_to_make_printf_sprintf_strtod_thread_safe_44d2ceb8j.html) 
				int8_t ___buffer[50];

				sprintf(___buffer, "%.3f", fdiff); // Utiliza sprintf como workaround		
  415404:	f107 000c 	add.w	r0, r7, #12
  415408:	e9d7 231a 	ldrd	r2, r3, [r7, #104]	; 0x68
  41540c:	491c      	ldr	r1, [pc, #112]	; (415480 <SNTP_Task+0x330>)
  41540e:	4c1d      	ldr	r4, [pc, #116]	; (415484 <SNTP_Task+0x334>)
  415410:	47a0      	blx	r4
				___buffer[49]=0;	// Garante NULL
  415412:	2300      	movs	r3, #0
  415414:	f887 303d 	strb.w	r3, [r7, #61]	; 0x3d
				printf("Diff=%ss\n",___buffer);
  415418:	f107 030c 	add.w	r3, r7, #12
  41541c:	4619      	mov	r1, r3
  41541e:	481a      	ldr	r0, [pc, #104]	; (415488 <SNTP_Task+0x338>)
  415420:	4b13      	ldr	r3, [pc, #76]	; (415470 <SNTP_Task+0x320>)
  415422:	4798      	blx	r3

				printf("Sync=");
  415424:	4819      	ldr	r0, [pc, #100]	; (41548c <SNTP_Task+0x33c>)
  415426:	4b12      	ldr	r3, [pc, #72]	; (415470 <SNTP_Task+0x320>)
  415428:	4798      	blx	r3
				if (bySync==1) { printf("Y\n"); }
  41542a:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
  41542e:	b2db      	uxtb	r3, r3
  415430:	2b01      	cmp	r3, #1
  415432:	d103      	bne.n	41543c <SNTP_Task+0x2ec>
  415434:	4816      	ldr	r0, [pc, #88]	; (415490 <SNTP_Task+0x340>)
  415436:	4b0e      	ldr	r3, [pc, #56]	; (415470 <SNTP_Task+0x320>)
  415438:	4798      	blx	r3
  41543a:	e002      	b.n	415442 <SNTP_Task+0x2f2>
				else { printf("N\n"); }
  41543c:	4815      	ldr	r0, [pc, #84]	; (415494 <SNTP_Task+0x344>)
  41543e:	4b0c      	ldr	r3, [pc, #48]	; (415470 <SNTP_Task+0x320>)
  415440:	4798      	blx	r3
	
					
			}

			// HICS:  Sincroniza timer a cada <TBD>
			vTaskDelay(  (60000UL / portTICK_PERIOD_MS) );	// Delay 60s (HICS TBD)
  415442:	f64e 2060 	movw	r0, #60000	; 0xea60
  415446:	4b14      	ldr	r3, [pc, #80]	; (415498 <SNTP_Task+0x348>)
  415448:	4798      	blx	r3
		if( stSocket_SNTP.can_create != pdFALSE )
  41544a:	e699      	b.n	415180 <SNTP_Task+0x30>
  41544c:	f3af 8000 	nop.w
  415450:	9999999a 	.word	0x9999999a
  415454:	bfb99999 	.word	0xbfb99999
  415458:	00416b9d 	.word	0x00416b9d
  41545c:	00414ea1 	.word	0x00414ea1
  415460:	0041103d 	.word	0x0041103d
  415464:	2000bc90 	.word	0x2000bc90
  415468:	00411099 	.word	0x00411099
  41546c:	0041e4d4 	.word	0x0041e4d4
  415470:	00416c7d 	.word	0x00416c7d
  415474:	0041e4dc 	.word	0x0041e4dc
  415478:	0041e4ec 	.word	0x0041e4ec
  41547c:	0041e4fc 	.word	0x0041e4fc
  415480:	0041e508 	.word	0x0041e508
  415484:	004171d5 	.word	0x004171d5
  415488:	0041e510 	.word	0x0041e510
  41548c:	0041e51c 	.word	0x0041e51c
  415490:	0041e524 	.word	0x0041e524
  415494:	0041e528 	.word	0x0041e528
  415498:	0041256d 	.word	0x0041256d

0041549c <vSockets_Init>:

stSocket stSocket_SNTP;


void vSockets_Init(void)
{
  41549c:	b480      	push	{r7}
  41549e:	af00      	add	r7, sp, #0
	// ATENCAO: Antes de criar tasks e sockets, sinaliza que sockets nao estao criados

	// ADC
	stSocket_ADC.can_create = pdFALSE;
  4154a0:	4b08      	ldr	r3, [pc, #32]	; (4154c4 <vSockets_Init+0x28>)
  4154a2:	2200      	movs	r2, #0
  4154a4:	731a      	strb	r2, [r3, #12]
	stSocket_ADC.up         = pdFALSE;
  4154a6:	4b07      	ldr	r3, [pc, #28]	; (4154c4 <vSockets_Init+0x28>)
  4154a8:	2200      	movs	r2, #0
  4154aa:	735a      	strb	r2, [r3, #13]

	// SNTP	
	stSocket_SNTP.can_create = pdFALSE;
  4154ac:	4b06      	ldr	r3, [pc, #24]	; (4154c8 <vSockets_Init+0x2c>)
  4154ae:	2200      	movs	r2, #0
  4154b0:	731a      	strb	r2, [r3, #12]
	stSocket_SNTP.up         = pdFALSE;
  4154b2:	4b05      	ldr	r3, [pc, #20]	; (4154c8 <vSockets_Init+0x2c>)
  4154b4:	2200      	movs	r2, #0
  4154b6:	735a      	strb	r2, [r3, #13]

}
  4154b8:	bf00      	nop
  4154ba:	46bd      	mov	sp, r7
  4154bc:	f85d 7b04 	ldr.w	r7, [sp], #4
  4154c0:	4770      	bx	lr
  4154c2:	bf00      	nop
  4154c4:	2000bcb0 	.word	0x2000bcb0
  4154c8:	2000bca0 	.word	0x2000bca0

004154cc <vSocket_ADC_tcp_create>:


/* ----------------------------------------------------------------------------------------- */

BaseType_t vSocket_ADC_tcp_create( void )
{
  4154cc:	b580      	push	{r7, lr}
  4154ce:	af00      	add	r7, sp, #0
	// Set IP::PORT
	stSocket_ADC.addr.sin_addr = FreeRTOS_inet_addr( &SOCKET_ADC_TCP_IP );
  4154d0:	481e      	ldr	r0, [pc, #120]	; (41554c <vSocket_ADC_tcp_create+0x80>)
  4154d2:	4b1f      	ldr	r3, [pc, #124]	; (415550 <vSocket_ADC_tcp_create+0x84>)
  4154d4:	4798      	blx	r3
  4154d6:	4602      	mov	r2, r0
  4154d8:	4b1e      	ldr	r3, [pc, #120]	; (415554 <vSocket_ADC_tcp_create+0x88>)
  4154da:	609a      	str	r2, [r3, #8]
	stSocket_ADC.addr.sin_port = FreeRTOS_htons( SOCKET_ADC_TCP_PORT );
  4154dc:	f643 2399 	movw	r3, #15001	; 0x3a99
  4154e0:	021b      	lsls	r3, r3, #8
  4154e2:	b21a      	sxth	r2, r3
  4154e4:	f643 2399 	movw	r3, #15001	; 0x3a99
  4154e8:	0a1b      	lsrs	r3, r3, #8
  4154ea:	b29b      	uxth	r3, r3
  4154ec:	b21b      	sxth	r3, r3
  4154ee:	4313      	orrs	r3, r2
  4154f0:	b21b      	sxth	r3, r3
  4154f2:	b29a      	uxth	r2, r3
  4154f4:	4b17      	ldr	r3, [pc, #92]	; (415554 <vSocket_ADC_tcp_create+0x88>)
  4154f6:	80da      	strh	r2, [r3, #6]

	/* Create the socket. */
	stSocket_ADC.socket = FreeRTOS_socket( FREERTOS_AF_INET,
  4154f8:	2206      	movs	r2, #6
  4154fa:	2101      	movs	r1, #1
  4154fc:	2002      	movs	r0, #2
  4154fe:	4b16      	ldr	r3, [pc, #88]	; (415558 <vSocket_ADC_tcp_create+0x8c>)
  415500:	4798      	blx	r3
  415502:	4602      	mov	r2, r0
  415504:	4b13      	ldr	r3, [pc, #76]	; (415554 <vSocket_ADC_tcp_create+0x88>)
  415506:	601a      	str	r2, [r3, #0]
								  FREERTOS_SOCK_STREAM,/* FREERTOS_SOCK_STREAM for TCP. */
                                  FREERTOS_IPPROTO_TCP  );

	/* Check the socket was created. */
	configASSERT( stSocket_ADC.socket != FREERTOS_INVALID_SOCKET );
  415508:	4b12      	ldr	r3, [pc, #72]	; (415554 <vSocket_ADC_tcp_create+0x88>)
  41550a:	681b      	ldr	r3, [r3, #0]
  41550c:	f1b3 3fff 	cmp.w	r3, #4294967295
  415510:	d104      	bne.n	41551c <vSocket_ADC_tcp_create+0x50>
  415512:	226e      	movs	r2, #110	; 0x6e
  415514:	4911      	ldr	r1, [pc, #68]	; (41555c <vSocket_ADC_tcp_create+0x90>)
  415516:	4812      	ldr	r0, [pc, #72]	; (415560 <vSocket_ADC_tcp_create+0x94>)
  415518:	4b12      	ldr	r3, [pc, #72]	; (415564 <vSocket_ADC_tcp_create+0x98>)
  41551a:	4798      	blx	r3

    /* Connect to the remote socket.  The socket has not previously been bound to
    a local port number so will get automatically bound to a local port inside
    the FreeRTOS_connect() function. */
    if( FreeRTOS_connect( stSocket_ADC.socket, &stSocket_ADC.addr, sizeof( stSocket_ADC.addr ) ) == 0 )
  41551c:	4b0d      	ldr	r3, [pc, #52]	; (415554 <vSocket_ADC_tcp_create+0x88>)
  41551e:	681b      	ldr	r3, [r3, #0]
  415520:	2208      	movs	r2, #8
  415522:	4911      	ldr	r1, [pc, #68]	; (415568 <vSocket_ADC_tcp_create+0x9c>)
  415524:	4618      	mov	r0, r3
  415526:	4b11      	ldr	r3, [pc, #68]	; (41556c <vSocket_ADC_tcp_create+0xa0>)
  415528:	4798      	blx	r3
  41552a:	4603      	mov	r3, r0
  41552c:	2b00      	cmp	r3, #0
  41552e:	d107      	bne.n	415540 <vSocket_ADC_tcp_create+0x74>
	{	stSocket_ADC.up = pdTRUE;	// Sinaliza socket ok para enviar pacotes
  415530:	4b08      	ldr	r3, [pc, #32]	; (415554 <vSocket_ADC_tcp_create+0x88>)
  415532:	2201      	movs	r2, #1
  415534:	735a      	strb	r2, [r3, #13]
		printf ("\nTCP-Socket-ADC is up!\n\n");
  415536:	480e      	ldr	r0, [pc, #56]	; (415570 <vSocket_ADC_tcp_create+0xa4>)
  415538:	4b0a      	ldr	r3, [pc, #40]	; (415564 <vSocket_ADC_tcp_create+0x98>)
  41553a:	4798      	blx	r3
		return (pdPASS);
  41553c:	2301      	movs	r3, #1
  41553e:	e003      	b.n	415548 <vSocket_ADC_tcp_create+0x7c>
	}
	else
	{	
		printf("\n\nERROR: TCP-Socket-ADC is not created!\n\n");
  415540:	480c      	ldr	r0, [pc, #48]	; (415574 <vSocket_ADC_tcp_create+0xa8>)
  415542:	4b08      	ldr	r3, [pc, #32]	; (415564 <vSocket_ADC_tcp_create+0x98>)
  415544:	4798      	blx	r3
		return (pdFAIL);
  415546:	2300      	movs	r3, #0
	}


}
  415548:	4618      	mov	r0, r3
  41554a:	bd80      	pop	{r7, pc}
  41554c:	0041e52c 	.word	0x0041e52c
  415550:	00409525 	.word	0x00409525
  415554:	2000bcb0 	.word	0x2000bcb0
  415558:	00408af5 	.word	0x00408af5
  41555c:	0041e594 	.word	0x0041e594
  415560:	0041e5b4 	.word	0x0041e5b4
  415564:	00416c7d 	.word	0x00416c7d
  415568:	2000bcb4 	.word	0x2000bcb4
  41556c:	0040981d 	.word	0x0040981d
  415570:	0041e5c4 	.word	0x0041e5c4
  415574:	0041e5e0 	.word	0x0041e5e0

00415578 <vSocket_ADC_tcp_sendto>:


BaseType_t  vSocket_ADC_tcp_sendto(uint8_t *pucBuffer, uint16_t usTotalDataLength)
{ 
  415578:	b590      	push	{r4, r7, lr}
  41557a:	b083      	sub	sp, #12
  41557c:	af00      	add	r7, sp, #0
  41557e:	6078      	str	r0, [r7, #4]
  415580:	460b      	mov	r3, r1
  415582:	807b      	strh	r3, [r7, #2]
    return FreeRTOS_send(stSocket_ADC.socket,
  415584:	4b05      	ldr	r3, [pc, #20]	; (41559c <vSocket_ADC_tcp_sendto+0x24>)
  415586:	6818      	ldr	r0, [r3, #0]
  415588:	887a      	ldrh	r2, [r7, #2]
  41558a:	2300      	movs	r3, #0
  41558c:	6879      	ldr	r1, [r7, #4]
  41558e:	4c04      	ldr	r4, [pc, #16]	; (4155a0 <vSocket_ADC_tcp_sendto+0x28>)
  415590:	47a0      	blx	r4
  415592:	4603      	mov	r3, r0
					pucBuffer,
					usTotalDataLength,
					0 ); /* ulFlags. */
}
  415594:	4618      	mov	r0, r3
  415596:	370c      	adds	r7, #12
  415598:	46bd      	mov	sp, r7
  41559a:	bd90      	pop	{r4, r7, pc}
  41559c:	2000bcb0 	.word	0x2000bcb0
  4155a0:	00409b59 	.word	0x00409b59

004155a4 <vSocket_ADC_tcp_close>:


void vSocket_ADC_tcp_close( void )
{
  4155a4:	b590      	push	{r4, r7, lr}
  4155a6:	b093      	sub	sp, #76	; 0x4c
  4155a8:	af00      	add	r7, sp, #0
	uint8_t cRxedData[ 64 ];
	uint8_t byTimeout=0;
  4155aa:	2300      	movs	r3, #0
  4155ac:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
	
	/* Initiate graceful shutdown. */
    FreeRTOS_shutdown( stSocket_ADC.socket, FREERTOS_SHUT_RDWR );
  4155b0:	4b14      	ldr	r3, [pc, #80]	; (415604 <vSocket_ADC_tcp_close+0x60>)
  4155b2:	681b      	ldr	r3, [r3, #0]
  4155b4:	2102      	movs	r1, #2
  4155b6:	4618      	mov	r0, r3
  4155b8:	4b13      	ldr	r3, [pc, #76]	; (415608 <vSocket_ADC_tcp_close+0x64>)
  4155ba:	4798      	blx	r3

    /* Wait for the socket to disconnect gracefully (indicated by FreeRTOS_recv()
    returning a FREERTOS_EINVAL error) before closing the socket. */
    while(byTimeout++ <= 4) // Timeout 1s
  4155bc:	e00c      	b.n	4155d8 <vSocket_ADC_tcp_close+0x34>
	{
		if (FreeRTOS_recv( stSocket_ADC.socket, &cRxedData, sizeof(cRxedData), 0 ) <  0 )
  4155be:	4b11      	ldr	r3, [pc, #68]	; (415604 <vSocket_ADC_tcp_close+0x60>)
  4155c0:	6818      	ldr	r0, [r3, #0]
  4155c2:	1d39      	adds	r1, r7, #4
  4155c4:	2300      	movs	r3, #0
  4155c6:	2240      	movs	r2, #64	; 0x40
  4155c8:	4c10      	ldr	r4, [pc, #64]	; (41560c <vSocket_ADC_tcp_close+0x68>)
  4155ca:	47a0      	blx	r4
  4155cc:	4603      	mov	r3, r0
  4155ce:	2b00      	cmp	r3, #0
  4155d0:	db0a      	blt.n	4155e8 <vSocket_ADC_tcp_close+0x44>
			
        /* Wait for shutdown to complete.  If a receive block time is used then
        this delay will not be necessary as FreeRTOS_recv() will place the RTOS task
        into the Blocked state anyway. */
        //vTaskDelay( pdTICKS_TO_MS( 250 ) );
		vTaskDelay(  (250 / portTICK_PERIOD_MS) );	// Delay 250ms
  4155d2:	20fa      	movs	r0, #250	; 0xfa
  4155d4:	4b0e      	ldr	r3, [pc, #56]	; (415610 <vSocket_ADC_tcp_close+0x6c>)
  4155d6:	4798      	blx	r3
    while(byTimeout++ <= 4) // Timeout 1s
  4155d8:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
  4155dc:	1c5a      	adds	r2, r3, #1
  4155de:	f887 2047 	strb.w	r2, [r7, #71]	; 0x47
  4155e2:	2b04      	cmp	r3, #4
  4155e4:	d9eb      	bls.n	4155be <vSocket_ADC_tcp_close+0x1a>
  4155e6:	e000      	b.n	4155ea <vSocket_ADC_tcp_close+0x46>
			break;
  4155e8:	bf00      	nop
        /* Note  real applications should implement a timeout here, not just
        loop forever. */ /*** DONE ***/
    }

    /* The socket has shut down and is safe to close. */
    FreeRTOS_closesocket( stSocket_ADC.socket );
  4155ea:	4b06      	ldr	r3, [pc, #24]	; (415604 <vSocket_ADC_tcp_close+0x60>)
  4155ec:	681b      	ldr	r3, [r3, #0]
  4155ee:	4618      	mov	r0, r3
  4155f0:	4b08      	ldr	r3, [pc, #32]	; (415614 <vSocket_ADC_tcp_close+0x70>)
  4155f2:	4798      	blx	r3
	
	printf ("\nTCP-Socket-ADC is down!\n\n");
  4155f4:	4808      	ldr	r0, [pc, #32]	; (415618 <vSocket_ADC_tcp_close+0x74>)
  4155f6:	4b09      	ldr	r3, [pc, #36]	; (41561c <vSocket_ADC_tcp_close+0x78>)
  4155f8:	4798      	blx	r3
	
}
  4155fa:	bf00      	nop
  4155fc:	374c      	adds	r7, #76	; 0x4c
  4155fe:	46bd      	mov	sp, r7
  415600:	bd90      	pop	{r4, r7, pc}
  415602:	bf00      	nop
  415604:	2000bcb0 	.word	0x2000bcb0
  415608:	00409d35 	.word	0x00409d35
  41560c:	004098d5 	.word	0x004098d5
  415610:	0041256d 	.word	0x0041256d
  415614:	00409189 	.word	0x00409189
  415618:	0041e60c 	.word	0x0041e60c
  41561c:	00416c7d 	.word	0x00416c7d

00415620 <vSocket_SNTP_create>:


/* ----------------------------------------------------------------------------------------- */

BaseType_t vSocket_SNTP_create( void )
{
  415620:	b580      	push	{r7, lr}
  415622:	af00      	add	r7, sp, #0
	// Set IP::PORT
	stSocket_SNTP.addr.sin_addr = FreeRTOS_inet_addr( &SOCKET_SNTP_IP );
  415624:	4816      	ldr	r0, [pc, #88]	; (415680 <vSocket_SNTP_create+0x60>)
  415626:	4b17      	ldr	r3, [pc, #92]	; (415684 <vSocket_SNTP_create+0x64>)
  415628:	4798      	blx	r3
  41562a:	4602      	mov	r2, r0
  41562c:	4b16      	ldr	r3, [pc, #88]	; (415688 <vSocket_SNTP_create+0x68>)
  41562e:	609a      	str	r2, [r3, #8]
	stSocket_SNTP.addr.sin_port = FreeRTOS_htons( SOCKET_SNTP_PORT );
  415630:	237b      	movs	r3, #123	; 0x7b
  415632:	021b      	lsls	r3, r3, #8
  415634:	b21a      	sxth	r2, r3
  415636:	237b      	movs	r3, #123	; 0x7b
  415638:	0a1b      	lsrs	r3, r3, #8
  41563a:	b29b      	uxth	r3, r3
  41563c:	b21b      	sxth	r3, r3
  41563e:	4313      	orrs	r3, r2
  415640:	b21b      	sxth	r3, r3
  415642:	b29a      	uxth	r2, r3
  415644:	4b10      	ldr	r3, [pc, #64]	; (415688 <vSocket_SNTP_create+0x68>)
  415646:	80da      	strh	r2, [r3, #6]

	/* Create the socket. */
	stSocket_SNTP.socket = FreeRTOS_socket( FREERTOS_AF_INET,
  415648:	2211      	movs	r2, #17
  41564a:	2102      	movs	r1, #2
  41564c:	2002      	movs	r0, #2
  41564e:	4b0f      	ldr	r3, [pc, #60]	; (41568c <vSocket_SNTP_create+0x6c>)
  415650:	4798      	blx	r3
  415652:	4602      	mov	r2, r0
  415654:	4b0c      	ldr	r3, [pc, #48]	; (415688 <vSocket_SNTP_create+0x68>)
  415656:	601a      	str	r2, [r3, #0]
                                  FREERTOS_IPPROTO_UDP );

	/* Check the socket was created. */
	//configASSERT( stSocket_SNTP.socket != FREERTOS_INVALID_SOCKET );

	if (stSocket_SNTP.socket != FREERTOS_INVALID_SOCKET)
  415658:	4b0b      	ldr	r3, [pc, #44]	; (415688 <vSocket_SNTP_create+0x68>)
  41565a:	681b      	ldr	r3, [r3, #0]
  41565c:	f1b3 3fff 	cmp.w	r3, #4294967295
  415660:	d007      	beq.n	415672 <vSocket_SNTP_create+0x52>
	{	stSocket_SNTP.up = pdTRUE;	// Sinaliza socket ok para enviar pacotes
  415662:	4b09      	ldr	r3, [pc, #36]	; (415688 <vSocket_SNTP_create+0x68>)
  415664:	2201      	movs	r2, #1
  415666:	735a      	strb	r2, [r3, #13]
		printf ("\nSocket-SNTP is up!\n\n");
  415668:	4809      	ldr	r0, [pc, #36]	; (415690 <vSocket_SNTP_create+0x70>)
  41566a:	4b0a      	ldr	r3, [pc, #40]	; (415694 <vSocket_SNTP_create+0x74>)
  41566c:	4798      	blx	r3
		return (pdPASS);
  41566e:	2301      	movs	r3, #1
  415670:	e003      	b.n	41567a <vSocket_SNTP_create+0x5a>
	}
	else
	{	
		printf("\n\nERROR: Socket-SNTP is not created!\n\n");
  415672:	4809      	ldr	r0, [pc, #36]	; (415698 <vSocket_SNTP_create+0x78>)
  415674:	4b07      	ldr	r3, [pc, #28]	; (415694 <vSocket_SNTP_create+0x74>)
  415676:	4798      	blx	r3
		return (pdFAIL);
  415678:	2300      	movs	r3, #0


   /* NOTE: FreeRTOS_bind() is not called.  This will only work if
   ipconfigALLOW_SOCKET_SEND_WITHOUT_BIND is set to 1 in FreeRTOSIPConfig.h. */

}
  41567a:	4618      	mov	r0, r3
  41567c:	bd80      	pop	{r7, pc}
  41567e:	bf00      	nop
  415680:	0041e53c 	.word	0x0041e53c
  415684:	00409525 	.word	0x00409525
  415688:	2000bca0 	.word	0x2000bca0
  41568c:	00408af5 	.word	0x00408af5
  415690:	0041e628 	.word	0x0041e628
  415694:	00416c7d 	.word	0x00416c7d
  415698:	0041e640 	.word	0x0041e640

0041569c <vSocket_SNTP_sendto>:

void vSocket_SNTP_sendto(uint8_t *pucBuffer, uint16_t usTotalDataLength)
{
  41569c:	b590      	push	{r4, r7, lr}
  41569e:	b085      	sub	sp, #20
  4156a0:	af02      	add	r7, sp, #8
  4156a2:	6078      	str	r0, [r7, #4]
  4156a4:	460b      	mov	r3, r1
  4156a6:	807b      	strh	r3, [r7, #2]

	FreeRTOS_sendto( stSocket_SNTP.socket,
  4156a8:	4b07      	ldr	r3, [pc, #28]	; (4156c8 <vSocket_SNTP_sendto+0x2c>)
  4156aa:	6818      	ldr	r0, [r3, #0]
  4156ac:	887a      	ldrh	r2, [r7, #2]
  4156ae:	2308      	movs	r3, #8
  4156b0:	9301      	str	r3, [sp, #4]
  4156b2:	4b06      	ldr	r3, [pc, #24]	; (4156cc <vSocket_SNTP_sendto+0x30>)
  4156b4:	9300      	str	r3, [sp, #0]
  4156b6:	2300      	movs	r3, #0
  4156b8:	6879      	ldr	r1, [r7, #4]
  4156ba:	4c05      	ldr	r4, [pc, #20]	; (4156d0 <vSocket_SNTP_sendto+0x34>)
  4156bc:	47a0      	blx	r4
	pucBuffer,
	usTotalDataLength,
	0,
	&stSocket_SNTP.addr,
	sizeof( stSocket_SNTP.addr ) );
}
  4156be:	bf00      	nop
  4156c0:	370c      	adds	r7, #12
  4156c2:	46bd      	mov	sp, r7
  4156c4:	bd90      	pop	{r4, r7, pc}
  4156c6:	bf00      	nop
  4156c8:	2000bca0 	.word	0x2000bca0
  4156cc:	2000bca4 	.word	0x2000bca4
  4156d0:	00408dc1 	.word	0x00408dc1

004156d4 <lSocket_SNTP_recv>:


int32_t lSocket_SNTP_recv(uint8_t *pucBuffer, uint16_t usTotalDataLength)
{
  4156d4:	b590      	push	{r4, r7, lr}
  4156d6:	b087      	sub	sp, #28
  4156d8:	af02      	add	r7, sp, #8
  4156da:	6078      	str	r0, [r7, #4]
  4156dc:	460b      	mov	r3, r1
  4156de:	807b      	strh	r3, [r7, #2]
	int32_t lReturned;
	
	/* Receive into the buffer with ulFlags set to 0, so the FREERTOS_ZERO_COPY bit is clear. */
	lReturned = FreeRTOS_recvfrom(
  4156e0:	4b08      	ldr	r3, [pc, #32]	; (415704 <lSocket_SNTP_recv+0x30>)
  4156e2:	6818      	ldr	r0, [r3, #0]
  4156e4:	887a      	ldrh	r2, [r7, #2]
  4156e6:	2308      	movs	r3, #8
  4156e8:	9301      	str	r3, [sp, #4]
  4156ea:	4b07      	ldr	r3, [pc, #28]	; (415708 <lSocket_SNTP_recv+0x34>)
  4156ec:	9300      	str	r3, [sp, #0]
  4156ee:	2300      	movs	r3, #0
  4156f0:	6879      	ldr	r1, [r7, #4]
  4156f2:	4c06      	ldr	r4, [pc, #24]	; (41570c <lSocket_SNTP_recv+0x38>)
  4156f4:	47a0      	blx	r4
  4156f6:	60f8      	str	r0, [r7, #12]
                                &stSocket_SNTP.addr,
                                /* Not used but should be set as shown. */
                                sizeof( stSocket_SNTP.addr )
                            );

	return lReturned;
  4156f8:	68fb      	ldr	r3, [r7, #12]
	
}
  4156fa:	4618      	mov	r0, r3
  4156fc:	3714      	adds	r7, #20
  4156fe:	46bd      	mov	sp, r7
  415700:	bd90      	pop	{r4, r7, pc}
  415702:	bf00      	nop
  415704:	2000bca0 	.word	0x2000bca0
  415708:	2000bca4 	.word	0x2000bca4
  41570c:	00408c49 	.word	0x00408c49

00415710 <NVIC_EnableIRQ>:
{
  415710:	b480      	push	{r7}
  415712:	b083      	sub	sp, #12
  415714:	af00      	add	r7, sp, #0
  415716:	4603      	mov	r3, r0
  415718:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
  41571a:	4909      	ldr	r1, [pc, #36]	; (415740 <NVIC_EnableIRQ+0x30>)
  41571c:	f997 3007 	ldrsb.w	r3, [r7, #7]
  415720:	095b      	lsrs	r3, r3, #5
  415722:	79fa      	ldrb	r2, [r7, #7]
  415724:	f002 021f 	and.w	r2, r2, #31
  415728:	2001      	movs	r0, #1
  41572a:	fa00 f202 	lsl.w	r2, r0, r2
  41572e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
  415732:	bf00      	nop
  415734:	370c      	adds	r7, #12
  415736:	46bd      	mov	sp, r7
  415738:	f85d 7b04 	ldr.w	r7, [sp], #4
  41573c:	4770      	bx	lr
  41573e:	bf00      	nop
  415740:	e000e100 	.word	0xe000e100

00415744 <NVIC_DisableIRQ>:
{
  415744:	b480      	push	{r7}
  415746:	b083      	sub	sp, #12
  415748:	af00      	add	r7, sp, #0
  41574a:	4603      	mov	r3, r0
  41574c:	71fb      	strb	r3, [r7, #7]
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
  41574e:	4909      	ldr	r1, [pc, #36]	; (415774 <NVIC_DisableIRQ+0x30>)
  415750:	f997 3007 	ldrsb.w	r3, [r7, #7]
  415754:	095b      	lsrs	r3, r3, #5
  415756:	79fa      	ldrb	r2, [r7, #7]
  415758:	f002 021f 	and.w	r2, r2, #31
  41575c:	2001      	movs	r0, #1
  41575e:	fa00 f202 	lsl.w	r2, r0, r2
  415762:	3320      	adds	r3, #32
  415764:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
  415768:	bf00      	nop
  41576a:	370c      	adds	r7, #12
  41576c:	46bd      	mov	sp, r7
  41576e:	f85d 7b04 	ldr.w	r7, [sp], #4
  415772:	4770      	bx	lr
  415774:	e000e100 	.word	0xe000e100

00415778 <NVIC_ClearPendingIRQ>:
{
  415778:	b480      	push	{r7}
  41577a:	b083      	sub	sp, #12
  41577c:	af00      	add	r7, sp, #0
  41577e:	4603      	mov	r3, r0
  415780:	71fb      	strb	r3, [r7, #7]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
  415782:	4909      	ldr	r1, [pc, #36]	; (4157a8 <NVIC_ClearPendingIRQ+0x30>)
  415784:	f997 3007 	ldrsb.w	r3, [r7, #7]
  415788:	095b      	lsrs	r3, r3, #5
  41578a:	79fa      	ldrb	r2, [r7, #7]
  41578c:	f002 021f 	and.w	r2, r2, #31
  415790:	2001      	movs	r0, #1
  415792:	fa00 f202 	lsl.w	r2, r0, r2
  415796:	3360      	adds	r3, #96	; 0x60
  415798:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
  41579c:	bf00      	nop
  41579e:	370c      	adds	r7, #12
  4157a0:	46bd      	mov	sp, r7
  4157a2:	f85d 7b04 	ldr.w	r7, [sp], #4
  4157a6:	4770      	bx	lr
  4157a8:	e000e100 	.word	0xe000e100

004157ac <NVIC_SetPriority>:
{
  4157ac:	b480      	push	{r7}
  4157ae:	b083      	sub	sp, #12
  4157b0:	af00      	add	r7, sp, #0
  4157b2:	4603      	mov	r3, r0
  4157b4:	6039      	str	r1, [r7, #0]
  4157b6:	71fb      	strb	r3, [r7, #7]
  if(IRQn < 0) {
  4157b8:	f997 3007 	ldrsb.w	r3, [r7, #7]
  4157bc:	2b00      	cmp	r3, #0
  4157be:	da0b      	bge.n	4157d8 <NVIC_SetPriority+0x2c>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
  4157c0:	490d      	ldr	r1, [pc, #52]	; (4157f8 <NVIC_SetPriority+0x4c>)
  4157c2:	79fb      	ldrb	r3, [r7, #7]
  4157c4:	f003 030f 	and.w	r3, r3, #15
  4157c8:	3b04      	subs	r3, #4
  4157ca:	683a      	ldr	r2, [r7, #0]
  4157cc:	b2d2      	uxtb	r2, r2
  4157ce:	0112      	lsls	r2, r2, #4
  4157d0:	b2d2      	uxtb	r2, r2
  4157d2:	440b      	add	r3, r1
  4157d4:	761a      	strb	r2, [r3, #24]
}
  4157d6:	e009      	b.n	4157ec <NVIC_SetPriority+0x40>
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
  4157d8:	4908      	ldr	r1, [pc, #32]	; (4157fc <NVIC_SetPriority+0x50>)
  4157da:	f997 3007 	ldrsb.w	r3, [r7, #7]
  4157de:	683a      	ldr	r2, [r7, #0]
  4157e0:	b2d2      	uxtb	r2, r2
  4157e2:	0112      	lsls	r2, r2, #4
  4157e4:	b2d2      	uxtb	r2, r2
  4157e6:	440b      	add	r3, r1
  4157e8:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
  4157ec:	bf00      	nop
  4157ee:	370c      	adds	r7, #12
  4157f0:	46bd      	mov	sp, r7
  4157f2:	f85d 7b04 	ldr.w	r7, [sp], #4
  4157f6:	4770      	bx	lr
  4157f8:	e000ed00 	.word	0xe000ed00
  4157fc:	e000e100 	.word	0xe000e100

00415800 <WDT_Init>:

volatile uint8_t byWDT_adcisr_ok = 0;
volatile uint8_t byWDT_iptask_ok = 0;

void WDT_Init(void)
{
  415800:	b590      	push	{r4, r7, lr}
  415802:	b083      	sub	sp, #12
  415804:	af00      	add	r7, sp, #0
	uint32_t wdt_mode, timeout_value;

	/* Get timeout value. */
	timeout_value = wdt_get_timeout_value(WDT_PERIOD * 1000, BOARD_FREQ_SLCK_XTAL);
  415806:	f44f 4100 	mov.w	r1, #32768	; 0x8000
  41580a:	4815      	ldr	r0, [pc, #84]	; (415860 <WDT_Init+0x60>)
  41580c:	4b15      	ldr	r3, [pc, #84]	; (415864 <WDT_Init+0x64>)
  41580e:	4798      	blx	r3
  415810:	6078      	str	r0, [r7, #4]
	if (timeout_value == WDT_INVALID_ARGUMENT) {
  415812:	687b      	ldr	r3, [r7, #4]
  415814:	f64f 72ff 	movw	r2, #65535	; 0xffff
  415818:	4293      	cmp	r3, r2
  41581a:	d100      	bne.n	41581e <WDT_Init+0x1e>
		while (1) {
  41581c:	e7fe      	b.n	41581c <WDT_Init+0x1c>
			/* Invalid timeout value, error. */
		}
	}
	/* Configure WDT to trigger an interrupt (or reset). */
	wdt_mode =		//WDT_MR_WDFIEN	 |  /* Watchdog Fault Interrupt Enable */
  41581e:	f04f 2320 	mov.w	r3, #536879104	; 0x20002000
  415822:	603b      	str	r3, [r7, #0]
					WDT_MR_WDRSTEN	 |	/* Watchdog Reset Enable */
					//WDT_MR_WDRPROC   |  /* WDT fault resets processor only. */
					WDT_MR_WDIDLEHLT;   /* WDT stops in idle state. */

	/* Initialize WDT with the given parameters. */
	wdt_init(WDT, wdt_mode, timeout_value, timeout_value);
  415824:	687b      	ldr	r3, [r7, #4]
  415826:	b29a      	uxth	r2, r3
  415828:	687b      	ldr	r3, [r7, #4]
  41582a:	b29b      	uxth	r3, r3
  41582c:	6839      	ldr	r1, [r7, #0]
  41582e:	480e      	ldr	r0, [pc, #56]	; (415868 <WDT_Init+0x68>)
  415830:	4c0e      	ldr	r4, [pc, #56]	; (41586c <WDT_Init+0x6c>)
  415832:	47a0      	blx	r4
	wdt_get_us_timeout_period(WDT, BOARD_FREQ_SLCK_XTAL);
  415834:	f44f 4100 	mov.w	r1, #32768	; 0x8000
  415838:	480b      	ldr	r0, [pc, #44]	; (415868 <WDT_Init+0x68>)
  41583a:	4b0d      	ldr	r3, [pc, #52]	; (415870 <WDT_Init+0x70>)
  41583c:	4798      	blx	r3

	/* Configure and enable WDT interrupt. */
	NVIC_DisableIRQ(WDT_IRQn);
  41583e:	2004      	movs	r0, #4
  415840:	4b0c      	ldr	r3, [pc, #48]	; (415874 <WDT_Init+0x74>)
  415842:	4798      	blx	r3
	NVIC_ClearPendingIRQ(WDT_IRQn);
  415844:	2004      	movs	r0, #4
  415846:	4b0c      	ldr	r3, [pc, #48]	; (415878 <WDT_Init+0x78>)
  415848:	4798      	blx	r3
	NVIC_SetPriority(WDT_IRQn, 0);
  41584a:	2100      	movs	r1, #0
  41584c:	2004      	movs	r0, #4
  41584e:	4b0b      	ldr	r3, [pc, #44]	; (41587c <WDT_Init+0x7c>)
  415850:	4798      	blx	r3
	NVIC_EnableIRQ(WDT_IRQn);
  415852:	2004      	movs	r0, #4
  415854:	4b0a      	ldr	r3, [pc, #40]	; (415880 <WDT_Init+0x80>)
  415856:	4798      	blx	r3
}
  415858:	bf00      	nop
  41585a:	370c      	adds	r7, #12
  41585c:	46bd      	mov	sp, r7
  41585e:	bd90      	pop	{r4, r7, pc}
  415860:	00989680 	.word	0x00989680
  415864:	00406b35 	.word	0x00406b35
  415868:	400e1850 	.word	0x400e1850
  41586c:	00406b85 	.word	0x00406b85
  415870:	00406c09 	.word	0x00406c09
  415874:	00415745 	.word	0x00415745
  415878:	00415779 	.word	0x00415779
  41587c:	004157ad 	.word	0x004157ad
  415880:	00415711 	.word	0x00415711

00415884 <WDT_Refresh>:

void WDT_Refresh(void)
{
  415884:	b580      	push	{r7, lr}
  415886:	af00      	add	r7, sp, #0
	// Faz o refresh do WDT se adc isr e iptask estao rodando ou se hics esta desacoplado da placa adc
	if ( ((byWDT_adcisr_ok==1) && (byWDT_iptask_ok==1)) || (wDESAC_enabled == true) )
  415888:	4b0d      	ldr	r3, [pc, #52]	; (4158c0 <WDT_Refresh+0x3c>)
  41588a:	781b      	ldrb	r3, [r3, #0]
  41588c:	b2db      	uxtb	r3, r3
  41588e:	2b01      	cmp	r3, #1
  415890:	d104      	bne.n	41589c <WDT_Refresh+0x18>
  415892:	4b0c      	ldr	r3, [pc, #48]	; (4158c4 <WDT_Refresh+0x40>)
  415894:	781b      	ldrb	r3, [r3, #0]
  415896:	b2db      	uxtb	r3, r3
  415898:	2b01      	cmp	r3, #1
  41589a:	d003      	beq.n	4158a4 <WDT_Refresh+0x20>
  41589c:	4b0a      	ldr	r3, [pc, #40]	; (4158c8 <WDT_Refresh+0x44>)
  41589e:	781b      	ldrb	r3, [r3, #0]
  4158a0:	2b01      	cmp	r3, #1
  4158a2:	d10b      	bne.n	4158bc <WDT_Refresh+0x38>
	{
		byWDT_adcisr_ok=0;
  4158a4:	4b06      	ldr	r3, [pc, #24]	; (4158c0 <WDT_Refresh+0x3c>)
  4158a6:	2200      	movs	r2, #0
  4158a8:	701a      	strb	r2, [r3, #0]
		byWDT_iptask_ok=0;
  4158aa:	4b06      	ldr	r3, [pc, #24]	; (4158c4 <WDT_Refresh+0x40>)
  4158ac:	2200      	movs	r2, #0
  4158ae:	701a      	strb	r2, [r3, #0]
	
		/* Clear status bit to acknowledge interrupt by dummy read. */
		wdt_get_status(WDT);
  4158b0:	4806      	ldr	r0, [pc, #24]	; (4158cc <WDT_Refresh+0x48>)
  4158b2:	4b07      	ldr	r3, [pc, #28]	; (4158d0 <WDT_Refresh+0x4c>)
  4158b4:	4798      	blx	r3
		/* Restart the WDT counter. */
		wdt_restart(WDT);
  4158b6:	4805      	ldr	r0, [pc, #20]	; (4158cc <WDT_Refresh+0x48>)
  4158b8:	4b06      	ldr	r3, [pc, #24]	; (4158d4 <WDT_Refresh+0x50>)
  4158ba:	4798      	blx	r3
	}
}
  4158bc:	bf00      	nop
  4158be:	bd80      	pop	{r7, pc}
  4158c0:	2000b536 	.word	0x2000b536
  4158c4:	2000b537 	.word	0x2000b537
  4158c8:	2000b4fe 	.word	0x2000b4fe
  4158cc:	400e1850 	.word	0x400e1850
  4158d0:	00406bf1 	.word	0x00406bf1
  4158d4:	00406bc5 	.word	0x00406bc5

004158d8 <WDT_Debug_printf_state>:


void WDT_Debug_printf_state(uint8_t byReset)
{
  4158d8:	b580      	push	{r7, lr}
  4158da:	b082      	sub	sp, #8
  4158dc:	af00      	add	r7, sp, #0
  4158de:	4603      	mov	r3, r0
  4158e0:	71fb      	strb	r3, [r7, #7]
	printf ("\nHICS debug state:\n");
  4158e2:	4818      	ldr	r0, [pc, #96]	; (415944 <WDT_Debug_printf_state+0x6c>)
  4158e4:	4b18      	ldr	r3, [pc, #96]	; (415948 <WDT_Debug_printf_state+0x70>)
  4158e6:	4798      	blx	r3
	printf ("-FHme=%d\n", xPortGetMinimumEverFreeHeapSize());
  4158e8:	4b18      	ldr	r3, [pc, #96]	; (41594c <WDT_Debug_printf_state+0x74>)
  4158ea:	4798      	blx	r3
  4158ec:	4603      	mov	r3, r0
  4158ee:	4619      	mov	r1, r3
  4158f0:	4817      	ldr	r0, [pc, #92]	; (415950 <WDT_Debug_printf_state+0x78>)
  4158f2:	4b15      	ldr	r3, [pc, #84]	; (415948 <WDT_Debug_printf_state+0x70>)
  4158f4:	4798      	blx	r3
	printf ("-FH=%d\n", xPortGetFreeHeapSize());
  4158f6:	4b17      	ldr	r3, [pc, #92]	; (415954 <WDT_Debug_printf_state+0x7c>)
  4158f8:	4798      	blx	r3
  4158fa:	4603      	mov	r3, r0
  4158fc:	4619      	mov	r1, r3
  4158fe:	4816      	ldr	r0, [pc, #88]	; (415958 <WDT_Debug_printf_state+0x80>)
  415900:	4b11      	ldr	r3, [pc, #68]	; (415948 <WDT_Debug_printf_state+0x70>)
  415902:	4798      	blx	r3
	
	extern volatile uint32_t dwmyMalloc_cx;
	extern volatile uint32_t dwmyFree_cx;
	printf   ("-Mcx=%d\n", dwmyMalloc_cx);
  415904:	4b15      	ldr	r3, [pc, #84]	; (41595c <WDT_Debug_printf_state+0x84>)
  415906:	681b      	ldr	r3, [r3, #0]
  415908:	4619      	mov	r1, r3
  41590a:	4815      	ldr	r0, [pc, #84]	; (415960 <WDT_Debug_printf_state+0x88>)
  41590c:	4b0e      	ldr	r3, [pc, #56]	; (415948 <WDT_Debug_printf_state+0x70>)
  41590e:	4798      	blx	r3
	printf   ("-Fcx=%d\n", dwmyFree_cx);
  415910:	4b14      	ldr	r3, [pc, #80]	; (415964 <WDT_Debug_printf_state+0x8c>)
  415912:	681b      	ldr	r3, [r3, #0]
  415914:	4619      	mov	r1, r3
  415916:	4814      	ldr	r0, [pc, #80]	; (415968 <WDT_Debug_printf_state+0x90>)
  415918:	4b0b      	ldr	r3, [pc, #44]	; (415948 <WDT_Debug_printf_state+0x70>)
  41591a:	4798      	blx	r3
	printf   ("-Mdi=%d\n", dwmyMalloc_cx-dwmyFree_cx);
  41591c:	4b0f      	ldr	r3, [pc, #60]	; (41595c <WDT_Debug_printf_state+0x84>)
  41591e:	681a      	ldr	r2, [r3, #0]
  415920:	4b10      	ldr	r3, [pc, #64]	; (415964 <WDT_Debug_printf_state+0x8c>)
  415922:	681b      	ldr	r3, [r3, #0]
  415924:	1ad3      	subs	r3, r2, r3
  415926:	4619      	mov	r1, r3
  415928:	4810      	ldr	r0, [pc, #64]	; (41596c <WDT_Debug_printf_state+0x94>)
  41592a:	4b07      	ldr	r3, [pc, #28]	; (415948 <WDT_Debug_printf_state+0x70>)
  41592c:	4798      	blx	r3
	
	if (byReset==1)
  41592e:	79fb      	ldrb	r3, [r7, #7]
  415930:	2b01      	cmp	r3, #1
  415932:	d103      	bne.n	41593c <WDT_Debug_printf_state+0x64>
	{	printf ("\nHICS wait reset by watchdog ...\n\n");
  415934:	480e      	ldr	r0, [pc, #56]	; (415970 <WDT_Debug_printf_state+0x98>)
  415936:	4b04      	ldr	r3, [pc, #16]	; (415948 <WDT_Debug_printf_state+0x70>)
  415938:	4798      	blx	r3
		while(1);
  41593a:	e7fe      	b.n	41593a <WDT_Debug_printf_state+0x62>
	}
	
	
}
  41593c:	bf00      	nop
  41593e:	3708      	adds	r7, #8
  415940:	46bd      	mov	sp, r7
  415942:	bd80      	pop	{r7, pc}
  415944:	0041e668 	.word	0x0041e668
  415948:	00416c7d 	.word	0x00416c7d
  41594c:	004114b9 	.word	0x004114b9
  415950:	0041e67c 	.word	0x0041e67c
  415954:	004114a1 	.word	0x004114a1
  415958:	0041e688 	.word	0x0041e688
  41595c:	2000b3f4 	.word	0x2000b3f4
  415960:	0041e690 	.word	0x0041e690
  415964:	2000b3f8 	.word	0x2000b3f8
  415968:	0041e69c 	.word	0x0041e69c
  41596c:	0041e6a8 	.word	0x0041e6a8
  415970:	0041e6b4 	.word	0x0041e6b4

00415974 <cpu_irq_save>:
{
  415974:	b480      	push	{r7}
  415976:	b083      	sub	sp, #12
  415978:	af00      	add	r7, sp, #0
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
  41597a:	f3ef 8310 	mrs	r3, PRIMASK
  41597e:	607b      	str	r3, [r7, #4]
  return(result);
  415980:	687b      	ldr	r3, [r7, #4]
	volatile irqflags_t flags = cpu_irq_is_enabled();
  415982:	2b00      	cmp	r3, #0
  415984:	bf0c      	ite	eq
  415986:	2301      	moveq	r3, #1
  415988:	2300      	movne	r3, #0
  41598a:	b2db      	uxtb	r3, r3
  41598c:	603b      	str	r3, [r7, #0]
  __ASM volatile ("cpsid i" : : : "memory");
  41598e:	b672      	cpsid	i
  __ASM volatile ("dmb");
  415990:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
  415994:	4b04      	ldr	r3, [pc, #16]	; (4159a8 <cpu_irq_save+0x34>)
  415996:	2200      	movs	r2, #0
  415998:	701a      	strb	r2, [r3, #0]
	return flags;
  41599a:	683b      	ldr	r3, [r7, #0]
}
  41599c:	4618      	mov	r0, r3
  41599e:	370c      	adds	r7, #12
  4159a0:	46bd      	mov	sp, r7
  4159a2:	f85d 7b04 	ldr.w	r7, [sp], #4
  4159a6:	4770      	bx	lr
  4159a8:	200000c2 	.word	0x200000c2

004159ac <cpu_irq_is_enabled_flags>:
{
  4159ac:	b480      	push	{r7}
  4159ae:	b083      	sub	sp, #12
  4159b0:	af00      	add	r7, sp, #0
  4159b2:	6078      	str	r0, [r7, #4]
	return (flags);
  4159b4:	687b      	ldr	r3, [r7, #4]
  4159b6:	2b00      	cmp	r3, #0
  4159b8:	bf14      	ite	ne
  4159ba:	2301      	movne	r3, #1
  4159bc:	2300      	moveq	r3, #0
  4159be:	b2db      	uxtb	r3, r3
}
  4159c0:	4618      	mov	r0, r3
  4159c2:	370c      	adds	r7, #12
  4159c4:	46bd      	mov	sp, r7
  4159c6:	f85d 7b04 	ldr.w	r7, [sp], #4
  4159ca:	4770      	bx	lr

004159cc <cpu_irq_restore>:
{
  4159cc:	b580      	push	{r7, lr}
  4159ce:	b082      	sub	sp, #8
  4159d0:	af00      	add	r7, sp, #0
  4159d2:	6078      	str	r0, [r7, #4]
	if (cpu_irq_is_enabled_flags(flags))
  4159d4:	6878      	ldr	r0, [r7, #4]
  4159d6:	4b07      	ldr	r3, [pc, #28]	; (4159f4 <cpu_irq_restore+0x28>)
  4159d8:	4798      	blx	r3
  4159da:	4603      	mov	r3, r0
  4159dc:	2b00      	cmp	r3, #0
  4159de:	d005      	beq.n	4159ec <cpu_irq_restore+0x20>
		cpu_irq_enable();
  4159e0:	4b05      	ldr	r3, [pc, #20]	; (4159f8 <cpu_irq_restore+0x2c>)
  4159e2:	2201      	movs	r2, #1
  4159e4:	701a      	strb	r2, [r3, #0]
  4159e6:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
  4159ea:	b662      	cpsie	i
}
  4159ec:	bf00      	nop
  4159ee:	3708      	adds	r7, #8
  4159f0:	46bd      	mov	sp, r7
  4159f2:	bd80      	pop	{r7, pc}
  4159f4:	004159ad 	.word	0x004159ad
  4159f8:	200000c2 	.word	0x200000c2

004159fc <osc_get_rate>:
{
  4159fc:	b480      	push	{r7}
  4159fe:	b083      	sub	sp, #12
  415a00:	af00      	add	r7, sp, #0
  415a02:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  415a04:	687b      	ldr	r3, [r7, #4]
  415a06:	2b07      	cmp	r3, #7
  415a08:	d825      	bhi.n	415a56 <osc_get_rate+0x5a>
  415a0a:	a201      	add	r2, pc, #4	; (adr r2, 415a10 <osc_get_rate+0x14>)
  415a0c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  415a10:	00415a31 	.word	0x00415a31
  415a14:	00415a37 	.word	0x00415a37
  415a18:	00415a3d 	.word	0x00415a3d
  415a1c:	00415a43 	.word	0x00415a43
  415a20:	00415a47 	.word	0x00415a47
  415a24:	00415a4b 	.word	0x00415a4b
  415a28:	00415a4f 	.word	0x00415a4f
  415a2c:	00415a53 	.word	0x00415a53
		return OSC_SLCK_32K_RC_HZ;
  415a30:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
  415a34:	e010      	b.n	415a58 <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_XTAL;
  415a36:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  415a3a:	e00d      	b.n	415a58 <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_BYPASS;
  415a3c:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  415a40:	e00a      	b.n	415a58 <osc_get_rate+0x5c>
		return OSC_MAINCK_4M_RC_HZ;
  415a42:	4b08      	ldr	r3, [pc, #32]	; (415a64 <osc_get_rate+0x68>)
  415a44:	e008      	b.n	415a58 <osc_get_rate+0x5c>
		return OSC_MAINCK_8M_RC_HZ;
  415a46:	4b08      	ldr	r3, [pc, #32]	; (415a68 <osc_get_rate+0x6c>)
  415a48:	e006      	b.n	415a58 <osc_get_rate+0x5c>
		return OSC_MAINCK_12M_RC_HZ;
  415a4a:	4b08      	ldr	r3, [pc, #32]	; (415a6c <osc_get_rate+0x70>)
  415a4c:	e004      	b.n	415a58 <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_XTAL;
  415a4e:	4b07      	ldr	r3, [pc, #28]	; (415a6c <osc_get_rate+0x70>)
  415a50:	e002      	b.n	415a58 <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_BYPASS;
  415a52:	4b06      	ldr	r3, [pc, #24]	; (415a6c <osc_get_rate+0x70>)
  415a54:	e000      	b.n	415a58 <osc_get_rate+0x5c>
	return 0;
  415a56:	2300      	movs	r3, #0
}
  415a58:	4618      	mov	r0, r3
  415a5a:	370c      	adds	r7, #12
  415a5c:	46bd      	mov	sp, r7
  415a5e:	f85d 7b04 	ldr.w	r7, [sp], #4
  415a62:	4770      	bx	lr
  415a64:	003d0900 	.word	0x003d0900
  415a68:	007a1200 	.word	0x007a1200
  415a6c:	00b71b00 	.word	0x00b71b00

00415a70 <sysclk_get_main_hz>:
{
  415a70:	b580      	push	{r7, lr}
  415a72:	af00      	add	r7, sp, #0
		return pll_get_default_rate(0);
  415a74:	2006      	movs	r0, #6
  415a76:	4b03      	ldr	r3, [pc, #12]	; (415a84 <sysclk_get_main_hz+0x14>)
  415a78:	4798      	blx	r3
  415a7a:	4603      	mov	r3, r0
  415a7c:	011b      	lsls	r3, r3, #4
}
  415a7e:	4618      	mov	r0, r3
  415a80:	bd80      	pop	{r7, pc}
  415a82:	bf00      	nop
  415a84:	004159fd 	.word	0x004159fd

00415a88 <sysclk_get_peripheral_hz>:
{
  415a88:	b580      	push	{r7, lr}
  415a8a:	af00      	add	r7, sp, #0
	return sysclk_get_main_hz() /
  415a8c:	4b02      	ldr	r3, [pc, #8]	; (415a98 <sysclk_get_peripheral_hz+0x10>)
  415a8e:	4798      	blx	r3
  415a90:	4603      	mov	r3, r0
  415a92:	085b      	lsrs	r3, r3, #1
}
  415a94:	4618      	mov	r0, r3
  415a96:	bd80      	pop	{r7, pc}
  415a98:	00415a71 	.word	0x00415a71

00415a9c <sysclk_enable_peripheral_clock>:
{
  415a9c:	b580      	push	{r7, lr}
  415a9e:	b082      	sub	sp, #8
  415aa0:	af00      	add	r7, sp, #0
  415aa2:	6078      	str	r0, [r7, #4]
	pmc_enable_periph_clk(ul_id);
  415aa4:	6878      	ldr	r0, [r7, #4]
  415aa6:	4b03      	ldr	r3, [pc, #12]	; (415ab4 <sysclk_enable_peripheral_clock+0x18>)
  415aa8:	4798      	blx	r3
}
  415aaa:	bf00      	nop
  415aac:	3708      	adds	r7, #8
  415aae:	46bd      	mov	sp, r7
  415ab0:	bd80      	pop	{r7, pc}
  415ab2:	bf00      	nop
  415ab4:	0040433d 	.word	0x0040433d

00415ab8 <sleepmgr_init>:
{
  415ab8:	b480      	push	{r7}
  415aba:	b083      	sub	sp, #12
  415abc:	af00      	add	r7, sp, #0
	for (i = 0; i < SLEEPMGR_NR_OF_MODES - 1; i++) {
  415abe:	2300      	movs	r3, #0
  415ac0:	71fb      	strb	r3, [r7, #7]
  415ac2:	e006      	b.n	415ad2 <sleepmgr_init+0x1a>
		sleepmgr_locks[i] = 0;
  415ac4:	79fb      	ldrb	r3, [r7, #7]
  415ac6:	4a09      	ldr	r2, [pc, #36]	; (415aec <sleepmgr_init+0x34>)
  415ac8:	2100      	movs	r1, #0
  415aca:	54d1      	strb	r1, [r2, r3]
	for (i = 0; i < SLEEPMGR_NR_OF_MODES - 1; i++) {
  415acc:	79fb      	ldrb	r3, [r7, #7]
  415ace:	3301      	adds	r3, #1
  415ad0:	71fb      	strb	r3, [r7, #7]
  415ad2:	79fb      	ldrb	r3, [r7, #7]
  415ad4:	2b04      	cmp	r3, #4
  415ad6:	d9f5      	bls.n	415ac4 <sleepmgr_init+0xc>
	sleepmgr_locks[SLEEPMGR_NR_OF_MODES - 1] = 1;
  415ad8:	4b04      	ldr	r3, [pc, #16]	; (415aec <sleepmgr_init+0x34>)
  415ada:	2201      	movs	r2, #1
  415adc:	715a      	strb	r2, [r3, #5]
}
  415ade:	bf00      	nop
  415ae0:	370c      	adds	r7, #12
  415ae2:	46bd      	mov	sp, r7
  415ae4:	f85d 7b04 	ldr.w	r7, [sp], #4
  415ae8:	4770      	bx	lr
  415aea:	bf00      	nop
  415aec:	2000b580 	.word	0x2000b580

00415af0 <sleepmgr_lock_mode>:
{
  415af0:	b580      	push	{r7, lr}
  415af2:	b084      	sub	sp, #16
  415af4:	af00      	add	r7, sp, #0
  415af6:	4603      	mov	r3, r0
  415af8:	71fb      	strb	r3, [r7, #7]
	if(sleepmgr_locks[mode] >= 0xff) {
  415afa:	79fb      	ldrb	r3, [r7, #7]
  415afc:	4a0a      	ldr	r2, [pc, #40]	; (415b28 <sleepmgr_lock_mode+0x38>)
  415afe:	5cd3      	ldrb	r3, [r2, r3]
  415b00:	2bff      	cmp	r3, #255	; 0xff
  415b02:	d100      	bne.n	415b06 <sleepmgr_lock_mode+0x16>
		while (true) {
  415b04:	e7fe      	b.n	415b04 <sleepmgr_lock_mode+0x14>
	flags = cpu_irq_save();
  415b06:	4b09      	ldr	r3, [pc, #36]	; (415b2c <sleepmgr_lock_mode+0x3c>)
  415b08:	4798      	blx	r3
  415b0a:	60f8      	str	r0, [r7, #12]
	++sleepmgr_locks[mode];
  415b0c:	79fb      	ldrb	r3, [r7, #7]
  415b0e:	4a06      	ldr	r2, [pc, #24]	; (415b28 <sleepmgr_lock_mode+0x38>)
  415b10:	5cd2      	ldrb	r2, [r2, r3]
  415b12:	3201      	adds	r2, #1
  415b14:	b2d1      	uxtb	r1, r2
  415b16:	4a04      	ldr	r2, [pc, #16]	; (415b28 <sleepmgr_lock_mode+0x38>)
  415b18:	54d1      	strb	r1, [r2, r3]
	cpu_irq_restore(flags);
  415b1a:	68f8      	ldr	r0, [r7, #12]
  415b1c:	4b04      	ldr	r3, [pc, #16]	; (415b30 <sleepmgr_lock_mode+0x40>)
  415b1e:	4798      	blx	r3
}
  415b20:	bf00      	nop
  415b22:	3710      	adds	r7, #16
  415b24:	46bd      	mov	sp, r7
  415b26:	bd80      	pop	{r7, pc}
  415b28:	2000b580 	.word	0x2000b580
  415b2c:	00415975 	.word	0x00415975
  415b30:	004159cd 	.word	0x004159cd

00415b34 <usart_serial_init>:
 * \param opt      Options needed to set up RS232 communication (see
 * \ref usart_options_t).
 */
static inline void usart_serial_init(usart_if p_usart,
		usart_serial_options_t *opt)
{
  415b34:	b580      	push	{r7, lr}
  415b36:	b08c      	sub	sp, #48	; 0x30
  415b38:	af00      	add	r7, sp, #0
  415b3a:	6078      	str	r0, [r7, #4]
  415b3c:	6039      	str	r1, [r7, #0]
#if ((!SAM4L) && (!SAMG55))
	sam_uart_opt_t uart_settings;
	uart_settings.ul_mck = sysclk_get_peripheral_hz();
  415b3e:	4b31      	ldr	r3, [pc, #196]	; (415c04 <usart_serial_init+0xd0>)
  415b40:	4798      	blx	r3
  415b42:	4603      	mov	r3, r0
  415b44:	627b      	str	r3, [r7, #36]	; 0x24
	uart_settings.ul_baudrate = opt->baudrate;
  415b46:	683b      	ldr	r3, [r7, #0]
  415b48:	681b      	ldr	r3, [r3, #0]
  415b4a:	62bb      	str	r3, [r7, #40]	; 0x28
	uart_settings.ul_mode = opt->paritytype;
  415b4c:	683b      	ldr	r3, [r7, #0]
  415b4e:	689b      	ldr	r3, [r3, #8]
  415b50:	62fb      	str	r3, [r7, #44]	; 0x2c
#endif

	sam_usart_opt_t usart_settings;
	usart_settings.baudrate = opt->baudrate;
  415b52:	683b      	ldr	r3, [r7, #0]
  415b54:	681b      	ldr	r3, [r3, #0]
  415b56:	60fb      	str	r3, [r7, #12]
	usart_settings.char_length = opt->charlength;
  415b58:	683b      	ldr	r3, [r7, #0]
  415b5a:	685b      	ldr	r3, [r3, #4]
  415b5c:	613b      	str	r3, [r7, #16]
	usart_settings.parity_type = opt->paritytype;
  415b5e:	683b      	ldr	r3, [r7, #0]
  415b60:	689b      	ldr	r3, [r3, #8]
  415b62:	617b      	str	r3, [r7, #20]
	usart_settings.stop_bits= opt->stopbits;
  415b64:	683b      	ldr	r3, [r7, #0]
  415b66:	68db      	ldr	r3, [r3, #12]
  415b68:	61bb      	str	r3, [r7, #24]
	usart_settings.channel_mode= US_MR_CHMODE_NORMAL;
  415b6a:	2300      	movs	r3, #0
  415b6c:	61fb      	str	r3, [r7, #28]
		/* Configure UART */
		uart_init((Uart*)p_usart, &uart_settings);
	}
#else
# ifdef UART0
	if (UART0 == (Uart*)p_usart) {
  415b6e:	687b      	ldr	r3, [r7, #4]
  415b70:	4a25      	ldr	r2, [pc, #148]	; (415c08 <usart_serial_init+0xd4>)
  415b72:	4293      	cmp	r3, r2
  415b74:	d108      	bne.n	415b88 <usart_serial_init+0x54>
		sysclk_enable_peripheral_clock(ID_UART0);
  415b76:	2007      	movs	r0, #7
  415b78:	4b24      	ldr	r3, [pc, #144]	; (415c0c <usart_serial_init+0xd8>)
  415b7a:	4798      	blx	r3
		/* Configure UART */
		uart_init((Uart*)p_usart, &uart_settings);
  415b7c:	f107 0324 	add.w	r3, r7, #36	; 0x24
  415b80:	4619      	mov	r1, r3
  415b82:	6878      	ldr	r0, [r7, #4]
  415b84:	4b22      	ldr	r3, [pc, #136]	; (415c10 <usart_serial_init+0xdc>)
  415b86:	4798      	blx	r3
	}
# endif
# ifdef UART1
	if (UART1 == (Uart*)p_usart) {
  415b88:	687b      	ldr	r3, [r7, #4]
  415b8a:	4a22      	ldr	r2, [pc, #136]	; (415c14 <usart_serial_init+0xe0>)
  415b8c:	4293      	cmp	r3, r2
  415b8e:	d108      	bne.n	415ba2 <usart_serial_init+0x6e>
		sysclk_enable_peripheral_clock(ID_UART1);
  415b90:	202d      	movs	r0, #45	; 0x2d
  415b92:	4b1e      	ldr	r3, [pc, #120]	; (415c0c <usart_serial_init+0xd8>)
  415b94:	4798      	blx	r3
		/* Configure UART */
		uart_init((Uart*)p_usart, &uart_settings);
  415b96:	f107 0324 	add.w	r3, r7, #36	; 0x24
  415b9a:	4619      	mov	r1, r3
  415b9c:	6878      	ldr	r0, [r7, #4]
  415b9e:	4b1c      	ldr	r3, [pc, #112]	; (415c10 <usart_serial_init+0xdc>)
  415ba0:	4798      	blx	r3
		usart_enable_tx(p_usart);
		usart_enable_rx(p_usart);
	}
#else
# ifdef USART0
	if (USART0 == p_usart) {
  415ba2:	687b      	ldr	r3, [r7, #4]
  415ba4:	4a1c      	ldr	r2, [pc, #112]	; (415c18 <usart_serial_init+0xe4>)
  415ba6:	4293      	cmp	r3, r2
  415ba8:	d111      	bne.n	415bce <usart_serial_init+0x9a>
#if (!SAM4L)
#if (SAMG55)
		flexcom_enable(FLEXCOM0);
		flexcom_set_opmode(FLEXCOM0, FLEXCOM_USART);
#else
		sysclk_enable_peripheral_clock(ID_USART0);
  415baa:	200e      	movs	r0, #14
  415bac:	4b17      	ldr	r3, [pc, #92]	; (415c0c <usart_serial_init+0xd8>)
  415bae:	4798      	blx	r3
#endif
		/* Configure USART */
		usart_init_rs232(p_usart, &usart_settings,
  415bb0:	4b14      	ldr	r3, [pc, #80]	; (415c04 <usart_serial_init+0xd0>)
  415bb2:	4798      	blx	r3
  415bb4:	4602      	mov	r2, r0
  415bb6:	f107 030c 	add.w	r3, r7, #12
  415bba:	4619      	mov	r1, r3
  415bbc:	6878      	ldr	r0, [r7, #4]
  415bbe:	4b17      	ldr	r3, [pc, #92]	; (415c1c <usart_serial_init+0xe8>)
  415bc0:	4798      	blx	r3
		/* Configure USART */
		usart_init_rs232(p_usart, &usart_settings,
				sysclk_get_peripheral_bus_hz(p_usart));
#endif
		/* Enable the receiver and transmitter. */
		usart_enable_tx(p_usart);
  415bc2:	6878      	ldr	r0, [r7, #4]
  415bc4:	4b16      	ldr	r3, [pc, #88]	; (415c20 <usart_serial_init+0xec>)
  415bc6:	4798      	blx	r3
		usart_enable_rx(p_usart);
  415bc8:	6878      	ldr	r0, [r7, #4]
  415bca:	4b16      	ldr	r3, [pc, #88]	; (415c24 <usart_serial_init+0xf0>)
  415bcc:	4798      	blx	r3
	}
# endif
# ifdef USART1
	if (USART1 == p_usart) {
  415bce:	687b      	ldr	r3, [r7, #4]
  415bd0:	4a15      	ldr	r2, [pc, #84]	; (415c28 <usart_serial_init+0xf4>)
  415bd2:	4293      	cmp	r3, r2
  415bd4:	d111      	bne.n	415bfa <usart_serial_init+0xc6>
#if (!SAM4L)
#if (SAMG55)
		flexcom_enable(FLEXCOM1);
		flexcom_set_opmode(FLEXCOM1, FLEXCOM_USART);
#else
		sysclk_enable_peripheral_clock(ID_USART1);
  415bd6:	200f      	movs	r0, #15
  415bd8:	4b0c      	ldr	r3, [pc, #48]	; (415c0c <usart_serial_init+0xd8>)
  415bda:	4798      	blx	r3
#endif
		/* Configure USART */
		usart_init_rs232(p_usart, &usart_settings,
  415bdc:	4b09      	ldr	r3, [pc, #36]	; (415c04 <usart_serial_init+0xd0>)
  415bde:	4798      	blx	r3
  415be0:	4602      	mov	r2, r0
  415be2:	f107 030c 	add.w	r3, r7, #12
  415be6:	4619      	mov	r1, r3
  415be8:	6878      	ldr	r0, [r7, #4]
  415bea:	4b0c      	ldr	r3, [pc, #48]	; (415c1c <usart_serial_init+0xe8>)
  415bec:	4798      	blx	r3
		/* Configure USART */
		usart_init_rs232(p_usart, &usart_settings,
				sysclk_get_peripheral_bus_hz(p_usart));
#endif
		/* Enable the receiver and transmitter. */
		usart_enable_tx(p_usart);
  415bee:	6878      	ldr	r0, [r7, #4]
  415bf0:	4b0b      	ldr	r3, [pc, #44]	; (415c20 <usart_serial_init+0xec>)
  415bf2:	4798      	blx	r3
		usart_enable_rx(p_usart);
  415bf4:	6878      	ldr	r0, [r7, #4]
  415bf6:	4b0b      	ldr	r3, [pc, #44]	; (415c24 <usart_serial_init+0xf0>)
  415bf8:	4798      	blx	r3
	}
# endif

#endif /* ifdef USART */

}
  415bfa:	bf00      	nop
  415bfc:	3730      	adds	r7, #48	; 0x30
  415bfe:	46bd      	mov	sp, r7
  415c00:	bd80      	pop	{r7, pc}
  415c02:	bf00      	nop
  415c04:	00415a89 	.word	0x00415a89
  415c08:	400e0600 	.word	0x400e0600
  415c0c:	00415a9d 	.word	0x00415a9d
  415c10:	00404799 	.word	0x00404799
  415c14:	40060600 	.word	0x40060600
  415c18:	400a0000 	.word	0x400a0000
  415c1c:	0040696d 	.word	0x0040696d
  415c20:	004069f1 	.word	0x004069f1
  415c24:	00406a25 	.word	0x00406a25
  415c28:	400a4000 	.word	0x400a4000

00415c2c <usart_serial_putchar>:
 *   \retval 1  The character was written.
 *   \retval 0  The function timed out before the USART transmitter became
 * ready to send.
 */
static inline int usart_serial_putchar(usart_if p_usart, const uint8_t c)
{
  415c2c:	b580      	push	{r7, lr}
  415c2e:	b082      	sub	sp, #8
  415c30:	af00      	add	r7, sp, #0
  415c32:	6078      	str	r0, [r7, #4]
  415c34:	460b      	mov	r3, r1
  415c36:	70fb      	strb	r3, [r7, #3]
		while (uart_write((Uart*)p_usart, c)!=0);
		return 1;
	}
#else
# ifdef UART0
	if (UART0 == (Uart*)p_usart) {
  415c38:	687b      	ldr	r3, [r7, #4]
  415c3a:	4a20      	ldr	r2, [pc, #128]	; (415cbc <usart_serial_putchar+0x90>)
  415c3c:	4293      	cmp	r3, r2
  415c3e:	d10a      	bne.n	415c56 <usart_serial_putchar+0x2a>
		while (uart_write((Uart*)p_usart, c)!=0);
  415c40:	bf00      	nop
  415c42:	78fb      	ldrb	r3, [r7, #3]
  415c44:	4619      	mov	r1, r3
  415c46:	6878      	ldr	r0, [r7, #4]
  415c48:	4b1d      	ldr	r3, [pc, #116]	; (415cc0 <usart_serial_putchar+0x94>)
  415c4a:	4798      	blx	r3
  415c4c:	4603      	mov	r3, r0
  415c4e:	2b00      	cmp	r3, #0
  415c50:	d1f7      	bne.n	415c42 <usart_serial_putchar+0x16>
		return 1;
  415c52:	2301      	movs	r3, #1
  415c54:	e02d      	b.n	415cb2 <usart_serial_putchar+0x86>
	}
# endif
# ifdef UART1
	if (UART1 == (Uart*)p_usart) {
  415c56:	687b      	ldr	r3, [r7, #4]
  415c58:	4a1a      	ldr	r2, [pc, #104]	; (415cc4 <usart_serial_putchar+0x98>)
  415c5a:	4293      	cmp	r3, r2
  415c5c:	d10a      	bne.n	415c74 <usart_serial_putchar+0x48>
		while (uart_write((Uart*)p_usart, c)!=0);
  415c5e:	bf00      	nop
  415c60:	78fb      	ldrb	r3, [r7, #3]
  415c62:	4619      	mov	r1, r3
  415c64:	6878      	ldr	r0, [r7, #4]
  415c66:	4b16      	ldr	r3, [pc, #88]	; (415cc0 <usart_serial_putchar+0x94>)
  415c68:	4798      	blx	r3
  415c6a:	4603      	mov	r3, r0
  415c6c:	2b00      	cmp	r3, #0
  415c6e:	d1f7      	bne.n	415c60 <usart_serial_putchar+0x34>
		return 1;
  415c70:	2301      	movs	r3, #1
  415c72:	e01e      	b.n	415cb2 <usart_serial_putchar+0x86>
		while (usart_write(p_usart, c)!=0);
		return 1;
	}
#else
# ifdef USART0
	if (USART0 == p_usart) {
  415c74:	687b      	ldr	r3, [r7, #4]
  415c76:	4a14      	ldr	r2, [pc, #80]	; (415cc8 <usart_serial_putchar+0x9c>)
  415c78:	4293      	cmp	r3, r2
  415c7a:	d10a      	bne.n	415c92 <usart_serial_putchar+0x66>
		while (usart_write(p_usart, c)!=0);
  415c7c:	bf00      	nop
  415c7e:	78fb      	ldrb	r3, [r7, #3]
  415c80:	4619      	mov	r1, r3
  415c82:	6878      	ldr	r0, [r7, #4]
  415c84:	4b11      	ldr	r3, [pc, #68]	; (415ccc <usart_serial_putchar+0xa0>)
  415c86:	4798      	blx	r3
  415c88:	4603      	mov	r3, r0
  415c8a:	2b00      	cmp	r3, #0
  415c8c:	d1f7      	bne.n	415c7e <usart_serial_putchar+0x52>
		return 1;
  415c8e:	2301      	movs	r3, #1
  415c90:	e00f      	b.n	415cb2 <usart_serial_putchar+0x86>
	}
# endif
# ifdef USART1
	if (USART1 == p_usart) {
  415c92:	687b      	ldr	r3, [r7, #4]
  415c94:	4a0e      	ldr	r2, [pc, #56]	; (415cd0 <usart_serial_putchar+0xa4>)
  415c96:	4293      	cmp	r3, r2
  415c98:	d10a      	bne.n	415cb0 <usart_serial_putchar+0x84>
		while (usart_write(p_usart, c)!=0);
  415c9a:	bf00      	nop
  415c9c:	78fb      	ldrb	r3, [r7, #3]
  415c9e:	4619      	mov	r1, r3
  415ca0:	6878      	ldr	r0, [r7, #4]
  415ca2:	4b0a      	ldr	r3, [pc, #40]	; (415ccc <usart_serial_putchar+0xa0>)
  415ca4:	4798      	blx	r3
  415ca6:	4603      	mov	r3, r0
  415ca8:	2b00      	cmp	r3, #0
  415caa:	d1f7      	bne.n	415c9c <usart_serial_putchar+0x70>
		return 1;
  415cac:	2301      	movs	r3, #1
  415cae:	e000      	b.n	415cb2 <usart_serial_putchar+0x86>
		return 1;
	}
# endif
#endif /* ifdef USART */

	return 0;
  415cb0:	2300      	movs	r3, #0
}
  415cb2:	4618      	mov	r0, r3
  415cb4:	3708      	adds	r7, #8
  415cb6:	46bd      	mov	sp, r7
  415cb8:	bd80      	pop	{r7, pc}
  415cba:	bf00      	nop
  415cbc:	400e0600 	.word	0x400e0600
  415cc0:	004047fb 	.word	0x004047fb
  415cc4:	40060600 	.word	0x40060600
  415cc8:	400a0000 	.word	0x400a0000
  415ccc:	00406aad 	.word	0x00406aad
  415cd0:	400a4000 	.word	0x400a4000

00415cd4 <usart_serial_getchar>:
 * \param p_usart   Base address of the USART instance.
 * \param data   Data to read
 *
 */
static inline void usart_serial_getchar(usart_if p_usart, uint8_t *data)
{
  415cd4:	b580      	push	{r7, lr}
  415cd6:	b084      	sub	sp, #16
  415cd8:	af00      	add	r7, sp, #0
  415cda:	6078      	str	r0, [r7, #4]
  415cdc:	6039      	str	r1, [r7, #0]
	uint32_t val = 0;
  415cde:	2300      	movs	r3, #0
  415ce0:	60fb      	str	r3, [r7, #12]
	if (UART == (Uart*)p_usart) {
		while (uart_read((Uart*)p_usart, data));
	}
#else
# ifdef UART0
	if (UART0 == (Uart*)p_usart) {
  415ce2:	687b      	ldr	r3, [r7, #4]
  415ce4:	4a1f      	ldr	r2, [pc, #124]	; (415d64 <usart_serial_getchar+0x90>)
  415ce6:	4293      	cmp	r3, r2
  415ce8:	d107      	bne.n	415cfa <usart_serial_getchar+0x26>
		while (uart_read((Uart*)p_usart, data));
  415cea:	bf00      	nop
  415cec:	6839      	ldr	r1, [r7, #0]
  415cee:	6878      	ldr	r0, [r7, #4]
  415cf0:	4b1d      	ldr	r3, [pc, #116]	; (415d68 <usart_serial_getchar+0x94>)
  415cf2:	4798      	blx	r3
  415cf4:	4603      	mov	r3, r0
  415cf6:	2b00      	cmp	r3, #0
  415cf8:	d1f8      	bne.n	415cec <usart_serial_getchar+0x18>
	}
# endif
# ifdef UART1
	if (UART1 == (Uart*)p_usart) {
  415cfa:	687b      	ldr	r3, [r7, #4]
  415cfc:	4a1b      	ldr	r2, [pc, #108]	; (415d6c <usart_serial_getchar+0x98>)
  415cfe:	4293      	cmp	r3, r2
  415d00:	d107      	bne.n	415d12 <usart_serial_getchar+0x3e>
		while (uart_read((Uart*)p_usart, data));
  415d02:	bf00      	nop
  415d04:	6839      	ldr	r1, [r7, #0]
  415d06:	6878      	ldr	r0, [r7, #4]
  415d08:	4b17      	ldr	r3, [pc, #92]	; (415d68 <usart_serial_getchar+0x94>)
  415d0a:	4798      	blx	r3
  415d0c:	4603      	mov	r3, r0
  415d0e:	2b00      	cmp	r3, #0
  415d10:	d1f8      	bne.n	415d04 <usart_serial_getchar+0x30>
		while (usart_read(p_usart, &val));
		*data = (uint8_t)(val & 0xFF);
	}
#else
# ifdef USART0
	if (USART0 == p_usart) {
  415d12:	687b      	ldr	r3, [r7, #4]
  415d14:	4a16      	ldr	r2, [pc, #88]	; (415d70 <usart_serial_getchar+0x9c>)
  415d16:	4293      	cmp	r3, r2
  415d18:	d10d      	bne.n	415d36 <usart_serial_getchar+0x62>
		while (usart_read(p_usart, &val));
  415d1a:	bf00      	nop
  415d1c:	f107 030c 	add.w	r3, r7, #12
  415d20:	4619      	mov	r1, r3
  415d22:	6878      	ldr	r0, [r7, #4]
  415d24:	4b13      	ldr	r3, [pc, #76]	; (415d74 <usart_serial_getchar+0xa0>)
  415d26:	4798      	blx	r3
  415d28:	4603      	mov	r3, r0
  415d2a:	2b00      	cmp	r3, #0
  415d2c:	d1f6      	bne.n	415d1c <usart_serial_getchar+0x48>
		*data = (uint8_t)(val & 0xFF);
  415d2e:	68fb      	ldr	r3, [r7, #12]
  415d30:	b2da      	uxtb	r2, r3
  415d32:	683b      	ldr	r3, [r7, #0]
  415d34:	701a      	strb	r2, [r3, #0]
	}
# endif
# ifdef USART1
	if (USART1 == p_usart) {
  415d36:	687b      	ldr	r3, [r7, #4]
  415d38:	4a0f      	ldr	r2, [pc, #60]	; (415d78 <usart_serial_getchar+0xa4>)
  415d3a:	4293      	cmp	r3, r2
  415d3c:	d10d      	bne.n	415d5a <usart_serial_getchar+0x86>
		while (usart_read(p_usart, &val));
  415d3e:	bf00      	nop
  415d40:	f107 030c 	add.w	r3, r7, #12
  415d44:	4619      	mov	r1, r3
  415d46:	6878      	ldr	r0, [r7, #4]
  415d48:	4b0a      	ldr	r3, [pc, #40]	; (415d74 <usart_serial_getchar+0xa0>)
  415d4a:	4798      	blx	r3
  415d4c:	4603      	mov	r3, r0
  415d4e:	2b00      	cmp	r3, #0
  415d50:	d1f6      	bne.n	415d40 <usart_serial_getchar+0x6c>
		*data = (uint8_t)(val & 0xFF);
  415d52:	68fb      	ldr	r3, [r7, #12]
  415d54:	b2da      	uxtb	r2, r3
  415d56:	683b      	ldr	r3, [r7, #0]
  415d58:	701a      	strb	r2, [r3, #0]
		*data = (uint8_t)(val & 0xFF);
	}
# endif
#endif /* ifdef USART */

}
  415d5a:	bf00      	nop
  415d5c:	3710      	adds	r7, #16
  415d5e:	46bd      	mov	sp, r7
  415d60:	bd80      	pop	{r7, pc}
  415d62:	bf00      	nop
  415d64:	400e0600 	.word	0x400e0600
  415d68:	0040482b 	.word	0x0040482b
  415d6c:	40060600 	.word	0x40060600
  415d70:	400a0000 	.word	0x400a0000
  415d74:	00406adf 	.word	0x00406adf
  415d78:	400a4000 	.word	0x400a4000

00415d7c <stdio_serial_init>:
 * \param usart       Base address of the USART instance.
 * \param opt         Options needed to set up RS232 communication (see \ref usart_options_t).
 *
 */
static inline void stdio_serial_init(volatile void *usart, const usart_serial_options_t *opt)
{
  415d7c:	b580      	push	{r7, lr}
  415d7e:	b082      	sub	sp, #8
  415d80:	af00      	add	r7, sp, #0
  415d82:	6078      	str	r0, [r7, #4]
  415d84:	6039      	str	r1, [r7, #0]
	stdio_base = (void *)usart;
  415d86:	4a0f      	ldr	r2, [pc, #60]	; (415dc4 <stdio_serial_init+0x48>)
  415d88:	687b      	ldr	r3, [r7, #4]
  415d8a:	6013      	str	r3, [r2, #0]
	ptr_put = (int (*)(void volatile*,char))&usart_serial_putchar;
  415d8c:	4b0e      	ldr	r3, [pc, #56]	; (415dc8 <stdio_serial_init+0x4c>)
  415d8e:	4a0f      	ldr	r2, [pc, #60]	; (415dcc <stdio_serial_init+0x50>)
  415d90:	601a      	str	r2, [r3, #0]
	ptr_get = (void (*)(void volatile*,char*))&usart_serial_getchar;
  415d92:	4b0f      	ldr	r3, [pc, #60]	; (415dd0 <stdio_serial_init+0x54>)
  415d94:	4a0f      	ldr	r2, [pc, #60]	; (415dd4 <stdio_serial_init+0x58>)
  415d96:	601a      	str	r2, [r3, #0]
# if (XMEGA || MEGA_RF)
	usart_serial_init((USART_t *)usart,opt);
# elif UC3
	usart_serial_init(usart,(usart_serial_options_t *)opt);
# elif SAM
	usart_serial_init((Usart *)usart,(usart_serial_options_t *)opt);
  415d98:	6839      	ldr	r1, [r7, #0]
  415d9a:	6878      	ldr	r0, [r7, #4]
  415d9c:	4b0e      	ldr	r3, [pc, #56]	; (415dd8 <stdio_serial_init+0x5c>)
  415d9e:	4798      	blx	r3
	fdevopen((int (*)(char, FILE*))(_write),(int (*)(FILE*))(_read));
#  endif
#  if UC3 || SAM
	// For AVR32 and SAM GCC
	// Specify that stdout and stdin should not be buffered.
	setbuf(stdout, NULL);
  415da0:	4b0e      	ldr	r3, [pc, #56]	; (415ddc <stdio_serial_init+0x60>)
  415da2:	681b      	ldr	r3, [r3, #0]
  415da4:	689b      	ldr	r3, [r3, #8]
  415da6:	2100      	movs	r1, #0
  415da8:	4618      	mov	r0, r3
  415daa:	4b0d      	ldr	r3, [pc, #52]	; (415de0 <stdio_serial_init+0x64>)
  415dac:	4798      	blx	r3
	setbuf(stdin, NULL);
  415dae:	4b0b      	ldr	r3, [pc, #44]	; (415ddc <stdio_serial_init+0x60>)
  415db0:	681b      	ldr	r3, [r3, #0]
  415db2:	685b      	ldr	r3, [r3, #4]
  415db4:	2100      	movs	r1, #0
  415db6:	4618      	mov	r0, r3
  415db8:	4b09      	ldr	r3, [pc, #36]	; (415de0 <stdio_serial_init+0x64>)
  415dba:	4798      	blx	r3
	// and AVR GCC library:
	// - printf() emits one character at a time.
	// - getchar() requests only 1 byte to exit.
#  endif
# endif
}
  415dbc:	bf00      	nop
  415dbe:	3708      	adds	r7, #8
  415dc0:	46bd      	mov	sp, r7
  415dc2:	bd80      	pop	{r7, pc}
  415dc4:	2000b590 	.word	0x2000b590
  415dc8:	2000b58c 	.word	0x2000b58c
  415dcc:	00415c2d 	.word	0x00415c2d
  415dd0:	2000b588 	.word	0x2000b588
  415dd4:	00415cd5 	.word	0x00415cd5
  415dd8:	00415b35 	.word	0x00415b35
  415ddc:	20000178 	.word	0x20000178
  415de0:	00416f9d 	.word	0x00416f9d

00415de4 <configure_console>:

/**
 *  Configure UART console.
 */
static void configure_console(void)
{
  415de4:	b580      	push	{r7, lr}
  415de6:	b084      	sub	sp, #16
  415de8:	af00      	add	r7, sp, #0
	const usart_serial_options_t uart_serial_options = {
  415dea:	463b      	mov	r3, r7
  415dec:	2200      	movs	r2, #0
  415dee:	601a      	str	r2, [r3, #0]
  415df0:	605a      	str	r2, [r3, #4]
  415df2:	609a      	str	r2, [r3, #8]
  415df4:	60da      	str	r2, [r3, #12]
  415df6:	f44f 33e1 	mov.w	r3, #115200	; 0x1c200
  415dfa:	603b      	str	r3, [r7, #0]
  415dfc:	f44f 6300 	mov.w	r3, #2048	; 0x800
  415e00:	60bb      	str	r3, [r7, #8]
		.stopbits = CONF_UART_STOP_BITS,
#endif
	};

	/* Configure console UART. */
	sysclk_enable_peripheral_clock(CONSOLE_UART_ID);
  415e02:	2007      	movs	r0, #7
  415e04:	4b08      	ldr	r3, [pc, #32]	; (415e28 <configure_console+0x44>)
  415e06:	4798      	blx	r3
	pio_configure_pin_group(CONF_UART_PIO, CONF_PINS_UART,
  415e08:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
  415e0c:	f44f 61c0 	mov.w	r1, #1536	; 0x600
  415e10:	4806      	ldr	r0, [pc, #24]	; (415e2c <configure_console+0x48>)
  415e12:	4b07      	ldr	r3, [pc, #28]	; (415e30 <configure_console+0x4c>)
  415e14:	4798      	blx	r3
			CONF_PINS_UART_FLAGS);
	stdio_serial_init(CONF_UART, &uart_serial_options);
  415e16:	463b      	mov	r3, r7
  415e18:	4619      	mov	r1, r3
  415e1a:	4806      	ldr	r0, [pc, #24]	; (415e34 <configure_console+0x50>)
  415e1c:	4b06      	ldr	r3, [pc, #24]	; (415e38 <configure_console+0x54>)
  415e1e:	4798      	blx	r3
}
  415e20:	bf00      	nop
  415e22:	3710      	adds	r7, #16
  415e24:	46bd      	mov	sp, r7
  415e26:	bd80      	pop	{r7, pc}
  415e28:	00415a9d 	.word	0x00415a9d
  415e2c:	400e0e00 	.word	0x400e0e00
  415e30:	00403df9 	.word	0x00403df9
  415e34:	400e0600 	.word	0x400e0600
  415e38:	00415d7d 	.word	0x00415d7d

00415e3c <uxRand>:

/* Use by the pseudo random number generator. */
static UBaseType_t ulNextRand;

UBaseType_t uxRand( void )
{
  415e3c:	b480      	push	{r7}
  415e3e:	b083      	sub	sp, #12
  415e40:	af00      	add	r7, sp, #0
	const uint32_t ulMultiplier = 0x015a4e35UL, ulIncrement = 1UL;
  415e42:	4b0c      	ldr	r3, [pc, #48]	; (415e74 <uxRand+0x38>)
  415e44:	607b      	str	r3, [r7, #4]
  415e46:	2301      	movs	r3, #1
  415e48:	603b      	str	r3, [r7, #0]

	/* Utility function to generate a pseudo random number. */

	ulNextRand = ( ulMultiplier * ulNextRand ) + ulIncrement;
  415e4a:	4b0b      	ldr	r3, [pc, #44]	; (415e78 <uxRand+0x3c>)
  415e4c:	681b      	ldr	r3, [r3, #0]
  415e4e:	687a      	ldr	r2, [r7, #4]
  415e50:	fb02 f203 	mul.w	r2, r2, r3
  415e54:	683b      	ldr	r3, [r7, #0]
  415e56:	4413      	add	r3, r2
  415e58:	4a07      	ldr	r2, [pc, #28]	; (415e78 <uxRand+0x3c>)
  415e5a:	6013      	str	r3, [r2, #0]
	return( ( int ) ( ulNextRand >> 16UL ) & 0x7fffUL );
  415e5c:	4b06      	ldr	r3, [pc, #24]	; (415e78 <uxRand+0x3c>)
  415e5e:	681b      	ldr	r3, [r3, #0]
  415e60:	0c1b      	lsrs	r3, r3, #16
  415e62:	f3c3 030e 	ubfx	r3, r3, #0, #15
}
  415e66:	4618      	mov	r0, r3
  415e68:	370c      	adds	r7, #12
  415e6a:	46bd      	mov	sp, r7
  415e6c:	f85d 7b04 	ldr.w	r7, [sp], #4
  415e70:	4770      	bx	lr
  415e72:	bf00      	nop
  415e74:	015a4e35 	.word	0x015a4e35
  415e78:	2000b540 	.word	0x2000b540

00415e7c <xApplicationGetRandomNumber>:
// HICS_end

// HICS
BaseType_t xApplicationGetRandomNumber( uint32_t * pulNumber )	
{
  415e7c:	b580      	push	{r7, lr}
  415e7e:	b082      	sub	sp, #8
  415e80:	af00      	add	r7, sp, #0
  415e82:	6078      	str	r0, [r7, #4]
	*( pulNumber ) = uxRand();
  415e84:	4b04      	ldr	r3, [pc, #16]	; (415e98 <xApplicationGetRandomNumber+0x1c>)
  415e86:	4798      	blx	r3
  415e88:	4602      	mov	r2, r0
  415e8a:	687b      	ldr	r3, [r7, #4]
  415e8c:	601a      	str	r2, [r3, #0]
}
  415e8e:	bf00      	nop
  415e90:	4618      	mov	r0, r3
  415e92:	3708      	adds	r7, #8
  415e94:	46bd      	mov	sp, r7
  415e96:	bd80      	pop	{r7, pc}
  415e98:	00415e3d 	.word	0x00415e3d

00415e9c <configure_sram>:
 * \brief Configure the SMC for SRAM access.
 *
 * \param cs  Chip select.
 */
static void configure_sram(uint32_t cs)
{
  415e9c:	b580      	push	{r7, lr}
  415e9e:	b082      	sub	sp, #8
  415ea0:	af00      	add	r7, sp, #0
  415ea2:	6078      	str	r0, [r7, #4]
	smc_set_setup_timing(SMC, cs, SMC_SETUP_NWE_SETUP(1)
  415ea4:	f04f 3201 	mov.w	r2, #16843009	; 0x1010101
  415ea8:	6879      	ldr	r1, [r7, #4]
  415eaa:	480c      	ldr	r0, [pc, #48]	; (415edc <configure_sram+0x40>)
  415eac:	4b0c      	ldr	r3, [pc, #48]	; (415ee0 <configure_sram+0x44>)
  415eae:	4798      	blx	r3
			| SMC_SETUP_NCS_WR_SETUP(1)
			| SMC_SETUP_NRD_SETUP(1)
			| SMC_SETUP_NCS_RD_SETUP(1));
	smc_set_pulse_timing(SMC, cs, SMC_PULSE_NWE_PULSE(6)
  415eb0:	f04f 3206 	mov.w	r2, #101058054	; 0x6060606
  415eb4:	6879      	ldr	r1, [r7, #4]
  415eb6:	4809      	ldr	r0, [pc, #36]	; (415edc <configure_sram+0x40>)
  415eb8:	4b0a      	ldr	r3, [pc, #40]	; (415ee4 <configure_sram+0x48>)
  415eba:	4798      	blx	r3
			| SMC_PULSE_NCS_WR_PULSE(6)
			| SMC_PULSE_NRD_PULSE(6)
			| SMC_PULSE_NCS_RD_PULSE(6));
	smc_set_cycle_timing(SMC, cs, SMC_CYCLE_NWE_CYCLE(7)
  415ebc:	f04f 1207 	mov.w	r2, #458759	; 0x70007
  415ec0:	6879      	ldr	r1, [r7, #4]
  415ec2:	4806      	ldr	r0, [pc, #24]	; (415edc <configure_sram+0x40>)
  415ec4:	4b08      	ldr	r3, [pc, #32]	; (415ee8 <configure_sram+0x4c>)
  415ec6:	4798      	blx	r3
			| SMC_CYCLE_NRD_CYCLE(7));
	smc_set_mode(SMC, cs, SMC_MODE_READ_MODE | SMC_MODE_WRITE_MODE);
  415ec8:	2203      	movs	r2, #3
  415eca:	6879      	ldr	r1, [r7, #4]
  415ecc:	4803      	ldr	r0, [pc, #12]	; (415edc <configure_sram+0x40>)
  415ece:	4b07      	ldr	r3, [pc, #28]	; (415eec <configure_sram+0x50>)
  415ed0:	4798      	blx	r3
}
  415ed2:	bf00      	nop
  415ed4:	3708      	adds	r7, #8
  415ed6:	46bd      	mov	sp, r7
  415ed8:	bd80      	pop	{r7, pc}
  415eda:	bf00      	nop
  415edc:	40060000 	.word	0x40060000
  415ee0:	004038d5 	.word	0x004038d5
  415ee4:	004038f9 	.word	0x004038f9
  415ee8:	0040391f 	.word	0x0040391f
  415eec:	00403945 	.word	0x00403945

00415ef0 <main>:


/*! \brief Main function. Execution starts here.
 */
int main(void)
{
  415ef0:	b590      	push	{r4, r7, lr}
  415ef2:	b083      	sub	sp, #12
  415ef4:	af02      	add	r7, sp, #8
	irq_initialize_vectors();
	cpu_irq_enable();
  415ef6:	4b5d      	ldr	r3, [pc, #372]	; (41606c <main+0x17c>)
  415ef8:	2201      	movs	r2, #1
  415efa:	701a      	strb	r2, [r3, #0]
  415efc:	f3bf 8f5f 	dmb	sy
  415f00:	b662      	cpsie	i

	// Initialize the sleep manager
	sleepmgr_init();
  415f02:	4b5b      	ldr	r3, [pc, #364]	; (416070 <main+0x180>)
  415f04:	4798      	blx	r3
	sysclk_init();
  415f06:	4b5b      	ldr	r3, [pc, #364]	; (416074 <main+0x184>)
  415f08:	4798      	blx	r3

	board_init();
  415f0a:	4b5b      	ldr	r3, [pc, #364]	; (416078 <main+0x188>)
  415f0c:	4798      	blx	r3
	ui_init();
  415f0e:	4b5b      	ldr	r3, [pc, #364]	; (41607c <main+0x18c>)
  415f10:	4798      	blx	r3
	//ui_powerdown();


	/* Enable PMC clock for SMC */
	pmc_enable_periph_clk(ID_SMC);
  415f12:	2008      	movs	r0, #8
  415f14:	4b5a      	ldr	r3, [pc, #360]	; (416080 <main+0x190>)
  415f16:	4798      	blx	r3
	/* SMC configuration between SRAM and SMC waveforms. */
	configure_sram(SRAM_CHIP_SELECT);		// SRAM1: HEAP			(EBI_CS1 @0x61000000)
  415f18:	2001      	movs	r0, #1
  415f1a:	4b5a      	ldr	r3, [pc, #360]	; (416084 <main+0x194>)
  415f1c:	4798      	blx	r3
	configure_sram(SRAM_CHIP_SELECT_2ND);	// SRAM2: BUFFER ADC	(EBI_CS3 @0x63000000)
  415f1e:	2003      	movs	r0, #3
  415f20:	4b58      	ldr	r3, [pc, #352]	; (416084 <main+0x194>)
  415f22:	4798      	blx	r3

	/* Initialize the console uart */
	configure_console();
  415f24:	4b58      	ldr	r3, [pc, #352]	; (416088 <main+0x198>)
  415f26:	4798      	blx	r3

	// HICS
	printf ("\n\n");
  415f28:	4858      	ldr	r0, [pc, #352]	; (41608c <main+0x19c>)
  415f2a:	4b59      	ldr	r3, [pc, #356]	; (416090 <main+0x1a0>)
  415f2c:	4798      	blx	r3
	printf ("*** CRAAM - Centro de Radio-Astronomia e Astrofisica Mackenzie          ***\n");
  415f2e:	4859      	ldr	r0, [pc, #356]	; (416094 <main+0x1a4>)
  415f30:	4b57      	ldr	r3, [pc, #348]	; (416090 <main+0x1a0>)
  415f32:	4798      	blx	r3
	printf ("*** HATS::HICS - Data Acquisition Module                                ***\n");
  415f34:	4858      	ldr	r0, [pc, #352]	; (416098 <main+0x1a8>)
  415f36:	4b56      	ldr	r3, [pc, #344]	; (416090 <main+0x1a0>)
  415f38:	4798      	blx	r3
	printf ("*** Firmware release 1.00 - 22/June/2020                                ***\n\n");
  415f3a:	4858      	ldr	r0, [pc, #352]	; (41609c <main+0x1ac>)
  415f3c:	4b54      	ldr	r3, [pc, #336]	; (416090 <main+0x1a0>)
  415f3e:	4798      	blx	r3
	
	
	printf("-- %s\r\n", BOARD_NAME);
  415f40:	4957      	ldr	r1, [pc, #348]	; (4160a0 <main+0x1b0>)
  415f42:	4858      	ldr	r0, [pc, #352]	; (4160a4 <main+0x1b4>)
  415f44:	4b52      	ldr	r3, [pc, #328]	; (416090 <main+0x1a0>)
  415f46:	4798      	blx	r3
	printf("-- Compiled: %s %s --\r\n\r\n", __DATE__, __TIME__);
  415f48:	4a57      	ldr	r2, [pc, #348]	; (4160a8 <main+0x1b8>)
  415f4a:	4958      	ldr	r1, [pc, #352]	; (4160ac <main+0x1bc>)
  415f4c:	4858      	ldr	r0, [pc, #352]	; (4160b0 <main+0x1c0>)
  415f4e:	4b50      	ldr	r3, [pc, #320]	; (416090 <main+0x1a0>)
  415f50:	4798      	blx	r3
	// HICS_end

	printf ("\n\nHICS-ErrorCode=0x%04X\n\n", wHICS_errorcode);
  415f52:	4b58      	ldr	r3, [pc, #352]	; (4160b4 <main+0x1c4>)
  415f54:	881b      	ldrh	r3, [r3, #0]
  415f56:	b29b      	uxth	r3, r3
  415f58:	4619      	mov	r1, r3
  415f5a:	4857      	ldr	r0, [pc, #348]	; (4160b8 <main+0x1c8>)
  415f5c:	4b4c      	ldr	r3, [pc, #304]	; (416090 <main+0x1a0>)
  415f5e:	4798      	blx	r3
	
	ctrl_access_init(); // Required with FreeRTOS
  415f60:	4b56      	ldr	r3, [pc, #344]	; (4160bc <main+0x1cc>)
  415f62:	4798      	blx	r3
	//memories_initialization();

	// HICS debug
	printf ("MinimumEverFreeHeapSize = %d\n", xPortGetMinimumEverFreeHeapSize());
  415f64:	4b56      	ldr	r3, [pc, #344]	; (4160c0 <main+0x1d0>)
  415f66:	4798      	blx	r3
  415f68:	4603      	mov	r3, r0
  415f6a:	4619      	mov	r1, r3
  415f6c:	4855      	ldr	r0, [pc, #340]	; (4160c4 <main+0x1d4>)
  415f6e:	4b48      	ldr	r3, [pc, #288]	; (416090 <main+0x1a0>)
  415f70:	4798      	blx	r3
	printf ("FreeHeapSize            = %d\n", xPortGetFreeHeapSize());
  415f72:	4b55      	ldr	r3, [pc, #340]	; (4160c8 <main+0x1d8>)
  415f74:	4798      	blx	r3
  415f76:	4603      	mov	r3, r0
  415f78:	4619      	mov	r1, r3
  415f7a:	4854      	ldr	r0, [pc, #336]	; (4160cc <main+0x1dc>)
  415f7c:	4b44      	ldr	r3, [pc, #272]	; (416090 <main+0x1a0>)
  415f7e:	4798      	blx	r3
	// HICS_end


	// HICS: Check if sprintf is ok
	printf("\nsprintf test:\n");
  415f80:	4853      	ldr	r0, [pc, #332]	; (4160d0 <main+0x1e0>)
  415f82:	4b43      	ldr	r3, [pc, #268]	; (416090 <main+0x1a0>)
  415f84:	4798      	blx	r3
	sprintf(buffer6, "%d", u1); // Utiliza sprintf como workaround
  415f86:	4b53      	ldr	r3, [pc, #332]	; (4160d4 <main+0x1e4>)
  415f88:	681b      	ldr	r3, [r3, #0]
  415f8a:	461a      	mov	r2, r3
  415f8c:	4952      	ldr	r1, [pc, #328]	; (4160d8 <main+0x1e8>)
  415f8e:	4853      	ldr	r0, [pc, #332]	; (4160dc <main+0x1ec>)
  415f90:	4b53      	ldr	r3, [pc, #332]	; (4160e0 <main+0x1f0>)
  415f92:	4798      	blx	r3
	buffer6[49]=0;	// Garante NULL
  415f94:	4b51      	ldr	r3, [pc, #324]	; (4160dc <main+0x1ec>)
  415f96:	2200      	movs	r2, #0
  415f98:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
	printf("u1=%ss\n",buffer6);
  415f9c:	494f      	ldr	r1, [pc, #316]	; (4160dc <main+0x1ec>)
  415f9e:	4851      	ldr	r0, [pc, #324]	; (4160e4 <main+0x1f4>)
  415fa0:	4b3b      	ldr	r3, [pc, #236]	; (416090 <main+0x1a0>)
  415fa2:	4798      	blx	r3
	
	sprintf(buffer6, "%.3f", f1); // Utiliza sprintf como workaround
  415fa4:	4b50      	ldr	r3, [pc, #320]	; (4160e8 <main+0x1f8>)
  415fa6:	681a      	ldr	r2, [r3, #0]
  415fa8:	4b50      	ldr	r3, [pc, #320]	; (4160ec <main+0x1fc>)
  415faa:	4610      	mov	r0, r2
  415fac:	4798      	blx	r3
  415fae:	4603      	mov	r3, r0
  415fb0:	460c      	mov	r4, r1
  415fb2:	461a      	mov	r2, r3
  415fb4:	4623      	mov	r3, r4
  415fb6:	494e      	ldr	r1, [pc, #312]	; (4160f0 <main+0x200>)
  415fb8:	4848      	ldr	r0, [pc, #288]	; (4160dc <main+0x1ec>)
  415fba:	4c49      	ldr	r4, [pc, #292]	; (4160e0 <main+0x1f0>)
  415fbc:	47a0      	blx	r4
	buffer6[49]=0;	// Garante NULL
  415fbe:	4b47      	ldr	r3, [pc, #284]	; (4160dc <main+0x1ec>)
  415fc0:	2200      	movs	r2, #0
  415fc2:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
	printf("f1=%ss\n",buffer6);
  415fc6:	4945      	ldr	r1, [pc, #276]	; (4160dc <main+0x1ec>)
  415fc8:	484a      	ldr	r0, [pc, #296]	; (4160f4 <main+0x204>)
  415fca:	4b31      	ldr	r3, [pc, #196]	; (416090 <main+0x1a0>)
  415fcc:	4798      	blx	r3

	sprintf(buffer6, "%.3f", d1); // Utiliza sprintf como workaround
  415fce:	4b4a      	ldr	r3, [pc, #296]	; (4160f8 <main+0x208>)
  415fd0:	e9d3 3400 	ldrd	r3, r4, [r3]
  415fd4:	461a      	mov	r2, r3
  415fd6:	4623      	mov	r3, r4
  415fd8:	4945      	ldr	r1, [pc, #276]	; (4160f0 <main+0x200>)
  415fda:	4840      	ldr	r0, [pc, #256]	; (4160dc <main+0x1ec>)
  415fdc:	4c40      	ldr	r4, [pc, #256]	; (4160e0 <main+0x1f0>)
  415fde:	47a0      	blx	r4
	buffer6[49]=0;	// Garante NULL
  415fe0:	4b3e      	ldr	r3, [pc, #248]	; (4160dc <main+0x1ec>)
  415fe2:	2200      	movs	r2, #0
  415fe4:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
	printf("d1=%ss\n\n",buffer6);
  415fe8:	493c      	ldr	r1, [pc, #240]	; (4160dc <main+0x1ec>)
  415fea:	4844      	ldr	r0, [pc, #272]	; (4160fc <main+0x20c>)
  415fec:	4b28      	ldr	r3, [pc, #160]	; (416090 <main+0x1a0>)
  415fee:	4798      	blx	r3
	

	// HICS
	printf("Sizeof buffer ADC:\n" ); 
  415ff0:	4843      	ldr	r0, [pc, #268]	; (416100 <main+0x210>)
  415ff2:	4b27      	ldr	r3, [pc, #156]	; (416090 <main+0x1a0>)
  415ff4:	4798      	blx	r3
	printf("	=> Tamanho de um registro : %d bytes\n",sizeof(CHBUF_DATA)); 
  415ff6:	2120      	movs	r1, #32
  415ff8:	4842      	ldr	r0, [pc, #264]	; (416104 <main+0x214>)
  415ffa:	4b25      	ldr	r3, [pc, #148]	; (416090 <main+0x1a0>)
  415ffc:	4798      	blx	r3
	printf("	=> Quantidade de registros: %d\n",ADC_BUFFER_LINES);
  415ffe:	f242 7110 	movw	r1, #10000	; 0x2710
  416002:	4841      	ldr	r0, [pc, #260]	; (416108 <main+0x218>)
  416004:	4b22      	ldr	r3, [pc, #136]	; (416090 <main+0x1a0>)
  416006:	4798      	blx	r3
	printf("	=> Tamanho do Buffer:       %d bytes\n\n",sizeof(chcbuf_data));
  416008:	4940      	ldr	r1, [pc, #256]	; (41610c <main+0x21c>)
  41600a:	4841      	ldr	r0, [pc, #260]	; (416110 <main+0x220>)
  41600c:	4b20      	ldr	r3, [pc, #128]	; (416090 <main+0x1a0>)
  41600e:	4798      	blx	r3

	// HICS: seguindo procedimento contido em gmac.h (ver tbem prvGMACInit())
    pmc_enable_periph_clk(ID_GMAC);
  416010:	202c      	movs	r0, #44	; 0x2c
  416012:	4b1b      	ldr	r3, [pc, #108]	; (416080 <main+0x190>)
  416014:	4798      	blx	r3

	// Antes de criar tasks e sockets, sinaliza que sockets nao estao criados
	vSockets_Init();
  416016:	4b3f      	ldr	r3, [pc, #252]	; (416114 <main+0x224>)
  416018:	4798      	blx	r3
	
	/* Initialise the RTOS's TCP/IP stack.  The tasks that use the network
    are created in the vApplicationIPNetworkEventHook() hook function
    below.  The hook function is called when the network connects. */
    FreeRTOS_IPInit( ucIPAddress,
  41601a:	4b3f      	ldr	r3, [pc, #252]	; (416118 <main+0x228>)
  41601c:	9300      	str	r3, [sp, #0]
  41601e:	4b3f      	ldr	r3, [pc, #252]	; (41611c <main+0x22c>)
  416020:	4a3f      	ldr	r2, [pc, #252]	; (416120 <main+0x230>)
  416022:	4940      	ldr	r1, [pc, #256]	; (416124 <main+0x234>)
  416024:	4840      	ldr	r0, [pc, #256]	; (416128 <main+0x238>)
  416026:	4c41      	ldr	r4, [pc, #260]	; (41612c <main+0x23c>)
  416028:	47a0      	blx	r4
                     ucGatewayAddress,
                     ucDNSServerAddress,
                     ucMACAddress );


	sleepmgr_lock_mode(SLEEPMGR_ACTIVE);	// HICS: Nao pode deixar entrar em sleep
  41602a:	2000      	movs	r0, #0
  41602c:	4b40      	ldr	r3, [pc, #256]	; (416130 <main+0x240>)
  41602e:	4798      	blx	r3
											

	// Main Task (scheduler)
	xTaskCreate(HICS_Task,((const signed portCHAR *)"HICS_Task"),	4096, NULL,configMAX_PRIORITIES-2, NULL);	
  416030:	2300      	movs	r3, #0
  416032:	9301      	str	r3, [sp, #4]
  416034:	2302      	movs	r3, #2
  416036:	9300      	str	r3, [sp, #0]
  416038:	2300      	movs	r3, #0
  41603a:	f44f 5280 	mov.w	r2, #4096	; 0x1000
  41603e:	493d      	ldr	r1, [pc, #244]	; (416134 <main+0x244>)
  416040:	483d      	ldr	r0, [pc, #244]	; (416138 <main+0x248>)
  416042:	4c3e      	ldr	r4, [pc, #248]	; (41613c <main+0x24c>)
  416044:	47a0      	blx	r4
	xTaskCreate(SNTP_Task,((const signed portCHAR *)"SNTP-TASK"),	1024, NULL, configMAX_PRIORITIES-2, NULL);	
  416046:	2300      	movs	r3, #0
  416048:	9301      	str	r3, [sp, #4]
  41604a:	2302      	movs	r3, #2
  41604c:	9300      	str	r3, [sp, #0]
  41604e:	2300      	movs	r3, #0
  416050:	f44f 6280 	mov.w	r2, #1024	; 0x400
  416054:	493a      	ldr	r1, [pc, #232]	; (416140 <main+0x250>)
  416056:	483b      	ldr	r0, [pc, #236]	; (416144 <main+0x254>)
  416058:	4c38      	ldr	r4, [pc, #224]	; (41613c <main+0x24c>)
  41605a:	47a0      	blx	r4

	// Start OS scheduler
	vTaskStartScheduler();
  41605c:	4b3a      	ldr	r3, [pc, #232]	; (416148 <main+0x258>)
  41605e:	4798      	blx	r3
	
	return 0;
  416060:	2300      	movs	r3, #0
}
  416062:	4618      	mov	r0, r3
  416064:	3704      	adds	r7, #4
  416066:	46bd      	mov	sp, r7
  416068:	bd90      	pop	{r4, r7, pc}
  41606a:	bf00      	nop
  41606c:	200000c2 	.word	0x200000c2
  416070:	00415ab9 	.word	0x00415ab9
  416074:	00400ba9 	.word	0x00400ba9
  416078:	00402e11 	.word	0x00402e11
  41607c:	0040073d 	.word	0x0040073d
  416080:	0040433d 	.word	0x0040433d
  416084:	00415e9d 	.word	0x00415e9d
  416088:	00415de5 	.word	0x00415de5
  41608c:	0041e6f0 	.word	0x0041e6f0
  416090:	00416c7d 	.word	0x00416c7d
  416094:	0041e6f4 	.word	0x0041e6f4
  416098:	0041e744 	.word	0x0041e744
  41609c:	0041e794 	.word	0x0041e794
  4160a0:	0041e7e4 	.word	0x0041e7e4
  4160a4:	0041e7f0 	.word	0x0041e7f0
  4160a8:	0041e7f8 	.word	0x0041e7f8
  4160ac:	0041e804 	.word	0x0041e804
  4160b0:	0041e810 	.word	0x0041e810
  4160b4:	2000b534 	.word	0x2000b534
  4160b8:	0041e82c 	.word	0x0041e82c
  4160bc:	00400c19 	.word	0x00400c19
  4160c0:	004114b9 	.word	0x004114b9
  4160c4:	0041e848 	.word	0x0041e848
  4160c8:	004114a1 	.word	0x004114a1
  4160cc:	0041e868 	.word	0x0041e868
  4160d0:	0041e888 	.word	0x0041e888
  4160d4:	20000168 	.word	0x20000168
  4160d8:	0041e898 	.word	0x0041e898
  4160dc:	2000bcc0 	.word	0x2000bcc0
  4160e0:	004171d5 	.word	0x004171d5
  4160e4:	0041e89c 	.word	0x0041e89c
  4160e8:	2000016c 	.word	0x2000016c
  4160ec:	00416611 	.word	0x00416611
  4160f0:	0041e8a4 	.word	0x0041e8a4
  4160f4:	0041e8ac 	.word	0x0041e8ac
  4160f8:	20000170 	.word	0x20000170
  4160fc:	0041e8b4 	.word	0x0041e8b4
  416100:	0041e8c0 	.word	0x0041e8c0
  416104:	0041e8d4 	.word	0x0041e8d4
  416108:	0041e8fc 	.word	0x0041e8fc
  41610c:	0004e200 	.word	0x0004e200
  416110:	0041e920 	.word	0x0041e920
  416114:	0041549d 	.word	0x0041549d
  416118:	0041e6d8 	.word	0x0041e6d8
  41611c:	0041e6ec 	.word	0x0041e6ec
  416120:	0041e6e8 	.word	0x0041e6e8
  416124:	0041e6e4 	.word	0x0041e6e4
  416128:	0041e6e0 	.word	0x0041e6e0
  41612c:	00407ba5 	.word	0x00407ba5
  416130:	00415af1 	.word	0x00415af1
  416134:	0041e948 	.word	0x0041e948
  416138:	00414d61 	.word	0x00414d61
  41613c:	004122f9 	.word	0x004122f9
  416140:	0041e954 	.word	0x0041e954
  416144:	00415151 	.word	0x00415151
  416148:	004125e5 	.word	0x004125e5

0041614c <vApplicationIPNetworkEventHook>:

/* Called by FreeRTOS+TCP when the network connects or disconnects.  Disconnect
events are only received if implemented in the MAC driver. */
void vApplicationIPNetworkEventHook( eIPCallbackEvent_t eNetworkEvent )
{
  41614c:	b590      	push	{r4, r7, lr}
  41614e:	b08d      	sub	sp, #52	; 0x34
  416150:	af02      	add	r7, sp, #8
  416152:	4603      	mov	r3, r0
  416154:	71fb      	strb	r3, [r7, #7]
uint32_t ulIPAddress, ulNetMask, ulGatewayAddress, ulDNSServerAddress;
char cBuffer[ 16 ];
static BaseType_t xTasksAlreadyCreated = pdFALSE;

	/* If the network has just come up...*/
	if( eNetworkEvent == eNetworkUp )
  416156:	79fb      	ldrb	r3, [r7, #7]
  416158:	2b00      	cmp	r3, #0
  41615a:	d17a      	bne.n	416252 <vApplicationIPNetworkEventHook+0x106>
	{
		/* Print out the network configuration, which may have come from a DHCP
		server. */
		FreeRTOS_GetAddressConfiguration( &ulIPAddress, &ulNetMask, &ulGatewayAddress, &ulDNSServerAddress );
  41615c:	f107 0318 	add.w	r3, r7, #24
  416160:	f107 021c 	add.w	r2, r7, #28
  416164:	f107 0120 	add.w	r1, r7, #32
  416168:	f107 0024 	add.w	r0, r7, #36	; 0x24
  41616c:	4c3b      	ldr	r4, [pc, #236]	; (41625c <vApplicationIPNetworkEventHook+0x110>)
  41616e:	47a0      	blx	r4
		FreeRTOS_inet_ntoa( ulIPAddress, cBuffer );
  416170:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  416172:	b2d9      	uxtb	r1, r3
  416174:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  416176:	0a1b      	lsrs	r3, r3, #8
  416178:	b2dc      	uxtb	r4, r3
  41617a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  41617c:	0c1b      	lsrs	r3, r3, #16
  41617e:	b2db      	uxtb	r3, r3
  416180:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  416182:	0e12      	lsrs	r2, r2, #24
  416184:	f107 0008 	add.w	r0, r7, #8
  416188:	9201      	str	r2, [sp, #4]
  41618a:	9300      	str	r3, [sp, #0]
  41618c:	4623      	mov	r3, r4
  41618e:	460a      	mov	r2, r1
  416190:	4933      	ldr	r1, [pc, #204]	; (416260 <vApplicationIPNetworkEventHook+0x114>)
  416192:	4c34      	ldr	r4, [pc, #208]	; (416264 <vApplicationIPNetworkEventHook+0x118>)
  416194:	47a0      	blx	r4
		FreeRTOS_printf( ( "\r\n\r\nIP Address: %s\r\n", cBuffer ) );
  416196:	f107 0308 	add.w	r3, r7, #8
  41619a:	4619      	mov	r1, r3
  41619c:	4832      	ldr	r0, [pc, #200]	; (416268 <vApplicationIPNetworkEventHook+0x11c>)
  41619e:	4b33      	ldr	r3, [pc, #204]	; (41626c <vApplicationIPNetworkEventHook+0x120>)
  4161a0:	4798      	blx	r3

		FreeRTOS_inet_ntoa( ulNetMask, cBuffer );
  4161a2:	6a3b      	ldr	r3, [r7, #32]
  4161a4:	b2d9      	uxtb	r1, r3
  4161a6:	6a3b      	ldr	r3, [r7, #32]
  4161a8:	0a1b      	lsrs	r3, r3, #8
  4161aa:	b2dc      	uxtb	r4, r3
  4161ac:	6a3b      	ldr	r3, [r7, #32]
  4161ae:	0c1b      	lsrs	r3, r3, #16
  4161b0:	b2db      	uxtb	r3, r3
  4161b2:	6a3a      	ldr	r2, [r7, #32]
  4161b4:	0e12      	lsrs	r2, r2, #24
  4161b6:	f107 0008 	add.w	r0, r7, #8
  4161ba:	9201      	str	r2, [sp, #4]
  4161bc:	9300      	str	r3, [sp, #0]
  4161be:	4623      	mov	r3, r4
  4161c0:	460a      	mov	r2, r1
  4161c2:	4927      	ldr	r1, [pc, #156]	; (416260 <vApplicationIPNetworkEventHook+0x114>)
  4161c4:	4c27      	ldr	r4, [pc, #156]	; (416264 <vApplicationIPNetworkEventHook+0x118>)
  4161c6:	47a0      	blx	r4
		FreeRTOS_printf( ( "Subnet Mask: %s\r\n", cBuffer ) );
  4161c8:	f107 0308 	add.w	r3, r7, #8
  4161cc:	4619      	mov	r1, r3
  4161ce:	4828      	ldr	r0, [pc, #160]	; (416270 <vApplicationIPNetworkEventHook+0x124>)
  4161d0:	4b26      	ldr	r3, [pc, #152]	; (41626c <vApplicationIPNetworkEventHook+0x120>)
  4161d2:	4798      	blx	r3

		FreeRTOS_inet_ntoa( ulGatewayAddress, cBuffer );
  4161d4:	69fb      	ldr	r3, [r7, #28]
  4161d6:	b2d9      	uxtb	r1, r3
  4161d8:	69fb      	ldr	r3, [r7, #28]
  4161da:	0a1b      	lsrs	r3, r3, #8
  4161dc:	b2dc      	uxtb	r4, r3
  4161de:	69fb      	ldr	r3, [r7, #28]
  4161e0:	0c1b      	lsrs	r3, r3, #16
  4161e2:	b2db      	uxtb	r3, r3
  4161e4:	69fa      	ldr	r2, [r7, #28]
  4161e6:	0e12      	lsrs	r2, r2, #24
  4161e8:	f107 0008 	add.w	r0, r7, #8
  4161ec:	9201      	str	r2, [sp, #4]
  4161ee:	9300      	str	r3, [sp, #0]
  4161f0:	4623      	mov	r3, r4
  4161f2:	460a      	mov	r2, r1
  4161f4:	491a      	ldr	r1, [pc, #104]	; (416260 <vApplicationIPNetworkEventHook+0x114>)
  4161f6:	4c1b      	ldr	r4, [pc, #108]	; (416264 <vApplicationIPNetworkEventHook+0x118>)
  4161f8:	47a0      	blx	r4
		FreeRTOS_printf( ( "Gateway Address: %s\r\n", cBuffer ) );
  4161fa:	f107 0308 	add.w	r3, r7, #8
  4161fe:	4619      	mov	r1, r3
  416200:	481c      	ldr	r0, [pc, #112]	; (416274 <vApplicationIPNetworkEventHook+0x128>)
  416202:	4b1a      	ldr	r3, [pc, #104]	; (41626c <vApplicationIPNetworkEventHook+0x120>)
  416204:	4798      	blx	r3

		FreeRTOS_inet_ntoa( ulDNSServerAddress, cBuffer );
  416206:	69bb      	ldr	r3, [r7, #24]
  416208:	b2d9      	uxtb	r1, r3
  41620a:	69bb      	ldr	r3, [r7, #24]
  41620c:	0a1b      	lsrs	r3, r3, #8
  41620e:	b2dc      	uxtb	r4, r3
  416210:	69bb      	ldr	r3, [r7, #24]
  416212:	0c1b      	lsrs	r3, r3, #16
  416214:	b2db      	uxtb	r3, r3
  416216:	69ba      	ldr	r2, [r7, #24]
  416218:	0e12      	lsrs	r2, r2, #24
  41621a:	f107 0008 	add.w	r0, r7, #8
  41621e:	9201      	str	r2, [sp, #4]
  416220:	9300      	str	r3, [sp, #0]
  416222:	4623      	mov	r3, r4
  416224:	460a      	mov	r2, r1
  416226:	490e      	ldr	r1, [pc, #56]	; (416260 <vApplicationIPNetworkEventHook+0x114>)
  416228:	4c0e      	ldr	r4, [pc, #56]	; (416264 <vApplicationIPNetworkEventHook+0x118>)
  41622a:	47a0      	blx	r4
		FreeRTOS_printf( ( "DNS Server Address: %s\r\n\r\n", cBuffer ) );
  41622c:	f107 0308 	add.w	r3, r7, #8
  416230:	4619      	mov	r1, r3
  416232:	4811      	ldr	r0, [pc, #68]	; (416278 <vApplicationIPNetworkEventHook+0x12c>)
  416234:	4b0d      	ldr	r3, [pc, #52]	; (41626c <vApplicationIPNetworkEventHook+0x120>)
  416236:	4798      	blx	r3
	
		
		/* Create the tasks that use the IP stack if they have not already been
		created. */
		if( xTasksAlreadyCreated == pdFALSE )
  416238:	4b10      	ldr	r3, [pc, #64]	; (41627c <vApplicationIPNetworkEventHook+0x130>)
  41623a:	681b      	ldr	r3, [r3, #0]
  41623c:	2b00      	cmp	r3, #0
  41623e:	d108      	bne.n	416252 <vApplicationIPNetworkEventHook+0x106>

			// HICS: Sinaliza que sockets ja podem ser criados
			// From: https://www.freertos.org/FreeRTOS_Support_Forum_Archive/April_2018/freertos_Need_help_with_example_project_Using_the_FreeRTOS_Windows_Port_ed0a9982j.html
			//		=> vApplicationIPNetworkEventHook() is being called from the IP-task, and it is not allowed to call FreeRTOS_bind() from within the IP-task.
			//		=> The best solution is to keep vApplicationIPNetworkEventHook() very short, just set a variable:
			 stSocket_ADC.can_create  = pdTRUE;
  416240:	4b0f      	ldr	r3, [pc, #60]	; (416280 <vApplicationIPNetworkEventHook+0x134>)
  416242:	2201      	movs	r2, #1
  416244:	731a      	strb	r2, [r3, #12]
 			 stSocket_SNTP.can_create = pdTRUE;
  416246:	4b0f      	ldr	r3, [pc, #60]	; (416284 <vApplicationIPNetworkEventHook+0x138>)
  416248:	2201      	movs	r2, #1
  41624a:	731a      	strb	r2, [r3, #12]
			// HICS_end

			xTasksAlreadyCreated = pdTRUE;
  41624c:	4b0b      	ldr	r3, [pc, #44]	; (41627c <vApplicationIPNetworkEventHook+0x130>)
  41624e:	2201      	movs	r2, #1
  416250:	601a      	str	r2, [r3, #0]
		}
	}
}
  416252:	bf00      	nop
  416254:	372c      	adds	r7, #44	; 0x2c
  416256:	46bd      	mov	sp, r7
  416258:	bd90      	pop	{r4, r7, pc}
  41625a:	bf00      	nop
  41625c:	00407dbd 	.word	0x00407dbd
  416260:	0041e960 	.word	0x0041e960
  416264:	004171d5 	.word	0x004171d5
  416268:	0041e96c 	.word	0x0041e96c
  41626c:	00416c7d 	.word	0x00416c7d
  416270:	0041e984 	.word	0x0041e984
  416274:	0041e998 	.word	0x0041e998
  416278:	0041e9b0 	.word	0x0041e9b0
  41627c:	2000b544 	.word	0x2000b544
  416280:	2000bcb0 	.word	0x2000bcb0
  416284:	2000bca0 	.word	0x2000bca0

00416288 <vApplicationIdleHook>:

void vApplicationIdleHook( void );
void vApplicationIdleHook( void )
{
  416288:	b480      	push	{r7}
  41628a:	af00      	add	r7, sp, #0
	// Management of sleep mode in Idle Hook from FreeRTOS
	// HICS removed: sleepmgr_enter_sleep();
	// https://www.freertos.org/a00016.html?_ga=2.97969567.1806821866.1583097460-1965068279.1581949294
	
}
  41628c:	bf00      	nop
  41628e:	46bd      	mov	sp, r7
  416290:	f85d 7b04 	ldr.w	r7, [sp], #4
  416294:	4770      	bx	lr
	...

00416298 <main_msc_notify_trans>:
		}
	}
}

void main_msc_notify_trans(void)
{
  416298:	b580      	push	{r7, lr}
  41629a:	af00      	add	r7, sp, #0
	static signed portBASE_TYPE xHigherPriorityTaskWoken;
	xHigherPriorityTaskWoken = pdFALSE;
  41629c:	4b05      	ldr	r3, [pc, #20]	; (4162b4 <main_msc_notify_trans+0x1c>)
  41629e:	2200      	movs	r2, #0
  4162a0:	601a      	str	r2, [r3, #0]
	// One transfer is requested 
	// It is now time for main_memories_trans_task() to run
	xSemaphoreGiveFromISR( main_trans_semphr, &xHigherPriorityTaskWoken );
  4162a2:	4b05      	ldr	r3, [pc, #20]	; (4162b8 <main_msc_notify_trans+0x20>)
  4162a4:	681b      	ldr	r3, [r3, #0]
  4162a6:	4903      	ldr	r1, [pc, #12]	; (4162b4 <main_msc_notify_trans+0x1c>)
  4162a8:	4618      	mov	r0, r3
  4162aa:	4b04      	ldr	r3, [pc, #16]	; (4162bc <main_msc_notify_trans+0x24>)
  4162ac:	4798      	blx	r3
}
  4162ae:	bf00      	nop
  4162b0:	bd80      	pop	{r7, pc}
  4162b2:	bf00      	nop
  4162b4:	2000b548 	.word	0x2000b548
  4162b8:	2000b53c 	.word	0x2000b53c
  4162bc:	00411b11 	.word	0x00411b11

004162c0 <main_suspend_action>:

void main_suspend_action(void)
{
  4162c0:	b580      	push	{r7, lr}
  4162c2:	af00      	add	r7, sp, #0
	ui_powerdown();
  4162c4:	4b01      	ldr	r3, [pc, #4]	; (4162cc <main_suspend_action+0xc>)
  4162c6:	4798      	blx	r3
}
  4162c8:	bf00      	nop
  4162ca:	bd80      	pop	{r7, pc}
  4162cc:	00400751 	.word	0x00400751

004162d0 <main_resume_action>:

void main_resume_action(void)
{
  4162d0:	b580      	push	{r7, lr}
  4162d2:	af00      	add	r7, sp, #0
	ui_wakeup();
  4162d4:	4b01      	ldr	r3, [pc, #4]	; (4162dc <main_resume_action+0xc>)
  4162d6:	4798      	blx	r3
}
  4162d8:	bf00      	nop
  4162da:	bd80      	pop	{r7, pc}
  4162dc:	0040075f 	.word	0x0040075f

004162e0 <main_sof_action>:

void main_sof_action(void)
{
  4162e0:	b580      	push	{r7, lr}
  4162e2:	af00      	add	r7, sp, #0
	if (!main_b_msc_enable)
  4162e4:	4b08      	ldr	r3, [pc, #32]	; (416308 <main_sof_action+0x28>)
  4162e6:	781b      	ldrb	r3, [r3, #0]
  4162e8:	b2db      	uxtb	r3, r3
  4162ea:	f083 0301 	eor.w	r3, r3, #1
  4162ee:	b2db      	uxtb	r3, r3
  4162f0:	2b00      	cmp	r3, #0
  4162f2:	d106      	bne.n	416302 <main_sof_action+0x22>
		return;
	ui_process(udd_get_frame_number());
  4162f4:	4b05      	ldr	r3, [pc, #20]	; (41630c <main_sof_action+0x2c>)
  4162f6:	4798      	blx	r3
  4162f8:	4603      	mov	r3, r0
  4162fa:	4618      	mov	r0, r3
  4162fc:	4b04      	ldr	r3, [pc, #16]	; (416310 <main_sof_action+0x30>)
  4162fe:	4798      	blx	r3
  416300:	e000      	b.n	416304 <main_sof_action+0x24>
		return;
  416302:	bf00      	nop
}
  416304:	bd80      	pop	{r7, pc}
  416306:	bf00      	nop
  416308:	2000b538 	.word	0x2000b538
  41630c:	00404c39 	.word	0x00404c39
  416310:	0040076d 	.word	0x0040076d

00416314 <main_msc_enable>:

bool main_msc_enable(void)
{
  416314:	b480      	push	{r7}
  416316:	af00      	add	r7, sp, #0
	main_b_msc_enable = true;
  416318:	4b04      	ldr	r3, [pc, #16]	; (41632c <main_msc_enable+0x18>)
  41631a:	2201      	movs	r2, #1
  41631c:	701a      	strb	r2, [r3, #0]
	return true;
  41631e:	2301      	movs	r3, #1
}
  416320:	4618      	mov	r0, r3
  416322:	46bd      	mov	sp, r7
  416324:	f85d 7b04 	ldr.w	r7, [sp], #4
  416328:	4770      	bx	lr
  41632a:	bf00      	nop
  41632c:	2000b538 	.word	0x2000b538

00416330 <main_msc_disable>:

void main_msc_disable(void)
{
  416330:	b480      	push	{r7}
  416332:	af00      	add	r7, sp, #0
	main_b_msc_enable = false;
  416334:	4b03      	ldr	r3, [pc, #12]	; (416344 <main_msc_disable+0x14>)
  416336:	2200      	movs	r2, #0
  416338:	701a      	strb	r2, [r3, #0]
}
  41633a:	bf00      	nop
  41633c:	46bd      	mov	sp, r7
  41633e:	f85d 7b04 	ldr.w	r7, [sp], #4
  416342:	4770      	bx	lr
  416344:	2000b538 	.word	0x2000b538

00416348 <__aeabi_drsub>:
  416348:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
  41634c:	e002      	b.n	416354 <__adddf3>
  41634e:	bf00      	nop

00416350 <__aeabi_dsub>:
  416350:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

00416354 <__adddf3>:
  416354:	b530      	push	{r4, r5, lr}
  416356:	ea4f 0441 	mov.w	r4, r1, lsl #1
  41635a:	ea4f 0543 	mov.w	r5, r3, lsl #1
  41635e:	ea94 0f05 	teq	r4, r5
  416362:	bf08      	it	eq
  416364:	ea90 0f02 	teqeq	r0, r2
  416368:	bf1f      	itttt	ne
  41636a:	ea54 0c00 	orrsne.w	ip, r4, r0
  41636e:	ea55 0c02 	orrsne.w	ip, r5, r2
  416372:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
  416376:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
  41637a:	f000 80e2 	beq.w	416542 <__adddf3+0x1ee>
  41637e:	ea4f 5454 	mov.w	r4, r4, lsr #21
  416382:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
  416386:	bfb8      	it	lt
  416388:	426d      	neglt	r5, r5
  41638a:	dd0c      	ble.n	4163a6 <__adddf3+0x52>
  41638c:	442c      	add	r4, r5
  41638e:	ea80 0202 	eor.w	r2, r0, r2
  416392:	ea81 0303 	eor.w	r3, r1, r3
  416396:	ea82 0000 	eor.w	r0, r2, r0
  41639a:	ea83 0101 	eor.w	r1, r3, r1
  41639e:	ea80 0202 	eor.w	r2, r0, r2
  4163a2:	ea81 0303 	eor.w	r3, r1, r3
  4163a6:	2d36      	cmp	r5, #54	; 0x36
  4163a8:	bf88      	it	hi
  4163aa:	bd30      	pophi	{r4, r5, pc}
  4163ac:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
  4163b0:	ea4f 3101 	mov.w	r1, r1, lsl #12
  4163b4:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
  4163b8:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
  4163bc:	d002      	beq.n	4163c4 <__adddf3+0x70>
  4163be:	4240      	negs	r0, r0
  4163c0:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  4163c4:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
  4163c8:	ea4f 3303 	mov.w	r3, r3, lsl #12
  4163cc:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
  4163d0:	d002      	beq.n	4163d8 <__adddf3+0x84>
  4163d2:	4252      	negs	r2, r2
  4163d4:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
  4163d8:	ea94 0f05 	teq	r4, r5
  4163dc:	f000 80a7 	beq.w	41652e <__adddf3+0x1da>
  4163e0:	f1a4 0401 	sub.w	r4, r4, #1
  4163e4:	f1d5 0e20 	rsbs	lr, r5, #32
  4163e8:	db0d      	blt.n	416406 <__adddf3+0xb2>
  4163ea:	fa02 fc0e 	lsl.w	ip, r2, lr
  4163ee:	fa22 f205 	lsr.w	r2, r2, r5
  4163f2:	1880      	adds	r0, r0, r2
  4163f4:	f141 0100 	adc.w	r1, r1, #0
  4163f8:	fa03 f20e 	lsl.w	r2, r3, lr
  4163fc:	1880      	adds	r0, r0, r2
  4163fe:	fa43 f305 	asr.w	r3, r3, r5
  416402:	4159      	adcs	r1, r3
  416404:	e00e      	b.n	416424 <__adddf3+0xd0>
  416406:	f1a5 0520 	sub.w	r5, r5, #32
  41640a:	f10e 0e20 	add.w	lr, lr, #32
  41640e:	2a01      	cmp	r2, #1
  416410:	fa03 fc0e 	lsl.w	ip, r3, lr
  416414:	bf28      	it	cs
  416416:	f04c 0c02 	orrcs.w	ip, ip, #2
  41641a:	fa43 f305 	asr.w	r3, r3, r5
  41641e:	18c0      	adds	r0, r0, r3
  416420:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
  416424:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  416428:	d507      	bpl.n	41643a <__adddf3+0xe6>
  41642a:	f04f 0e00 	mov.w	lr, #0
  41642e:	f1dc 0c00 	rsbs	ip, ip, #0
  416432:	eb7e 0000 	sbcs.w	r0, lr, r0
  416436:	eb6e 0101 	sbc.w	r1, lr, r1
  41643a:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
  41643e:	d31b      	bcc.n	416478 <__adddf3+0x124>
  416440:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
  416444:	d30c      	bcc.n	416460 <__adddf3+0x10c>
  416446:	0849      	lsrs	r1, r1, #1
  416448:	ea5f 0030 	movs.w	r0, r0, rrx
  41644c:	ea4f 0c3c 	mov.w	ip, ip, rrx
  416450:	f104 0401 	add.w	r4, r4, #1
  416454:	ea4f 5244 	mov.w	r2, r4, lsl #21
  416458:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
  41645c:	f080 809a 	bcs.w	416594 <__adddf3+0x240>
  416460:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
  416464:	bf08      	it	eq
  416466:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
  41646a:	f150 0000 	adcs.w	r0, r0, #0
  41646e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
  416472:	ea41 0105 	orr.w	r1, r1, r5
  416476:	bd30      	pop	{r4, r5, pc}
  416478:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
  41647c:	4140      	adcs	r0, r0
  41647e:	eb41 0101 	adc.w	r1, r1, r1
  416482:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  416486:	f1a4 0401 	sub.w	r4, r4, #1
  41648a:	d1e9      	bne.n	416460 <__adddf3+0x10c>
  41648c:	f091 0f00 	teq	r1, #0
  416490:	bf04      	itt	eq
  416492:	4601      	moveq	r1, r0
  416494:	2000      	moveq	r0, #0
  416496:	fab1 f381 	clz	r3, r1
  41649a:	bf08      	it	eq
  41649c:	3320      	addeq	r3, #32
  41649e:	f1a3 030b 	sub.w	r3, r3, #11
  4164a2:	f1b3 0220 	subs.w	r2, r3, #32
  4164a6:	da0c      	bge.n	4164c2 <__adddf3+0x16e>
  4164a8:	320c      	adds	r2, #12
  4164aa:	dd08      	ble.n	4164be <__adddf3+0x16a>
  4164ac:	f102 0c14 	add.w	ip, r2, #20
  4164b0:	f1c2 020c 	rsb	r2, r2, #12
  4164b4:	fa01 f00c 	lsl.w	r0, r1, ip
  4164b8:	fa21 f102 	lsr.w	r1, r1, r2
  4164bc:	e00c      	b.n	4164d8 <__adddf3+0x184>
  4164be:	f102 0214 	add.w	r2, r2, #20
  4164c2:	bfd8      	it	le
  4164c4:	f1c2 0c20 	rsble	ip, r2, #32
  4164c8:	fa01 f102 	lsl.w	r1, r1, r2
  4164cc:	fa20 fc0c 	lsr.w	ip, r0, ip
  4164d0:	bfdc      	itt	le
  4164d2:	ea41 010c 	orrle.w	r1, r1, ip
  4164d6:	4090      	lslle	r0, r2
  4164d8:	1ae4      	subs	r4, r4, r3
  4164da:	bfa2      	ittt	ge
  4164dc:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
  4164e0:	4329      	orrge	r1, r5
  4164e2:	bd30      	popge	{r4, r5, pc}
  4164e4:	ea6f 0404 	mvn.w	r4, r4
  4164e8:	3c1f      	subs	r4, #31
  4164ea:	da1c      	bge.n	416526 <__adddf3+0x1d2>
  4164ec:	340c      	adds	r4, #12
  4164ee:	dc0e      	bgt.n	41650e <__adddf3+0x1ba>
  4164f0:	f104 0414 	add.w	r4, r4, #20
  4164f4:	f1c4 0220 	rsb	r2, r4, #32
  4164f8:	fa20 f004 	lsr.w	r0, r0, r4
  4164fc:	fa01 f302 	lsl.w	r3, r1, r2
  416500:	ea40 0003 	orr.w	r0, r0, r3
  416504:	fa21 f304 	lsr.w	r3, r1, r4
  416508:	ea45 0103 	orr.w	r1, r5, r3
  41650c:	bd30      	pop	{r4, r5, pc}
  41650e:	f1c4 040c 	rsb	r4, r4, #12
  416512:	f1c4 0220 	rsb	r2, r4, #32
  416516:	fa20 f002 	lsr.w	r0, r0, r2
  41651a:	fa01 f304 	lsl.w	r3, r1, r4
  41651e:	ea40 0003 	orr.w	r0, r0, r3
  416522:	4629      	mov	r1, r5
  416524:	bd30      	pop	{r4, r5, pc}
  416526:	fa21 f004 	lsr.w	r0, r1, r4
  41652a:	4629      	mov	r1, r5
  41652c:	bd30      	pop	{r4, r5, pc}
  41652e:	f094 0f00 	teq	r4, #0
  416532:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
  416536:	bf06      	itte	eq
  416538:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
  41653c:	3401      	addeq	r4, #1
  41653e:	3d01      	subne	r5, #1
  416540:	e74e      	b.n	4163e0 <__adddf3+0x8c>
  416542:	ea7f 5c64 	mvns.w	ip, r4, asr #21
  416546:	bf18      	it	ne
  416548:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
  41654c:	d029      	beq.n	4165a2 <__adddf3+0x24e>
  41654e:	ea94 0f05 	teq	r4, r5
  416552:	bf08      	it	eq
  416554:	ea90 0f02 	teqeq	r0, r2
  416558:	d005      	beq.n	416566 <__adddf3+0x212>
  41655a:	ea54 0c00 	orrs.w	ip, r4, r0
  41655e:	bf04      	itt	eq
  416560:	4619      	moveq	r1, r3
  416562:	4610      	moveq	r0, r2
  416564:	bd30      	pop	{r4, r5, pc}
  416566:	ea91 0f03 	teq	r1, r3
  41656a:	bf1e      	ittt	ne
  41656c:	2100      	movne	r1, #0
  41656e:	2000      	movne	r0, #0
  416570:	bd30      	popne	{r4, r5, pc}
  416572:	ea5f 5c54 	movs.w	ip, r4, lsr #21
  416576:	d105      	bne.n	416584 <__adddf3+0x230>
  416578:	0040      	lsls	r0, r0, #1
  41657a:	4149      	adcs	r1, r1
  41657c:	bf28      	it	cs
  41657e:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
  416582:	bd30      	pop	{r4, r5, pc}
  416584:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
  416588:	bf3c      	itt	cc
  41658a:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
  41658e:	bd30      	popcc	{r4, r5, pc}
  416590:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  416594:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
  416598:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
  41659c:	f04f 0000 	mov.w	r0, #0
  4165a0:	bd30      	pop	{r4, r5, pc}
  4165a2:	ea7f 5c64 	mvns.w	ip, r4, asr #21
  4165a6:	bf1a      	itte	ne
  4165a8:	4619      	movne	r1, r3
  4165aa:	4610      	movne	r0, r2
  4165ac:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
  4165b0:	bf1c      	itt	ne
  4165b2:	460b      	movne	r3, r1
  4165b4:	4602      	movne	r2, r0
  4165b6:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
  4165ba:	bf06      	itte	eq
  4165bc:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
  4165c0:	ea91 0f03 	teqeq	r1, r3
  4165c4:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
  4165c8:	bd30      	pop	{r4, r5, pc}
  4165ca:	bf00      	nop

004165cc <__aeabi_ui2d>:
  4165cc:	f090 0f00 	teq	r0, #0
  4165d0:	bf04      	itt	eq
  4165d2:	2100      	moveq	r1, #0
  4165d4:	4770      	bxeq	lr
  4165d6:	b530      	push	{r4, r5, lr}
  4165d8:	f44f 6480 	mov.w	r4, #1024	; 0x400
  4165dc:	f104 0432 	add.w	r4, r4, #50	; 0x32
  4165e0:	f04f 0500 	mov.w	r5, #0
  4165e4:	f04f 0100 	mov.w	r1, #0
  4165e8:	e750      	b.n	41648c <__adddf3+0x138>
  4165ea:	bf00      	nop

004165ec <__aeabi_i2d>:
  4165ec:	f090 0f00 	teq	r0, #0
  4165f0:	bf04      	itt	eq
  4165f2:	2100      	moveq	r1, #0
  4165f4:	4770      	bxeq	lr
  4165f6:	b530      	push	{r4, r5, lr}
  4165f8:	f44f 6480 	mov.w	r4, #1024	; 0x400
  4165fc:	f104 0432 	add.w	r4, r4, #50	; 0x32
  416600:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
  416604:	bf48      	it	mi
  416606:	4240      	negmi	r0, r0
  416608:	f04f 0100 	mov.w	r1, #0
  41660c:	e73e      	b.n	41648c <__adddf3+0x138>
  41660e:	bf00      	nop

00416610 <__aeabi_f2d>:
  416610:	0042      	lsls	r2, r0, #1
  416612:	ea4f 01e2 	mov.w	r1, r2, asr #3
  416616:	ea4f 0131 	mov.w	r1, r1, rrx
  41661a:	ea4f 7002 	mov.w	r0, r2, lsl #28
  41661e:	bf1f      	itttt	ne
  416620:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
  416624:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
  416628:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
  41662c:	4770      	bxne	lr
  41662e:	f092 0f00 	teq	r2, #0
  416632:	bf14      	ite	ne
  416634:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
  416638:	4770      	bxeq	lr
  41663a:	b530      	push	{r4, r5, lr}
  41663c:	f44f 7460 	mov.w	r4, #896	; 0x380
  416640:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  416644:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
  416648:	e720      	b.n	41648c <__adddf3+0x138>
  41664a:	bf00      	nop

0041664c <__aeabi_ul2d>:
  41664c:	ea50 0201 	orrs.w	r2, r0, r1
  416650:	bf08      	it	eq
  416652:	4770      	bxeq	lr
  416654:	b530      	push	{r4, r5, lr}
  416656:	f04f 0500 	mov.w	r5, #0
  41665a:	e00a      	b.n	416672 <__aeabi_l2d+0x16>

0041665c <__aeabi_l2d>:
  41665c:	ea50 0201 	orrs.w	r2, r0, r1
  416660:	bf08      	it	eq
  416662:	4770      	bxeq	lr
  416664:	b530      	push	{r4, r5, lr}
  416666:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
  41666a:	d502      	bpl.n	416672 <__aeabi_l2d+0x16>
  41666c:	4240      	negs	r0, r0
  41666e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  416672:	f44f 6480 	mov.w	r4, #1024	; 0x400
  416676:	f104 0432 	add.w	r4, r4, #50	; 0x32
  41667a:	ea5f 5c91 	movs.w	ip, r1, lsr #22
  41667e:	f43f aedc 	beq.w	41643a <__adddf3+0xe6>
  416682:	f04f 0203 	mov.w	r2, #3
  416686:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
  41668a:	bf18      	it	ne
  41668c:	3203      	addne	r2, #3
  41668e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
  416692:	bf18      	it	ne
  416694:	3203      	addne	r2, #3
  416696:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
  41669a:	f1c2 0320 	rsb	r3, r2, #32
  41669e:	fa00 fc03 	lsl.w	ip, r0, r3
  4166a2:	fa20 f002 	lsr.w	r0, r0, r2
  4166a6:	fa01 fe03 	lsl.w	lr, r1, r3
  4166aa:	ea40 000e 	orr.w	r0, r0, lr
  4166ae:	fa21 f102 	lsr.w	r1, r1, r2
  4166b2:	4414      	add	r4, r2
  4166b4:	e6c1      	b.n	41643a <__adddf3+0xe6>
  4166b6:	bf00      	nop

004166b8 <__aeabi_dmul>:
  4166b8:	b570      	push	{r4, r5, r6, lr}
  4166ba:	f04f 0cff 	mov.w	ip, #255	; 0xff
  4166be:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
  4166c2:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
  4166c6:	bf1d      	ittte	ne
  4166c8:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
  4166cc:	ea94 0f0c 	teqne	r4, ip
  4166d0:	ea95 0f0c 	teqne	r5, ip
  4166d4:	f000 f8de 	bleq	416894 <__aeabi_dmul+0x1dc>
  4166d8:	442c      	add	r4, r5
  4166da:	ea81 0603 	eor.w	r6, r1, r3
  4166de:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
  4166e2:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
  4166e6:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
  4166ea:	bf18      	it	ne
  4166ec:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
  4166f0:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  4166f4:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
  4166f8:	d038      	beq.n	41676c <__aeabi_dmul+0xb4>
  4166fa:	fba0 ce02 	umull	ip, lr, r0, r2
  4166fe:	f04f 0500 	mov.w	r5, #0
  416702:	fbe1 e502 	umlal	lr, r5, r1, r2
  416706:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
  41670a:	fbe0 e503 	umlal	lr, r5, r0, r3
  41670e:	f04f 0600 	mov.w	r6, #0
  416712:	fbe1 5603 	umlal	r5, r6, r1, r3
  416716:	f09c 0f00 	teq	ip, #0
  41671a:	bf18      	it	ne
  41671c:	f04e 0e01 	orrne.w	lr, lr, #1
  416720:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
  416724:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
  416728:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
  41672c:	d204      	bcs.n	416738 <__aeabi_dmul+0x80>
  41672e:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
  416732:	416d      	adcs	r5, r5
  416734:	eb46 0606 	adc.w	r6, r6, r6
  416738:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
  41673c:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
  416740:	ea4f 20c5 	mov.w	r0, r5, lsl #11
  416744:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
  416748:	ea4f 2ece 	mov.w	lr, lr, lsl #11
  41674c:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
  416750:	bf88      	it	hi
  416752:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
  416756:	d81e      	bhi.n	416796 <__aeabi_dmul+0xde>
  416758:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
  41675c:	bf08      	it	eq
  41675e:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
  416762:	f150 0000 	adcs.w	r0, r0, #0
  416766:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
  41676a:	bd70      	pop	{r4, r5, r6, pc}
  41676c:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
  416770:	ea46 0101 	orr.w	r1, r6, r1
  416774:	ea40 0002 	orr.w	r0, r0, r2
  416778:	ea81 0103 	eor.w	r1, r1, r3
  41677c:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
  416780:	bfc2      	ittt	gt
  416782:	ebd4 050c 	rsbsgt	r5, r4, ip
  416786:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
  41678a:	bd70      	popgt	{r4, r5, r6, pc}
  41678c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  416790:	f04f 0e00 	mov.w	lr, #0
  416794:	3c01      	subs	r4, #1
  416796:	f300 80ab 	bgt.w	4168f0 <__aeabi_dmul+0x238>
  41679a:	f114 0f36 	cmn.w	r4, #54	; 0x36
  41679e:	bfde      	ittt	le
  4167a0:	2000      	movle	r0, #0
  4167a2:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
  4167a6:	bd70      	pople	{r4, r5, r6, pc}
  4167a8:	f1c4 0400 	rsb	r4, r4, #0
  4167ac:	3c20      	subs	r4, #32
  4167ae:	da35      	bge.n	41681c <__aeabi_dmul+0x164>
  4167b0:	340c      	adds	r4, #12
  4167b2:	dc1b      	bgt.n	4167ec <__aeabi_dmul+0x134>
  4167b4:	f104 0414 	add.w	r4, r4, #20
  4167b8:	f1c4 0520 	rsb	r5, r4, #32
  4167bc:	fa00 f305 	lsl.w	r3, r0, r5
  4167c0:	fa20 f004 	lsr.w	r0, r0, r4
  4167c4:	fa01 f205 	lsl.w	r2, r1, r5
  4167c8:	ea40 0002 	orr.w	r0, r0, r2
  4167cc:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
  4167d0:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
  4167d4:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
  4167d8:	fa21 f604 	lsr.w	r6, r1, r4
  4167dc:	eb42 0106 	adc.w	r1, r2, r6
  4167e0:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
  4167e4:	bf08      	it	eq
  4167e6:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
  4167ea:	bd70      	pop	{r4, r5, r6, pc}
  4167ec:	f1c4 040c 	rsb	r4, r4, #12
  4167f0:	f1c4 0520 	rsb	r5, r4, #32
  4167f4:	fa00 f304 	lsl.w	r3, r0, r4
  4167f8:	fa20 f005 	lsr.w	r0, r0, r5
  4167fc:	fa01 f204 	lsl.w	r2, r1, r4
  416800:	ea40 0002 	orr.w	r0, r0, r2
  416804:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  416808:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
  41680c:	f141 0100 	adc.w	r1, r1, #0
  416810:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
  416814:	bf08      	it	eq
  416816:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
  41681a:	bd70      	pop	{r4, r5, r6, pc}
  41681c:	f1c4 0520 	rsb	r5, r4, #32
  416820:	fa00 f205 	lsl.w	r2, r0, r5
  416824:	ea4e 0e02 	orr.w	lr, lr, r2
  416828:	fa20 f304 	lsr.w	r3, r0, r4
  41682c:	fa01 f205 	lsl.w	r2, r1, r5
  416830:	ea43 0302 	orr.w	r3, r3, r2
  416834:	fa21 f004 	lsr.w	r0, r1, r4
  416838:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  41683c:	fa21 f204 	lsr.w	r2, r1, r4
  416840:	ea20 0002 	bic.w	r0, r0, r2
  416844:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
  416848:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
  41684c:	bf08      	it	eq
  41684e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
  416852:	bd70      	pop	{r4, r5, r6, pc}
  416854:	f094 0f00 	teq	r4, #0
  416858:	d10f      	bne.n	41687a <__aeabi_dmul+0x1c2>
  41685a:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
  41685e:	0040      	lsls	r0, r0, #1
  416860:	eb41 0101 	adc.w	r1, r1, r1
  416864:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  416868:	bf08      	it	eq
  41686a:	3c01      	subeq	r4, #1
  41686c:	d0f7      	beq.n	41685e <__aeabi_dmul+0x1a6>
  41686e:	ea41 0106 	orr.w	r1, r1, r6
  416872:	f095 0f00 	teq	r5, #0
  416876:	bf18      	it	ne
  416878:	4770      	bxne	lr
  41687a:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
  41687e:	0052      	lsls	r2, r2, #1
  416880:	eb43 0303 	adc.w	r3, r3, r3
  416884:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
  416888:	bf08      	it	eq
  41688a:	3d01      	subeq	r5, #1
  41688c:	d0f7      	beq.n	41687e <__aeabi_dmul+0x1c6>
  41688e:	ea43 0306 	orr.w	r3, r3, r6
  416892:	4770      	bx	lr
  416894:	ea94 0f0c 	teq	r4, ip
  416898:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
  41689c:	bf18      	it	ne
  41689e:	ea95 0f0c 	teqne	r5, ip
  4168a2:	d00c      	beq.n	4168be <__aeabi_dmul+0x206>
  4168a4:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
  4168a8:	bf18      	it	ne
  4168aa:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
  4168ae:	d1d1      	bne.n	416854 <__aeabi_dmul+0x19c>
  4168b0:	ea81 0103 	eor.w	r1, r1, r3
  4168b4:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  4168b8:	f04f 0000 	mov.w	r0, #0
  4168bc:	bd70      	pop	{r4, r5, r6, pc}
  4168be:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
  4168c2:	bf06      	itte	eq
  4168c4:	4610      	moveq	r0, r2
  4168c6:	4619      	moveq	r1, r3
  4168c8:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
  4168cc:	d019      	beq.n	416902 <__aeabi_dmul+0x24a>
  4168ce:	ea94 0f0c 	teq	r4, ip
  4168d2:	d102      	bne.n	4168da <__aeabi_dmul+0x222>
  4168d4:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
  4168d8:	d113      	bne.n	416902 <__aeabi_dmul+0x24a>
  4168da:	ea95 0f0c 	teq	r5, ip
  4168de:	d105      	bne.n	4168ec <__aeabi_dmul+0x234>
  4168e0:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
  4168e4:	bf1c      	itt	ne
  4168e6:	4610      	movne	r0, r2
  4168e8:	4619      	movne	r1, r3
  4168ea:	d10a      	bne.n	416902 <__aeabi_dmul+0x24a>
  4168ec:	ea81 0103 	eor.w	r1, r1, r3
  4168f0:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  4168f4:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
  4168f8:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
  4168fc:	f04f 0000 	mov.w	r0, #0
  416900:	bd70      	pop	{r4, r5, r6, pc}
  416902:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
  416906:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
  41690a:	bd70      	pop	{r4, r5, r6, pc}

0041690c <__aeabi_ddiv>:
  41690c:	b570      	push	{r4, r5, r6, lr}
  41690e:	f04f 0cff 	mov.w	ip, #255	; 0xff
  416912:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
  416916:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
  41691a:	bf1d      	ittte	ne
  41691c:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
  416920:	ea94 0f0c 	teqne	r4, ip
  416924:	ea95 0f0c 	teqne	r5, ip
  416928:	f000 f8a7 	bleq	416a7a <__aeabi_ddiv+0x16e>
  41692c:	eba4 0405 	sub.w	r4, r4, r5
  416930:	ea81 0e03 	eor.w	lr, r1, r3
  416934:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
  416938:	ea4f 3101 	mov.w	r1, r1, lsl #12
  41693c:	f000 8088 	beq.w	416a50 <__aeabi_ddiv+0x144>
  416940:	ea4f 3303 	mov.w	r3, r3, lsl #12
  416944:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
  416948:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
  41694c:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
  416950:	ea4f 2202 	mov.w	r2, r2, lsl #8
  416954:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
  416958:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
  41695c:	ea4f 2600 	mov.w	r6, r0, lsl #8
  416960:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
  416964:	429d      	cmp	r5, r3
  416966:	bf08      	it	eq
  416968:	4296      	cmpeq	r6, r2
  41696a:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
  41696e:	f504 7440 	add.w	r4, r4, #768	; 0x300
  416972:	d202      	bcs.n	41697a <__aeabi_ddiv+0x6e>
  416974:	085b      	lsrs	r3, r3, #1
  416976:	ea4f 0232 	mov.w	r2, r2, rrx
  41697a:	1ab6      	subs	r6, r6, r2
  41697c:	eb65 0503 	sbc.w	r5, r5, r3
  416980:	085b      	lsrs	r3, r3, #1
  416982:	ea4f 0232 	mov.w	r2, r2, rrx
  416986:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
  41698a:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
  41698e:	ebb6 0e02 	subs.w	lr, r6, r2
  416992:	eb75 0e03 	sbcs.w	lr, r5, r3
  416996:	bf22      	ittt	cs
  416998:	1ab6      	subcs	r6, r6, r2
  41699a:	4675      	movcs	r5, lr
  41699c:	ea40 000c 	orrcs.w	r0, r0, ip
  4169a0:	085b      	lsrs	r3, r3, #1
  4169a2:	ea4f 0232 	mov.w	r2, r2, rrx
  4169a6:	ebb6 0e02 	subs.w	lr, r6, r2
  4169aa:	eb75 0e03 	sbcs.w	lr, r5, r3
  4169ae:	bf22      	ittt	cs
  4169b0:	1ab6      	subcs	r6, r6, r2
  4169b2:	4675      	movcs	r5, lr
  4169b4:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
  4169b8:	085b      	lsrs	r3, r3, #1
  4169ba:	ea4f 0232 	mov.w	r2, r2, rrx
  4169be:	ebb6 0e02 	subs.w	lr, r6, r2
  4169c2:	eb75 0e03 	sbcs.w	lr, r5, r3
  4169c6:	bf22      	ittt	cs
  4169c8:	1ab6      	subcs	r6, r6, r2
  4169ca:	4675      	movcs	r5, lr
  4169cc:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
  4169d0:	085b      	lsrs	r3, r3, #1
  4169d2:	ea4f 0232 	mov.w	r2, r2, rrx
  4169d6:	ebb6 0e02 	subs.w	lr, r6, r2
  4169da:	eb75 0e03 	sbcs.w	lr, r5, r3
  4169de:	bf22      	ittt	cs
  4169e0:	1ab6      	subcs	r6, r6, r2
  4169e2:	4675      	movcs	r5, lr
  4169e4:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
  4169e8:	ea55 0e06 	orrs.w	lr, r5, r6
  4169ec:	d018      	beq.n	416a20 <__aeabi_ddiv+0x114>
  4169ee:	ea4f 1505 	mov.w	r5, r5, lsl #4
  4169f2:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
  4169f6:	ea4f 1606 	mov.w	r6, r6, lsl #4
  4169fa:	ea4f 03c3 	mov.w	r3, r3, lsl #3
  4169fe:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
  416a02:	ea4f 02c2 	mov.w	r2, r2, lsl #3
  416a06:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
  416a0a:	d1c0      	bne.n	41698e <__aeabi_ddiv+0x82>
  416a0c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  416a10:	d10b      	bne.n	416a2a <__aeabi_ddiv+0x11e>
  416a12:	ea41 0100 	orr.w	r1, r1, r0
  416a16:	f04f 0000 	mov.w	r0, #0
  416a1a:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
  416a1e:	e7b6      	b.n	41698e <__aeabi_ddiv+0x82>
  416a20:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  416a24:	bf04      	itt	eq
  416a26:	4301      	orreq	r1, r0
  416a28:	2000      	moveq	r0, #0
  416a2a:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
  416a2e:	bf88      	it	hi
  416a30:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
  416a34:	f63f aeaf 	bhi.w	416796 <__aeabi_dmul+0xde>
  416a38:	ebb5 0c03 	subs.w	ip, r5, r3
  416a3c:	bf04      	itt	eq
  416a3e:	ebb6 0c02 	subseq.w	ip, r6, r2
  416a42:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
  416a46:	f150 0000 	adcs.w	r0, r0, #0
  416a4a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
  416a4e:	bd70      	pop	{r4, r5, r6, pc}
  416a50:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
  416a54:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
  416a58:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
  416a5c:	bfc2      	ittt	gt
  416a5e:	ebd4 050c 	rsbsgt	r5, r4, ip
  416a62:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
  416a66:	bd70      	popgt	{r4, r5, r6, pc}
  416a68:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  416a6c:	f04f 0e00 	mov.w	lr, #0
  416a70:	3c01      	subs	r4, #1
  416a72:	e690      	b.n	416796 <__aeabi_dmul+0xde>
  416a74:	ea45 0e06 	orr.w	lr, r5, r6
  416a78:	e68d      	b.n	416796 <__aeabi_dmul+0xde>
  416a7a:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
  416a7e:	ea94 0f0c 	teq	r4, ip
  416a82:	bf08      	it	eq
  416a84:	ea95 0f0c 	teqeq	r5, ip
  416a88:	f43f af3b 	beq.w	416902 <__aeabi_dmul+0x24a>
  416a8c:	ea94 0f0c 	teq	r4, ip
  416a90:	d10a      	bne.n	416aa8 <__aeabi_ddiv+0x19c>
  416a92:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
  416a96:	f47f af34 	bne.w	416902 <__aeabi_dmul+0x24a>
  416a9a:	ea95 0f0c 	teq	r5, ip
  416a9e:	f47f af25 	bne.w	4168ec <__aeabi_dmul+0x234>
  416aa2:	4610      	mov	r0, r2
  416aa4:	4619      	mov	r1, r3
  416aa6:	e72c      	b.n	416902 <__aeabi_dmul+0x24a>
  416aa8:	ea95 0f0c 	teq	r5, ip
  416aac:	d106      	bne.n	416abc <__aeabi_ddiv+0x1b0>
  416aae:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
  416ab2:	f43f aefd 	beq.w	4168b0 <__aeabi_dmul+0x1f8>
  416ab6:	4610      	mov	r0, r2
  416ab8:	4619      	mov	r1, r3
  416aba:	e722      	b.n	416902 <__aeabi_dmul+0x24a>
  416abc:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
  416ac0:	bf18      	it	ne
  416ac2:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
  416ac6:	f47f aec5 	bne.w	416854 <__aeabi_dmul+0x19c>
  416aca:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
  416ace:	f47f af0d 	bne.w	4168ec <__aeabi_dmul+0x234>
  416ad2:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
  416ad6:	f47f aeeb 	bne.w	4168b0 <__aeabi_dmul+0x1f8>
  416ada:	e712      	b.n	416902 <__aeabi_dmul+0x24a>

00416adc <__gedf2>:
  416adc:	f04f 3cff 	mov.w	ip, #4294967295
  416ae0:	e006      	b.n	416af0 <__cmpdf2+0x4>
  416ae2:	bf00      	nop

00416ae4 <__ledf2>:
  416ae4:	f04f 0c01 	mov.w	ip, #1
  416ae8:	e002      	b.n	416af0 <__cmpdf2+0x4>
  416aea:	bf00      	nop

00416aec <__cmpdf2>:
  416aec:	f04f 0c01 	mov.w	ip, #1
  416af0:	f84d cd04 	str.w	ip, [sp, #-4]!
  416af4:	ea4f 0c41 	mov.w	ip, r1, lsl #1
  416af8:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
  416afc:	ea4f 0c43 	mov.w	ip, r3, lsl #1
  416b00:	bf18      	it	ne
  416b02:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
  416b06:	d01b      	beq.n	416b40 <__cmpdf2+0x54>
  416b08:	b001      	add	sp, #4
  416b0a:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
  416b0e:	bf0c      	ite	eq
  416b10:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
  416b14:	ea91 0f03 	teqne	r1, r3
  416b18:	bf02      	ittt	eq
  416b1a:	ea90 0f02 	teqeq	r0, r2
  416b1e:	2000      	moveq	r0, #0
  416b20:	4770      	bxeq	lr
  416b22:	f110 0f00 	cmn.w	r0, #0
  416b26:	ea91 0f03 	teq	r1, r3
  416b2a:	bf58      	it	pl
  416b2c:	4299      	cmppl	r1, r3
  416b2e:	bf08      	it	eq
  416b30:	4290      	cmpeq	r0, r2
  416b32:	bf2c      	ite	cs
  416b34:	17d8      	asrcs	r0, r3, #31
  416b36:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
  416b3a:	f040 0001 	orr.w	r0, r0, #1
  416b3e:	4770      	bx	lr
  416b40:	ea4f 0c41 	mov.w	ip, r1, lsl #1
  416b44:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
  416b48:	d102      	bne.n	416b50 <__cmpdf2+0x64>
  416b4a:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
  416b4e:	d107      	bne.n	416b60 <__cmpdf2+0x74>
  416b50:	ea4f 0c43 	mov.w	ip, r3, lsl #1
  416b54:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
  416b58:	d1d6      	bne.n	416b08 <__cmpdf2+0x1c>
  416b5a:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
  416b5e:	d0d3      	beq.n	416b08 <__cmpdf2+0x1c>
  416b60:	f85d 0b04 	ldr.w	r0, [sp], #4
  416b64:	4770      	bx	lr
  416b66:	bf00      	nop

00416b68 <__aeabi_cdrcmple>:
  416b68:	4684      	mov	ip, r0
  416b6a:	4610      	mov	r0, r2
  416b6c:	4662      	mov	r2, ip
  416b6e:	468c      	mov	ip, r1
  416b70:	4619      	mov	r1, r3
  416b72:	4663      	mov	r3, ip
  416b74:	e000      	b.n	416b78 <__aeabi_cdcmpeq>
  416b76:	bf00      	nop

00416b78 <__aeabi_cdcmpeq>:
  416b78:	b501      	push	{r0, lr}
  416b7a:	f7ff ffb7 	bl	416aec <__cmpdf2>
  416b7e:	2800      	cmp	r0, #0
  416b80:	bf48      	it	mi
  416b82:	f110 0f00 	cmnmi.w	r0, #0
  416b86:	bd01      	pop	{r0, pc}

00416b88 <__aeabi_dcmpeq>:
  416b88:	f84d ed08 	str.w	lr, [sp, #-8]!
  416b8c:	f7ff fff4 	bl	416b78 <__aeabi_cdcmpeq>
  416b90:	bf0c      	ite	eq
  416b92:	2001      	moveq	r0, #1
  416b94:	2000      	movne	r0, #0
  416b96:	f85d fb08 	ldr.w	pc, [sp], #8
  416b9a:	bf00      	nop

00416b9c <__aeabi_dcmplt>:
  416b9c:	f84d ed08 	str.w	lr, [sp, #-8]!
  416ba0:	f7ff ffea 	bl	416b78 <__aeabi_cdcmpeq>
  416ba4:	bf34      	ite	cc
  416ba6:	2001      	movcc	r0, #1
  416ba8:	2000      	movcs	r0, #0
  416baa:	f85d fb08 	ldr.w	pc, [sp], #8
  416bae:	bf00      	nop

00416bb0 <__aeabi_dcmple>:
  416bb0:	f84d ed08 	str.w	lr, [sp, #-8]!
  416bb4:	f7ff ffe0 	bl	416b78 <__aeabi_cdcmpeq>
  416bb8:	bf94      	ite	ls
  416bba:	2001      	movls	r0, #1
  416bbc:	2000      	movhi	r0, #0
  416bbe:	f85d fb08 	ldr.w	pc, [sp], #8
  416bc2:	bf00      	nop

00416bc4 <__aeabi_dcmpge>:
  416bc4:	f84d ed08 	str.w	lr, [sp, #-8]!
  416bc8:	f7ff ffce 	bl	416b68 <__aeabi_cdrcmple>
  416bcc:	bf94      	ite	ls
  416bce:	2001      	movls	r0, #1
  416bd0:	2000      	movhi	r0, #0
  416bd2:	f85d fb08 	ldr.w	pc, [sp], #8
  416bd6:	bf00      	nop

00416bd8 <__aeabi_dcmpgt>:
  416bd8:	f84d ed08 	str.w	lr, [sp, #-8]!
  416bdc:	f7ff ffc4 	bl	416b68 <__aeabi_cdrcmple>
  416be0:	bf34      	ite	cc
  416be2:	2001      	movcc	r0, #1
  416be4:	2000      	movcs	r0, #0
  416be6:	f85d fb08 	ldr.w	pc, [sp], #8
  416bea:	bf00      	nop

00416bec <__aeabi_d2uiz>:
  416bec:	004a      	lsls	r2, r1, #1
  416bee:	d211      	bcs.n	416c14 <__aeabi_d2uiz+0x28>
  416bf0:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
  416bf4:	d211      	bcs.n	416c1a <__aeabi_d2uiz+0x2e>
  416bf6:	d50d      	bpl.n	416c14 <__aeabi_d2uiz+0x28>
  416bf8:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
  416bfc:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
  416c00:	d40e      	bmi.n	416c20 <__aeabi_d2uiz+0x34>
  416c02:	ea4f 23c1 	mov.w	r3, r1, lsl #11
  416c06:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
  416c0a:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
  416c0e:	fa23 f002 	lsr.w	r0, r3, r2
  416c12:	4770      	bx	lr
  416c14:	f04f 0000 	mov.w	r0, #0
  416c18:	4770      	bx	lr
  416c1a:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
  416c1e:	d102      	bne.n	416c26 <__aeabi_d2uiz+0x3a>
  416c20:	f04f 30ff 	mov.w	r0, #4294967295
  416c24:	4770      	bx	lr
  416c26:	f04f 0000 	mov.w	r0, #0
  416c2a:	4770      	bx	lr

00416c2c <__libc_init_array>:
  416c2c:	b570      	push	{r4, r5, r6, lr}
  416c2e:	4e0f      	ldr	r6, [pc, #60]	; (416c6c <__libc_init_array+0x40>)
  416c30:	4d0f      	ldr	r5, [pc, #60]	; (416c70 <__libc_init_array+0x44>)
  416c32:	1b76      	subs	r6, r6, r5
  416c34:	10b6      	asrs	r6, r6, #2
  416c36:	bf18      	it	ne
  416c38:	2400      	movne	r4, #0
  416c3a:	d005      	beq.n	416c48 <__libc_init_array+0x1c>
  416c3c:	3401      	adds	r4, #1
  416c3e:	f855 3b04 	ldr.w	r3, [r5], #4
  416c42:	4798      	blx	r3
  416c44:	42a6      	cmp	r6, r4
  416c46:	d1f9      	bne.n	416c3c <__libc_init_array+0x10>
  416c48:	4e0a      	ldr	r6, [pc, #40]	; (416c74 <__libc_init_array+0x48>)
  416c4a:	4d0b      	ldr	r5, [pc, #44]	; (416c78 <__libc_init_array+0x4c>)
  416c4c:	1b76      	subs	r6, r6, r5
  416c4e:	f008 f813 	bl	41ec78 <_init>
  416c52:	10b6      	asrs	r6, r6, #2
  416c54:	bf18      	it	ne
  416c56:	2400      	movne	r4, #0
  416c58:	d006      	beq.n	416c68 <__libc_init_array+0x3c>
  416c5a:	3401      	adds	r4, #1
  416c5c:	f855 3b04 	ldr.w	r3, [r5], #4
  416c60:	4798      	blx	r3
  416c62:	42a6      	cmp	r6, r4
  416c64:	d1f9      	bne.n	416c5a <__libc_init_array+0x2e>
  416c66:	bd70      	pop	{r4, r5, r6, pc}
  416c68:	bd70      	pop	{r4, r5, r6, pc}
  416c6a:	bf00      	nop
  416c6c:	0041ec84 	.word	0x0041ec84
  416c70:	0041ec84 	.word	0x0041ec84
  416c74:	0041ec8c 	.word	0x0041ec8c
  416c78:	0041ec84 	.word	0x0041ec84

00416c7c <iprintf>:
  416c7c:	b40f      	push	{r0, r1, r2, r3}
  416c7e:	b500      	push	{lr}
  416c80:	4907      	ldr	r1, [pc, #28]	; (416ca0 <iprintf+0x24>)
  416c82:	b083      	sub	sp, #12
  416c84:	ab04      	add	r3, sp, #16
  416c86:	6808      	ldr	r0, [r1, #0]
  416c88:	f853 2b04 	ldr.w	r2, [r3], #4
  416c8c:	6881      	ldr	r1, [r0, #8]
  416c8e:	9301      	str	r3, [sp, #4]
  416c90:	f001 fd34 	bl	4186fc <_vfiprintf_r>
  416c94:	b003      	add	sp, #12
  416c96:	f85d eb04 	ldr.w	lr, [sp], #4
  416c9a:	b004      	add	sp, #16
  416c9c:	4770      	bx	lr
  416c9e:	bf00      	nop
  416ca0:	20000178 	.word	0x20000178

00416ca4 <memcmp>:
  416ca4:	2a03      	cmp	r2, #3
  416ca6:	b470      	push	{r4, r5, r6}
  416ca8:	d922      	bls.n	416cf0 <memcmp+0x4c>
  416caa:	ea40 0301 	orr.w	r3, r0, r1
  416cae:	079b      	lsls	r3, r3, #30
  416cb0:	d011      	beq.n	416cd6 <memcmp+0x32>
  416cb2:	7803      	ldrb	r3, [r0, #0]
  416cb4:	780c      	ldrb	r4, [r1, #0]
  416cb6:	42a3      	cmp	r3, r4
  416cb8:	d11d      	bne.n	416cf6 <memcmp+0x52>
  416cba:	440a      	add	r2, r1
  416cbc:	3101      	adds	r1, #1
  416cbe:	e005      	b.n	416ccc <memcmp+0x28>
  416cc0:	f810 3f01 	ldrb.w	r3, [r0, #1]!
  416cc4:	f811 4b01 	ldrb.w	r4, [r1], #1
  416cc8:	42a3      	cmp	r3, r4
  416cca:	d114      	bne.n	416cf6 <memcmp+0x52>
  416ccc:	4291      	cmp	r1, r2
  416cce:	d1f7      	bne.n	416cc0 <memcmp+0x1c>
  416cd0:	2000      	movs	r0, #0
  416cd2:	bc70      	pop	{r4, r5, r6}
  416cd4:	4770      	bx	lr
  416cd6:	680d      	ldr	r5, [r1, #0]
  416cd8:	6806      	ldr	r6, [r0, #0]
  416cda:	42ae      	cmp	r6, r5
  416cdc:	460c      	mov	r4, r1
  416cde:	4603      	mov	r3, r0
  416ce0:	f101 0104 	add.w	r1, r1, #4
  416ce4:	f100 0004 	add.w	r0, r0, #4
  416ce8:	d108      	bne.n	416cfc <memcmp+0x58>
  416cea:	3a04      	subs	r2, #4
  416cec:	2a03      	cmp	r2, #3
  416cee:	d8f2      	bhi.n	416cd6 <memcmp+0x32>
  416cf0:	2a00      	cmp	r2, #0
  416cf2:	d1de      	bne.n	416cb2 <memcmp+0xe>
  416cf4:	e7ec      	b.n	416cd0 <memcmp+0x2c>
  416cf6:	1b18      	subs	r0, r3, r4
  416cf8:	bc70      	pop	{r4, r5, r6}
  416cfa:	4770      	bx	lr
  416cfc:	4621      	mov	r1, r4
  416cfe:	4618      	mov	r0, r3
  416d00:	e7d7      	b.n	416cb2 <memcmp+0xe>
  416d02:	bf00      	nop

00416d04 <memcpy>:
  416d04:	4684      	mov	ip, r0
  416d06:	ea41 0300 	orr.w	r3, r1, r0
  416d0a:	f013 0303 	ands.w	r3, r3, #3
  416d0e:	d16d      	bne.n	416dec <memcpy+0xe8>
  416d10:	3a40      	subs	r2, #64	; 0x40
  416d12:	d341      	bcc.n	416d98 <memcpy+0x94>
  416d14:	f851 3b04 	ldr.w	r3, [r1], #4
  416d18:	f840 3b04 	str.w	r3, [r0], #4
  416d1c:	f851 3b04 	ldr.w	r3, [r1], #4
  416d20:	f840 3b04 	str.w	r3, [r0], #4
  416d24:	f851 3b04 	ldr.w	r3, [r1], #4
  416d28:	f840 3b04 	str.w	r3, [r0], #4
  416d2c:	f851 3b04 	ldr.w	r3, [r1], #4
  416d30:	f840 3b04 	str.w	r3, [r0], #4
  416d34:	f851 3b04 	ldr.w	r3, [r1], #4
  416d38:	f840 3b04 	str.w	r3, [r0], #4
  416d3c:	f851 3b04 	ldr.w	r3, [r1], #4
  416d40:	f840 3b04 	str.w	r3, [r0], #4
  416d44:	f851 3b04 	ldr.w	r3, [r1], #4
  416d48:	f840 3b04 	str.w	r3, [r0], #4
  416d4c:	f851 3b04 	ldr.w	r3, [r1], #4
  416d50:	f840 3b04 	str.w	r3, [r0], #4
  416d54:	f851 3b04 	ldr.w	r3, [r1], #4
  416d58:	f840 3b04 	str.w	r3, [r0], #4
  416d5c:	f851 3b04 	ldr.w	r3, [r1], #4
  416d60:	f840 3b04 	str.w	r3, [r0], #4
  416d64:	f851 3b04 	ldr.w	r3, [r1], #4
  416d68:	f840 3b04 	str.w	r3, [r0], #4
  416d6c:	f851 3b04 	ldr.w	r3, [r1], #4
  416d70:	f840 3b04 	str.w	r3, [r0], #4
  416d74:	f851 3b04 	ldr.w	r3, [r1], #4
  416d78:	f840 3b04 	str.w	r3, [r0], #4
  416d7c:	f851 3b04 	ldr.w	r3, [r1], #4
  416d80:	f840 3b04 	str.w	r3, [r0], #4
  416d84:	f851 3b04 	ldr.w	r3, [r1], #4
  416d88:	f840 3b04 	str.w	r3, [r0], #4
  416d8c:	f851 3b04 	ldr.w	r3, [r1], #4
  416d90:	f840 3b04 	str.w	r3, [r0], #4
  416d94:	3a40      	subs	r2, #64	; 0x40
  416d96:	d2bd      	bcs.n	416d14 <memcpy+0x10>
  416d98:	3230      	adds	r2, #48	; 0x30
  416d9a:	d311      	bcc.n	416dc0 <memcpy+0xbc>
  416d9c:	f851 3b04 	ldr.w	r3, [r1], #4
  416da0:	f840 3b04 	str.w	r3, [r0], #4
  416da4:	f851 3b04 	ldr.w	r3, [r1], #4
  416da8:	f840 3b04 	str.w	r3, [r0], #4
  416dac:	f851 3b04 	ldr.w	r3, [r1], #4
  416db0:	f840 3b04 	str.w	r3, [r0], #4
  416db4:	f851 3b04 	ldr.w	r3, [r1], #4
  416db8:	f840 3b04 	str.w	r3, [r0], #4
  416dbc:	3a10      	subs	r2, #16
  416dbe:	d2ed      	bcs.n	416d9c <memcpy+0x98>
  416dc0:	320c      	adds	r2, #12
  416dc2:	d305      	bcc.n	416dd0 <memcpy+0xcc>
  416dc4:	f851 3b04 	ldr.w	r3, [r1], #4
  416dc8:	f840 3b04 	str.w	r3, [r0], #4
  416dcc:	3a04      	subs	r2, #4
  416dce:	d2f9      	bcs.n	416dc4 <memcpy+0xc0>
  416dd0:	3204      	adds	r2, #4
  416dd2:	d008      	beq.n	416de6 <memcpy+0xe2>
  416dd4:	07d2      	lsls	r2, r2, #31
  416dd6:	bf1c      	itt	ne
  416dd8:	f811 3b01 	ldrbne.w	r3, [r1], #1
  416ddc:	f800 3b01 	strbne.w	r3, [r0], #1
  416de0:	d301      	bcc.n	416de6 <memcpy+0xe2>
  416de2:	880b      	ldrh	r3, [r1, #0]
  416de4:	8003      	strh	r3, [r0, #0]
  416de6:	4660      	mov	r0, ip
  416de8:	4770      	bx	lr
  416dea:	bf00      	nop
  416dec:	2a08      	cmp	r2, #8
  416dee:	d313      	bcc.n	416e18 <memcpy+0x114>
  416df0:	078b      	lsls	r3, r1, #30
  416df2:	d08d      	beq.n	416d10 <memcpy+0xc>
  416df4:	f010 0303 	ands.w	r3, r0, #3
  416df8:	d08a      	beq.n	416d10 <memcpy+0xc>
  416dfa:	f1c3 0304 	rsb	r3, r3, #4
  416dfe:	1ad2      	subs	r2, r2, r3
  416e00:	07db      	lsls	r3, r3, #31
  416e02:	bf1c      	itt	ne
  416e04:	f811 3b01 	ldrbne.w	r3, [r1], #1
  416e08:	f800 3b01 	strbne.w	r3, [r0], #1
  416e0c:	d380      	bcc.n	416d10 <memcpy+0xc>
  416e0e:	f831 3b02 	ldrh.w	r3, [r1], #2
  416e12:	f820 3b02 	strh.w	r3, [r0], #2
  416e16:	e77b      	b.n	416d10 <memcpy+0xc>
  416e18:	3a04      	subs	r2, #4
  416e1a:	d3d9      	bcc.n	416dd0 <memcpy+0xcc>
  416e1c:	3a01      	subs	r2, #1
  416e1e:	f811 3b01 	ldrb.w	r3, [r1], #1
  416e22:	f800 3b01 	strb.w	r3, [r0], #1
  416e26:	d2f9      	bcs.n	416e1c <memcpy+0x118>
  416e28:	780b      	ldrb	r3, [r1, #0]
  416e2a:	7003      	strb	r3, [r0, #0]
  416e2c:	784b      	ldrb	r3, [r1, #1]
  416e2e:	7043      	strb	r3, [r0, #1]
  416e30:	788b      	ldrb	r3, [r1, #2]
  416e32:	7083      	strb	r3, [r0, #2]
  416e34:	4660      	mov	r0, ip
  416e36:	4770      	bx	lr

00416e38 <memmove>:
  416e38:	4288      	cmp	r0, r1
  416e3a:	b5f0      	push	{r4, r5, r6, r7, lr}
  416e3c:	d90d      	bls.n	416e5a <memmove+0x22>
  416e3e:	188b      	adds	r3, r1, r2
  416e40:	4298      	cmp	r0, r3
  416e42:	d20a      	bcs.n	416e5a <memmove+0x22>
  416e44:	1884      	adds	r4, r0, r2
  416e46:	2a00      	cmp	r2, #0
  416e48:	d051      	beq.n	416eee <memmove+0xb6>
  416e4a:	4622      	mov	r2, r4
  416e4c:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
  416e50:	f802 4d01 	strb.w	r4, [r2, #-1]!
  416e54:	4299      	cmp	r1, r3
  416e56:	d1f9      	bne.n	416e4c <memmove+0x14>
  416e58:	bdf0      	pop	{r4, r5, r6, r7, pc}
  416e5a:	2a0f      	cmp	r2, #15
  416e5c:	d948      	bls.n	416ef0 <memmove+0xb8>
  416e5e:	ea41 0300 	orr.w	r3, r1, r0
  416e62:	079b      	lsls	r3, r3, #30
  416e64:	d146      	bne.n	416ef4 <memmove+0xbc>
  416e66:	f100 0410 	add.w	r4, r0, #16
  416e6a:	f101 0310 	add.w	r3, r1, #16
  416e6e:	4615      	mov	r5, r2
  416e70:	f853 6c10 	ldr.w	r6, [r3, #-16]
  416e74:	f844 6c10 	str.w	r6, [r4, #-16]
  416e78:	f853 6c0c 	ldr.w	r6, [r3, #-12]
  416e7c:	f844 6c0c 	str.w	r6, [r4, #-12]
  416e80:	f853 6c08 	ldr.w	r6, [r3, #-8]
  416e84:	f844 6c08 	str.w	r6, [r4, #-8]
  416e88:	3d10      	subs	r5, #16
  416e8a:	f853 6c04 	ldr.w	r6, [r3, #-4]
  416e8e:	f844 6c04 	str.w	r6, [r4, #-4]
  416e92:	2d0f      	cmp	r5, #15
  416e94:	f103 0310 	add.w	r3, r3, #16
  416e98:	f104 0410 	add.w	r4, r4, #16
  416e9c:	d8e8      	bhi.n	416e70 <memmove+0x38>
  416e9e:	f1a2 0310 	sub.w	r3, r2, #16
  416ea2:	f023 030f 	bic.w	r3, r3, #15
  416ea6:	f002 0e0f 	and.w	lr, r2, #15
  416eaa:	3310      	adds	r3, #16
  416eac:	f1be 0f03 	cmp.w	lr, #3
  416eb0:	4419      	add	r1, r3
  416eb2:	4403      	add	r3, r0
  416eb4:	d921      	bls.n	416efa <memmove+0xc2>
  416eb6:	1f1e      	subs	r6, r3, #4
  416eb8:	460d      	mov	r5, r1
  416eba:	4674      	mov	r4, lr
  416ebc:	3c04      	subs	r4, #4
  416ebe:	f855 7b04 	ldr.w	r7, [r5], #4
  416ec2:	f846 7f04 	str.w	r7, [r6, #4]!
  416ec6:	2c03      	cmp	r4, #3
  416ec8:	d8f8      	bhi.n	416ebc <memmove+0x84>
  416eca:	f1ae 0404 	sub.w	r4, lr, #4
  416ece:	f024 0403 	bic.w	r4, r4, #3
  416ed2:	3404      	adds	r4, #4
  416ed4:	4421      	add	r1, r4
  416ed6:	4423      	add	r3, r4
  416ed8:	f002 0203 	and.w	r2, r2, #3
  416edc:	b162      	cbz	r2, 416ef8 <memmove+0xc0>
  416ede:	3b01      	subs	r3, #1
  416ee0:	440a      	add	r2, r1
  416ee2:	f811 4b01 	ldrb.w	r4, [r1], #1
  416ee6:	f803 4f01 	strb.w	r4, [r3, #1]!
  416eea:	428a      	cmp	r2, r1
  416eec:	d1f9      	bne.n	416ee2 <memmove+0xaa>
  416eee:	bdf0      	pop	{r4, r5, r6, r7, pc}
  416ef0:	4603      	mov	r3, r0
  416ef2:	e7f3      	b.n	416edc <memmove+0xa4>
  416ef4:	4603      	mov	r3, r0
  416ef6:	e7f2      	b.n	416ede <memmove+0xa6>
  416ef8:	bdf0      	pop	{r4, r5, r6, r7, pc}
  416efa:	4672      	mov	r2, lr
  416efc:	e7ee      	b.n	416edc <memmove+0xa4>
  416efe:	bf00      	nop

00416f00 <memset>:
  416f00:	b470      	push	{r4, r5, r6}
  416f02:	0786      	lsls	r6, r0, #30
  416f04:	d046      	beq.n	416f94 <memset+0x94>
  416f06:	1e54      	subs	r4, r2, #1
  416f08:	2a00      	cmp	r2, #0
  416f0a:	d041      	beq.n	416f90 <memset+0x90>
  416f0c:	b2ca      	uxtb	r2, r1
  416f0e:	4603      	mov	r3, r0
  416f10:	e002      	b.n	416f18 <memset+0x18>
  416f12:	f114 34ff 	adds.w	r4, r4, #4294967295
  416f16:	d33b      	bcc.n	416f90 <memset+0x90>
  416f18:	f803 2b01 	strb.w	r2, [r3], #1
  416f1c:	079d      	lsls	r5, r3, #30
  416f1e:	d1f8      	bne.n	416f12 <memset+0x12>
  416f20:	2c03      	cmp	r4, #3
  416f22:	d92e      	bls.n	416f82 <memset+0x82>
  416f24:	b2cd      	uxtb	r5, r1
  416f26:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
  416f2a:	2c0f      	cmp	r4, #15
  416f2c:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
  416f30:	d919      	bls.n	416f66 <memset+0x66>
  416f32:	f103 0210 	add.w	r2, r3, #16
  416f36:	4626      	mov	r6, r4
  416f38:	3e10      	subs	r6, #16
  416f3a:	2e0f      	cmp	r6, #15
  416f3c:	f842 5c10 	str.w	r5, [r2, #-16]
  416f40:	f842 5c0c 	str.w	r5, [r2, #-12]
  416f44:	f842 5c08 	str.w	r5, [r2, #-8]
  416f48:	f842 5c04 	str.w	r5, [r2, #-4]
  416f4c:	f102 0210 	add.w	r2, r2, #16
  416f50:	d8f2      	bhi.n	416f38 <memset+0x38>
  416f52:	f1a4 0210 	sub.w	r2, r4, #16
  416f56:	f022 020f 	bic.w	r2, r2, #15
  416f5a:	f004 040f 	and.w	r4, r4, #15
  416f5e:	3210      	adds	r2, #16
  416f60:	2c03      	cmp	r4, #3
  416f62:	4413      	add	r3, r2
  416f64:	d90d      	bls.n	416f82 <memset+0x82>
  416f66:	461e      	mov	r6, r3
  416f68:	4622      	mov	r2, r4
  416f6a:	3a04      	subs	r2, #4
  416f6c:	2a03      	cmp	r2, #3
  416f6e:	f846 5b04 	str.w	r5, [r6], #4
  416f72:	d8fa      	bhi.n	416f6a <memset+0x6a>
  416f74:	1f22      	subs	r2, r4, #4
  416f76:	f022 0203 	bic.w	r2, r2, #3
  416f7a:	3204      	adds	r2, #4
  416f7c:	4413      	add	r3, r2
  416f7e:	f004 0403 	and.w	r4, r4, #3
  416f82:	b12c      	cbz	r4, 416f90 <memset+0x90>
  416f84:	b2c9      	uxtb	r1, r1
  416f86:	441c      	add	r4, r3
  416f88:	f803 1b01 	strb.w	r1, [r3], #1
  416f8c:	429c      	cmp	r4, r3
  416f8e:	d1fb      	bne.n	416f88 <memset+0x88>
  416f90:	bc70      	pop	{r4, r5, r6}
  416f92:	4770      	bx	lr
  416f94:	4614      	mov	r4, r2
  416f96:	4603      	mov	r3, r0
  416f98:	e7c2      	b.n	416f20 <memset+0x20>
  416f9a:	bf00      	nop

00416f9c <setbuf>:
  416f9c:	2900      	cmp	r1, #0
  416f9e:	bf0c      	ite	eq
  416fa0:	2202      	moveq	r2, #2
  416fa2:	2200      	movne	r2, #0
  416fa4:	f44f 6380 	mov.w	r3, #1024	; 0x400
  416fa8:	f000 b800 	b.w	416fac <setvbuf>

00416fac <setvbuf>:
  416fac:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  416fb0:	4c61      	ldr	r4, [pc, #388]	; (417138 <setvbuf+0x18c>)
  416fb2:	6825      	ldr	r5, [r4, #0]
  416fb4:	b083      	sub	sp, #12
  416fb6:	4604      	mov	r4, r0
  416fb8:	460f      	mov	r7, r1
  416fba:	4690      	mov	r8, r2
  416fbc:	461e      	mov	r6, r3
  416fbe:	b115      	cbz	r5, 416fc6 <setvbuf+0x1a>
  416fc0:	6bab      	ldr	r3, [r5, #56]	; 0x38
  416fc2:	2b00      	cmp	r3, #0
  416fc4:	d064      	beq.n	417090 <setvbuf+0xe4>
  416fc6:	f1b8 0f02 	cmp.w	r8, #2
  416fca:	d006      	beq.n	416fda <setvbuf+0x2e>
  416fcc:	f1b8 0f01 	cmp.w	r8, #1
  416fd0:	f200 809f 	bhi.w	417112 <setvbuf+0x166>
  416fd4:	2e00      	cmp	r6, #0
  416fd6:	f2c0 809c 	blt.w	417112 <setvbuf+0x166>
  416fda:	6e63      	ldr	r3, [r4, #100]	; 0x64
  416fdc:	07d8      	lsls	r0, r3, #31
  416fde:	d534      	bpl.n	41704a <setvbuf+0x9e>
  416fe0:	4621      	mov	r1, r4
  416fe2:	4628      	mov	r0, r5
  416fe4:	f003 fae6 	bl	41a5b4 <_fflush_r>
  416fe8:	6b21      	ldr	r1, [r4, #48]	; 0x30
  416fea:	b141      	cbz	r1, 416ffe <setvbuf+0x52>
  416fec:	f104 0340 	add.w	r3, r4, #64	; 0x40
  416ff0:	4299      	cmp	r1, r3
  416ff2:	d002      	beq.n	416ffa <setvbuf+0x4e>
  416ff4:	4628      	mov	r0, r5
  416ff6:	f003 fc5b 	bl	41a8b0 <_free_r>
  416ffa:	2300      	movs	r3, #0
  416ffc:	6323      	str	r3, [r4, #48]	; 0x30
  416ffe:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
  417002:	2200      	movs	r2, #0
  417004:	61a2      	str	r2, [r4, #24]
  417006:	6062      	str	r2, [r4, #4]
  417008:	061a      	lsls	r2, r3, #24
  41700a:	d43a      	bmi.n	417082 <setvbuf+0xd6>
  41700c:	f423 634a 	bic.w	r3, r3, #3232	; 0xca0
  417010:	f023 0303 	bic.w	r3, r3, #3
  417014:	f1b8 0f02 	cmp.w	r8, #2
  417018:	81a3      	strh	r3, [r4, #12]
  41701a:	d01d      	beq.n	417058 <setvbuf+0xac>
  41701c:	ab01      	add	r3, sp, #4
  41701e:	466a      	mov	r2, sp
  417020:	4621      	mov	r1, r4
  417022:	4628      	mov	r0, r5
  417024:	f003 fef0 	bl	41ae08 <__swhatbuf_r>
  417028:	89a3      	ldrh	r3, [r4, #12]
  41702a:	4318      	orrs	r0, r3
  41702c:	81a0      	strh	r0, [r4, #12]
  41702e:	2e00      	cmp	r6, #0
  417030:	d132      	bne.n	417098 <setvbuf+0xec>
  417032:	9e00      	ldr	r6, [sp, #0]
  417034:	4630      	mov	r0, r6
  417036:	f003 ff5f 	bl	41aef8 <malloc>
  41703a:	4607      	mov	r7, r0
  41703c:	2800      	cmp	r0, #0
  41703e:	d06b      	beq.n	417118 <setvbuf+0x16c>
  417040:	89a3      	ldrh	r3, [r4, #12]
  417042:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  417046:	81a3      	strh	r3, [r4, #12]
  417048:	e028      	b.n	41709c <setvbuf+0xf0>
  41704a:	89a3      	ldrh	r3, [r4, #12]
  41704c:	0599      	lsls	r1, r3, #22
  41704e:	d4c7      	bmi.n	416fe0 <setvbuf+0x34>
  417050:	6da0      	ldr	r0, [r4, #88]	; 0x58
  417052:	f003 fed5 	bl	41ae00 <__retarget_lock_acquire_recursive>
  417056:	e7c3      	b.n	416fe0 <setvbuf+0x34>
  417058:	2500      	movs	r5, #0
  41705a:	6e61      	ldr	r1, [r4, #100]	; 0x64
  41705c:	2600      	movs	r6, #0
  41705e:	f104 0243 	add.w	r2, r4, #67	; 0x43
  417062:	f043 0302 	orr.w	r3, r3, #2
  417066:	2001      	movs	r0, #1
  417068:	60a6      	str	r6, [r4, #8]
  41706a:	07ce      	lsls	r6, r1, #31
  41706c:	81a3      	strh	r3, [r4, #12]
  41706e:	6022      	str	r2, [r4, #0]
  417070:	6122      	str	r2, [r4, #16]
  417072:	6160      	str	r0, [r4, #20]
  417074:	d401      	bmi.n	41707a <setvbuf+0xce>
  417076:	0598      	lsls	r0, r3, #22
  417078:	d53e      	bpl.n	4170f8 <setvbuf+0x14c>
  41707a:	4628      	mov	r0, r5
  41707c:	b003      	add	sp, #12
  41707e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  417082:	6921      	ldr	r1, [r4, #16]
  417084:	4628      	mov	r0, r5
  417086:	f003 fc13 	bl	41a8b0 <_free_r>
  41708a:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
  41708e:	e7bd      	b.n	41700c <setvbuf+0x60>
  417090:	4628      	mov	r0, r5
  417092:	f003 fae7 	bl	41a664 <__sinit>
  417096:	e796      	b.n	416fc6 <setvbuf+0x1a>
  417098:	2f00      	cmp	r7, #0
  41709a:	d0cb      	beq.n	417034 <setvbuf+0x88>
  41709c:	6bab      	ldr	r3, [r5, #56]	; 0x38
  41709e:	2b00      	cmp	r3, #0
  4170a0:	d033      	beq.n	41710a <setvbuf+0x15e>
  4170a2:	9b00      	ldr	r3, [sp, #0]
  4170a4:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
  4170a8:	6027      	str	r7, [r4, #0]
  4170aa:	429e      	cmp	r6, r3
  4170ac:	bf1c      	itt	ne
  4170ae:	f442 6200 	orrne.w	r2, r2, #2048	; 0x800
  4170b2:	81a2      	strhne	r2, [r4, #12]
  4170b4:	f1b8 0f01 	cmp.w	r8, #1
  4170b8:	bf04      	itt	eq
  4170ba:	f042 0201 	orreq.w	r2, r2, #1
  4170be:	81a2      	strheq	r2, [r4, #12]
  4170c0:	b292      	uxth	r2, r2
  4170c2:	f012 0308 	ands.w	r3, r2, #8
  4170c6:	6127      	str	r7, [r4, #16]
  4170c8:	6166      	str	r6, [r4, #20]
  4170ca:	d00e      	beq.n	4170ea <setvbuf+0x13e>
  4170cc:	07d1      	lsls	r1, r2, #31
  4170ce:	d51a      	bpl.n	417106 <setvbuf+0x15a>
  4170d0:	6e65      	ldr	r5, [r4, #100]	; 0x64
  4170d2:	4276      	negs	r6, r6
  4170d4:	2300      	movs	r3, #0
  4170d6:	f015 0501 	ands.w	r5, r5, #1
  4170da:	61a6      	str	r6, [r4, #24]
  4170dc:	60a3      	str	r3, [r4, #8]
  4170de:	d009      	beq.n	4170f4 <setvbuf+0x148>
  4170e0:	2500      	movs	r5, #0
  4170e2:	4628      	mov	r0, r5
  4170e4:	b003      	add	sp, #12
  4170e6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  4170ea:	60a3      	str	r3, [r4, #8]
  4170ec:	6e65      	ldr	r5, [r4, #100]	; 0x64
  4170ee:	f015 0501 	ands.w	r5, r5, #1
  4170f2:	d1f5      	bne.n	4170e0 <setvbuf+0x134>
  4170f4:	0593      	lsls	r3, r2, #22
  4170f6:	d4c0      	bmi.n	41707a <setvbuf+0xce>
  4170f8:	6da0      	ldr	r0, [r4, #88]	; 0x58
  4170fa:	f003 fe83 	bl	41ae04 <__retarget_lock_release_recursive>
  4170fe:	4628      	mov	r0, r5
  417100:	b003      	add	sp, #12
  417102:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  417106:	60a6      	str	r6, [r4, #8]
  417108:	e7f0      	b.n	4170ec <setvbuf+0x140>
  41710a:	4628      	mov	r0, r5
  41710c:	f003 faaa 	bl	41a664 <__sinit>
  417110:	e7c7      	b.n	4170a2 <setvbuf+0xf6>
  417112:	f04f 35ff 	mov.w	r5, #4294967295
  417116:	e7b0      	b.n	41707a <setvbuf+0xce>
  417118:	f8dd 9000 	ldr.w	r9, [sp]
  41711c:	45b1      	cmp	r9, r6
  41711e:	d004      	beq.n	41712a <setvbuf+0x17e>
  417120:	4648      	mov	r0, r9
  417122:	f003 fee9 	bl	41aef8 <malloc>
  417126:	4607      	mov	r7, r0
  417128:	b920      	cbnz	r0, 417134 <setvbuf+0x188>
  41712a:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
  41712e:	f04f 35ff 	mov.w	r5, #4294967295
  417132:	e792      	b.n	41705a <setvbuf+0xae>
  417134:	464e      	mov	r6, r9
  417136:	e783      	b.n	417040 <setvbuf+0x94>
  417138:	20000178 	.word	0x20000178

0041713c <snprintf>:
  41713c:	b40c      	push	{r2, r3}
  41713e:	b5f0      	push	{r4, r5, r6, r7, lr}
  417140:	4b23      	ldr	r3, [pc, #140]	; (4171d0 <snprintf+0x94>)
  417142:	1e0c      	subs	r4, r1, #0
  417144:	b09d      	sub	sp, #116	; 0x74
  417146:	681d      	ldr	r5, [r3, #0]
  417148:	db3d      	blt.n	4171c6 <snprintf+0x8a>
  41714a:	f44f 7302 	mov.w	r3, #520	; 0x208
  41714e:	9002      	str	r0, [sp, #8]
  417150:	9006      	str	r0, [sp, #24]
  417152:	f8ad 3014 	strh.w	r3, [sp, #20]
  417156:	ae23      	add	r6, sp, #140	; 0x8c
  417158:	d017      	beq.n	41718a <snprintf+0x4e>
  41715a:	3c01      	subs	r4, #1
  41715c:	9a22      	ldr	r2, [sp, #136]	; 0x88
  41715e:	9404      	str	r4, [sp, #16]
  417160:	4633      	mov	r3, r6
  417162:	f64f 77ff 	movw	r7, #65535	; 0xffff
  417166:	a902      	add	r1, sp, #8
  417168:	4628      	mov	r0, r5
  41716a:	9407      	str	r4, [sp, #28]
  41716c:	9601      	str	r6, [sp, #4]
  41716e:	f8ad 7016 	strh.w	r7, [sp, #22]
  417172:	f000 f855 	bl	417220 <_svfprintf_r>
  417176:	1c42      	adds	r2, r0, #1
  417178:	db1b      	blt.n	4171b2 <snprintf+0x76>
  41717a:	9b02      	ldr	r3, [sp, #8]
  41717c:	2200      	movs	r2, #0
  41717e:	701a      	strb	r2, [r3, #0]
  417180:	b01d      	add	sp, #116	; 0x74
  417182:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  417186:	b002      	add	sp, #8
  417188:	4770      	bx	lr
  41718a:	4633      	mov	r3, r6
  41718c:	f64f 77ff 	movw	r7, #65535	; 0xffff
  417190:	9a22      	ldr	r2, [sp, #136]	; 0x88
  417192:	9404      	str	r4, [sp, #16]
  417194:	a902      	add	r1, sp, #8
  417196:	4628      	mov	r0, r5
  417198:	9407      	str	r4, [sp, #28]
  41719a:	9601      	str	r6, [sp, #4]
  41719c:	f8ad 7016 	strh.w	r7, [sp, #22]
  4171a0:	f000 f83e 	bl	417220 <_svfprintf_r>
  4171a4:	1c43      	adds	r3, r0, #1
  4171a6:	db07      	blt.n	4171b8 <snprintf+0x7c>
  4171a8:	b01d      	add	sp, #116	; 0x74
  4171aa:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  4171ae:	b002      	add	sp, #8
  4171b0:	4770      	bx	lr
  4171b2:	238b      	movs	r3, #139	; 0x8b
  4171b4:	602b      	str	r3, [r5, #0]
  4171b6:	e7e0      	b.n	41717a <snprintf+0x3e>
  4171b8:	238b      	movs	r3, #139	; 0x8b
  4171ba:	602b      	str	r3, [r5, #0]
  4171bc:	b01d      	add	sp, #116	; 0x74
  4171be:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  4171c2:	b002      	add	sp, #8
  4171c4:	4770      	bx	lr
  4171c6:	238b      	movs	r3, #139	; 0x8b
  4171c8:	602b      	str	r3, [r5, #0]
  4171ca:	f04f 30ff 	mov.w	r0, #4294967295
  4171ce:	e7eb      	b.n	4171a8 <snprintf+0x6c>
  4171d0:	20000178 	.word	0x20000178

004171d4 <sprintf>:
  4171d4:	b40e      	push	{r1, r2, r3}
  4171d6:	b5f0      	push	{r4, r5, r6, r7, lr}
  4171d8:	b09c      	sub	sp, #112	; 0x70
  4171da:	ab21      	add	r3, sp, #132	; 0x84
  4171dc:	490f      	ldr	r1, [pc, #60]	; (41721c <sprintf+0x48>)
  4171de:	f853 2b04 	ldr.w	r2, [r3], #4
  4171e2:	9301      	str	r3, [sp, #4]
  4171e4:	4605      	mov	r5, r0
  4171e6:	f06f 4400 	mvn.w	r4, #2147483648	; 0x80000000
  4171ea:	6808      	ldr	r0, [r1, #0]
  4171ec:	9502      	str	r5, [sp, #8]
  4171ee:	f44f 7702 	mov.w	r7, #520	; 0x208
  4171f2:	f64f 76ff 	movw	r6, #65535	; 0xffff
  4171f6:	a902      	add	r1, sp, #8
  4171f8:	9506      	str	r5, [sp, #24]
  4171fa:	f8ad 7014 	strh.w	r7, [sp, #20]
  4171fe:	9404      	str	r4, [sp, #16]
  417200:	9407      	str	r4, [sp, #28]
  417202:	f8ad 6016 	strh.w	r6, [sp, #22]
  417206:	f000 f80b 	bl	417220 <_svfprintf_r>
  41720a:	9b02      	ldr	r3, [sp, #8]
  41720c:	2200      	movs	r2, #0
  41720e:	701a      	strb	r2, [r3, #0]
  417210:	b01c      	add	sp, #112	; 0x70
  417212:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  417216:	b003      	add	sp, #12
  417218:	4770      	bx	lr
  41721a:	bf00      	nop
  41721c:	20000178 	.word	0x20000178

00417220 <_svfprintf_r>:
  417220:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  417224:	b0c3      	sub	sp, #268	; 0x10c
  417226:	460c      	mov	r4, r1
  417228:	910b      	str	r1, [sp, #44]	; 0x2c
  41722a:	4692      	mov	sl, r2
  41722c:	930f      	str	r3, [sp, #60]	; 0x3c
  41722e:	900c      	str	r0, [sp, #48]	; 0x30
  417230:	f003 fdd4 	bl	41addc <_localeconv_r>
  417234:	6803      	ldr	r3, [r0, #0]
  417236:	931a      	str	r3, [sp, #104]	; 0x68
  417238:	4618      	mov	r0, r3
  41723a:	f004 fea1 	bl	41bf80 <strlen>
  41723e:	89a3      	ldrh	r3, [r4, #12]
  417240:	9019      	str	r0, [sp, #100]	; 0x64
  417242:	0619      	lsls	r1, r3, #24
  417244:	d503      	bpl.n	41724e <_svfprintf_r+0x2e>
  417246:	6923      	ldr	r3, [r4, #16]
  417248:	2b00      	cmp	r3, #0
  41724a:	f001 8003 	beq.w	418254 <_svfprintf_r+0x1034>
  41724e:	2300      	movs	r3, #0
  417250:	f10d 09c8 	add.w	r9, sp, #200	; 0xc8
  417254:	9313      	str	r3, [sp, #76]	; 0x4c
  417256:	9315      	str	r3, [sp, #84]	; 0x54
  417258:	9314      	str	r3, [sp, #80]	; 0x50
  41725a:	9327      	str	r3, [sp, #156]	; 0x9c
  41725c:	9326      	str	r3, [sp, #152]	; 0x98
  41725e:	9318      	str	r3, [sp, #96]	; 0x60
  417260:	931b      	str	r3, [sp, #108]	; 0x6c
  417262:	9309      	str	r3, [sp, #36]	; 0x24
  417264:	f8cd 9094 	str.w	r9, [sp, #148]	; 0x94
  417268:	46c8      	mov	r8, r9
  41726a:	9316      	str	r3, [sp, #88]	; 0x58
  41726c:	9317      	str	r3, [sp, #92]	; 0x5c
  41726e:	f89a 3000 	ldrb.w	r3, [sl]
  417272:	4654      	mov	r4, sl
  417274:	b1e3      	cbz	r3, 4172b0 <_svfprintf_r+0x90>
  417276:	2b25      	cmp	r3, #37	; 0x25
  417278:	d102      	bne.n	417280 <_svfprintf_r+0x60>
  41727a:	e019      	b.n	4172b0 <_svfprintf_r+0x90>
  41727c:	2b25      	cmp	r3, #37	; 0x25
  41727e:	d003      	beq.n	417288 <_svfprintf_r+0x68>
  417280:	f814 3f01 	ldrb.w	r3, [r4, #1]!
  417284:	2b00      	cmp	r3, #0
  417286:	d1f9      	bne.n	41727c <_svfprintf_r+0x5c>
  417288:	eba4 050a 	sub.w	r5, r4, sl
  41728c:	b185      	cbz	r5, 4172b0 <_svfprintf_r+0x90>
  41728e:	9b26      	ldr	r3, [sp, #152]	; 0x98
  417290:	9a27      	ldr	r2, [sp, #156]	; 0x9c
  417292:	f8c8 a000 	str.w	sl, [r8]
  417296:	3301      	adds	r3, #1
  417298:	442a      	add	r2, r5
  41729a:	2b07      	cmp	r3, #7
  41729c:	f8c8 5004 	str.w	r5, [r8, #4]
  4172a0:	9227      	str	r2, [sp, #156]	; 0x9c
  4172a2:	9326      	str	r3, [sp, #152]	; 0x98
  4172a4:	dc7f      	bgt.n	4173a6 <_svfprintf_r+0x186>
  4172a6:	f108 0808 	add.w	r8, r8, #8
  4172aa:	9b09      	ldr	r3, [sp, #36]	; 0x24
  4172ac:	442b      	add	r3, r5
  4172ae:	9309      	str	r3, [sp, #36]	; 0x24
  4172b0:	7823      	ldrb	r3, [r4, #0]
  4172b2:	2b00      	cmp	r3, #0
  4172b4:	d07f      	beq.n	4173b6 <_svfprintf_r+0x196>
  4172b6:	2300      	movs	r3, #0
  4172b8:	461a      	mov	r2, r3
  4172ba:	f88d 3077 	strb.w	r3, [sp, #119]	; 0x77
  4172be:	4619      	mov	r1, r3
  4172c0:	930d      	str	r3, [sp, #52]	; 0x34
  4172c2:	469b      	mov	fp, r3
  4172c4:	f04f 30ff 	mov.w	r0, #4294967295
  4172c8:	7863      	ldrb	r3, [r4, #1]
  4172ca:	900a      	str	r0, [sp, #40]	; 0x28
  4172cc:	f104 0a01 	add.w	sl, r4, #1
  4172d0:	f10a 0a01 	add.w	sl, sl, #1
  4172d4:	f1a3 0020 	sub.w	r0, r3, #32
  4172d8:	2858      	cmp	r0, #88	; 0x58
  4172da:	f200 83c1 	bhi.w	417a60 <_svfprintf_r+0x840>
  4172de:	e8df f010 	tbh	[pc, r0, lsl #1]
  4172e2:	0238      	.short	0x0238
  4172e4:	03bf03bf 	.word	0x03bf03bf
  4172e8:	03bf0240 	.word	0x03bf0240
  4172ec:	03bf03bf 	.word	0x03bf03bf
  4172f0:	03bf03bf 	.word	0x03bf03bf
  4172f4:	024503bf 	.word	0x024503bf
  4172f8:	03bf0203 	.word	0x03bf0203
  4172fc:	026b005d 	.word	0x026b005d
  417300:	028603bf 	.word	0x028603bf
  417304:	039d039d 	.word	0x039d039d
  417308:	039d039d 	.word	0x039d039d
  41730c:	039d039d 	.word	0x039d039d
  417310:	039d039d 	.word	0x039d039d
  417314:	03bf039d 	.word	0x03bf039d
  417318:	03bf03bf 	.word	0x03bf03bf
  41731c:	03bf03bf 	.word	0x03bf03bf
  417320:	03bf03bf 	.word	0x03bf03bf
  417324:	03bf03bf 	.word	0x03bf03bf
  417328:	033703bf 	.word	0x033703bf
  41732c:	03bf0357 	.word	0x03bf0357
  417330:	03bf0357 	.word	0x03bf0357
  417334:	03bf03bf 	.word	0x03bf03bf
  417338:	039803bf 	.word	0x039803bf
  41733c:	03bf03bf 	.word	0x03bf03bf
  417340:	03bf03ad 	.word	0x03bf03ad
  417344:	03bf03bf 	.word	0x03bf03bf
  417348:	03bf03bf 	.word	0x03bf03bf
  41734c:	03bf0259 	.word	0x03bf0259
  417350:	031e03bf 	.word	0x031e03bf
  417354:	03bf03bf 	.word	0x03bf03bf
  417358:	03bf03bf 	.word	0x03bf03bf
  41735c:	03bf03bf 	.word	0x03bf03bf
  417360:	03bf03bf 	.word	0x03bf03bf
  417364:	03bf03bf 	.word	0x03bf03bf
  417368:	02db02c6 	.word	0x02db02c6
  41736c:	03570357 	.word	0x03570357
  417370:	028b0357 	.word	0x028b0357
  417374:	03bf02db 	.word	0x03bf02db
  417378:	029003bf 	.word	0x029003bf
  41737c:	029d03bf 	.word	0x029d03bf
  417380:	02b401cc 	.word	0x02b401cc
  417384:	03bf0208 	.word	0x03bf0208
  417388:	03bf01e1 	.word	0x03bf01e1
  41738c:	03bf007e 	.word	0x03bf007e
  417390:	020d03bf 	.word	0x020d03bf
  417394:	980d      	ldr	r0, [sp, #52]	; 0x34
  417396:	930f      	str	r3, [sp, #60]	; 0x3c
  417398:	4240      	negs	r0, r0
  41739a:	900d      	str	r0, [sp, #52]	; 0x34
  41739c:	f04b 0b04 	orr.w	fp, fp, #4
  4173a0:	f89a 3000 	ldrb.w	r3, [sl]
  4173a4:	e794      	b.n	4172d0 <_svfprintf_r+0xb0>
  4173a6:	aa25      	add	r2, sp, #148	; 0x94
  4173a8:	990b      	ldr	r1, [sp, #44]	; 0x2c
  4173aa:	980c      	ldr	r0, [sp, #48]	; 0x30
  4173ac:	f004 fe56 	bl	41c05c <__ssprint_r>
  4173b0:	b940      	cbnz	r0, 4173c4 <_svfprintf_r+0x1a4>
  4173b2:	46c8      	mov	r8, r9
  4173b4:	e779      	b.n	4172aa <_svfprintf_r+0x8a>
  4173b6:	9b27      	ldr	r3, [sp, #156]	; 0x9c
  4173b8:	b123      	cbz	r3, 4173c4 <_svfprintf_r+0x1a4>
  4173ba:	980c      	ldr	r0, [sp, #48]	; 0x30
  4173bc:	990b      	ldr	r1, [sp, #44]	; 0x2c
  4173be:	aa25      	add	r2, sp, #148	; 0x94
  4173c0:	f004 fe4c 	bl	41c05c <__ssprint_r>
  4173c4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  4173c6:	899b      	ldrh	r3, [r3, #12]
  4173c8:	f013 0f40 	tst.w	r3, #64	; 0x40
  4173cc:	9b09      	ldr	r3, [sp, #36]	; 0x24
  4173ce:	bf18      	it	ne
  4173d0:	f04f 33ff 	movne.w	r3, #4294967295
  4173d4:	9309      	str	r3, [sp, #36]	; 0x24
  4173d6:	9809      	ldr	r0, [sp, #36]	; 0x24
  4173d8:	b043      	add	sp, #268	; 0x10c
  4173da:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4173de:	f01b 0f20 	tst.w	fp, #32
  4173e2:	9311      	str	r3, [sp, #68]	; 0x44
  4173e4:	f040 81dd 	bne.w	4177a2 <_svfprintf_r+0x582>
  4173e8:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
  4173ea:	f01b 0f10 	tst.w	fp, #16
  4173ee:	4613      	mov	r3, r2
  4173f0:	f040 856e 	bne.w	417ed0 <_svfprintf_r+0xcb0>
  4173f4:	f01b 0f40 	tst.w	fp, #64	; 0x40
  4173f8:	f000 856a 	beq.w	417ed0 <_svfprintf_r+0xcb0>
  4173fc:	8814      	ldrh	r4, [r2, #0]
  4173fe:	3204      	adds	r2, #4
  417400:	2500      	movs	r5, #0
  417402:	2301      	movs	r3, #1
  417404:	920f      	str	r2, [sp, #60]	; 0x3c
  417406:	2700      	movs	r7, #0
  417408:	f88d 7077 	strb.w	r7, [sp, #119]	; 0x77
  41740c:	990a      	ldr	r1, [sp, #40]	; 0x28
  41740e:	1c4a      	adds	r2, r1, #1
  417410:	f000 8265 	beq.w	4178de <_svfprintf_r+0x6be>
  417414:	f02b 0280 	bic.w	r2, fp, #128	; 0x80
  417418:	9207      	str	r2, [sp, #28]
  41741a:	ea54 0205 	orrs.w	r2, r4, r5
  41741e:	f040 8264 	bne.w	4178ea <_svfprintf_r+0x6ca>
  417422:	2900      	cmp	r1, #0
  417424:	f040 843c 	bne.w	417ca0 <_svfprintf_r+0xa80>
  417428:	2b00      	cmp	r3, #0
  41742a:	f040 84d7 	bne.w	417ddc <_svfprintf_r+0xbbc>
  41742e:	f01b 0301 	ands.w	r3, fp, #1
  417432:	930e      	str	r3, [sp, #56]	; 0x38
  417434:	f000 8604 	beq.w	418040 <_svfprintf_r+0xe20>
  417438:	ae42      	add	r6, sp, #264	; 0x108
  41743a:	2330      	movs	r3, #48	; 0x30
  41743c:	f806 3d41 	strb.w	r3, [r6, #-65]!
  417440:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  417442:	9a0e      	ldr	r2, [sp, #56]	; 0x38
  417444:	4293      	cmp	r3, r2
  417446:	bfb8      	it	lt
  417448:	4613      	movlt	r3, r2
  41744a:	9308      	str	r3, [sp, #32]
  41744c:	2300      	movs	r3, #0
  41744e:	9312      	str	r3, [sp, #72]	; 0x48
  417450:	b117      	cbz	r7, 417458 <_svfprintf_r+0x238>
  417452:	9b08      	ldr	r3, [sp, #32]
  417454:	3301      	adds	r3, #1
  417456:	9308      	str	r3, [sp, #32]
  417458:	9b07      	ldr	r3, [sp, #28]
  41745a:	f013 0302 	ands.w	r3, r3, #2
  41745e:	9310      	str	r3, [sp, #64]	; 0x40
  417460:	d002      	beq.n	417468 <_svfprintf_r+0x248>
  417462:	9b08      	ldr	r3, [sp, #32]
  417464:	3302      	adds	r3, #2
  417466:	9308      	str	r3, [sp, #32]
  417468:	9b07      	ldr	r3, [sp, #28]
  41746a:	f013 0584 	ands.w	r5, r3, #132	; 0x84
  41746e:	f040 830e 	bne.w	417a8e <_svfprintf_r+0x86e>
  417472:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  417474:	9a08      	ldr	r2, [sp, #32]
  417476:	eba3 0b02 	sub.w	fp, r3, r2
  41747a:	f1bb 0f00 	cmp.w	fp, #0
  41747e:	f340 8306 	ble.w	417a8e <_svfprintf_r+0x86e>
  417482:	f1bb 0f10 	cmp.w	fp, #16
  417486:	9c27      	ldr	r4, [sp, #156]	; 0x9c
  417488:	9a26      	ldr	r2, [sp, #152]	; 0x98
  41748a:	dd29      	ble.n	4174e0 <_svfprintf_r+0x2c0>
  41748c:	4643      	mov	r3, r8
  41748e:	4621      	mov	r1, r4
  417490:	46a8      	mov	r8, r5
  417492:	2710      	movs	r7, #16
  417494:	9c0c      	ldr	r4, [sp, #48]	; 0x30
  417496:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
  417498:	e006      	b.n	4174a8 <_svfprintf_r+0x288>
  41749a:	f1ab 0b10 	sub.w	fp, fp, #16
  41749e:	f1bb 0f10 	cmp.w	fp, #16
  4174a2:	f103 0308 	add.w	r3, r3, #8
  4174a6:	dd18      	ble.n	4174da <_svfprintf_r+0x2ba>
  4174a8:	3201      	adds	r2, #1
  4174aa:	48b7      	ldr	r0, [pc, #732]	; (417788 <_svfprintf_r+0x568>)
  4174ac:	9226      	str	r2, [sp, #152]	; 0x98
  4174ae:	3110      	adds	r1, #16
  4174b0:	2a07      	cmp	r2, #7
  4174b2:	9127      	str	r1, [sp, #156]	; 0x9c
  4174b4:	e883 0081 	stmia.w	r3, {r0, r7}
  4174b8:	ddef      	ble.n	41749a <_svfprintf_r+0x27a>
  4174ba:	aa25      	add	r2, sp, #148	; 0x94
  4174bc:	4629      	mov	r1, r5
  4174be:	4620      	mov	r0, r4
  4174c0:	f004 fdcc 	bl	41c05c <__ssprint_r>
  4174c4:	2800      	cmp	r0, #0
  4174c6:	f47f af7d 	bne.w	4173c4 <_svfprintf_r+0x1a4>
  4174ca:	f1ab 0b10 	sub.w	fp, fp, #16
  4174ce:	f1bb 0f10 	cmp.w	fp, #16
  4174d2:	9927      	ldr	r1, [sp, #156]	; 0x9c
  4174d4:	9a26      	ldr	r2, [sp, #152]	; 0x98
  4174d6:	464b      	mov	r3, r9
  4174d8:	dce6      	bgt.n	4174a8 <_svfprintf_r+0x288>
  4174da:	4645      	mov	r5, r8
  4174dc:	460c      	mov	r4, r1
  4174de:	4698      	mov	r8, r3
  4174e0:	3201      	adds	r2, #1
  4174e2:	4ba9      	ldr	r3, [pc, #676]	; (417788 <_svfprintf_r+0x568>)
  4174e4:	9226      	str	r2, [sp, #152]	; 0x98
  4174e6:	445c      	add	r4, fp
  4174e8:	2a07      	cmp	r2, #7
  4174ea:	9427      	str	r4, [sp, #156]	; 0x9c
  4174ec:	e888 0808 	stmia.w	r8, {r3, fp}
  4174f0:	f300 8498 	bgt.w	417e24 <_svfprintf_r+0xc04>
  4174f4:	f89d 7077 	ldrb.w	r7, [sp, #119]	; 0x77
  4174f8:	f108 0808 	add.w	r8, r8, #8
  4174fc:	b177      	cbz	r7, 41751c <_svfprintf_r+0x2fc>
  4174fe:	9b26      	ldr	r3, [sp, #152]	; 0x98
  417500:	3301      	adds	r3, #1
  417502:	3401      	adds	r4, #1
  417504:	f10d 0177 	add.w	r1, sp, #119	; 0x77
  417508:	2201      	movs	r2, #1
  41750a:	2b07      	cmp	r3, #7
  41750c:	9427      	str	r4, [sp, #156]	; 0x9c
  41750e:	9326      	str	r3, [sp, #152]	; 0x98
  417510:	e888 0006 	stmia.w	r8, {r1, r2}
  417514:	f300 83db 	bgt.w	417cce <_svfprintf_r+0xaae>
  417518:	f108 0808 	add.w	r8, r8, #8
  41751c:	9b10      	ldr	r3, [sp, #64]	; 0x40
  41751e:	b16b      	cbz	r3, 41753c <_svfprintf_r+0x31c>
  417520:	9b26      	ldr	r3, [sp, #152]	; 0x98
  417522:	3301      	adds	r3, #1
  417524:	3402      	adds	r4, #2
  417526:	a91e      	add	r1, sp, #120	; 0x78
  417528:	2202      	movs	r2, #2
  41752a:	2b07      	cmp	r3, #7
  41752c:	9427      	str	r4, [sp, #156]	; 0x9c
  41752e:	9326      	str	r3, [sp, #152]	; 0x98
  417530:	e888 0006 	stmia.w	r8, {r1, r2}
  417534:	f300 83d6 	bgt.w	417ce4 <_svfprintf_r+0xac4>
  417538:	f108 0808 	add.w	r8, r8, #8
  41753c:	2d80      	cmp	r5, #128	; 0x80
  41753e:	f000 8315 	beq.w	417b6c <_svfprintf_r+0x94c>
  417542:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  417544:	9a0e      	ldr	r2, [sp, #56]	; 0x38
  417546:	1a9f      	subs	r7, r3, r2
  417548:	2f00      	cmp	r7, #0
  41754a:	dd36      	ble.n	4175ba <_svfprintf_r+0x39a>
  41754c:	2f10      	cmp	r7, #16
  41754e:	9b26      	ldr	r3, [sp, #152]	; 0x98
  417550:	4d8e      	ldr	r5, [pc, #568]	; (41778c <_svfprintf_r+0x56c>)
  417552:	dd27      	ble.n	4175a4 <_svfprintf_r+0x384>
  417554:	4642      	mov	r2, r8
  417556:	4621      	mov	r1, r4
  417558:	46b0      	mov	r8, r6
  41755a:	f04f 0b10 	mov.w	fp, #16
  41755e:	462e      	mov	r6, r5
  417560:	9c0c      	ldr	r4, [sp, #48]	; 0x30
  417562:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
  417564:	e004      	b.n	417570 <_svfprintf_r+0x350>
  417566:	3f10      	subs	r7, #16
  417568:	2f10      	cmp	r7, #16
  41756a:	f102 0208 	add.w	r2, r2, #8
  41756e:	dd15      	ble.n	41759c <_svfprintf_r+0x37c>
  417570:	3301      	adds	r3, #1
  417572:	3110      	adds	r1, #16
  417574:	2b07      	cmp	r3, #7
  417576:	9127      	str	r1, [sp, #156]	; 0x9c
  417578:	9326      	str	r3, [sp, #152]	; 0x98
  41757a:	e882 0840 	stmia.w	r2, {r6, fp}
  41757e:	ddf2      	ble.n	417566 <_svfprintf_r+0x346>
  417580:	aa25      	add	r2, sp, #148	; 0x94
  417582:	4629      	mov	r1, r5
  417584:	4620      	mov	r0, r4
  417586:	f004 fd69 	bl	41c05c <__ssprint_r>
  41758a:	2800      	cmp	r0, #0
  41758c:	f47f af1a 	bne.w	4173c4 <_svfprintf_r+0x1a4>
  417590:	3f10      	subs	r7, #16
  417592:	2f10      	cmp	r7, #16
  417594:	9927      	ldr	r1, [sp, #156]	; 0x9c
  417596:	9b26      	ldr	r3, [sp, #152]	; 0x98
  417598:	464a      	mov	r2, r9
  41759a:	dce9      	bgt.n	417570 <_svfprintf_r+0x350>
  41759c:	4635      	mov	r5, r6
  41759e:	460c      	mov	r4, r1
  4175a0:	4646      	mov	r6, r8
  4175a2:	4690      	mov	r8, r2
  4175a4:	3301      	adds	r3, #1
  4175a6:	443c      	add	r4, r7
  4175a8:	2b07      	cmp	r3, #7
  4175aa:	9427      	str	r4, [sp, #156]	; 0x9c
  4175ac:	9326      	str	r3, [sp, #152]	; 0x98
  4175ae:	e888 00a0 	stmia.w	r8, {r5, r7}
  4175b2:	f300 8381 	bgt.w	417cb8 <_svfprintf_r+0xa98>
  4175b6:	f108 0808 	add.w	r8, r8, #8
  4175ba:	9b07      	ldr	r3, [sp, #28]
  4175bc:	05df      	lsls	r7, r3, #23
  4175be:	f100 8268 	bmi.w	417a92 <_svfprintf_r+0x872>
  4175c2:	9b26      	ldr	r3, [sp, #152]	; 0x98
  4175c4:	990e      	ldr	r1, [sp, #56]	; 0x38
  4175c6:	f8c8 6000 	str.w	r6, [r8]
  4175ca:	3301      	adds	r3, #1
  4175cc:	440c      	add	r4, r1
  4175ce:	2b07      	cmp	r3, #7
  4175d0:	9427      	str	r4, [sp, #156]	; 0x9c
  4175d2:	f8c8 1004 	str.w	r1, [r8, #4]
  4175d6:	9326      	str	r3, [sp, #152]	; 0x98
  4175d8:	f300 834d 	bgt.w	417c76 <_svfprintf_r+0xa56>
  4175dc:	f108 0808 	add.w	r8, r8, #8
  4175e0:	9b07      	ldr	r3, [sp, #28]
  4175e2:	075b      	lsls	r3, r3, #29
  4175e4:	d53a      	bpl.n	41765c <_svfprintf_r+0x43c>
  4175e6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  4175e8:	9a08      	ldr	r2, [sp, #32]
  4175ea:	1a9d      	subs	r5, r3, r2
  4175ec:	2d00      	cmp	r5, #0
  4175ee:	dd35      	ble.n	41765c <_svfprintf_r+0x43c>
  4175f0:	2d10      	cmp	r5, #16
  4175f2:	9b26      	ldr	r3, [sp, #152]	; 0x98
  4175f4:	dd20      	ble.n	417638 <_svfprintf_r+0x418>
  4175f6:	2610      	movs	r6, #16
  4175f8:	9f0c      	ldr	r7, [sp, #48]	; 0x30
  4175fa:	f8dd b02c 	ldr.w	fp, [sp, #44]	; 0x2c
  4175fe:	e004      	b.n	41760a <_svfprintf_r+0x3ea>
  417600:	3d10      	subs	r5, #16
  417602:	2d10      	cmp	r5, #16
  417604:	f108 0808 	add.w	r8, r8, #8
  417608:	dd16      	ble.n	417638 <_svfprintf_r+0x418>
  41760a:	3301      	adds	r3, #1
  41760c:	4a5e      	ldr	r2, [pc, #376]	; (417788 <_svfprintf_r+0x568>)
  41760e:	9326      	str	r3, [sp, #152]	; 0x98
  417610:	3410      	adds	r4, #16
  417612:	2b07      	cmp	r3, #7
  417614:	9427      	str	r4, [sp, #156]	; 0x9c
  417616:	e888 0044 	stmia.w	r8, {r2, r6}
  41761a:	ddf1      	ble.n	417600 <_svfprintf_r+0x3e0>
  41761c:	aa25      	add	r2, sp, #148	; 0x94
  41761e:	4659      	mov	r1, fp
  417620:	4638      	mov	r0, r7
  417622:	f004 fd1b 	bl	41c05c <__ssprint_r>
  417626:	2800      	cmp	r0, #0
  417628:	f47f aecc 	bne.w	4173c4 <_svfprintf_r+0x1a4>
  41762c:	3d10      	subs	r5, #16
  41762e:	2d10      	cmp	r5, #16
  417630:	9c27      	ldr	r4, [sp, #156]	; 0x9c
  417632:	9b26      	ldr	r3, [sp, #152]	; 0x98
  417634:	46c8      	mov	r8, r9
  417636:	dce8      	bgt.n	41760a <_svfprintf_r+0x3ea>
  417638:	3301      	adds	r3, #1
  41763a:	4a53      	ldr	r2, [pc, #332]	; (417788 <_svfprintf_r+0x568>)
  41763c:	9326      	str	r3, [sp, #152]	; 0x98
  41763e:	442c      	add	r4, r5
  417640:	2b07      	cmp	r3, #7
  417642:	9427      	str	r4, [sp, #156]	; 0x9c
  417644:	e888 0024 	stmia.w	r8, {r2, r5}
  417648:	dd08      	ble.n	41765c <_svfprintf_r+0x43c>
  41764a:	aa25      	add	r2, sp, #148	; 0x94
  41764c:	990b      	ldr	r1, [sp, #44]	; 0x2c
  41764e:	980c      	ldr	r0, [sp, #48]	; 0x30
  417650:	f004 fd04 	bl	41c05c <__ssprint_r>
  417654:	2800      	cmp	r0, #0
  417656:	f47f aeb5 	bne.w	4173c4 <_svfprintf_r+0x1a4>
  41765a:	9c27      	ldr	r4, [sp, #156]	; 0x9c
  41765c:	9b09      	ldr	r3, [sp, #36]	; 0x24
  41765e:	9a0d      	ldr	r2, [sp, #52]	; 0x34
  417660:	9908      	ldr	r1, [sp, #32]
  417662:	428a      	cmp	r2, r1
  417664:	bfac      	ite	ge
  417666:	189b      	addge	r3, r3, r2
  417668:	185b      	addlt	r3, r3, r1
  41766a:	9309      	str	r3, [sp, #36]	; 0x24
  41766c:	2c00      	cmp	r4, #0
  41766e:	f040 830d 	bne.w	417c8c <_svfprintf_r+0xa6c>
  417672:	2300      	movs	r3, #0
  417674:	9326      	str	r3, [sp, #152]	; 0x98
  417676:	46c8      	mov	r8, r9
  417678:	e5f9      	b.n	41726e <_svfprintf_r+0x4e>
  41767a:	9311      	str	r3, [sp, #68]	; 0x44
  41767c:	f01b 0320 	ands.w	r3, fp, #32
  417680:	f040 81e3 	bne.w	417a4a <_svfprintf_r+0x82a>
  417684:	f01b 0210 	ands.w	r2, fp, #16
  417688:	f040 842e 	bne.w	417ee8 <_svfprintf_r+0xcc8>
  41768c:	f01b 0340 	ands.w	r3, fp, #64	; 0x40
  417690:	f000 842a 	beq.w	417ee8 <_svfprintf_r+0xcc8>
  417694:	990f      	ldr	r1, [sp, #60]	; 0x3c
  417696:	4613      	mov	r3, r2
  417698:	460a      	mov	r2, r1
  41769a:	3204      	adds	r2, #4
  41769c:	880c      	ldrh	r4, [r1, #0]
  41769e:	920f      	str	r2, [sp, #60]	; 0x3c
  4176a0:	2500      	movs	r5, #0
  4176a2:	e6b0      	b.n	417406 <_svfprintf_r+0x1e6>
  4176a4:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
  4176a6:	9311      	str	r3, [sp, #68]	; 0x44
  4176a8:	6816      	ldr	r6, [r2, #0]
  4176aa:	2400      	movs	r4, #0
  4176ac:	f88d 4077 	strb.w	r4, [sp, #119]	; 0x77
  4176b0:	1d15      	adds	r5, r2, #4
  4176b2:	2e00      	cmp	r6, #0
  4176b4:	f000 86a7 	beq.w	418406 <_svfprintf_r+0x11e6>
  4176b8:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  4176ba:	1c53      	adds	r3, r2, #1
  4176bc:	f000 8609 	beq.w	4182d2 <_svfprintf_r+0x10b2>
  4176c0:	4621      	mov	r1, r4
  4176c2:	4630      	mov	r0, r6
  4176c4:	f003 feec 	bl	41b4a0 <memchr>
  4176c8:	2800      	cmp	r0, #0
  4176ca:	f000 86e1 	beq.w	418490 <_svfprintf_r+0x1270>
  4176ce:	1b83      	subs	r3, r0, r6
  4176d0:	930e      	str	r3, [sp, #56]	; 0x38
  4176d2:	940a      	str	r4, [sp, #40]	; 0x28
  4176d4:	950f      	str	r5, [sp, #60]	; 0x3c
  4176d6:	f8cd b01c 	str.w	fp, [sp, #28]
  4176da:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
  4176de:	9308      	str	r3, [sp, #32]
  4176e0:	9412      	str	r4, [sp, #72]	; 0x48
  4176e2:	f89d 7077 	ldrb.w	r7, [sp, #119]	; 0x77
  4176e6:	e6b3      	b.n	417450 <_svfprintf_r+0x230>
  4176e8:	f89a 3000 	ldrb.w	r3, [sl]
  4176ec:	2201      	movs	r2, #1
  4176ee:	212b      	movs	r1, #43	; 0x2b
  4176f0:	e5ee      	b.n	4172d0 <_svfprintf_r+0xb0>
  4176f2:	f04b 0b20 	orr.w	fp, fp, #32
  4176f6:	f89a 3000 	ldrb.w	r3, [sl]
  4176fa:	e5e9      	b.n	4172d0 <_svfprintf_r+0xb0>
  4176fc:	9311      	str	r3, [sp, #68]	; 0x44
  4176fe:	2a00      	cmp	r2, #0
  417700:	f040 8795 	bne.w	41862e <_svfprintf_r+0x140e>
  417704:	4b22      	ldr	r3, [pc, #136]	; (417790 <_svfprintf_r+0x570>)
  417706:	9318      	str	r3, [sp, #96]	; 0x60
  417708:	f01b 0f20 	tst.w	fp, #32
  41770c:	f040 8111 	bne.w	417932 <_svfprintf_r+0x712>
  417710:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
  417712:	f01b 0f10 	tst.w	fp, #16
  417716:	4613      	mov	r3, r2
  417718:	f040 83e1 	bne.w	417ede <_svfprintf_r+0xcbe>
  41771c:	f01b 0f40 	tst.w	fp, #64	; 0x40
  417720:	f000 83dd 	beq.w	417ede <_svfprintf_r+0xcbe>
  417724:	3304      	adds	r3, #4
  417726:	8814      	ldrh	r4, [r2, #0]
  417728:	930f      	str	r3, [sp, #60]	; 0x3c
  41772a:	2500      	movs	r5, #0
  41772c:	f01b 0f01 	tst.w	fp, #1
  417730:	f000 810c 	beq.w	41794c <_svfprintf_r+0x72c>
  417734:	ea54 0305 	orrs.w	r3, r4, r5
  417738:	f000 8108 	beq.w	41794c <_svfprintf_r+0x72c>
  41773c:	2330      	movs	r3, #48	; 0x30
  41773e:	f89d 2044 	ldrb.w	r2, [sp, #68]	; 0x44
  417742:	f88d 3078 	strb.w	r3, [sp, #120]	; 0x78
  417746:	f88d 2079 	strb.w	r2, [sp, #121]	; 0x79
  41774a:	f04b 0b02 	orr.w	fp, fp, #2
  41774e:	2302      	movs	r3, #2
  417750:	e659      	b.n	417406 <_svfprintf_r+0x1e6>
  417752:	f89a 3000 	ldrb.w	r3, [sl]
  417756:	2900      	cmp	r1, #0
  417758:	f47f adba 	bne.w	4172d0 <_svfprintf_r+0xb0>
  41775c:	2201      	movs	r2, #1
  41775e:	2120      	movs	r1, #32
  417760:	e5b6      	b.n	4172d0 <_svfprintf_r+0xb0>
  417762:	f04b 0b01 	orr.w	fp, fp, #1
  417766:	f89a 3000 	ldrb.w	r3, [sl]
  41776a:	e5b1      	b.n	4172d0 <_svfprintf_r+0xb0>
  41776c:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
  41776e:	6823      	ldr	r3, [r4, #0]
  417770:	930d      	str	r3, [sp, #52]	; 0x34
  417772:	4618      	mov	r0, r3
  417774:	2800      	cmp	r0, #0
  417776:	4623      	mov	r3, r4
  417778:	f103 0304 	add.w	r3, r3, #4
  41777c:	f6ff ae0a 	blt.w	417394 <_svfprintf_r+0x174>
  417780:	930f      	str	r3, [sp, #60]	; 0x3c
  417782:	f89a 3000 	ldrb.w	r3, [sl]
  417786:	e5a3      	b.n	4172d0 <_svfprintf_r+0xb0>
  417788:	0041ea14 	.word	0x0041ea14
  41778c:	0041ea24 	.word	0x0041ea24
  417790:	0041e9f4 	.word	0x0041e9f4
  417794:	f04b 0b10 	orr.w	fp, fp, #16
  417798:	f01b 0f20 	tst.w	fp, #32
  41779c:	9311      	str	r3, [sp, #68]	; 0x44
  41779e:	f43f ae23 	beq.w	4173e8 <_svfprintf_r+0x1c8>
  4177a2:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
  4177a4:	3507      	adds	r5, #7
  4177a6:	f025 0307 	bic.w	r3, r5, #7
  4177aa:	f103 0208 	add.w	r2, r3, #8
  4177ae:	e9d3 4500 	ldrd	r4, r5, [r3]
  4177b2:	920f      	str	r2, [sp, #60]	; 0x3c
  4177b4:	2301      	movs	r3, #1
  4177b6:	e626      	b.n	417406 <_svfprintf_r+0x1e6>
  4177b8:	f89a 3000 	ldrb.w	r3, [sl]
  4177bc:	2b2a      	cmp	r3, #42	; 0x2a
  4177be:	f10a 0401 	add.w	r4, sl, #1
  4177c2:	f000 8727 	beq.w	418614 <_svfprintf_r+0x13f4>
  4177c6:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
  4177ca:	2809      	cmp	r0, #9
  4177cc:	46a2      	mov	sl, r4
  4177ce:	f200 86ad 	bhi.w	41852c <_svfprintf_r+0x130c>
  4177d2:	2300      	movs	r3, #0
  4177d4:	461c      	mov	r4, r3
  4177d6:	f81a 3b01 	ldrb.w	r3, [sl], #1
  4177da:	eb04 0484 	add.w	r4, r4, r4, lsl #2
  4177de:	eb00 0444 	add.w	r4, r0, r4, lsl #1
  4177e2:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
  4177e6:	2809      	cmp	r0, #9
  4177e8:	d9f5      	bls.n	4177d6 <_svfprintf_r+0x5b6>
  4177ea:	940a      	str	r4, [sp, #40]	; 0x28
  4177ec:	e572      	b.n	4172d4 <_svfprintf_r+0xb4>
  4177ee:	f04b 0b80 	orr.w	fp, fp, #128	; 0x80
  4177f2:	f89a 3000 	ldrb.w	r3, [sl]
  4177f6:	e56b      	b.n	4172d0 <_svfprintf_r+0xb0>
  4177f8:	f04b 0b40 	orr.w	fp, fp, #64	; 0x40
  4177fc:	f89a 3000 	ldrb.w	r3, [sl]
  417800:	e566      	b.n	4172d0 <_svfprintf_r+0xb0>
  417802:	f89a 3000 	ldrb.w	r3, [sl]
  417806:	2b6c      	cmp	r3, #108	; 0x6c
  417808:	bf03      	ittte	eq
  41780a:	f89a 3001 	ldrbeq.w	r3, [sl, #1]
  41780e:	f04b 0b20 	orreq.w	fp, fp, #32
  417812:	f10a 0a01 	addeq.w	sl, sl, #1
  417816:	f04b 0b10 	orrne.w	fp, fp, #16
  41781a:	e559      	b.n	4172d0 <_svfprintf_r+0xb0>
  41781c:	2a00      	cmp	r2, #0
  41781e:	f040 8711 	bne.w	418644 <_svfprintf_r+0x1424>
  417822:	f01b 0f20 	tst.w	fp, #32
  417826:	f040 84f9 	bne.w	41821c <_svfprintf_r+0xffc>
  41782a:	f01b 0f10 	tst.w	fp, #16
  41782e:	f040 84ac 	bne.w	41818a <_svfprintf_r+0xf6a>
  417832:	f01b 0f40 	tst.w	fp, #64	; 0x40
  417836:	f000 84a8 	beq.w	41818a <_svfprintf_r+0xf6a>
  41783a:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
  41783c:	6813      	ldr	r3, [r2, #0]
  41783e:	3204      	adds	r2, #4
  417840:	920f      	str	r2, [sp, #60]	; 0x3c
  417842:	f8bd 2024 	ldrh.w	r2, [sp, #36]	; 0x24
  417846:	801a      	strh	r2, [r3, #0]
  417848:	e511      	b.n	41726e <_svfprintf_r+0x4e>
  41784a:	990f      	ldr	r1, [sp, #60]	; 0x3c
  41784c:	4bb3      	ldr	r3, [pc, #716]	; (417b1c <_svfprintf_r+0x8fc>)
  41784e:	680c      	ldr	r4, [r1, #0]
  417850:	9318      	str	r3, [sp, #96]	; 0x60
  417852:	2230      	movs	r2, #48	; 0x30
  417854:	2378      	movs	r3, #120	; 0x78
  417856:	3104      	adds	r1, #4
  417858:	f88d 3079 	strb.w	r3, [sp, #121]	; 0x79
  41785c:	9311      	str	r3, [sp, #68]	; 0x44
  41785e:	f04b 0b02 	orr.w	fp, fp, #2
  417862:	910f      	str	r1, [sp, #60]	; 0x3c
  417864:	2500      	movs	r5, #0
  417866:	f88d 2078 	strb.w	r2, [sp, #120]	; 0x78
  41786a:	2302      	movs	r3, #2
  41786c:	e5cb      	b.n	417406 <_svfprintf_r+0x1e6>
  41786e:	990f      	ldr	r1, [sp, #60]	; 0x3c
  417870:	9311      	str	r3, [sp, #68]	; 0x44
  417872:	680a      	ldr	r2, [r1, #0]
  417874:	f88d 20a0 	strb.w	r2, [sp, #160]	; 0xa0
  417878:	2300      	movs	r3, #0
  41787a:	460a      	mov	r2, r1
  41787c:	461f      	mov	r7, r3
  41787e:	f88d 3077 	strb.w	r3, [sp, #119]	; 0x77
  417882:	3204      	adds	r2, #4
  417884:	2301      	movs	r3, #1
  417886:	9308      	str	r3, [sp, #32]
  417888:	f8cd b01c 	str.w	fp, [sp, #28]
  41788c:	970a      	str	r7, [sp, #40]	; 0x28
  41788e:	9712      	str	r7, [sp, #72]	; 0x48
  417890:	920f      	str	r2, [sp, #60]	; 0x3c
  417892:	930e      	str	r3, [sp, #56]	; 0x38
  417894:	ae28      	add	r6, sp, #160	; 0xa0
  417896:	e5df      	b.n	417458 <_svfprintf_r+0x238>
  417898:	9311      	str	r3, [sp, #68]	; 0x44
  41789a:	2a00      	cmp	r2, #0
  41789c:	f040 86ea 	bne.w	418674 <_svfprintf_r+0x1454>
  4178a0:	f01b 0f20 	tst.w	fp, #32
  4178a4:	d15d      	bne.n	417962 <_svfprintf_r+0x742>
  4178a6:	f01b 0f10 	tst.w	fp, #16
  4178aa:	f040 8308 	bne.w	417ebe <_svfprintf_r+0xc9e>
  4178ae:	f01b 0f40 	tst.w	fp, #64	; 0x40
  4178b2:	f000 8304 	beq.w	417ebe <_svfprintf_r+0xc9e>
  4178b6:	990f      	ldr	r1, [sp, #60]	; 0x3c
  4178b8:	f9b1 4000 	ldrsh.w	r4, [r1]
  4178bc:	3104      	adds	r1, #4
  4178be:	17e5      	asrs	r5, r4, #31
  4178c0:	4622      	mov	r2, r4
  4178c2:	462b      	mov	r3, r5
  4178c4:	910f      	str	r1, [sp, #60]	; 0x3c
  4178c6:	2a00      	cmp	r2, #0
  4178c8:	f173 0300 	sbcs.w	r3, r3, #0
  4178cc:	db58      	blt.n	417980 <_svfprintf_r+0x760>
  4178ce:	990a      	ldr	r1, [sp, #40]	; 0x28
  4178d0:	f89d 7077 	ldrb.w	r7, [sp, #119]	; 0x77
  4178d4:	1c4a      	adds	r2, r1, #1
  4178d6:	f04f 0301 	mov.w	r3, #1
  4178da:	f47f ad9b 	bne.w	417414 <_svfprintf_r+0x1f4>
  4178de:	ea54 0205 	orrs.w	r2, r4, r5
  4178e2:	f000 81df 	beq.w	417ca4 <_svfprintf_r+0xa84>
  4178e6:	f8cd b01c 	str.w	fp, [sp, #28]
  4178ea:	2b01      	cmp	r3, #1
  4178ec:	f000 827b 	beq.w	417de6 <_svfprintf_r+0xbc6>
  4178f0:	2b02      	cmp	r3, #2
  4178f2:	f040 8206 	bne.w	417d02 <_svfprintf_r+0xae2>
  4178f6:	9818      	ldr	r0, [sp, #96]	; 0x60
  4178f8:	464e      	mov	r6, r9
  4178fa:	0923      	lsrs	r3, r4, #4
  4178fc:	f004 010f 	and.w	r1, r4, #15
  417900:	ea43 7305 	orr.w	r3, r3, r5, lsl #28
  417904:	092a      	lsrs	r2, r5, #4
  417906:	461c      	mov	r4, r3
  417908:	4615      	mov	r5, r2
  41790a:	5c43      	ldrb	r3, [r0, r1]
  41790c:	f806 3d01 	strb.w	r3, [r6, #-1]!
  417910:	ea54 0305 	orrs.w	r3, r4, r5
  417914:	d1f1      	bne.n	4178fa <_svfprintf_r+0x6da>
  417916:	eba9 0306 	sub.w	r3, r9, r6
  41791a:	930e      	str	r3, [sp, #56]	; 0x38
  41791c:	e590      	b.n	417440 <_svfprintf_r+0x220>
  41791e:	9311      	str	r3, [sp, #68]	; 0x44
  417920:	2a00      	cmp	r2, #0
  417922:	f040 86a3 	bne.w	41866c <_svfprintf_r+0x144c>
  417926:	4b7e      	ldr	r3, [pc, #504]	; (417b20 <_svfprintf_r+0x900>)
  417928:	9318      	str	r3, [sp, #96]	; 0x60
  41792a:	f01b 0f20 	tst.w	fp, #32
  41792e:	f43f aeef 	beq.w	417710 <_svfprintf_r+0x4f0>
  417932:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
  417934:	3507      	adds	r5, #7
  417936:	f025 0307 	bic.w	r3, r5, #7
  41793a:	f103 0208 	add.w	r2, r3, #8
  41793e:	f01b 0f01 	tst.w	fp, #1
  417942:	920f      	str	r2, [sp, #60]	; 0x3c
  417944:	e9d3 4500 	ldrd	r4, r5, [r3]
  417948:	f47f aef4 	bne.w	417734 <_svfprintf_r+0x514>
  41794c:	2302      	movs	r3, #2
  41794e:	e55a      	b.n	417406 <_svfprintf_r+0x1e6>
  417950:	9311      	str	r3, [sp, #68]	; 0x44
  417952:	2a00      	cmp	r2, #0
  417954:	f040 8686 	bne.w	418664 <_svfprintf_r+0x1444>
  417958:	f04b 0b10 	orr.w	fp, fp, #16
  41795c:	f01b 0f20 	tst.w	fp, #32
  417960:	d0a1      	beq.n	4178a6 <_svfprintf_r+0x686>
  417962:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
  417964:	3507      	adds	r5, #7
  417966:	f025 0507 	bic.w	r5, r5, #7
  41796a:	e9d5 2300 	ldrd	r2, r3, [r5]
  41796e:	2a00      	cmp	r2, #0
  417970:	f105 0108 	add.w	r1, r5, #8
  417974:	461d      	mov	r5, r3
  417976:	f173 0300 	sbcs.w	r3, r3, #0
  41797a:	910f      	str	r1, [sp, #60]	; 0x3c
  41797c:	4614      	mov	r4, r2
  41797e:	daa6      	bge.n	4178ce <_svfprintf_r+0x6ae>
  417980:	272d      	movs	r7, #45	; 0x2d
  417982:	4264      	negs	r4, r4
  417984:	eb65 0545 	sbc.w	r5, r5, r5, lsl #1
  417988:	f88d 7077 	strb.w	r7, [sp, #119]	; 0x77
  41798c:	2301      	movs	r3, #1
  41798e:	e53d      	b.n	41740c <_svfprintf_r+0x1ec>
  417990:	9311      	str	r3, [sp, #68]	; 0x44
  417992:	2a00      	cmp	r2, #0
  417994:	f040 8662 	bne.w	41865c <_svfprintf_r+0x143c>
  417998:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
  41799a:	3507      	adds	r5, #7
  41799c:	f025 0307 	bic.w	r3, r5, #7
  4179a0:	f103 0208 	add.w	r2, r3, #8
  4179a4:	920f      	str	r2, [sp, #60]	; 0x3c
  4179a6:	681a      	ldr	r2, [r3, #0]
  4179a8:	9215      	str	r2, [sp, #84]	; 0x54
  4179aa:	685b      	ldr	r3, [r3, #4]
  4179ac:	9314      	str	r3, [sp, #80]	; 0x50
  4179ae:	9b14      	ldr	r3, [sp, #80]	; 0x50
  4179b0:	9d15      	ldr	r5, [sp, #84]	; 0x54
  4179b2:	f023 4400 	bic.w	r4, r3, #2147483648	; 0x80000000
  4179b6:	4628      	mov	r0, r5
  4179b8:	4621      	mov	r1, r4
  4179ba:	f04f 32ff 	mov.w	r2, #4294967295
  4179be:	4b59      	ldr	r3, [pc, #356]	; (417b24 <_svfprintf_r+0x904>)
  4179c0:	f004 fdc8 	bl	41c554 <__aeabi_dcmpun>
  4179c4:	2800      	cmp	r0, #0
  4179c6:	f040 834a 	bne.w	41805e <_svfprintf_r+0xe3e>
  4179ca:	4628      	mov	r0, r5
  4179cc:	4621      	mov	r1, r4
  4179ce:	f04f 32ff 	mov.w	r2, #4294967295
  4179d2:	4b54      	ldr	r3, [pc, #336]	; (417b24 <_svfprintf_r+0x904>)
  4179d4:	f7ff f8ec 	bl	416bb0 <__aeabi_dcmple>
  4179d8:	2800      	cmp	r0, #0
  4179da:	f040 8340 	bne.w	41805e <_svfprintf_r+0xe3e>
  4179de:	a815      	add	r0, sp, #84	; 0x54
  4179e0:	c80d      	ldmia	r0, {r0, r2, r3}
  4179e2:	9914      	ldr	r1, [sp, #80]	; 0x50
  4179e4:	f7ff f8da 	bl	416b9c <__aeabi_dcmplt>
  4179e8:	2800      	cmp	r0, #0
  4179ea:	f040 8530 	bne.w	41844e <_svfprintf_r+0x122e>
  4179ee:	f89d 7077 	ldrb.w	r7, [sp, #119]	; 0x77
  4179f2:	4e4d      	ldr	r6, [pc, #308]	; (417b28 <_svfprintf_r+0x908>)
  4179f4:	4b4d      	ldr	r3, [pc, #308]	; (417b2c <_svfprintf_r+0x90c>)
  4179f6:	f02b 0080 	bic.w	r0, fp, #128	; 0x80
  4179fa:	9007      	str	r0, [sp, #28]
  4179fc:	9811      	ldr	r0, [sp, #68]	; 0x44
  4179fe:	2203      	movs	r2, #3
  417a00:	2100      	movs	r1, #0
  417a02:	9208      	str	r2, [sp, #32]
  417a04:	910a      	str	r1, [sp, #40]	; 0x28
  417a06:	2847      	cmp	r0, #71	; 0x47
  417a08:	bfd8      	it	le
  417a0a:	461e      	movle	r6, r3
  417a0c:	920e      	str	r2, [sp, #56]	; 0x38
  417a0e:	9112      	str	r1, [sp, #72]	; 0x48
  417a10:	e51e      	b.n	417450 <_svfprintf_r+0x230>
  417a12:	f04b 0b08 	orr.w	fp, fp, #8
  417a16:	f89a 3000 	ldrb.w	r3, [sl]
  417a1a:	e459      	b.n	4172d0 <_svfprintf_r+0xb0>
  417a1c:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
  417a20:	2300      	movs	r3, #0
  417a22:	461c      	mov	r4, r3
  417a24:	f81a 3b01 	ldrb.w	r3, [sl], #1
  417a28:	eb04 0484 	add.w	r4, r4, r4, lsl #2
  417a2c:	eb00 0444 	add.w	r4, r0, r4, lsl #1
  417a30:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
  417a34:	2809      	cmp	r0, #9
  417a36:	d9f5      	bls.n	417a24 <_svfprintf_r+0x804>
  417a38:	940d      	str	r4, [sp, #52]	; 0x34
  417a3a:	e44b      	b.n	4172d4 <_svfprintf_r+0xb4>
  417a3c:	f04b 0b10 	orr.w	fp, fp, #16
  417a40:	9311      	str	r3, [sp, #68]	; 0x44
  417a42:	f01b 0320 	ands.w	r3, fp, #32
  417a46:	f43f ae1d 	beq.w	417684 <_svfprintf_r+0x464>
  417a4a:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
  417a4c:	3507      	adds	r5, #7
  417a4e:	f025 0307 	bic.w	r3, r5, #7
  417a52:	f103 0208 	add.w	r2, r3, #8
  417a56:	e9d3 4500 	ldrd	r4, r5, [r3]
  417a5a:	920f      	str	r2, [sp, #60]	; 0x3c
  417a5c:	2300      	movs	r3, #0
  417a5e:	e4d2      	b.n	417406 <_svfprintf_r+0x1e6>
  417a60:	9311      	str	r3, [sp, #68]	; 0x44
  417a62:	2a00      	cmp	r2, #0
  417a64:	f040 85e7 	bne.w	418636 <_svfprintf_r+0x1416>
  417a68:	9a11      	ldr	r2, [sp, #68]	; 0x44
  417a6a:	2a00      	cmp	r2, #0
  417a6c:	f43f aca3 	beq.w	4173b6 <_svfprintf_r+0x196>
  417a70:	2300      	movs	r3, #0
  417a72:	2101      	movs	r1, #1
  417a74:	461f      	mov	r7, r3
  417a76:	9108      	str	r1, [sp, #32]
  417a78:	f88d 20a0 	strb.w	r2, [sp, #160]	; 0xa0
  417a7c:	f8cd b01c 	str.w	fp, [sp, #28]
  417a80:	f88d 3077 	strb.w	r3, [sp, #119]	; 0x77
  417a84:	930a      	str	r3, [sp, #40]	; 0x28
  417a86:	9312      	str	r3, [sp, #72]	; 0x48
  417a88:	910e      	str	r1, [sp, #56]	; 0x38
  417a8a:	ae28      	add	r6, sp, #160	; 0xa0
  417a8c:	e4e4      	b.n	417458 <_svfprintf_r+0x238>
  417a8e:	9c27      	ldr	r4, [sp, #156]	; 0x9c
  417a90:	e534      	b.n	4174fc <_svfprintf_r+0x2dc>
  417a92:	9b11      	ldr	r3, [sp, #68]	; 0x44
  417a94:	2b65      	cmp	r3, #101	; 0x65
  417a96:	f340 80a7 	ble.w	417be8 <_svfprintf_r+0x9c8>
  417a9a:	a815      	add	r0, sp, #84	; 0x54
  417a9c:	c80d      	ldmia	r0, {r0, r2, r3}
  417a9e:	9914      	ldr	r1, [sp, #80]	; 0x50
  417aa0:	f7ff f872 	bl	416b88 <__aeabi_dcmpeq>
  417aa4:	2800      	cmp	r0, #0
  417aa6:	f000 8150 	beq.w	417d4a <_svfprintf_r+0xb2a>
  417aaa:	9b26      	ldr	r3, [sp, #152]	; 0x98
  417aac:	4a20      	ldr	r2, [pc, #128]	; (417b30 <_svfprintf_r+0x910>)
  417aae:	f8c8 2000 	str.w	r2, [r8]
  417ab2:	3301      	adds	r3, #1
  417ab4:	3401      	adds	r4, #1
  417ab6:	2201      	movs	r2, #1
  417ab8:	2b07      	cmp	r3, #7
  417aba:	9427      	str	r4, [sp, #156]	; 0x9c
  417abc:	9326      	str	r3, [sp, #152]	; 0x98
  417abe:	f8c8 2004 	str.w	r2, [r8, #4]
  417ac2:	f300 836a 	bgt.w	41819a <_svfprintf_r+0xf7a>
  417ac6:	f108 0808 	add.w	r8, r8, #8
  417aca:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
  417acc:	9a13      	ldr	r2, [sp, #76]	; 0x4c
  417ace:	9c27      	ldr	r4, [sp, #156]	; 0x9c
  417ad0:	4293      	cmp	r3, r2
  417ad2:	db03      	blt.n	417adc <_svfprintf_r+0x8bc>
  417ad4:	9b07      	ldr	r3, [sp, #28]
  417ad6:	07dd      	lsls	r5, r3, #31
  417ad8:	f57f ad82 	bpl.w	4175e0 <_svfprintf_r+0x3c0>
  417adc:	9b26      	ldr	r3, [sp, #152]	; 0x98
  417ade:	9919      	ldr	r1, [sp, #100]	; 0x64
  417ae0:	9a1a      	ldr	r2, [sp, #104]	; 0x68
  417ae2:	f8c8 2000 	str.w	r2, [r8]
  417ae6:	3301      	adds	r3, #1
  417ae8:	440c      	add	r4, r1
  417aea:	2b07      	cmp	r3, #7
  417aec:	f8c8 1004 	str.w	r1, [r8, #4]
  417af0:	9427      	str	r4, [sp, #156]	; 0x9c
  417af2:	9326      	str	r3, [sp, #152]	; 0x98
  417af4:	f300 839e 	bgt.w	418234 <_svfprintf_r+0x1014>
  417af8:	f108 0808 	add.w	r8, r8, #8
  417afc:	9b13      	ldr	r3, [sp, #76]	; 0x4c
  417afe:	1e5e      	subs	r6, r3, #1
  417b00:	2e00      	cmp	r6, #0
  417b02:	f77f ad6d 	ble.w	4175e0 <_svfprintf_r+0x3c0>
  417b06:	2e10      	cmp	r6, #16
  417b08:	9b26      	ldr	r3, [sp, #152]	; 0x98
  417b0a:	4d0a      	ldr	r5, [pc, #40]	; (417b34 <_svfprintf_r+0x914>)
  417b0c:	f340 81f5 	ble.w	417efa <_svfprintf_r+0xcda>
  417b10:	4622      	mov	r2, r4
  417b12:	2710      	movs	r7, #16
  417b14:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
  417b18:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
  417b1a:	e013      	b.n	417b44 <_svfprintf_r+0x924>
  417b1c:	0041e9f4 	.word	0x0041e9f4
  417b20:	0041e9e0 	.word	0x0041e9e0
  417b24:	7fefffff 	.word	0x7fefffff
  417b28:	0041e9d4 	.word	0x0041e9d4
  417b2c:	0041e9d0 	.word	0x0041e9d0
  417b30:	0041ea10 	.word	0x0041ea10
  417b34:	0041ea24 	.word	0x0041ea24
  417b38:	f108 0808 	add.w	r8, r8, #8
  417b3c:	3e10      	subs	r6, #16
  417b3e:	2e10      	cmp	r6, #16
  417b40:	f340 81da 	ble.w	417ef8 <_svfprintf_r+0xcd8>
  417b44:	3301      	adds	r3, #1
  417b46:	3210      	adds	r2, #16
  417b48:	2b07      	cmp	r3, #7
  417b4a:	9227      	str	r2, [sp, #156]	; 0x9c
  417b4c:	9326      	str	r3, [sp, #152]	; 0x98
  417b4e:	e888 00a0 	stmia.w	r8, {r5, r7}
  417b52:	ddf1      	ble.n	417b38 <_svfprintf_r+0x918>
  417b54:	aa25      	add	r2, sp, #148	; 0x94
  417b56:	4621      	mov	r1, r4
  417b58:	4658      	mov	r0, fp
  417b5a:	f004 fa7f 	bl	41c05c <__ssprint_r>
  417b5e:	2800      	cmp	r0, #0
  417b60:	f47f ac30 	bne.w	4173c4 <_svfprintf_r+0x1a4>
  417b64:	9a27      	ldr	r2, [sp, #156]	; 0x9c
  417b66:	9b26      	ldr	r3, [sp, #152]	; 0x98
  417b68:	46c8      	mov	r8, r9
  417b6a:	e7e7      	b.n	417b3c <_svfprintf_r+0x91c>
  417b6c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  417b6e:	9a08      	ldr	r2, [sp, #32]
  417b70:	1a9f      	subs	r7, r3, r2
  417b72:	2f00      	cmp	r7, #0
  417b74:	f77f ace5 	ble.w	417542 <_svfprintf_r+0x322>
  417b78:	2f10      	cmp	r7, #16
  417b7a:	9b26      	ldr	r3, [sp, #152]	; 0x98
  417b7c:	4db6      	ldr	r5, [pc, #728]	; (417e58 <_svfprintf_r+0xc38>)
  417b7e:	dd27      	ble.n	417bd0 <_svfprintf_r+0x9b0>
  417b80:	4642      	mov	r2, r8
  417b82:	4621      	mov	r1, r4
  417b84:	46b0      	mov	r8, r6
  417b86:	f04f 0b10 	mov.w	fp, #16
  417b8a:	462e      	mov	r6, r5
  417b8c:	9c0c      	ldr	r4, [sp, #48]	; 0x30
  417b8e:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
  417b90:	e004      	b.n	417b9c <_svfprintf_r+0x97c>
  417b92:	3f10      	subs	r7, #16
  417b94:	2f10      	cmp	r7, #16
  417b96:	f102 0208 	add.w	r2, r2, #8
  417b9a:	dd15      	ble.n	417bc8 <_svfprintf_r+0x9a8>
  417b9c:	3301      	adds	r3, #1
  417b9e:	3110      	adds	r1, #16
  417ba0:	2b07      	cmp	r3, #7
  417ba2:	9127      	str	r1, [sp, #156]	; 0x9c
  417ba4:	9326      	str	r3, [sp, #152]	; 0x98
  417ba6:	e882 0840 	stmia.w	r2, {r6, fp}
  417baa:	ddf2      	ble.n	417b92 <_svfprintf_r+0x972>
  417bac:	aa25      	add	r2, sp, #148	; 0x94
  417bae:	4629      	mov	r1, r5
  417bb0:	4620      	mov	r0, r4
  417bb2:	f004 fa53 	bl	41c05c <__ssprint_r>
  417bb6:	2800      	cmp	r0, #0
  417bb8:	f47f ac04 	bne.w	4173c4 <_svfprintf_r+0x1a4>
  417bbc:	3f10      	subs	r7, #16
  417bbe:	2f10      	cmp	r7, #16
  417bc0:	9927      	ldr	r1, [sp, #156]	; 0x9c
  417bc2:	9b26      	ldr	r3, [sp, #152]	; 0x98
  417bc4:	464a      	mov	r2, r9
  417bc6:	dce9      	bgt.n	417b9c <_svfprintf_r+0x97c>
  417bc8:	4635      	mov	r5, r6
  417bca:	460c      	mov	r4, r1
  417bcc:	4646      	mov	r6, r8
  417bce:	4690      	mov	r8, r2
  417bd0:	3301      	adds	r3, #1
  417bd2:	443c      	add	r4, r7
  417bd4:	2b07      	cmp	r3, #7
  417bd6:	9427      	str	r4, [sp, #156]	; 0x9c
  417bd8:	9326      	str	r3, [sp, #152]	; 0x98
  417bda:	e888 00a0 	stmia.w	r8, {r5, r7}
  417bde:	f300 8232 	bgt.w	418046 <_svfprintf_r+0xe26>
  417be2:	f108 0808 	add.w	r8, r8, #8
  417be6:	e4ac      	b.n	417542 <_svfprintf_r+0x322>
  417be8:	9b13      	ldr	r3, [sp, #76]	; 0x4c
  417bea:	9f26      	ldr	r7, [sp, #152]	; 0x98
  417bec:	2b01      	cmp	r3, #1
  417bee:	f340 81fe 	ble.w	417fee <_svfprintf_r+0xdce>
  417bf2:	3701      	adds	r7, #1
  417bf4:	3401      	adds	r4, #1
  417bf6:	2301      	movs	r3, #1
  417bf8:	2f07      	cmp	r7, #7
  417bfa:	9427      	str	r4, [sp, #156]	; 0x9c
  417bfc:	9726      	str	r7, [sp, #152]	; 0x98
  417bfe:	f8c8 6000 	str.w	r6, [r8]
  417c02:	f8c8 3004 	str.w	r3, [r8, #4]
  417c06:	f300 8203 	bgt.w	418010 <_svfprintf_r+0xdf0>
  417c0a:	f108 0808 	add.w	r8, r8, #8
  417c0e:	9a19      	ldr	r2, [sp, #100]	; 0x64
  417c10:	9b1a      	ldr	r3, [sp, #104]	; 0x68
  417c12:	f8c8 3000 	str.w	r3, [r8]
  417c16:	3701      	adds	r7, #1
  417c18:	4414      	add	r4, r2
  417c1a:	2f07      	cmp	r7, #7
  417c1c:	9427      	str	r4, [sp, #156]	; 0x9c
  417c1e:	9726      	str	r7, [sp, #152]	; 0x98
  417c20:	f8c8 2004 	str.w	r2, [r8, #4]
  417c24:	f300 8200 	bgt.w	418028 <_svfprintf_r+0xe08>
  417c28:	f108 0808 	add.w	r8, r8, #8
  417c2c:	a815      	add	r0, sp, #84	; 0x54
  417c2e:	c80d      	ldmia	r0, {r0, r2, r3}
  417c30:	9914      	ldr	r1, [sp, #80]	; 0x50
  417c32:	f7fe ffa9 	bl	416b88 <__aeabi_dcmpeq>
  417c36:	9b13      	ldr	r3, [sp, #76]	; 0x4c
  417c38:	2800      	cmp	r0, #0
  417c3a:	f040 8101 	bne.w	417e40 <_svfprintf_r+0xc20>
  417c3e:	3b01      	subs	r3, #1
  417c40:	3701      	adds	r7, #1
  417c42:	3601      	adds	r6, #1
  417c44:	441c      	add	r4, r3
  417c46:	2f07      	cmp	r7, #7
  417c48:	9726      	str	r7, [sp, #152]	; 0x98
  417c4a:	9427      	str	r4, [sp, #156]	; 0x9c
  417c4c:	f8c8 6000 	str.w	r6, [r8]
  417c50:	f8c8 3004 	str.w	r3, [r8, #4]
  417c54:	f300 8127 	bgt.w	417ea6 <_svfprintf_r+0xc86>
  417c58:	f108 0808 	add.w	r8, r8, #8
  417c5c:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
  417c5e:	f8c8 2004 	str.w	r2, [r8, #4]
  417c62:	3701      	adds	r7, #1
  417c64:	4414      	add	r4, r2
  417c66:	ab21      	add	r3, sp, #132	; 0x84
  417c68:	2f07      	cmp	r7, #7
  417c6a:	9427      	str	r4, [sp, #156]	; 0x9c
  417c6c:	9726      	str	r7, [sp, #152]	; 0x98
  417c6e:	f8c8 3000 	str.w	r3, [r8]
  417c72:	f77f acb3 	ble.w	4175dc <_svfprintf_r+0x3bc>
  417c76:	aa25      	add	r2, sp, #148	; 0x94
  417c78:	990b      	ldr	r1, [sp, #44]	; 0x2c
  417c7a:	980c      	ldr	r0, [sp, #48]	; 0x30
  417c7c:	f004 f9ee 	bl	41c05c <__ssprint_r>
  417c80:	2800      	cmp	r0, #0
  417c82:	f47f ab9f 	bne.w	4173c4 <_svfprintf_r+0x1a4>
  417c86:	9c27      	ldr	r4, [sp, #156]	; 0x9c
  417c88:	46c8      	mov	r8, r9
  417c8a:	e4a9      	b.n	4175e0 <_svfprintf_r+0x3c0>
  417c8c:	aa25      	add	r2, sp, #148	; 0x94
  417c8e:	990b      	ldr	r1, [sp, #44]	; 0x2c
  417c90:	980c      	ldr	r0, [sp, #48]	; 0x30
  417c92:	f004 f9e3 	bl	41c05c <__ssprint_r>
  417c96:	2800      	cmp	r0, #0
  417c98:	f43f aceb 	beq.w	417672 <_svfprintf_r+0x452>
  417c9c:	f7ff bb92 	b.w	4173c4 <_svfprintf_r+0x1a4>
  417ca0:	f8dd b01c 	ldr.w	fp, [sp, #28]
  417ca4:	2b01      	cmp	r3, #1
  417ca6:	f000 8134 	beq.w	417f12 <_svfprintf_r+0xcf2>
  417caa:	2b02      	cmp	r3, #2
  417cac:	d125      	bne.n	417cfa <_svfprintf_r+0xada>
  417cae:	f8cd b01c 	str.w	fp, [sp, #28]
  417cb2:	2400      	movs	r4, #0
  417cb4:	2500      	movs	r5, #0
  417cb6:	e61e      	b.n	4178f6 <_svfprintf_r+0x6d6>
  417cb8:	aa25      	add	r2, sp, #148	; 0x94
  417cba:	990b      	ldr	r1, [sp, #44]	; 0x2c
  417cbc:	980c      	ldr	r0, [sp, #48]	; 0x30
  417cbe:	f004 f9cd 	bl	41c05c <__ssprint_r>
  417cc2:	2800      	cmp	r0, #0
  417cc4:	f47f ab7e 	bne.w	4173c4 <_svfprintf_r+0x1a4>
  417cc8:	9c27      	ldr	r4, [sp, #156]	; 0x9c
  417cca:	46c8      	mov	r8, r9
  417ccc:	e475      	b.n	4175ba <_svfprintf_r+0x39a>
  417cce:	aa25      	add	r2, sp, #148	; 0x94
  417cd0:	990b      	ldr	r1, [sp, #44]	; 0x2c
  417cd2:	980c      	ldr	r0, [sp, #48]	; 0x30
  417cd4:	f004 f9c2 	bl	41c05c <__ssprint_r>
  417cd8:	2800      	cmp	r0, #0
  417cda:	f47f ab73 	bne.w	4173c4 <_svfprintf_r+0x1a4>
  417cde:	9c27      	ldr	r4, [sp, #156]	; 0x9c
  417ce0:	46c8      	mov	r8, r9
  417ce2:	e41b      	b.n	41751c <_svfprintf_r+0x2fc>
  417ce4:	aa25      	add	r2, sp, #148	; 0x94
  417ce6:	990b      	ldr	r1, [sp, #44]	; 0x2c
  417ce8:	980c      	ldr	r0, [sp, #48]	; 0x30
  417cea:	f004 f9b7 	bl	41c05c <__ssprint_r>
  417cee:	2800      	cmp	r0, #0
  417cf0:	f47f ab68 	bne.w	4173c4 <_svfprintf_r+0x1a4>
  417cf4:	9c27      	ldr	r4, [sp, #156]	; 0x9c
  417cf6:	46c8      	mov	r8, r9
  417cf8:	e420      	b.n	41753c <_svfprintf_r+0x31c>
  417cfa:	f8cd b01c 	str.w	fp, [sp, #28]
  417cfe:	2400      	movs	r4, #0
  417d00:	2500      	movs	r5, #0
  417d02:	4649      	mov	r1, r9
  417d04:	e000      	b.n	417d08 <_svfprintf_r+0xae8>
  417d06:	4631      	mov	r1, r6
  417d08:	08e2      	lsrs	r2, r4, #3
  417d0a:	ea42 7245 	orr.w	r2, r2, r5, lsl #29
  417d0e:	08e8      	lsrs	r0, r5, #3
  417d10:	f004 0307 	and.w	r3, r4, #7
  417d14:	4605      	mov	r5, r0
  417d16:	4614      	mov	r4, r2
  417d18:	3330      	adds	r3, #48	; 0x30
  417d1a:	ea54 0205 	orrs.w	r2, r4, r5
  417d1e:	f801 3c01 	strb.w	r3, [r1, #-1]
  417d22:	f101 36ff 	add.w	r6, r1, #4294967295
  417d26:	d1ee      	bne.n	417d06 <_svfprintf_r+0xae6>
  417d28:	9a07      	ldr	r2, [sp, #28]
  417d2a:	07d2      	lsls	r2, r2, #31
  417d2c:	f57f adf3 	bpl.w	417916 <_svfprintf_r+0x6f6>
  417d30:	2b30      	cmp	r3, #48	; 0x30
  417d32:	f43f adf0 	beq.w	417916 <_svfprintf_r+0x6f6>
  417d36:	3902      	subs	r1, #2
  417d38:	2330      	movs	r3, #48	; 0x30
  417d3a:	f806 3c01 	strb.w	r3, [r6, #-1]
  417d3e:	eba9 0301 	sub.w	r3, r9, r1
  417d42:	930e      	str	r3, [sp, #56]	; 0x38
  417d44:	460e      	mov	r6, r1
  417d46:	f7ff bb7b 	b.w	417440 <_svfprintf_r+0x220>
  417d4a:	991f      	ldr	r1, [sp, #124]	; 0x7c
  417d4c:	2900      	cmp	r1, #0
  417d4e:	f340 822e 	ble.w	4181ae <_svfprintf_r+0xf8e>
  417d52:	9b12      	ldr	r3, [sp, #72]	; 0x48
  417d54:	9a13      	ldr	r2, [sp, #76]	; 0x4c
  417d56:	4293      	cmp	r3, r2
  417d58:	bfa8      	it	ge
  417d5a:	4613      	movge	r3, r2
  417d5c:	2b00      	cmp	r3, #0
  417d5e:	461f      	mov	r7, r3
  417d60:	dd0d      	ble.n	417d7e <_svfprintf_r+0xb5e>
  417d62:	9b26      	ldr	r3, [sp, #152]	; 0x98
  417d64:	f8c8 6000 	str.w	r6, [r8]
  417d68:	3301      	adds	r3, #1
  417d6a:	443c      	add	r4, r7
  417d6c:	2b07      	cmp	r3, #7
  417d6e:	9427      	str	r4, [sp, #156]	; 0x9c
  417d70:	f8c8 7004 	str.w	r7, [r8, #4]
  417d74:	9326      	str	r3, [sp, #152]	; 0x98
  417d76:	f300 831f 	bgt.w	4183b8 <_svfprintf_r+0x1198>
  417d7a:	f108 0808 	add.w	r8, r8, #8
  417d7e:	9b12      	ldr	r3, [sp, #72]	; 0x48
  417d80:	2f00      	cmp	r7, #0
  417d82:	bfa8      	it	ge
  417d84:	1bdb      	subge	r3, r3, r7
  417d86:	2b00      	cmp	r3, #0
  417d88:	461f      	mov	r7, r3
  417d8a:	f340 80d6 	ble.w	417f3a <_svfprintf_r+0xd1a>
  417d8e:	2f10      	cmp	r7, #16
  417d90:	9b26      	ldr	r3, [sp, #152]	; 0x98
  417d92:	4d31      	ldr	r5, [pc, #196]	; (417e58 <_svfprintf_r+0xc38>)
  417d94:	f340 81ed 	ble.w	418172 <_svfprintf_r+0xf52>
  417d98:	4642      	mov	r2, r8
  417d9a:	4621      	mov	r1, r4
  417d9c:	46b0      	mov	r8, r6
  417d9e:	f04f 0b10 	mov.w	fp, #16
  417da2:	462e      	mov	r6, r5
  417da4:	9c0c      	ldr	r4, [sp, #48]	; 0x30
  417da6:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
  417da8:	e004      	b.n	417db4 <_svfprintf_r+0xb94>
  417daa:	3208      	adds	r2, #8
  417dac:	3f10      	subs	r7, #16
  417dae:	2f10      	cmp	r7, #16
  417db0:	f340 81db 	ble.w	41816a <_svfprintf_r+0xf4a>
  417db4:	3301      	adds	r3, #1
  417db6:	3110      	adds	r1, #16
  417db8:	2b07      	cmp	r3, #7
  417dba:	9127      	str	r1, [sp, #156]	; 0x9c
  417dbc:	9326      	str	r3, [sp, #152]	; 0x98
  417dbe:	e882 0840 	stmia.w	r2, {r6, fp}
  417dc2:	ddf2      	ble.n	417daa <_svfprintf_r+0xb8a>
  417dc4:	aa25      	add	r2, sp, #148	; 0x94
  417dc6:	4629      	mov	r1, r5
  417dc8:	4620      	mov	r0, r4
  417dca:	f004 f947 	bl	41c05c <__ssprint_r>
  417dce:	2800      	cmp	r0, #0
  417dd0:	f47f aaf8 	bne.w	4173c4 <_svfprintf_r+0x1a4>
  417dd4:	9927      	ldr	r1, [sp, #156]	; 0x9c
  417dd6:	9b26      	ldr	r3, [sp, #152]	; 0x98
  417dd8:	464a      	mov	r2, r9
  417dda:	e7e7      	b.n	417dac <_svfprintf_r+0xb8c>
  417ddc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  417dde:	930e      	str	r3, [sp, #56]	; 0x38
  417de0:	464e      	mov	r6, r9
  417de2:	f7ff bb2d 	b.w	417440 <_svfprintf_r+0x220>
  417de6:	2d00      	cmp	r5, #0
  417de8:	bf08      	it	eq
  417dea:	2c0a      	cmpeq	r4, #10
  417dec:	f0c0 808f 	bcc.w	417f0e <_svfprintf_r+0xcee>
  417df0:	464e      	mov	r6, r9
  417df2:	4620      	mov	r0, r4
  417df4:	4629      	mov	r1, r5
  417df6:	220a      	movs	r2, #10
  417df8:	2300      	movs	r3, #0
  417dfa:	f004 fbe9 	bl	41c5d0 <__aeabi_uldivmod>
  417dfe:	3230      	adds	r2, #48	; 0x30
  417e00:	f806 2d01 	strb.w	r2, [r6, #-1]!
  417e04:	4620      	mov	r0, r4
  417e06:	4629      	mov	r1, r5
  417e08:	2300      	movs	r3, #0
  417e0a:	220a      	movs	r2, #10
  417e0c:	f004 fbe0 	bl	41c5d0 <__aeabi_uldivmod>
  417e10:	4604      	mov	r4, r0
  417e12:	460d      	mov	r5, r1
  417e14:	ea54 0305 	orrs.w	r3, r4, r5
  417e18:	d1eb      	bne.n	417df2 <_svfprintf_r+0xbd2>
  417e1a:	eba9 0306 	sub.w	r3, r9, r6
  417e1e:	930e      	str	r3, [sp, #56]	; 0x38
  417e20:	f7ff bb0e 	b.w	417440 <_svfprintf_r+0x220>
  417e24:	aa25      	add	r2, sp, #148	; 0x94
  417e26:	990b      	ldr	r1, [sp, #44]	; 0x2c
  417e28:	980c      	ldr	r0, [sp, #48]	; 0x30
  417e2a:	f004 f917 	bl	41c05c <__ssprint_r>
  417e2e:	2800      	cmp	r0, #0
  417e30:	f47f aac8 	bne.w	4173c4 <_svfprintf_r+0x1a4>
  417e34:	f89d 7077 	ldrb.w	r7, [sp, #119]	; 0x77
  417e38:	9c27      	ldr	r4, [sp, #156]	; 0x9c
  417e3a:	46c8      	mov	r8, r9
  417e3c:	f7ff bb5e 	b.w	4174fc <_svfprintf_r+0x2dc>
  417e40:	1e5e      	subs	r6, r3, #1
  417e42:	2e00      	cmp	r6, #0
  417e44:	f77f af0a 	ble.w	417c5c <_svfprintf_r+0xa3c>
  417e48:	2e10      	cmp	r6, #16
  417e4a:	4d03      	ldr	r5, [pc, #12]	; (417e58 <_svfprintf_r+0xc38>)
  417e4c:	dd22      	ble.n	417e94 <_svfprintf_r+0xc74>
  417e4e:	4622      	mov	r2, r4
  417e50:	f04f 0b10 	mov.w	fp, #16
  417e54:	9c0c      	ldr	r4, [sp, #48]	; 0x30
  417e56:	e006      	b.n	417e66 <_svfprintf_r+0xc46>
  417e58:	0041ea24 	.word	0x0041ea24
  417e5c:	3e10      	subs	r6, #16
  417e5e:	2e10      	cmp	r6, #16
  417e60:	f108 0808 	add.w	r8, r8, #8
  417e64:	dd15      	ble.n	417e92 <_svfprintf_r+0xc72>
  417e66:	3701      	adds	r7, #1
  417e68:	3210      	adds	r2, #16
  417e6a:	2f07      	cmp	r7, #7
  417e6c:	9227      	str	r2, [sp, #156]	; 0x9c
  417e6e:	9726      	str	r7, [sp, #152]	; 0x98
  417e70:	e888 0820 	stmia.w	r8, {r5, fp}
  417e74:	ddf2      	ble.n	417e5c <_svfprintf_r+0xc3c>
  417e76:	aa25      	add	r2, sp, #148	; 0x94
  417e78:	990b      	ldr	r1, [sp, #44]	; 0x2c
  417e7a:	4620      	mov	r0, r4
  417e7c:	f004 f8ee 	bl	41c05c <__ssprint_r>
  417e80:	2800      	cmp	r0, #0
  417e82:	f47f aa9f 	bne.w	4173c4 <_svfprintf_r+0x1a4>
  417e86:	3e10      	subs	r6, #16
  417e88:	2e10      	cmp	r6, #16
  417e8a:	9a27      	ldr	r2, [sp, #156]	; 0x9c
  417e8c:	9f26      	ldr	r7, [sp, #152]	; 0x98
  417e8e:	46c8      	mov	r8, r9
  417e90:	dce9      	bgt.n	417e66 <_svfprintf_r+0xc46>
  417e92:	4614      	mov	r4, r2
  417e94:	3701      	adds	r7, #1
  417e96:	4434      	add	r4, r6
  417e98:	2f07      	cmp	r7, #7
  417e9a:	9427      	str	r4, [sp, #156]	; 0x9c
  417e9c:	9726      	str	r7, [sp, #152]	; 0x98
  417e9e:	e888 0060 	stmia.w	r8, {r5, r6}
  417ea2:	f77f aed9 	ble.w	417c58 <_svfprintf_r+0xa38>
  417ea6:	aa25      	add	r2, sp, #148	; 0x94
  417ea8:	990b      	ldr	r1, [sp, #44]	; 0x2c
  417eaa:	980c      	ldr	r0, [sp, #48]	; 0x30
  417eac:	f004 f8d6 	bl	41c05c <__ssprint_r>
  417eb0:	2800      	cmp	r0, #0
  417eb2:	f47f aa87 	bne.w	4173c4 <_svfprintf_r+0x1a4>
  417eb6:	9c27      	ldr	r4, [sp, #156]	; 0x9c
  417eb8:	9f26      	ldr	r7, [sp, #152]	; 0x98
  417eba:	46c8      	mov	r8, r9
  417ebc:	e6ce      	b.n	417c5c <_svfprintf_r+0xa3c>
  417ebe:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
  417ec0:	6814      	ldr	r4, [r2, #0]
  417ec2:	4613      	mov	r3, r2
  417ec4:	3304      	adds	r3, #4
  417ec6:	17e5      	asrs	r5, r4, #31
  417ec8:	930f      	str	r3, [sp, #60]	; 0x3c
  417eca:	4622      	mov	r2, r4
  417ecc:	462b      	mov	r3, r5
  417ece:	e4fa      	b.n	4178c6 <_svfprintf_r+0x6a6>
  417ed0:	3204      	adds	r2, #4
  417ed2:	681c      	ldr	r4, [r3, #0]
  417ed4:	920f      	str	r2, [sp, #60]	; 0x3c
  417ed6:	2301      	movs	r3, #1
  417ed8:	2500      	movs	r5, #0
  417eda:	f7ff ba94 	b.w	417406 <_svfprintf_r+0x1e6>
  417ede:	681c      	ldr	r4, [r3, #0]
  417ee0:	3304      	adds	r3, #4
  417ee2:	930f      	str	r3, [sp, #60]	; 0x3c
  417ee4:	2500      	movs	r5, #0
  417ee6:	e421      	b.n	41772c <_svfprintf_r+0x50c>
  417ee8:	990f      	ldr	r1, [sp, #60]	; 0x3c
  417eea:	460a      	mov	r2, r1
  417eec:	3204      	adds	r2, #4
  417eee:	680c      	ldr	r4, [r1, #0]
  417ef0:	920f      	str	r2, [sp, #60]	; 0x3c
  417ef2:	2500      	movs	r5, #0
  417ef4:	f7ff ba87 	b.w	417406 <_svfprintf_r+0x1e6>
  417ef8:	4614      	mov	r4, r2
  417efa:	3301      	adds	r3, #1
  417efc:	4434      	add	r4, r6
  417efe:	2b07      	cmp	r3, #7
  417f00:	9427      	str	r4, [sp, #156]	; 0x9c
  417f02:	9326      	str	r3, [sp, #152]	; 0x98
  417f04:	e888 0060 	stmia.w	r8, {r5, r6}
  417f08:	f77f ab68 	ble.w	4175dc <_svfprintf_r+0x3bc>
  417f0c:	e6b3      	b.n	417c76 <_svfprintf_r+0xa56>
  417f0e:	f8dd b01c 	ldr.w	fp, [sp, #28]
  417f12:	f8cd b01c 	str.w	fp, [sp, #28]
  417f16:	ae42      	add	r6, sp, #264	; 0x108
  417f18:	3430      	adds	r4, #48	; 0x30
  417f1a:	2301      	movs	r3, #1
  417f1c:	f806 4d41 	strb.w	r4, [r6, #-65]!
  417f20:	930e      	str	r3, [sp, #56]	; 0x38
  417f22:	f7ff ba8d 	b.w	417440 <_svfprintf_r+0x220>
  417f26:	aa25      	add	r2, sp, #148	; 0x94
  417f28:	990b      	ldr	r1, [sp, #44]	; 0x2c
  417f2a:	980c      	ldr	r0, [sp, #48]	; 0x30
  417f2c:	f004 f896 	bl	41c05c <__ssprint_r>
  417f30:	2800      	cmp	r0, #0
  417f32:	f47f aa47 	bne.w	4173c4 <_svfprintf_r+0x1a4>
  417f36:	9c27      	ldr	r4, [sp, #156]	; 0x9c
  417f38:	46c8      	mov	r8, r9
  417f3a:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
  417f3c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
  417f3e:	429a      	cmp	r2, r3
  417f40:	db44      	blt.n	417fcc <_svfprintf_r+0xdac>
  417f42:	9b07      	ldr	r3, [sp, #28]
  417f44:	07d9      	lsls	r1, r3, #31
  417f46:	d441      	bmi.n	417fcc <_svfprintf_r+0xdac>
  417f48:	9b13      	ldr	r3, [sp, #76]	; 0x4c
  417f4a:	9812      	ldr	r0, [sp, #72]	; 0x48
  417f4c:	1a9a      	subs	r2, r3, r2
  417f4e:	1a1d      	subs	r5, r3, r0
  417f50:	4295      	cmp	r5, r2
  417f52:	bfa8      	it	ge
  417f54:	4615      	movge	r5, r2
  417f56:	2d00      	cmp	r5, #0
  417f58:	dd0e      	ble.n	417f78 <_svfprintf_r+0xd58>
  417f5a:	9926      	ldr	r1, [sp, #152]	; 0x98
  417f5c:	f8c8 5004 	str.w	r5, [r8, #4]
  417f60:	3101      	adds	r1, #1
  417f62:	4406      	add	r6, r0
  417f64:	442c      	add	r4, r5
  417f66:	2907      	cmp	r1, #7
  417f68:	f8c8 6000 	str.w	r6, [r8]
  417f6c:	9427      	str	r4, [sp, #156]	; 0x9c
  417f6e:	9126      	str	r1, [sp, #152]	; 0x98
  417f70:	f300 823b 	bgt.w	4183ea <_svfprintf_r+0x11ca>
  417f74:	f108 0808 	add.w	r8, r8, #8
  417f78:	2d00      	cmp	r5, #0
  417f7a:	bfac      	ite	ge
  417f7c:	1b56      	subge	r6, r2, r5
  417f7e:	4616      	movlt	r6, r2
  417f80:	2e00      	cmp	r6, #0
  417f82:	f77f ab2d 	ble.w	4175e0 <_svfprintf_r+0x3c0>
  417f86:	2e10      	cmp	r6, #16
  417f88:	9b26      	ldr	r3, [sp, #152]	; 0x98
  417f8a:	4db0      	ldr	r5, [pc, #704]	; (41824c <_svfprintf_r+0x102c>)
  417f8c:	ddb5      	ble.n	417efa <_svfprintf_r+0xcda>
  417f8e:	4622      	mov	r2, r4
  417f90:	2710      	movs	r7, #16
  417f92:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
  417f96:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
  417f98:	e004      	b.n	417fa4 <_svfprintf_r+0xd84>
  417f9a:	f108 0808 	add.w	r8, r8, #8
  417f9e:	3e10      	subs	r6, #16
  417fa0:	2e10      	cmp	r6, #16
  417fa2:	dda9      	ble.n	417ef8 <_svfprintf_r+0xcd8>
  417fa4:	3301      	adds	r3, #1
  417fa6:	3210      	adds	r2, #16
  417fa8:	2b07      	cmp	r3, #7
  417faa:	9227      	str	r2, [sp, #156]	; 0x9c
  417fac:	9326      	str	r3, [sp, #152]	; 0x98
  417fae:	e888 00a0 	stmia.w	r8, {r5, r7}
  417fb2:	ddf2      	ble.n	417f9a <_svfprintf_r+0xd7a>
  417fb4:	aa25      	add	r2, sp, #148	; 0x94
  417fb6:	4621      	mov	r1, r4
  417fb8:	4658      	mov	r0, fp
  417fba:	f004 f84f 	bl	41c05c <__ssprint_r>
  417fbe:	2800      	cmp	r0, #0
  417fc0:	f47f aa00 	bne.w	4173c4 <_svfprintf_r+0x1a4>
  417fc4:	9a27      	ldr	r2, [sp, #156]	; 0x9c
  417fc6:	9b26      	ldr	r3, [sp, #152]	; 0x98
  417fc8:	46c8      	mov	r8, r9
  417fca:	e7e8      	b.n	417f9e <_svfprintf_r+0xd7e>
  417fcc:	9b26      	ldr	r3, [sp, #152]	; 0x98
  417fce:	9819      	ldr	r0, [sp, #100]	; 0x64
  417fd0:	991a      	ldr	r1, [sp, #104]	; 0x68
  417fd2:	f8c8 1000 	str.w	r1, [r8]
  417fd6:	3301      	adds	r3, #1
  417fd8:	4404      	add	r4, r0
  417fda:	2b07      	cmp	r3, #7
  417fdc:	9427      	str	r4, [sp, #156]	; 0x9c
  417fde:	f8c8 0004 	str.w	r0, [r8, #4]
  417fe2:	9326      	str	r3, [sp, #152]	; 0x98
  417fe4:	f300 81f5 	bgt.w	4183d2 <_svfprintf_r+0x11b2>
  417fe8:	f108 0808 	add.w	r8, r8, #8
  417fec:	e7ac      	b.n	417f48 <_svfprintf_r+0xd28>
  417fee:	9b07      	ldr	r3, [sp, #28]
  417ff0:	07da      	lsls	r2, r3, #31
  417ff2:	f53f adfe 	bmi.w	417bf2 <_svfprintf_r+0x9d2>
  417ff6:	3701      	adds	r7, #1
  417ff8:	3401      	adds	r4, #1
  417ffa:	2301      	movs	r3, #1
  417ffc:	2f07      	cmp	r7, #7
  417ffe:	9427      	str	r4, [sp, #156]	; 0x9c
  418000:	9726      	str	r7, [sp, #152]	; 0x98
  418002:	f8c8 6000 	str.w	r6, [r8]
  418006:	f8c8 3004 	str.w	r3, [r8, #4]
  41800a:	f77f ae25 	ble.w	417c58 <_svfprintf_r+0xa38>
  41800e:	e74a      	b.n	417ea6 <_svfprintf_r+0xc86>
  418010:	aa25      	add	r2, sp, #148	; 0x94
  418012:	990b      	ldr	r1, [sp, #44]	; 0x2c
  418014:	980c      	ldr	r0, [sp, #48]	; 0x30
  418016:	f004 f821 	bl	41c05c <__ssprint_r>
  41801a:	2800      	cmp	r0, #0
  41801c:	f47f a9d2 	bne.w	4173c4 <_svfprintf_r+0x1a4>
  418020:	9c27      	ldr	r4, [sp, #156]	; 0x9c
  418022:	9f26      	ldr	r7, [sp, #152]	; 0x98
  418024:	46c8      	mov	r8, r9
  418026:	e5f2      	b.n	417c0e <_svfprintf_r+0x9ee>
  418028:	aa25      	add	r2, sp, #148	; 0x94
  41802a:	990b      	ldr	r1, [sp, #44]	; 0x2c
  41802c:	980c      	ldr	r0, [sp, #48]	; 0x30
  41802e:	f004 f815 	bl	41c05c <__ssprint_r>
  418032:	2800      	cmp	r0, #0
  418034:	f47f a9c6 	bne.w	4173c4 <_svfprintf_r+0x1a4>
  418038:	9c27      	ldr	r4, [sp, #156]	; 0x9c
  41803a:	9f26      	ldr	r7, [sp, #152]	; 0x98
  41803c:	46c8      	mov	r8, r9
  41803e:	e5f5      	b.n	417c2c <_svfprintf_r+0xa0c>
  418040:	464e      	mov	r6, r9
  418042:	f7ff b9fd 	b.w	417440 <_svfprintf_r+0x220>
  418046:	aa25      	add	r2, sp, #148	; 0x94
  418048:	990b      	ldr	r1, [sp, #44]	; 0x2c
  41804a:	980c      	ldr	r0, [sp, #48]	; 0x30
  41804c:	f004 f806 	bl	41c05c <__ssprint_r>
  418050:	2800      	cmp	r0, #0
  418052:	f47f a9b7 	bne.w	4173c4 <_svfprintf_r+0x1a4>
  418056:	9c27      	ldr	r4, [sp, #156]	; 0x9c
  418058:	46c8      	mov	r8, r9
  41805a:	f7ff ba72 	b.w	417542 <_svfprintf_r+0x322>
  41805e:	9c15      	ldr	r4, [sp, #84]	; 0x54
  418060:	4622      	mov	r2, r4
  418062:	4620      	mov	r0, r4
  418064:	9c14      	ldr	r4, [sp, #80]	; 0x50
  418066:	4623      	mov	r3, r4
  418068:	4621      	mov	r1, r4
  41806a:	f004 fa73 	bl	41c554 <__aeabi_dcmpun>
  41806e:	2800      	cmp	r0, #0
  418070:	f040 8286 	bne.w	418580 <_svfprintf_r+0x1360>
  418074:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  418076:	3301      	adds	r3, #1
  418078:	9b11      	ldr	r3, [sp, #68]	; 0x44
  41807a:	f023 0320 	bic.w	r3, r3, #32
  41807e:	930e      	str	r3, [sp, #56]	; 0x38
  418080:	f000 81e2 	beq.w	418448 <_svfprintf_r+0x1228>
  418084:	2b47      	cmp	r3, #71	; 0x47
  418086:	f000 811e 	beq.w	4182c6 <_svfprintf_r+0x10a6>
  41808a:	f44b 7380 	orr.w	r3, fp, #256	; 0x100
  41808e:	9307      	str	r3, [sp, #28]
  418090:	9b14      	ldr	r3, [sp, #80]	; 0x50
  418092:	1e1f      	subs	r7, r3, #0
  418094:	9b15      	ldr	r3, [sp, #84]	; 0x54
  418096:	9308      	str	r3, [sp, #32]
  418098:	bfbb      	ittet	lt
  41809a:	463b      	movlt	r3, r7
  41809c:	f103 4700 	addlt.w	r7, r3, #2147483648	; 0x80000000
  4180a0:	2300      	movge	r3, #0
  4180a2:	232d      	movlt	r3, #45	; 0x2d
  4180a4:	9310      	str	r3, [sp, #64]	; 0x40
  4180a6:	9b11      	ldr	r3, [sp, #68]	; 0x44
  4180a8:	2b66      	cmp	r3, #102	; 0x66
  4180aa:	f000 81bb 	beq.w	418424 <_svfprintf_r+0x1204>
  4180ae:	2b46      	cmp	r3, #70	; 0x46
  4180b0:	f000 80df 	beq.w	418272 <_svfprintf_r+0x1052>
  4180b4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  4180b6:	9a08      	ldr	r2, [sp, #32]
  4180b8:	2b45      	cmp	r3, #69	; 0x45
  4180ba:	bf0c      	ite	eq
  4180bc:	9b0a      	ldreq	r3, [sp, #40]	; 0x28
  4180be:	9d0a      	ldrne	r5, [sp, #40]	; 0x28
  4180c0:	a823      	add	r0, sp, #140	; 0x8c
  4180c2:	a920      	add	r1, sp, #128	; 0x80
  4180c4:	bf08      	it	eq
  4180c6:	1c5d      	addeq	r5, r3, #1
  4180c8:	9004      	str	r0, [sp, #16]
  4180ca:	9103      	str	r1, [sp, #12]
  4180cc:	a81f      	add	r0, sp, #124	; 0x7c
  4180ce:	2102      	movs	r1, #2
  4180d0:	463b      	mov	r3, r7
  4180d2:	9002      	str	r0, [sp, #8]
  4180d4:	9501      	str	r5, [sp, #4]
  4180d6:	9100      	str	r1, [sp, #0]
  4180d8:	980c      	ldr	r0, [sp, #48]	; 0x30
  4180da:	f001 faa1 	bl	419620 <_dtoa_r>
  4180de:	9b11      	ldr	r3, [sp, #68]	; 0x44
  4180e0:	2b67      	cmp	r3, #103	; 0x67
  4180e2:	4606      	mov	r6, r0
  4180e4:	f040 81e0 	bne.w	4184a8 <_svfprintf_r+0x1288>
  4180e8:	f01b 0f01 	tst.w	fp, #1
  4180ec:	f000 8246 	beq.w	41857c <_svfprintf_r+0x135c>
  4180f0:	1974      	adds	r4, r6, r5
  4180f2:	9a16      	ldr	r2, [sp, #88]	; 0x58
  4180f4:	9808      	ldr	r0, [sp, #32]
  4180f6:	9b17      	ldr	r3, [sp, #92]	; 0x5c
  4180f8:	4639      	mov	r1, r7
  4180fa:	f7fe fd45 	bl	416b88 <__aeabi_dcmpeq>
  4180fe:	2800      	cmp	r0, #0
  418100:	f040 8165 	bne.w	4183ce <_svfprintf_r+0x11ae>
  418104:	9b23      	ldr	r3, [sp, #140]	; 0x8c
  418106:	42a3      	cmp	r3, r4
  418108:	d206      	bcs.n	418118 <_svfprintf_r+0xef8>
  41810a:	2130      	movs	r1, #48	; 0x30
  41810c:	1c5a      	adds	r2, r3, #1
  41810e:	9223      	str	r2, [sp, #140]	; 0x8c
  418110:	7019      	strb	r1, [r3, #0]
  418112:	9b23      	ldr	r3, [sp, #140]	; 0x8c
  418114:	429c      	cmp	r4, r3
  418116:	d8f9      	bhi.n	41810c <_svfprintf_r+0xeec>
  418118:	1b9b      	subs	r3, r3, r6
  41811a:	9313      	str	r3, [sp, #76]	; 0x4c
  41811c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  41811e:	2b47      	cmp	r3, #71	; 0x47
  418120:	f000 80e9 	beq.w	4182f6 <_svfprintf_r+0x10d6>
  418124:	9b11      	ldr	r3, [sp, #68]	; 0x44
  418126:	2b65      	cmp	r3, #101	; 0x65
  418128:	f340 81cd 	ble.w	4184c6 <_svfprintf_r+0x12a6>
  41812c:	9b11      	ldr	r3, [sp, #68]	; 0x44
  41812e:	2b66      	cmp	r3, #102	; 0x66
  418130:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
  418132:	9312      	str	r3, [sp, #72]	; 0x48
  418134:	f000 819e 	beq.w	418474 <_svfprintf_r+0x1254>
  418138:	9b13      	ldr	r3, [sp, #76]	; 0x4c
  41813a:	9a12      	ldr	r2, [sp, #72]	; 0x48
  41813c:	4619      	mov	r1, r3
  41813e:	4291      	cmp	r1, r2
  418140:	f300 818a 	bgt.w	418458 <_svfprintf_r+0x1238>
  418144:	f01b 0f01 	tst.w	fp, #1
  418148:	f040 8213 	bne.w	418572 <_svfprintf_r+0x1352>
  41814c:	ea22 73e2 	bic.w	r3, r2, r2, asr #31
  418150:	9308      	str	r3, [sp, #32]
  418152:	2367      	movs	r3, #103	; 0x67
  418154:	920e      	str	r2, [sp, #56]	; 0x38
  418156:	9311      	str	r3, [sp, #68]	; 0x44
  418158:	9b10      	ldr	r3, [sp, #64]	; 0x40
  41815a:	2b00      	cmp	r3, #0
  41815c:	f040 80c4 	bne.w	4182e8 <_svfprintf_r+0x10c8>
  418160:	930a      	str	r3, [sp, #40]	; 0x28
  418162:	f89d 7077 	ldrb.w	r7, [sp, #119]	; 0x77
  418166:	f7ff b973 	b.w	417450 <_svfprintf_r+0x230>
  41816a:	4635      	mov	r5, r6
  41816c:	460c      	mov	r4, r1
  41816e:	4646      	mov	r6, r8
  418170:	4690      	mov	r8, r2
  418172:	3301      	adds	r3, #1
  418174:	443c      	add	r4, r7
  418176:	2b07      	cmp	r3, #7
  418178:	9427      	str	r4, [sp, #156]	; 0x9c
  41817a:	9326      	str	r3, [sp, #152]	; 0x98
  41817c:	e888 00a0 	stmia.w	r8, {r5, r7}
  418180:	f73f aed1 	bgt.w	417f26 <_svfprintf_r+0xd06>
  418184:	f108 0808 	add.w	r8, r8, #8
  418188:	e6d7      	b.n	417f3a <_svfprintf_r+0xd1a>
  41818a:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
  41818c:	6813      	ldr	r3, [r2, #0]
  41818e:	3204      	adds	r2, #4
  418190:	920f      	str	r2, [sp, #60]	; 0x3c
  418192:	9a09      	ldr	r2, [sp, #36]	; 0x24
  418194:	601a      	str	r2, [r3, #0]
  418196:	f7ff b86a 	b.w	41726e <_svfprintf_r+0x4e>
  41819a:	aa25      	add	r2, sp, #148	; 0x94
  41819c:	990b      	ldr	r1, [sp, #44]	; 0x2c
  41819e:	980c      	ldr	r0, [sp, #48]	; 0x30
  4181a0:	f003 ff5c 	bl	41c05c <__ssprint_r>
  4181a4:	2800      	cmp	r0, #0
  4181a6:	f47f a90d 	bne.w	4173c4 <_svfprintf_r+0x1a4>
  4181aa:	46c8      	mov	r8, r9
  4181ac:	e48d      	b.n	417aca <_svfprintf_r+0x8aa>
  4181ae:	9b26      	ldr	r3, [sp, #152]	; 0x98
  4181b0:	4a27      	ldr	r2, [pc, #156]	; (418250 <_svfprintf_r+0x1030>)
  4181b2:	f8c8 2000 	str.w	r2, [r8]
  4181b6:	3301      	adds	r3, #1
  4181b8:	3401      	adds	r4, #1
  4181ba:	2201      	movs	r2, #1
  4181bc:	2b07      	cmp	r3, #7
  4181be:	9427      	str	r4, [sp, #156]	; 0x9c
  4181c0:	9326      	str	r3, [sp, #152]	; 0x98
  4181c2:	f8c8 2004 	str.w	r2, [r8, #4]
  4181c6:	dc72      	bgt.n	4182ae <_svfprintf_r+0x108e>
  4181c8:	f108 0808 	add.w	r8, r8, #8
  4181cc:	b929      	cbnz	r1, 4181da <_svfprintf_r+0xfba>
  4181ce:	9b13      	ldr	r3, [sp, #76]	; 0x4c
  4181d0:	b91b      	cbnz	r3, 4181da <_svfprintf_r+0xfba>
  4181d2:	9b07      	ldr	r3, [sp, #28]
  4181d4:	07d8      	lsls	r0, r3, #31
  4181d6:	f57f aa03 	bpl.w	4175e0 <_svfprintf_r+0x3c0>
  4181da:	9b26      	ldr	r3, [sp, #152]	; 0x98
  4181dc:	9819      	ldr	r0, [sp, #100]	; 0x64
  4181de:	9a1a      	ldr	r2, [sp, #104]	; 0x68
  4181e0:	f8c8 2000 	str.w	r2, [r8]
  4181e4:	3301      	adds	r3, #1
  4181e6:	4602      	mov	r2, r0
  4181e8:	4422      	add	r2, r4
  4181ea:	2b07      	cmp	r3, #7
  4181ec:	9227      	str	r2, [sp, #156]	; 0x9c
  4181ee:	f8c8 0004 	str.w	r0, [r8, #4]
  4181f2:	9326      	str	r3, [sp, #152]	; 0x98
  4181f4:	f300 818d 	bgt.w	418512 <_svfprintf_r+0x12f2>
  4181f8:	f108 0808 	add.w	r8, r8, #8
  4181fc:	2900      	cmp	r1, #0
  4181fe:	f2c0 8165 	blt.w	4184cc <_svfprintf_r+0x12ac>
  418202:	9913      	ldr	r1, [sp, #76]	; 0x4c
  418204:	f8c8 6000 	str.w	r6, [r8]
  418208:	3301      	adds	r3, #1
  41820a:	188c      	adds	r4, r1, r2
  41820c:	2b07      	cmp	r3, #7
  41820e:	9427      	str	r4, [sp, #156]	; 0x9c
  418210:	9326      	str	r3, [sp, #152]	; 0x98
  418212:	f8c8 1004 	str.w	r1, [r8, #4]
  418216:	f77f a9e1 	ble.w	4175dc <_svfprintf_r+0x3bc>
  41821a:	e52c      	b.n	417c76 <_svfprintf_r+0xa56>
  41821c:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
  41821e:	9909      	ldr	r1, [sp, #36]	; 0x24
  418220:	6813      	ldr	r3, [r2, #0]
  418222:	17cd      	asrs	r5, r1, #31
  418224:	4608      	mov	r0, r1
  418226:	3204      	adds	r2, #4
  418228:	4629      	mov	r1, r5
  41822a:	920f      	str	r2, [sp, #60]	; 0x3c
  41822c:	e9c3 0100 	strd	r0, r1, [r3]
  418230:	f7ff b81d 	b.w	41726e <_svfprintf_r+0x4e>
  418234:	aa25      	add	r2, sp, #148	; 0x94
  418236:	990b      	ldr	r1, [sp, #44]	; 0x2c
  418238:	980c      	ldr	r0, [sp, #48]	; 0x30
  41823a:	f003 ff0f 	bl	41c05c <__ssprint_r>
  41823e:	2800      	cmp	r0, #0
  418240:	f47f a8c0 	bne.w	4173c4 <_svfprintf_r+0x1a4>
  418244:	9c27      	ldr	r4, [sp, #156]	; 0x9c
  418246:	46c8      	mov	r8, r9
  418248:	e458      	b.n	417afc <_svfprintf_r+0x8dc>
  41824a:	bf00      	nop
  41824c:	0041ea24 	.word	0x0041ea24
  418250:	0041ea10 	.word	0x0041ea10
  418254:	2140      	movs	r1, #64	; 0x40
  418256:	980c      	ldr	r0, [sp, #48]	; 0x30
  418258:	f002 fe56 	bl	41af08 <_malloc_r>
  41825c:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
  41825e:	6010      	str	r0, [r2, #0]
  418260:	6110      	str	r0, [r2, #16]
  418262:	2800      	cmp	r0, #0
  418264:	f000 81f2 	beq.w	41864c <_svfprintf_r+0x142c>
  418268:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
  41826a:	2340      	movs	r3, #64	; 0x40
  41826c:	6153      	str	r3, [r2, #20]
  41826e:	f7fe bfee 	b.w	41724e <_svfprintf_r+0x2e>
  418272:	a823      	add	r0, sp, #140	; 0x8c
  418274:	a920      	add	r1, sp, #128	; 0x80
  418276:	9c0a      	ldr	r4, [sp, #40]	; 0x28
  418278:	9004      	str	r0, [sp, #16]
  41827a:	9103      	str	r1, [sp, #12]
  41827c:	a81f      	add	r0, sp, #124	; 0x7c
  41827e:	2103      	movs	r1, #3
  418280:	9002      	str	r0, [sp, #8]
  418282:	9a08      	ldr	r2, [sp, #32]
  418284:	9401      	str	r4, [sp, #4]
  418286:	463b      	mov	r3, r7
  418288:	9100      	str	r1, [sp, #0]
  41828a:	980c      	ldr	r0, [sp, #48]	; 0x30
  41828c:	f001 f9c8 	bl	419620 <_dtoa_r>
  418290:	4625      	mov	r5, r4
  418292:	4606      	mov	r6, r0
  418294:	9b11      	ldr	r3, [sp, #68]	; 0x44
  418296:	2b46      	cmp	r3, #70	; 0x46
  418298:	eb06 0405 	add.w	r4, r6, r5
  41829c:	f47f af29 	bne.w	4180f2 <_svfprintf_r+0xed2>
  4182a0:	7833      	ldrb	r3, [r6, #0]
  4182a2:	2b30      	cmp	r3, #48	; 0x30
  4182a4:	f000 8178 	beq.w	418598 <_svfprintf_r+0x1378>
  4182a8:	9d1f      	ldr	r5, [sp, #124]	; 0x7c
  4182aa:	442c      	add	r4, r5
  4182ac:	e721      	b.n	4180f2 <_svfprintf_r+0xed2>
  4182ae:	aa25      	add	r2, sp, #148	; 0x94
  4182b0:	990b      	ldr	r1, [sp, #44]	; 0x2c
  4182b2:	980c      	ldr	r0, [sp, #48]	; 0x30
  4182b4:	f003 fed2 	bl	41c05c <__ssprint_r>
  4182b8:	2800      	cmp	r0, #0
  4182ba:	f47f a883 	bne.w	4173c4 <_svfprintf_r+0x1a4>
  4182be:	991f      	ldr	r1, [sp, #124]	; 0x7c
  4182c0:	9c27      	ldr	r4, [sp, #156]	; 0x9c
  4182c2:	46c8      	mov	r8, r9
  4182c4:	e782      	b.n	4181cc <_svfprintf_r+0xfac>
  4182c6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  4182c8:	2b00      	cmp	r3, #0
  4182ca:	bf08      	it	eq
  4182cc:	2301      	moveq	r3, #1
  4182ce:	930a      	str	r3, [sp, #40]	; 0x28
  4182d0:	e6db      	b.n	41808a <_svfprintf_r+0xe6a>
  4182d2:	4630      	mov	r0, r6
  4182d4:	940a      	str	r4, [sp, #40]	; 0x28
  4182d6:	f003 fe53 	bl	41bf80 <strlen>
  4182da:	950f      	str	r5, [sp, #60]	; 0x3c
  4182dc:	900e      	str	r0, [sp, #56]	; 0x38
  4182de:	f8cd b01c 	str.w	fp, [sp, #28]
  4182e2:	4603      	mov	r3, r0
  4182e4:	f7ff b9f9 	b.w	4176da <_svfprintf_r+0x4ba>
  4182e8:	272d      	movs	r7, #45	; 0x2d
  4182ea:	2300      	movs	r3, #0
  4182ec:	f88d 7077 	strb.w	r7, [sp, #119]	; 0x77
  4182f0:	930a      	str	r3, [sp, #40]	; 0x28
  4182f2:	f7ff b8ae 	b.w	417452 <_svfprintf_r+0x232>
  4182f6:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
  4182f8:	9312      	str	r3, [sp, #72]	; 0x48
  4182fa:	461a      	mov	r2, r3
  4182fc:	3303      	adds	r3, #3
  4182fe:	db04      	blt.n	41830a <_svfprintf_r+0x10ea>
  418300:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  418302:	4619      	mov	r1, r3
  418304:	4291      	cmp	r1, r2
  418306:	f6bf af17 	bge.w	418138 <_svfprintf_r+0xf18>
  41830a:	9b11      	ldr	r3, [sp, #68]	; 0x44
  41830c:	3b02      	subs	r3, #2
  41830e:	9311      	str	r3, [sp, #68]	; 0x44
  418310:	f89d 3044 	ldrb.w	r3, [sp, #68]	; 0x44
  418314:	f88d 3084 	strb.w	r3, [sp, #132]	; 0x84
  418318:	9b12      	ldr	r3, [sp, #72]	; 0x48
  41831a:	3b01      	subs	r3, #1
  41831c:	2b00      	cmp	r3, #0
  41831e:	931f      	str	r3, [sp, #124]	; 0x7c
  418320:	bfbd      	ittte	lt
  418322:	9b12      	ldrlt	r3, [sp, #72]	; 0x48
  418324:	f1c3 0301 	rsblt	r3, r3, #1
  418328:	222d      	movlt	r2, #45	; 0x2d
  41832a:	222b      	movge	r2, #43	; 0x2b
  41832c:	2b09      	cmp	r3, #9
  41832e:	f88d 2085 	strb.w	r2, [sp, #133]	; 0x85
  418332:	f340 8116 	ble.w	418562 <_svfprintf_r+0x1342>
  418336:	f10d 0493 	add.w	r4, sp, #147	; 0x93
  41833a:	4620      	mov	r0, r4
  41833c:	4dab      	ldr	r5, [pc, #684]	; (4185ec <_svfprintf_r+0x13cc>)
  41833e:	e000      	b.n	418342 <_svfprintf_r+0x1122>
  418340:	4610      	mov	r0, r2
  418342:	fb85 1203 	smull	r1, r2, r5, r3
  418346:	17d9      	asrs	r1, r3, #31
  418348:	ebc1 01a2 	rsb	r1, r1, r2, asr #2
  41834c:	eb01 0281 	add.w	r2, r1, r1, lsl #2
  418350:	eba3 0242 	sub.w	r2, r3, r2, lsl #1
  418354:	3230      	adds	r2, #48	; 0x30
  418356:	2909      	cmp	r1, #9
  418358:	f800 2c01 	strb.w	r2, [r0, #-1]
  41835c:	460b      	mov	r3, r1
  41835e:	f100 32ff 	add.w	r2, r0, #4294967295
  418362:	dced      	bgt.n	418340 <_svfprintf_r+0x1120>
  418364:	3330      	adds	r3, #48	; 0x30
  418366:	3802      	subs	r0, #2
  418368:	b2d9      	uxtb	r1, r3
  41836a:	4284      	cmp	r4, r0
  41836c:	f802 1c01 	strb.w	r1, [r2, #-1]
  418370:	f240 8165 	bls.w	41863e <_svfprintf_r+0x141e>
  418374:	f10d 0086 	add.w	r0, sp, #134	; 0x86
  418378:	4613      	mov	r3, r2
  41837a:	e001      	b.n	418380 <_svfprintf_r+0x1160>
  41837c:	f813 1b01 	ldrb.w	r1, [r3], #1
  418380:	f800 1b01 	strb.w	r1, [r0], #1
  418384:	42a3      	cmp	r3, r4
  418386:	d1f9      	bne.n	41837c <_svfprintf_r+0x115c>
  418388:	3301      	adds	r3, #1
  41838a:	1a9b      	subs	r3, r3, r2
  41838c:	f10d 0286 	add.w	r2, sp, #134	; 0x86
  418390:	4413      	add	r3, r2
  418392:	aa21      	add	r2, sp, #132	; 0x84
  418394:	1a9b      	subs	r3, r3, r2
  418396:	9a13      	ldr	r2, [sp, #76]	; 0x4c
  418398:	931b      	str	r3, [sp, #108]	; 0x6c
  41839a:	2a01      	cmp	r2, #1
  41839c:	4413      	add	r3, r2
  41839e:	930e      	str	r3, [sp, #56]	; 0x38
  4183a0:	f340 8119 	ble.w	4185d6 <_svfprintf_r+0x13b6>
  4183a4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  4183a6:	9a19      	ldr	r2, [sp, #100]	; 0x64
  4183a8:	4413      	add	r3, r2
  4183aa:	930e      	str	r3, [sp, #56]	; 0x38
  4183ac:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
  4183b0:	9308      	str	r3, [sp, #32]
  4183b2:	2300      	movs	r3, #0
  4183b4:	9312      	str	r3, [sp, #72]	; 0x48
  4183b6:	e6cf      	b.n	418158 <_svfprintf_r+0xf38>
  4183b8:	aa25      	add	r2, sp, #148	; 0x94
  4183ba:	990b      	ldr	r1, [sp, #44]	; 0x2c
  4183bc:	980c      	ldr	r0, [sp, #48]	; 0x30
  4183be:	f003 fe4d 	bl	41c05c <__ssprint_r>
  4183c2:	2800      	cmp	r0, #0
  4183c4:	f47e affe 	bne.w	4173c4 <_svfprintf_r+0x1a4>
  4183c8:	9c27      	ldr	r4, [sp, #156]	; 0x9c
  4183ca:	46c8      	mov	r8, r9
  4183cc:	e4d7      	b.n	417d7e <_svfprintf_r+0xb5e>
  4183ce:	4623      	mov	r3, r4
  4183d0:	e6a2      	b.n	418118 <_svfprintf_r+0xef8>
  4183d2:	aa25      	add	r2, sp, #148	; 0x94
  4183d4:	990b      	ldr	r1, [sp, #44]	; 0x2c
  4183d6:	980c      	ldr	r0, [sp, #48]	; 0x30
  4183d8:	f003 fe40 	bl	41c05c <__ssprint_r>
  4183dc:	2800      	cmp	r0, #0
  4183de:	f47e aff1 	bne.w	4173c4 <_svfprintf_r+0x1a4>
  4183e2:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
  4183e4:	9c27      	ldr	r4, [sp, #156]	; 0x9c
  4183e6:	46c8      	mov	r8, r9
  4183e8:	e5ae      	b.n	417f48 <_svfprintf_r+0xd28>
  4183ea:	aa25      	add	r2, sp, #148	; 0x94
  4183ec:	990b      	ldr	r1, [sp, #44]	; 0x2c
  4183ee:	980c      	ldr	r0, [sp, #48]	; 0x30
  4183f0:	f003 fe34 	bl	41c05c <__ssprint_r>
  4183f4:	2800      	cmp	r0, #0
  4183f6:	f47e afe5 	bne.w	4173c4 <_svfprintf_r+0x1a4>
  4183fa:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
  4183fc:	9b13      	ldr	r3, [sp, #76]	; 0x4c
  4183fe:	9c27      	ldr	r4, [sp, #156]	; 0x9c
  418400:	1a9a      	subs	r2, r3, r2
  418402:	46c8      	mov	r8, r9
  418404:	e5b8      	b.n	417f78 <_svfprintf_r+0xd58>
  418406:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  418408:	9612      	str	r6, [sp, #72]	; 0x48
  41840a:	2b06      	cmp	r3, #6
  41840c:	bf28      	it	cs
  41840e:	2306      	movcs	r3, #6
  418410:	960a      	str	r6, [sp, #40]	; 0x28
  418412:	4637      	mov	r7, r6
  418414:	9308      	str	r3, [sp, #32]
  418416:	950f      	str	r5, [sp, #60]	; 0x3c
  418418:	f8cd b01c 	str.w	fp, [sp, #28]
  41841c:	930e      	str	r3, [sp, #56]	; 0x38
  41841e:	4e74      	ldr	r6, [pc, #464]	; (4185f0 <_svfprintf_r+0x13d0>)
  418420:	f7ff b816 	b.w	417450 <_svfprintf_r+0x230>
  418424:	a823      	add	r0, sp, #140	; 0x8c
  418426:	a920      	add	r1, sp, #128	; 0x80
  418428:	9d0a      	ldr	r5, [sp, #40]	; 0x28
  41842a:	9004      	str	r0, [sp, #16]
  41842c:	9103      	str	r1, [sp, #12]
  41842e:	a81f      	add	r0, sp, #124	; 0x7c
  418430:	2103      	movs	r1, #3
  418432:	9002      	str	r0, [sp, #8]
  418434:	9a08      	ldr	r2, [sp, #32]
  418436:	9501      	str	r5, [sp, #4]
  418438:	463b      	mov	r3, r7
  41843a:	9100      	str	r1, [sp, #0]
  41843c:	980c      	ldr	r0, [sp, #48]	; 0x30
  41843e:	f001 f8ef 	bl	419620 <_dtoa_r>
  418442:	4606      	mov	r6, r0
  418444:	1944      	adds	r4, r0, r5
  418446:	e72b      	b.n	4182a0 <_svfprintf_r+0x1080>
  418448:	2306      	movs	r3, #6
  41844a:	930a      	str	r3, [sp, #40]	; 0x28
  41844c:	e61d      	b.n	41808a <_svfprintf_r+0xe6a>
  41844e:	272d      	movs	r7, #45	; 0x2d
  418450:	f88d 7077 	strb.w	r7, [sp, #119]	; 0x77
  418454:	f7ff bacd 	b.w	4179f2 <_svfprintf_r+0x7d2>
  418458:	9a19      	ldr	r2, [sp, #100]	; 0x64
  41845a:	9b13      	ldr	r3, [sp, #76]	; 0x4c
  41845c:	4413      	add	r3, r2
  41845e:	9a12      	ldr	r2, [sp, #72]	; 0x48
  418460:	930e      	str	r3, [sp, #56]	; 0x38
  418462:	2a00      	cmp	r2, #0
  418464:	f340 80b0 	ble.w	4185c8 <_svfprintf_r+0x13a8>
  418468:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
  41846c:	9308      	str	r3, [sp, #32]
  41846e:	2367      	movs	r3, #103	; 0x67
  418470:	9311      	str	r3, [sp, #68]	; 0x44
  418472:	e671      	b.n	418158 <_svfprintf_r+0xf38>
  418474:	2b00      	cmp	r3, #0
  418476:	f340 80c3 	ble.w	418600 <_svfprintf_r+0x13e0>
  41847a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  41847c:	2a00      	cmp	r2, #0
  41847e:	f040 8099 	bne.w	4185b4 <_svfprintf_r+0x1394>
  418482:	f01b 0f01 	tst.w	fp, #1
  418486:	f040 8095 	bne.w	4185b4 <_svfprintf_r+0x1394>
  41848a:	9308      	str	r3, [sp, #32]
  41848c:	930e      	str	r3, [sp, #56]	; 0x38
  41848e:	e663      	b.n	418158 <_svfprintf_r+0xf38>
  418490:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  418492:	9308      	str	r3, [sp, #32]
  418494:	930e      	str	r3, [sp, #56]	; 0x38
  418496:	900a      	str	r0, [sp, #40]	; 0x28
  418498:	950f      	str	r5, [sp, #60]	; 0x3c
  41849a:	f8cd b01c 	str.w	fp, [sp, #28]
  41849e:	9012      	str	r0, [sp, #72]	; 0x48
  4184a0:	f89d 7077 	ldrb.w	r7, [sp, #119]	; 0x77
  4184a4:	f7fe bfd4 	b.w	417450 <_svfprintf_r+0x230>
  4184a8:	9b11      	ldr	r3, [sp, #68]	; 0x44
  4184aa:	2b47      	cmp	r3, #71	; 0x47
  4184ac:	f47f ae20 	bne.w	4180f0 <_svfprintf_r+0xed0>
  4184b0:	f01b 0f01 	tst.w	fp, #1
  4184b4:	f47f aeee 	bne.w	418294 <_svfprintf_r+0x1074>
  4184b8:	9b23      	ldr	r3, [sp, #140]	; 0x8c
  4184ba:	1b9b      	subs	r3, r3, r6
  4184bc:	9313      	str	r3, [sp, #76]	; 0x4c
  4184be:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  4184c0:	2b47      	cmp	r3, #71	; 0x47
  4184c2:	f43f af18 	beq.w	4182f6 <_svfprintf_r+0x10d6>
  4184c6:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
  4184c8:	9312      	str	r3, [sp, #72]	; 0x48
  4184ca:	e721      	b.n	418310 <_svfprintf_r+0x10f0>
  4184cc:	424f      	negs	r7, r1
  4184ce:	3110      	adds	r1, #16
  4184d0:	4d48      	ldr	r5, [pc, #288]	; (4185f4 <_svfprintf_r+0x13d4>)
  4184d2:	da2f      	bge.n	418534 <_svfprintf_r+0x1314>
  4184d4:	2410      	movs	r4, #16
  4184d6:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
  4184da:	e004      	b.n	4184e6 <_svfprintf_r+0x12c6>
  4184dc:	f108 0808 	add.w	r8, r8, #8
  4184e0:	3f10      	subs	r7, #16
  4184e2:	2f10      	cmp	r7, #16
  4184e4:	dd26      	ble.n	418534 <_svfprintf_r+0x1314>
  4184e6:	3301      	adds	r3, #1
  4184e8:	3210      	adds	r2, #16
  4184ea:	2b07      	cmp	r3, #7
  4184ec:	9227      	str	r2, [sp, #156]	; 0x9c
  4184ee:	9326      	str	r3, [sp, #152]	; 0x98
  4184f0:	f8c8 5000 	str.w	r5, [r8]
  4184f4:	f8c8 4004 	str.w	r4, [r8, #4]
  4184f8:	ddf0      	ble.n	4184dc <_svfprintf_r+0x12bc>
  4184fa:	aa25      	add	r2, sp, #148	; 0x94
  4184fc:	990b      	ldr	r1, [sp, #44]	; 0x2c
  4184fe:	4658      	mov	r0, fp
  418500:	f003 fdac 	bl	41c05c <__ssprint_r>
  418504:	2800      	cmp	r0, #0
  418506:	f47e af5d 	bne.w	4173c4 <_svfprintf_r+0x1a4>
  41850a:	9a27      	ldr	r2, [sp, #156]	; 0x9c
  41850c:	9b26      	ldr	r3, [sp, #152]	; 0x98
  41850e:	46c8      	mov	r8, r9
  418510:	e7e6      	b.n	4184e0 <_svfprintf_r+0x12c0>
  418512:	aa25      	add	r2, sp, #148	; 0x94
  418514:	990b      	ldr	r1, [sp, #44]	; 0x2c
  418516:	980c      	ldr	r0, [sp, #48]	; 0x30
  418518:	f003 fda0 	bl	41c05c <__ssprint_r>
  41851c:	2800      	cmp	r0, #0
  41851e:	f47e af51 	bne.w	4173c4 <_svfprintf_r+0x1a4>
  418522:	991f      	ldr	r1, [sp, #124]	; 0x7c
  418524:	9a27      	ldr	r2, [sp, #156]	; 0x9c
  418526:	9b26      	ldr	r3, [sp, #152]	; 0x98
  418528:	46c8      	mov	r8, r9
  41852a:	e667      	b.n	4181fc <_svfprintf_r+0xfdc>
  41852c:	2000      	movs	r0, #0
  41852e:	900a      	str	r0, [sp, #40]	; 0x28
  418530:	f7fe bed0 	b.w	4172d4 <_svfprintf_r+0xb4>
  418534:	3301      	adds	r3, #1
  418536:	443a      	add	r2, r7
  418538:	2b07      	cmp	r3, #7
  41853a:	e888 00a0 	stmia.w	r8, {r5, r7}
  41853e:	9227      	str	r2, [sp, #156]	; 0x9c
  418540:	9326      	str	r3, [sp, #152]	; 0x98
  418542:	f108 0808 	add.w	r8, r8, #8
  418546:	f77f ae5c 	ble.w	418202 <_svfprintf_r+0xfe2>
  41854a:	aa25      	add	r2, sp, #148	; 0x94
  41854c:	990b      	ldr	r1, [sp, #44]	; 0x2c
  41854e:	980c      	ldr	r0, [sp, #48]	; 0x30
  418550:	f003 fd84 	bl	41c05c <__ssprint_r>
  418554:	2800      	cmp	r0, #0
  418556:	f47e af35 	bne.w	4173c4 <_svfprintf_r+0x1a4>
  41855a:	9a27      	ldr	r2, [sp, #156]	; 0x9c
  41855c:	9b26      	ldr	r3, [sp, #152]	; 0x98
  41855e:	46c8      	mov	r8, r9
  418560:	e64f      	b.n	418202 <_svfprintf_r+0xfe2>
  418562:	3330      	adds	r3, #48	; 0x30
  418564:	2230      	movs	r2, #48	; 0x30
  418566:	f88d 3087 	strb.w	r3, [sp, #135]	; 0x87
  41856a:	f88d 2086 	strb.w	r2, [sp, #134]	; 0x86
  41856e:	ab22      	add	r3, sp, #136	; 0x88
  418570:	e70f      	b.n	418392 <_svfprintf_r+0x1172>
  418572:	9b12      	ldr	r3, [sp, #72]	; 0x48
  418574:	9a19      	ldr	r2, [sp, #100]	; 0x64
  418576:	4413      	add	r3, r2
  418578:	930e      	str	r3, [sp, #56]	; 0x38
  41857a:	e775      	b.n	418468 <_svfprintf_r+0x1248>
  41857c:	9b23      	ldr	r3, [sp, #140]	; 0x8c
  41857e:	e5cb      	b.n	418118 <_svfprintf_r+0xef8>
  418580:	9b14      	ldr	r3, [sp, #80]	; 0x50
  418582:	4e1d      	ldr	r6, [pc, #116]	; (4185f8 <_svfprintf_r+0x13d8>)
  418584:	2b00      	cmp	r3, #0
  418586:	bfb6      	itet	lt
  418588:	272d      	movlt	r7, #45	; 0x2d
  41858a:	f89d 7077 	ldrbge.w	r7, [sp, #119]	; 0x77
  41858e:	f88d 7077 	strblt.w	r7, [sp, #119]	; 0x77
  418592:	4b1a      	ldr	r3, [pc, #104]	; (4185fc <_svfprintf_r+0x13dc>)
  418594:	f7ff ba2f 	b.w	4179f6 <_svfprintf_r+0x7d6>
  418598:	9a16      	ldr	r2, [sp, #88]	; 0x58
  41859a:	9808      	ldr	r0, [sp, #32]
  41859c:	9b17      	ldr	r3, [sp, #92]	; 0x5c
  41859e:	4639      	mov	r1, r7
  4185a0:	f7fe faf2 	bl	416b88 <__aeabi_dcmpeq>
  4185a4:	2800      	cmp	r0, #0
  4185a6:	f47f ae7f 	bne.w	4182a8 <_svfprintf_r+0x1088>
  4185aa:	f1c5 0501 	rsb	r5, r5, #1
  4185ae:	951f      	str	r5, [sp, #124]	; 0x7c
  4185b0:	442c      	add	r4, r5
  4185b2:	e59e      	b.n	4180f2 <_svfprintf_r+0xed2>
  4185b4:	9b12      	ldr	r3, [sp, #72]	; 0x48
  4185b6:	9a19      	ldr	r2, [sp, #100]	; 0x64
  4185b8:	4413      	add	r3, r2
  4185ba:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  4185bc:	441a      	add	r2, r3
  4185be:	ea22 73e2 	bic.w	r3, r2, r2, asr #31
  4185c2:	920e      	str	r2, [sp, #56]	; 0x38
  4185c4:	9308      	str	r3, [sp, #32]
  4185c6:	e5c7      	b.n	418158 <_svfprintf_r+0xf38>
  4185c8:	9b12      	ldr	r3, [sp, #72]	; 0x48
  4185ca:	9a0e      	ldr	r2, [sp, #56]	; 0x38
  4185cc:	f1c3 0301 	rsb	r3, r3, #1
  4185d0:	441a      	add	r2, r3
  4185d2:	4613      	mov	r3, r2
  4185d4:	e7d0      	b.n	418578 <_svfprintf_r+0x1358>
  4185d6:	f01b 0301 	ands.w	r3, fp, #1
  4185da:	9312      	str	r3, [sp, #72]	; 0x48
  4185dc:	f47f aee2 	bne.w	4183a4 <_svfprintf_r+0x1184>
  4185e0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  4185e2:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
  4185e6:	9308      	str	r3, [sp, #32]
  4185e8:	e5b6      	b.n	418158 <_svfprintf_r+0xf38>
  4185ea:	bf00      	nop
  4185ec:	66666667 	.word	0x66666667
  4185f0:	0041ea08 	.word	0x0041ea08
  4185f4:	0041ea24 	.word	0x0041ea24
  4185f8:	0041e9dc 	.word	0x0041e9dc
  4185fc:	0041e9d8 	.word	0x0041e9d8
  418600:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  418602:	b913      	cbnz	r3, 41860a <_svfprintf_r+0x13ea>
  418604:	f01b 0f01 	tst.w	fp, #1
  418608:	d002      	beq.n	418610 <_svfprintf_r+0x13f0>
  41860a:	9b19      	ldr	r3, [sp, #100]	; 0x64
  41860c:	3301      	adds	r3, #1
  41860e:	e7d4      	b.n	4185ba <_svfprintf_r+0x139a>
  418610:	2301      	movs	r3, #1
  418612:	e73a      	b.n	41848a <_svfprintf_r+0x126a>
  418614:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
  418616:	f89a 3001 	ldrb.w	r3, [sl, #1]
  41861a:	6828      	ldr	r0, [r5, #0]
  41861c:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
  418620:	900a      	str	r0, [sp, #40]	; 0x28
  418622:	4628      	mov	r0, r5
  418624:	3004      	adds	r0, #4
  418626:	46a2      	mov	sl, r4
  418628:	900f      	str	r0, [sp, #60]	; 0x3c
  41862a:	f7fe be51 	b.w	4172d0 <_svfprintf_r+0xb0>
  41862e:	f88d 1077 	strb.w	r1, [sp, #119]	; 0x77
  418632:	f7ff b867 	b.w	417704 <_svfprintf_r+0x4e4>
  418636:	f88d 1077 	strb.w	r1, [sp, #119]	; 0x77
  41863a:	f7ff ba15 	b.w	417a68 <_svfprintf_r+0x848>
  41863e:	f10d 0386 	add.w	r3, sp, #134	; 0x86
  418642:	e6a6      	b.n	418392 <_svfprintf_r+0x1172>
  418644:	f88d 1077 	strb.w	r1, [sp, #119]	; 0x77
  418648:	f7ff b8eb 	b.w	417822 <_svfprintf_r+0x602>
  41864c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
  41864e:	230c      	movs	r3, #12
  418650:	6013      	str	r3, [r2, #0]
  418652:	f04f 33ff 	mov.w	r3, #4294967295
  418656:	9309      	str	r3, [sp, #36]	; 0x24
  418658:	f7fe bebd 	b.w	4173d6 <_svfprintf_r+0x1b6>
  41865c:	f88d 1077 	strb.w	r1, [sp, #119]	; 0x77
  418660:	f7ff b99a 	b.w	417998 <_svfprintf_r+0x778>
  418664:	f88d 1077 	strb.w	r1, [sp, #119]	; 0x77
  418668:	f7ff b976 	b.w	417958 <_svfprintf_r+0x738>
  41866c:	f88d 1077 	strb.w	r1, [sp, #119]	; 0x77
  418670:	f7ff b959 	b.w	417926 <_svfprintf_r+0x706>
  418674:	f88d 1077 	strb.w	r1, [sp, #119]	; 0x77
  418678:	f7ff b912 	b.w	4178a0 <_svfprintf_r+0x680>

0041867c <__sprint_r.part.0>:
  41867c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  418680:	6e4b      	ldr	r3, [r1, #100]	; 0x64
  418682:	049c      	lsls	r4, r3, #18
  418684:	4693      	mov	fp, r2
  418686:	d52f      	bpl.n	4186e8 <__sprint_r.part.0+0x6c>
  418688:	6893      	ldr	r3, [r2, #8]
  41868a:	6812      	ldr	r2, [r2, #0]
  41868c:	b353      	cbz	r3, 4186e4 <__sprint_r.part.0+0x68>
  41868e:	460e      	mov	r6, r1
  418690:	4607      	mov	r7, r0
  418692:	f102 0908 	add.w	r9, r2, #8
  418696:	e919 0420 	ldmdb	r9, {r5, sl}
  41869a:	ea5f 089a 	movs.w	r8, sl, lsr #2
  41869e:	d017      	beq.n	4186d0 <__sprint_r.part.0+0x54>
  4186a0:	3d04      	subs	r5, #4
  4186a2:	2400      	movs	r4, #0
  4186a4:	e001      	b.n	4186aa <__sprint_r.part.0+0x2e>
  4186a6:	45a0      	cmp	r8, r4
  4186a8:	d010      	beq.n	4186cc <__sprint_r.part.0+0x50>
  4186aa:	4632      	mov	r2, r6
  4186ac:	f855 1f04 	ldr.w	r1, [r5, #4]!
  4186b0:	4638      	mov	r0, r7
  4186b2:	f002 f879 	bl	41a7a8 <_fputwc_r>
  4186b6:	1c43      	adds	r3, r0, #1
  4186b8:	f104 0401 	add.w	r4, r4, #1
  4186bc:	d1f3      	bne.n	4186a6 <__sprint_r.part.0+0x2a>
  4186be:	2300      	movs	r3, #0
  4186c0:	f8cb 3008 	str.w	r3, [fp, #8]
  4186c4:	f8cb 3004 	str.w	r3, [fp, #4]
  4186c8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4186cc:	f8db 3008 	ldr.w	r3, [fp, #8]
  4186d0:	f02a 0a03 	bic.w	sl, sl, #3
  4186d4:	eba3 030a 	sub.w	r3, r3, sl
  4186d8:	f8cb 3008 	str.w	r3, [fp, #8]
  4186dc:	f109 0908 	add.w	r9, r9, #8
  4186e0:	2b00      	cmp	r3, #0
  4186e2:	d1d8      	bne.n	418696 <__sprint_r.part.0+0x1a>
  4186e4:	2000      	movs	r0, #0
  4186e6:	e7ea      	b.n	4186be <__sprint_r.part.0+0x42>
  4186e8:	f002 f9c8 	bl	41aa7c <__sfvwrite_r>
  4186ec:	2300      	movs	r3, #0
  4186ee:	f8cb 3008 	str.w	r3, [fp, #8]
  4186f2:	f8cb 3004 	str.w	r3, [fp, #4]
  4186f6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4186fa:	bf00      	nop

004186fc <_vfiprintf_r>:
  4186fc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  418700:	b0ad      	sub	sp, #180	; 0xb4
  418702:	461d      	mov	r5, r3
  418704:	468b      	mov	fp, r1
  418706:	4690      	mov	r8, r2
  418708:	9307      	str	r3, [sp, #28]
  41870a:	9006      	str	r0, [sp, #24]
  41870c:	b118      	cbz	r0, 418716 <_vfiprintf_r+0x1a>
  41870e:	6b83      	ldr	r3, [r0, #56]	; 0x38
  418710:	2b00      	cmp	r3, #0
  418712:	f000 80f3 	beq.w	4188fc <_vfiprintf_r+0x200>
  418716:	f8db 3064 	ldr.w	r3, [fp, #100]	; 0x64
  41871a:	f9bb 000c 	ldrsh.w	r0, [fp, #12]
  41871e:	07df      	lsls	r7, r3, #31
  418720:	b281      	uxth	r1, r0
  418722:	d402      	bmi.n	41872a <_vfiprintf_r+0x2e>
  418724:	058e      	lsls	r6, r1, #22
  418726:	f140 80fc 	bpl.w	418922 <_vfiprintf_r+0x226>
  41872a:	048c      	lsls	r4, r1, #18
  41872c:	d40a      	bmi.n	418744 <_vfiprintf_r+0x48>
  41872e:	f8db 3064 	ldr.w	r3, [fp, #100]	; 0x64
  418732:	f440 5100 	orr.w	r1, r0, #8192	; 0x2000
  418736:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
  41873a:	f8ab 100c 	strh.w	r1, [fp, #12]
  41873e:	f8cb 3064 	str.w	r3, [fp, #100]	; 0x64
  418742:	b289      	uxth	r1, r1
  418744:	0708      	lsls	r0, r1, #28
  418746:	f140 80b3 	bpl.w	4188b0 <_vfiprintf_r+0x1b4>
  41874a:	f8db 3010 	ldr.w	r3, [fp, #16]
  41874e:	2b00      	cmp	r3, #0
  418750:	f000 80ae 	beq.w	4188b0 <_vfiprintf_r+0x1b4>
  418754:	f001 031a 	and.w	r3, r1, #26
  418758:	2b0a      	cmp	r3, #10
  41875a:	f000 80b5 	beq.w	4188c8 <_vfiprintf_r+0x1cc>
  41875e:	2300      	movs	r3, #0
  418760:	f10d 0970 	add.w	r9, sp, #112	; 0x70
  418764:	930b      	str	r3, [sp, #44]	; 0x2c
  418766:	9311      	str	r3, [sp, #68]	; 0x44
  418768:	9310      	str	r3, [sp, #64]	; 0x40
  41876a:	9303      	str	r3, [sp, #12]
  41876c:	f8cd 903c 	str.w	r9, [sp, #60]	; 0x3c
  418770:	46ca      	mov	sl, r9
  418772:	f8cd b010 	str.w	fp, [sp, #16]
  418776:	f898 3000 	ldrb.w	r3, [r8]
  41877a:	4644      	mov	r4, r8
  41877c:	b1fb      	cbz	r3, 4187be <_vfiprintf_r+0xc2>
  41877e:	2b25      	cmp	r3, #37	; 0x25
  418780:	d102      	bne.n	418788 <_vfiprintf_r+0x8c>
  418782:	e01c      	b.n	4187be <_vfiprintf_r+0xc2>
  418784:	2b25      	cmp	r3, #37	; 0x25
  418786:	d003      	beq.n	418790 <_vfiprintf_r+0x94>
  418788:	f814 3f01 	ldrb.w	r3, [r4, #1]!
  41878c:	2b00      	cmp	r3, #0
  41878e:	d1f9      	bne.n	418784 <_vfiprintf_r+0x88>
  418790:	eba4 0508 	sub.w	r5, r4, r8
  418794:	b19d      	cbz	r5, 4187be <_vfiprintf_r+0xc2>
  418796:	9b10      	ldr	r3, [sp, #64]	; 0x40
  418798:	9a11      	ldr	r2, [sp, #68]	; 0x44
  41879a:	f8ca 8000 	str.w	r8, [sl]
  41879e:	3301      	adds	r3, #1
  4187a0:	442a      	add	r2, r5
  4187a2:	2b07      	cmp	r3, #7
  4187a4:	f8ca 5004 	str.w	r5, [sl, #4]
  4187a8:	9211      	str	r2, [sp, #68]	; 0x44
  4187aa:	9310      	str	r3, [sp, #64]	; 0x40
  4187ac:	dd7a      	ble.n	4188a4 <_vfiprintf_r+0x1a8>
  4187ae:	2a00      	cmp	r2, #0
  4187b0:	f040 84b0 	bne.w	419114 <_vfiprintf_r+0xa18>
  4187b4:	9b03      	ldr	r3, [sp, #12]
  4187b6:	9210      	str	r2, [sp, #64]	; 0x40
  4187b8:	442b      	add	r3, r5
  4187ba:	46ca      	mov	sl, r9
  4187bc:	9303      	str	r3, [sp, #12]
  4187be:	7823      	ldrb	r3, [r4, #0]
  4187c0:	2b00      	cmp	r3, #0
  4187c2:	f000 83e0 	beq.w	418f86 <_vfiprintf_r+0x88a>
  4187c6:	2000      	movs	r0, #0
  4187c8:	f04f 0300 	mov.w	r3, #0
  4187cc:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
  4187d0:	f104 0801 	add.w	r8, r4, #1
  4187d4:	7862      	ldrb	r2, [r4, #1]
  4187d6:	4605      	mov	r5, r0
  4187d8:	4606      	mov	r6, r0
  4187da:	4603      	mov	r3, r0
  4187dc:	f04f 34ff 	mov.w	r4, #4294967295
  4187e0:	f108 0801 	add.w	r8, r8, #1
  4187e4:	f1a2 0120 	sub.w	r1, r2, #32
  4187e8:	2958      	cmp	r1, #88	; 0x58
  4187ea:	f200 82de 	bhi.w	418daa <_vfiprintf_r+0x6ae>
  4187ee:	e8df f011 	tbh	[pc, r1, lsl #1]
  4187f2:	0221      	.short	0x0221
  4187f4:	02dc02dc 	.word	0x02dc02dc
  4187f8:	02dc0229 	.word	0x02dc0229
  4187fc:	02dc02dc 	.word	0x02dc02dc
  418800:	02dc02dc 	.word	0x02dc02dc
  418804:	028902dc 	.word	0x028902dc
  418808:	02dc0295 	.word	0x02dc0295
  41880c:	02bd00a2 	.word	0x02bd00a2
  418810:	019f02dc 	.word	0x019f02dc
  418814:	01a401a4 	.word	0x01a401a4
  418818:	01a401a4 	.word	0x01a401a4
  41881c:	01a401a4 	.word	0x01a401a4
  418820:	01a401a4 	.word	0x01a401a4
  418824:	02dc01a4 	.word	0x02dc01a4
  418828:	02dc02dc 	.word	0x02dc02dc
  41882c:	02dc02dc 	.word	0x02dc02dc
  418830:	02dc02dc 	.word	0x02dc02dc
  418834:	02dc02dc 	.word	0x02dc02dc
  418838:	01b202dc 	.word	0x01b202dc
  41883c:	02dc02dc 	.word	0x02dc02dc
  418840:	02dc02dc 	.word	0x02dc02dc
  418844:	02dc02dc 	.word	0x02dc02dc
  418848:	02dc02dc 	.word	0x02dc02dc
  41884c:	02dc02dc 	.word	0x02dc02dc
  418850:	02dc0197 	.word	0x02dc0197
  418854:	02dc02dc 	.word	0x02dc02dc
  418858:	02dc02dc 	.word	0x02dc02dc
  41885c:	02dc019b 	.word	0x02dc019b
  418860:	025302dc 	.word	0x025302dc
  418864:	02dc02dc 	.word	0x02dc02dc
  418868:	02dc02dc 	.word	0x02dc02dc
  41886c:	02dc02dc 	.word	0x02dc02dc
  418870:	02dc02dc 	.word	0x02dc02dc
  418874:	02dc02dc 	.word	0x02dc02dc
  418878:	021b025a 	.word	0x021b025a
  41887c:	02dc02dc 	.word	0x02dc02dc
  418880:	026e02dc 	.word	0x026e02dc
  418884:	02dc021b 	.word	0x02dc021b
  418888:	027302dc 	.word	0x027302dc
  41888c:	01f502dc 	.word	0x01f502dc
  418890:	02090182 	.word	0x02090182
  418894:	02dc02d7 	.word	0x02dc02d7
  418898:	02dc029a 	.word	0x02dc029a
  41889c:	02dc00a7 	.word	0x02dc00a7
  4188a0:	022e02dc 	.word	0x022e02dc
  4188a4:	f10a 0a08 	add.w	sl, sl, #8
  4188a8:	9b03      	ldr	r3, [sp, #12]
  4188aa:	442b      	add	r3, r5
  4188ac:	9303      	str	r3, [sp, #12]
  4188ae:	e786      	b.n	4187be <_vfiprintf_r+0xc2>
  4188b0:	4659      	mov	r1, fp
  4188b2:	9806      	ldr	r0, [sp, #24]
  4188b4:	f000 fdac 	bl	419410 <__swsetup_r>
  4188b8:	bb18      	cbnz	r0, 418902 <_vfiprintf_r+0x206>
  4188ba:	f8bb 100c 	ldrh.w	r1, [fp, #12]
  4188be:	f001 031a 	and.w	r3, r1, #26
  4188c2:	2b0a      	cmp	r3, #10
  4188c4:	f47f af4b 	bne.w	41875e <_vfiprintf_r+0x62>
  4188c8:	f9bb 300e 	ldrsh.w	r3, [fp, #14]
  4188cc:	2b00      	cmp	r3, #0
  4188ce:	f6ff af46 	blt.w	41875e <_vfiprintf_r+0x62>
  4188d2:	f8db 3064 	ldr.w	r3, [fp, #100]	; 0x64
  4188d6:	07db      	lsls	r3, r3, #31
  4188d8:	d405      	bmi.n	4188e6 <_vfiprintf_r+0x1ea>
  4188da:	058f      	lsls	r7, r1, #22
  4188dc:	d403      	bmi.n	4188e6 <_vfiprintf_r+0x1ea>
  4188de:	f8db 0058 	ldr.w	r0, [fp, #88]	; 0x58
  4188e2:	f002 fa8f 	bl	41ae04 <__retarget_lock_release_recursive>
  4188e6:	462b      	mov	r3, r5
  4188e8:	4642      	mov	r2, r8
  4188ea:	4659      	mov	r1, fp
  4188ec:	9806      	ldr	r0, [sp, #24]
  4188ee:	f000 fd4d 	bl	41938c <__sbprintf>
  4188f2:	9003      	str	r0, [sp, #12]
  4188f4:	9803      	ldr	r0, [sp, #12]
  4188f6:	b02d      	add	sp, #180	; 0xb4
  4188f8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4188fc:	f001 feb2 	bl	41a664 <__sinit>
  418900:	e709      	b.n	418716 <_vfiprintf_r+0x1a>
  418902:	f8db 3064 	ldr.w	r3, [fp, #100]	; 0x64
  418906:	07d9      	lsls	r1, r3, #31
  418908:	d404      	bmi.n	418914 <_vfiprintf_r+0x218>
  41890a:	f8bb 300c 	ldrh.w	r3, [fp, #12]
  41890e:	059a      	lsls	r2, r3, #22
  418910:	f140 84aa 	bpl.w	419268 <_vfiprintf_r+0xb6c>
  418914:	f04f 33ff 	mov.w	r3, #4294967295
  418918:	9303      	str	r3, [sp, #12]
  41891a:	9803      	ldr	r0, [sp, #12]
  41891c:	b02d      	add	sp, #180	; 0xb4
  41891e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  418922:	f8db 0058 	ldr.w	r0, [fp, #88]	; 0x58
  418926:	f002 fa6b 	bl	41ae00 <__retarget_lock_acquire_recursive>
  41892a:	f9bb 000c 	ldrsh.w	r0, [fp, #12]
  41892e:	b281      	uxth	r1, r0
  418930:	e6fb      	b.n	41872a <_vfiprintf_r+0x2e>
  418932:	4276      	negs	r6, r6
  418934:	9207      	str	r2, [sp, #28]
  418936:	f043 0304 	orr.w	r3, r3, #4
  41893a:	f898 2000 	ldrb.w	r2, [r8]
  41893e:	e74f      	b.n	4187e0 <_vfiprintf_r+0xe4>
  418940:	9608      	str	r6, [sp, #32]
  418942:	069e      	lsls	r6, r3, #26
  418944:	f100 8450 	bmi.w	4191e8 <_vfiprintf_r+0xaec>
  418948:	9907      	ldr	r1, [sp, #28]
  41894a:	06dd      	lsls	r5, r3, #27
  41894c:	460a      	mov	r2, r1
  41894e:	f100 83ef 	bmi.w	419130 <_vfiprintf_r+0xa34>
  418952:	0658      	lsls	r0, r3, #25
  418954:	f140 83ec 	bpl.w	419130 <_vfiprintf_r+0xa34>
  418958:	880e      	ldrh	r6, [r1, #0]
  41895a:	3104      	adds	r1, #4
  41895c:	2700      	movs	r7, #0
  41895e:	2201      	movs	r2, #1
  418960:	9107      	str	r1, [sp, #28]
  418962:	f04f 0100 	mov.w	r1, #0
  418966:	f88d 1037 	strb.w	r1, [sp, #55]	; 0x37
  41896a:	2500      	movs	r5, #0
  41896c:	1c61      	adds	r1, r4, #1
  41896e:	f000 8116 	beq.w	418b9e <_vfiprintf_r+0x4a2>
  418972:	f023 0180 	bic.w	r1, r3, #128	; 0x80
  418976:	9102      	str	r1, [sp, #8]
  418978:	ea56 0107 	orrs.w	r1, r6, r7
  41897c:	f040 8114 	bne.w	418ba8 <_vfiprintf_r+0x4ac>
  418980:	2c00      	cmp	r4, #0
  418982:	f040 835c 	bne.w	41903e <_vfiprintf_r+0x942>
  418986:	2a00      	cmp	r2, #0
  418988:	f040 83b7 	bne.w	4190fa <_vfiprintf_r+0x9fe>
  41898c:	f013 0301 	ands.w	r3, r3, #1
  418990:	9305      	str	r3, [sp, #20]
  418992:	f000 8457 	beq.w	419244 <_vfiprintf_r+0xb48>
  418996:	f10d 0bb0 	add.w	fp, sp, #176	; 0xb0
  41899a:	2330      	movs	r3, #48	; 0x30
  41899c:	f80b 3d41 	strb.w	r3, [fp, #-65]!
  4189a0:	9b05      	ldr	r3, [sp, #20]
  4189a2:	42a3      	cmp	r3, r4
  4189a4:	bfb8      	it	lt
  4189a6:	4623      	movlt	r3, r4
  4189a8:	9301      	str	r3, [sp, #4]
  4189aa:	b10d      	cbz	r5, 4189b0 <_vfiprintf_r+0x2b4>
  4189ac:	3301      	adds	r3, #1
  4189ae:	9301      	str	r3, [sp, #4]
  4189b0:	9b02      	ldr	r3, [sp, #8]
  4189b2:	f013 0302 	ands.w	r3, r3, #2
  4189b6:	9309      	str	r3, [sp, #36]	; 0x24
  4189b8:	d002      	beq.n	4189c0 <_vfiprintf_r+0x2c4>
  4189ba:	9b01      	ldr	r3, [sp, #4]
  4189bc:	3302      	adds	r3, #2
  4189be:	9301      	str	r3, [sp, #4]
  4189c0:	9b02      	ldr	r3, [sp, #8]
  4189c2:	f013 0384 	ands.w	r3, r3, #132	; 0x84
  4189c6:	930a      	str	r3, [sp, #40]	; 0x28
  4189c8:	f040 8217 	bne.w	418dfa <_vfiprintf_r+0x6fe>
  4189cc:	9b08      	ldr	r3, [sp, #32]
  4189ce:	9a01      	ldr	r2, [sp, #4]
  4189d0:	1a9d      	subs	r5, r3, r2
  4189d2:	2d00      	cmp	r5, #0
  4189d4:	f340 8211 	ble.w	418dfa <_vfiprintf_r+0x6fe>
  4189d8:	2d10      	cmp	r5, #16
  4189da:	f340 8490 	ble.w	4192fe <_vfiprintf_r+0xc02>
  4189de:	9b10      	ldr	r3, [sp, #64]	; 0x40
  4189e0:	9a11      	ldr	r2, [sp, #68]	; 0x44
  4189e2:	4ec4      	ldr	r6, [pc, #784]	; (418cf4 <_vfiprintf_r+0x5f8>)
  4189e4:	46d6      	mov	lr, sl
  4189e6:	2710      	movs	r7, #16
  4189e8:	46a2      	mov	sl, r4
  4189ea:	4619      	mov	r1, r3
  4189ec:	9c06      	ldr	r4, [sp, #24]
  4189ee:	e007      	b.n	418a00 <_vfiprintf_r+0x304>
  4189f0:	f101 0c02 	add.w	ip, r1, #2
  4189f4:	f10e 0e08 	add.w	lr, lr, #8
  4189f8:	4601      	mov	r1, r0
  4189fa:	3d10      	subs	r5, #16
  4189fc:	2d10      	cmp	r5, #16
  4189fe:	dd11      	ble.n	418a24 <_vfiprintf_r+0x328>
  418a00:	1c48      	adds	r0, r1, #1
  418a02:	3210      	adds	r2, #16
  418a04:	2807      	cmp	r0, #7
  418a06:	9211      	str	r2, [sp, #68]	; 0x44
  418a08:	e88e 00c0 	stmia.w	lr, {r6, r7}
  418a0c:	9010      	str	r0, [sp, #64]	; 0x40
  418a0e:	ddef      	ble.n	4189f0 <_vfiprintf_r+0x2f4>
  418a10:	2a00      	cmp	r2, #0
  418a12:	f040 81e4 	bne.w	418dde <_vfiprintf_r+0x6e2>
  418a16:	3d10      	subs	r5, #16
  418a18:	2d10      	cmp	r5, #16
  418a1a:	4611      	mov	r1, r2
  418a1c:	f04f 0c01 	mov.w	ip, #1
  418a20:	46ce      	mov	lr, r9
  418a22:	dced      	bgt.n	418a00 <_vfiprintf_r+0x304>
  418a24:	4654      	mov	r4, sl
  418a26:	4661      	mov	r1, ip
  418a28:	46f2      	mov	sl, lr
  418a2a:	442a      	add	r2, r5
  418a2c:	2907      	cmp	r1, #7
  418a2e:	9211      	str	r2, [sp, #68]	; 0x44
  418a30:	f8ca 6000 	str.w	r6, [sl]
  418a34:	f8ca 5004 	str.w	r5, [sl, #4]
  418a38:	9110      	str	r1, [sp, #64]	; 0x40
  418a3a:	f300 82ec 	bgt.w	419016 <_vfiprintf_r+0x91a>
  418a3e:	f89d 5037 	ldrb.w	r5, [sp, #55]	; 0x37
  418a42:	f10a 0a08 	add.w	sl, sl, #8
  418a46:	1c48      	adds	r0, r1, #1
  418a48:	2d00      	cmp	r5, #0
  418a4a:	f040 81de 	bne.w	418e0a <_vfiprintf_r+0x70e>
  418a4e:	9b09      	ldr	r3, [sp, #36]	; 0x24
  418a50:	2b00      	cmp	r3, #0
  418a52:	f000 81f8 	beq.w	418e46 <_vfiprintf_r+0x74a>
  418a56:	3202      	adds	r2, #2
  418a58:	a90e      	add	r1, sp, #56	; 0x38
  418a5a:	2302      	movs	r3, #2
  418a5c:	2807      	cmp	r0, #7
  418a5e:	9211      	str	r2, [sp, #68]	; 0x44
  418a60:	9010      	str	r0, [sp, #64]	; 0x40
  418a62:	e88a 000a 	stmia.w	sl, {r1, r3}
  418a66:	f340 81ea 	ble.w	418e3e <_vfiprintf_r+0x742>
  418a6a:	2a00      	cmp	r2, #0
  418a6c:	f040 838c 	bne.w	419188 <_vfiprintf_r+0xa8c>
  418a70:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  418a72:	2b80      	cmp	r3, #128	; 0x80
  418a74:	f04f 0001 	mov.w	r0, #1
  418a78:	4611      	mov	r1, r2
  418a7a:	46ca      	mov	sl, r9
  418a7c:	f040 81e7 	bne.w	418e4e <_vfiprintf_r+0x752>
  418a80:	9b08      	ldr	r3, [sp, #32]
  418a82:	9d01      	ldr	r5, [sp, #4]
  418a84:	1b5e      	subs	r6, r3, r5
  418a86:	2e00      	cmp	r6, #0
  418a88:	f340 81e1 	ble.w	418e4e <_vfiprintf_r+0x752>
  418a8c:	2e10      	cmp	r6, #16
  418a8e:	4d9a      	ldr	r5, [pc, #616]	; (418cf8 <_vfiprintf_r+0x5fc>)
  418a90:	f340 8450 	ble.w	419334 <_vfiprintf_r+0xc38>
  418a94:	46d4      	mov	ip, sl
  418a96:	2710      	movs	r7, #16
  418a98:	46a2      	mov	sl, r4
  418a9a:	9c06      	ldr	r4, [sp, #24]
  418a9c:	e007      	b.n	418aae <_vfiprintf_r+0x3b2>
  418a9e:	f101 0e02 	add.w	lr, r1, #2
  418aa2:	f10c 0c08 	add.w	ip, ip, #8
  418aa6:	4601      	mov	r1, r0
  418aa8:	3e10      	subs	r6, #16
  418aaa:	2e10      	cmp	r6, #16
  418aac:	dd11      	ble.n	418ad2 <_vfiprintf_r+0x3d6>
  418aae:	1c48      	adds	r0, r1, #1
  418ab0:	3210      	adds	r2, #16
  418ab2:	2807      	cmp	r0, #7
  418ab4:	9211      	str	r2, [sp, #68]	; 0x44
  418ab6:	e88c 00a0 	stmia.w	ip, {r5, r7}
  418aba:	9010      	str	r0, [sp, #64]	; 0x40
  418abc:	ddef      	ble.n	418a9e <_vfiprintf_r+0x3a2>
  418abe:	2a00      	cmp	r2, #0
  418ac0:	f040 829d 	bne.w	418ffe <_vfiprintf_r+0x902>
  418ac4:	3e10      	subs	r6, #16
  418ac6:	2e10      	cmp	r6, #16
  418ac8:	f04f 0e01 	mov.w	lr, #1
  418acc:	4611      	mov	r1, r2
  418ace:	46cc      	mov	ip, r9
  418ad0:	dced      	bgt.n	418aae <_vfiprintf_r+0x3b2>
  418ad2:	4654      	mov	r4, sl
  418ad4:	46e2      	mov	sl, ip
  418ad6:	4432      	add	r2, r6
  418ad8:	f1be 0f07 	cmp.w	lr, #7
  418adc:	9211      	str	r2, [sp, #68]	; 0x44
  418ade:	e88a 0060 	stmia.w	sl, {r5, r6}
  418ae2:	f8cd e040 	str.w	lr, [sp, #64]	; 0x40
  418ae6:	f300 8369 	bgt.w	4191bc <_vfiprintf_r+0xac0>
  418aea:	f10a 0a08 	add.w	sl, sl, #8
  418aee:	f10e 0001 	add.w	r0, lr, #1
  418af2:	4671      	mov	r1, lr
  418af4:	e1ab      	b.n	418e4e <_vfiprintf_r+0x752>
  418af6:	9608      	str	r6, [sp, #32]
  418af8:	f013 0220 	ands.w	r2, r3, #32
  418afc:	f040 838c 	bne.w	419218 <_vfiprintf_r+0xb1c>
  418b00:	f013 0110 	ands.w	r1, r3, #16
  418b04:	f040 831a 	bne.w	41913c <_vfiprintf_r+0xa40>
  418b08:	f013 0240 	ands.w	r2, r3, #64	; 0x40
  418b0c:	f000 8316 	beq.w	41913c <_vfiprintf_r+0xa40>
  418b10:	9807      	ldr	r0, [sp, #28]
  418b12:	460a      	mov	r2, r1
  418b14:	4601      	mov	r1, r0
  418b16:	3104      	adds	r1, #4
  418b18:	8806      	ldrh	r6, [r0, #0]
  418b1a:	9107      	str	r1, [sp, #28]
  418b1c:	2700      	movs	r7, #0
  418b1e:	e720      	b.n	418962 <_vfiprintf_r+0x266>
  418b20:	9608      	str	r6, [sp, #32]
  418b22:	f043 0310 	orr.w	r3, r3, #16
  418b26:	e7e7      	b.n	418af8 <_vfiprintf_r+0x3fc>
  418b28:	9608      	str	r6, [sp, #32]
  418b2a:	f043 0310 	orr.w	r3, r3, #16
  418b2e:	e708      	b.n	418942 <_vfiprintf_r+0x246>
  418b30:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  418b34:	f898 2000 	ldrb.w	r2, [r8]
  418b38:	e652      	b.n	4187e0 <_vfiprintf_r+0xe4>
  418b3a:	f1a2 0130 	sub.w	r1, r2, #48	; 0x30
  418b3e:	2600      	movs	r6, #0
  418b40:	f818 2b01 	ldrb.w	r2, [r8], #1
  418b44:	eb06 0686 	add.w	r6, r6, r6, lsl #2
  418b48:	eb01 0646 	add.w	r6, r1, r6, lsl #1
  418b4c:	f1a2 0130 	sub.w	r1, r2, #48	; 0x30
  418b50:	2909      	cmp	r1, #9
  418b52:	d9f5      	bls.n	418b40 <_vfiprintf_r+0x444>
  418b54:	e646      	b.n	4187e4 <_vfiprintf_r+0xe8>
  418b56:	9608      	str	r6, [sp, #32]
  418b58:	2800      	cmp	r0, #0
  418b5a:	f040 8408 	bne.w	41936e <_vfiprintf_r+0xc72>
  418b5e:	f043 0310 	orr.w	r3, r3, #16
  418b62:	069e      	lsls	r6, r3, #26
  418b64:	f100 834c 	bmi.w	419200 <_vfiprintf_r+0xb04>
  418b68:	06dd      	lsls	r5, r3, #27
  418b6a:	f100 82f3 	bmi.w	419154 <_vfiprintf_r+0xa58>
  418b6e:	0658      	lsls	r0, r3, #25
  418b70:	f140 82f0 	bpl.w	419154 <_vfiprintf_r+0xa58>
  418b74:	9d07      	ldr	r5, [sp, #28]
  418b76:	f9b5 6000 	ldrsh.w	r6, [r5]
  418b7a:	462a      	mov	r2, r5
  418b7c:	17f7      	asrs	r7, r6, #31
  418b7e:	3204      	adds	r2, #4
  418b80:	4630      	mov	r0, r6
  418b82:	4639      	mov	r1, r7
  418b84:	9207      	str	r2, [sp, #28]
  418b86:	2800      	cmp	r0, #0
  418b88:	f171 0200 	sbcs.w	r2, r1, #0
  418b8c:	f2c0 835d 	blt.w	41924a <_vfiprintf_r+0xb4e>
  418b90:	1c61      	adds	r1, r4, #1
  418b92:	f89d 5037 	ldrb.w	r5, [sp, #55]	; 0x37
  418b96:	f04f 0201 	mov.w	r2, #1
  418b9a:	f47f aeea 	bne.w	418972 <_vfiprintf_r+0x276>
  418b9e:	ea56 0107 	orrs.w	r1, r6, r7
  418ba2:	f000 824d 	beq.w	419040 <_vfiprintf_r+0x944>
  418ba6:	9302      	str	r3, [sp, #8]
  418ba8:	2a01      	cmp	r2, #1
  418baa:	f000 828c 	beq.w	4190c6 <_vfiprintf_r+0x9ca>
  418bae:	2a02      	cmp	r2, #2
  418bb0:	f040 825c 	bne.w	41906c <_vfiprintf_r+0x970>
  418bb4:	980b      	ldr	r0, [sp, #44]	; 0x2c
  418bb6:	46cb      	mov	fp, r9
  418bb8:	0933      	lsrs	r3, r6, #4
  418bba:	f006 010f 	and.w	r1, r6, #15
  418bbe:	ea43 7307 	orr.w	r3, r3, r7, lsl #28
  418bc2:	093a      	lsrs	r2, r7, #4
  418bc4:	461e      	mov	r6, r3
  418bc6:	4617      	mov	r7, r2
  418bc8:	5c43      	ldrb	r3, [r0, r1]
  418bca:	f80b 3d01 	strb.w	r3, [fp, #-1]!
  418bce:	ea56 0307 	orrs.w	r3, r6, r7
  418bd2:	d1f1      	bne.n	418bb8 <_vfiprintf_r+0x4bc>
  418bd4:	eba9 030b 	sub.w	r3, r9, fp
  418bd8:	9305      	str	r3, [sp, #20]
  418bda:	e6e1      	b.n	4189a0 <_vfiprintf_r+0x2a4>
  418bdc:	2800      	cmp	r0, #0
  418bde:	f040 83c0 	bne.w	419362 <_vfiprintf_r+0xc66>
  418be2:	0699      	lsls	r1, r3, #26
  418be4:	f100 8367 	bmi.w	4192b6 <_vfiprintf_r+0xbba>
  418be8:	06da      	lsls	r2, r3, #27
  418bea:	f100 80f1 	bmi.w	418dd0 <_vfiprintf_r+0x6d4>
  418bee:	065b      	lsls	r3, r3, #25
  418bf0:	f140 80ee 	bpl.w	418dd0 <_vfiprintf_r+0x6d4>
  418bf4:	9a07      	ldr	r2, [sp, #28]
  418bf6:	6813      	ldr	r3, [r2, #0]
  418bf8:	3204      	adds	r2, #4
  418bfa:	9207      	str	r2, [sp, #28]
  418bfc:	f8bd 200c 	ldrh.w	r2, [sp, #12]
  418c00:	801a      	strh	r2, [r3, #0]
  418c02:	e5b8      	b.n	418776 <_vfiprintf_r+0x7a>
  418c04:	9807      	ldr	r0, [sp, #28]
  418c06:	4a3d      	ldr	r2, [pc, #244]	; (418cfc <_vfiprintf_r+0x600>)
  418c08:	9608      	str	r6, [sp, #32]
  418c0a:	920b      	str	r2, [sp, #44]	; 0x2c
  418c0c:	6806      	ldr	r6, [r0, #0]
  418c0e:	2278      	movs	r2, #120	; 0x78
  418c10:	2130      	movs	r1, #48	; 0x30
  418c12:	3004      	adds	r0, #4
  418c14:	f88d 2039 	strb.w	r2, [sp, #57]	; 0x39
  418c18:	f043 0302 	orr.w	r3, r3, #2
  418c1c:	9007      	str	r0, [sp, #28]
  418c1e:	2700      	movs	r7, #0
  418c20:	f88d 1038 	strb.w	r1, [sp, #56]	; 0x38
  418c24:	2202      	movs	r2, #2
  418c26:	e69c      	b.n	418962 <_vfiprintf_r+0x266>
  418c28:	9608      	str	r6, [sp, #32]
  418c2a:	2800      	cmp	r0, #0
  418c2c:	d099      	beq.n	418b62 <_vfiprintf_r+0x466>
  418c2e:	f88d 5037 	strb.w	r5, [sp, #55]	; 0x37
  418c32:	e796      	b.n	418b62 <_vfiprintf_r+0x466>
  418c34:	f898 2000 	ldrb.w	r2, [r8]
  418c38:	2d00      	cmp	r5, #0
  418c3a:	f47f add1 	bne.w	4187e0 <_vfiprintf_r+0xe4>
  418c3e:	2001      	movs	r0, #1
  418c40:	2520      	movs	r5, #32
  418c42:	e5cd      	b.n	4187e0 <_vfiprintf_r+0xe4>
  418c44:	f043 0301 	orr.w	r3, r3, #1
  418c48:	f898 2000 	ldrb.w	r2, [r8]
  418c4c:	e5c8      	b.n	4187e0 <_vfiprintf_r+0xe4>
  418c4e:	9608      	str	r6, [sp, #32]
  418c50:	2800      	cmp	r0, #0
  418c52:	f040 8393 	bne.w	41937c <_vfiprintf_r+0xc80>
  418c56:	4929      	ldr	r1, [pc, #164]	; (418cfc <_vfiprintf_r+0x600>)
  418c58:	910b      	str	r1, [sp, #44]	; 0x2c
  418c5a:	069f      	lsls	r7, r3, #26
  418c5c:	f100 82e8 	bmi.w	419230 <_vfiprintf_r+0xb34>
  418c60:	9807      	ldr	r0, [sp, #28]
  418c62:	06de      	lsls	r6, r3, #27
  418c64:	4601      	mov	r1, r0
  418c66:	f100 8270 	bmi.w	41914a <_vfiprintf_r+0xa4e>
  418c6a:	065d      	lsls	r5, r3, #25
  418c6c:	f140 826d 	bpl.w	41914a <_vfiprintf_r+0xa4e>
  418c70:	3104      	adds	r1, #4
  418c72:	8806      	ldrh	r6, [r0, #0]
  418c74:	9107      	str	r1, [sp, #28]
  418c76:	2700      	movs	r7, #0
  418c78:	07d8      	lsls	r0, r3, #31
  418c7a:	f140 8222 	bpl.w	4190c2 <_vfiprintf_r+0x9c6>
  418c7e:	ea56 0107 	orrs.w	r1, r6, r7
  418c82:	f000 821e 	beq.w	4190c2 <_vfiprintf_r+0x9c6>
  418c86:	2130      	movs	r1, #48	; 0x30
  418c88:	f88d 2039 	strb.w	r2, [sp, #57]	; 0x39
  418c8c:	f043 0302 	orr.w	r3, r3, #2
  418c90:	f88d 1038 	strb.w	r1, [sp, #56]	; 0x38
  418c94:	2202      	movs	r2, #2
  418c96:	e664      	b.n	418962 <_vfiprintf_r+0x266>
  418c98:	9608      	str	r6, [sp, #32]
  418c9a:	2800      	cmp	r0, #0
  418c9c:	f040 836b 	bne.w	419376 <_vfiprintf_r+0xc7a>
  418ca0:	4917      	ldr	r1, [pc, #92]	; (418d00 <_vfiprintf_r+0x604>)
  418ca2:	910b      	str	r1, [sp, #44]	; 0x2c
  418ca4:	e7d9      	b.n	418c5a <_vfiprintf_r+0x55e>
  418ca6:	9907      	ldr	r1, [sp, #28]
  418ca8:	9608      	str	r6, [sp, #32]
  418caa:	680a      	ldr	r2, [r1, #0]
  418cac:	f88d 2048 	strb.w	r2, [sp, #72]	; 0x48
  418cb0:	f04f 0000 	mov.w	r0, #0
  418cb4:	460a      	mov	r2, r1
  418cb6:	f88d 0037 	strb.w	r0, [sp, #55]	; 0x37
  418cba:	3204      	adds	r2, #4
  418cbc:	2001      	movs	r0, #1
  418cbe:	9001      	str	r0, [sp, #4]
  418cc0:	9207      	str	r2, [sp, #28]
  418cc2:	9005      	str	r0, [sp, #20]
  418cc4:	f10d 0b48 	add.w	fp, sp, #72	; 0x48
  418cc8:	9302      	str	r3, [sp, #8]
  418cca:	2400      	movs	r4, #0
  418ccc:	e670      	b.n	4189b0 <_vfiprintf_r+0x2b4>
  418cce:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  418cd2:	f898 2000 	ldrb.w	r2, [r8]
  418cd6:	e583      	b.n	4187e0 <_vfiprintf_r+0xe4>
  418cd8:	f898 2000 	ldrb.w	r2, [r8]
  418cdc:	2a6c      	cmp	r2, #108	; 0x6c
  418cde:	bf03      	ittte	eq
  418ce0:	f898 2001 	ldrbeq.w	r2, [r8, #1]
  418ce4:	f043 0320 	orreq.w	r3, r3, #32
  418ce8:	f108 0801 	addeq.w	r8, r8, #1
  418cec:	f043 0310 	orrne.w	r3, r3, #16
  418cf0:	e576      	b.n	4187e0 <_vfiprintf_r+0xe4>
  418cf2:	bf00      	nop
  418cf4:	0041ea34 	.word	0x0041ea34
  418cf8:	0041ea44 	.word	0x0041ea44
  418cfc:	0041e9f4 	.word	0x0041e9f4
  418d00:	0041e9e0 	.word	0x0041e9e0
  418d04:	9907      	ldr	r1, [sp, #28]
  418d06:	680e      	ldr	r6, [r1, #0]
  418d08:	460a      	mov	r2, r1
  418d0a:	2e00      	cmp	r6, #0
  418d0c:	f102 0204 	add.w	r2, r2, #4
  418d10:	f6ff ae0f 	blt.w	418932 <_vfiprintf_r+0x236>
  418d14:	9207      	str	r2, [sp, #28]
  418d16:	f898 2000 	ldrb.w	r2, [r8]
  418d1a:	e561      	b.n	4187e0 <_vfiprintf_r+0xe4>
  418d1c:	f898 2000 	ldrb.w	r2, [r8]
  418d20:	2001      	movs	r0, #1
  418d22:	252b      	movs	r5, #43	; 0x2b
  418d24:	e55c      	b.n	4187e0 <_vfiprintf_r+0xe4>
  418d26:	9907      	ldr	r1, [sp, #28]
  418d28:	9608      	str	r6, [sp, #32]
  418d2a:	f8d1 b000 	ldr.w	fp, [r1]
  418d2e:	f04f 0200 	mov.w	r2, #0
  418d32:	f88d 2037 	strb.w	r2, [sp, #55]	; 0x37
  418d36:	1d0e      	adds	r6, r1, #4
  418d38:	f1bb 0f00 	cmp.w	fp, #0
  418d3c:	f000 82e5 	beq.w	41930a <_vfiprintf_r+0xc0e>
  418d40:	1c67      	adds	r7, r4, #1
  418d42:	f000 82c4 	beq.w	4192ce <_vfiprintf_r+0xbd2>
  418d46:	4622      	mov	r2, r4
  418d48:	2100      	movs	r1, #0
  418d4a:	4658      	mov	r0, fp
  418d4c:	9301      	str	r3, [sp, #4]
  418d4e:	f002 fba7 	bl	41b4a0 <memchr>
  418d52:	9b01      	ldr	r3, [sp, #4]
  418d54:	2800      	cmp	r0, #0
  418d56:	f000 82e5 	beq.w	419324 <_vfiprintf_r+0xc28>
  418d5a:	eba0 020b 	sub.w	r2, r0, fp
  418d5e:	9205      	str	r2, [sp, #20]
  418d60:	9607      	str	r6, [sp, #28]
  418d62:	9302      	str	r3, [sp, #8]
  418d64:	f89d 5037 	ldrb.w	r5, [sp, #55]	; 0x37
  418d68:	2400      	movs	r4, #0
  418d6a:	e619      	b.n	4189a0 <_vfiprintf_r+0x2a4>
  418d6c:	f898 2000 	ldrb.w	r2, [r8]
  418d70:	2a2a      	cmp	r2, #42	; 0x2a
  418d72:	f108 0701 	add.w	r7, r8, #1
  418d76:	f000 82e9 	beq.w	41934c <_vfiprintf_r+0xc50>
  418d7a:	f1a2 0130 	sub.w	r1, r2, #48	; 0x30
  418d7e:	2909      	cmp	r1, #9
  418d80:	46b8      	mov	r8, r7
  418d82:	f04f 0400 	mov.w	r4, #0
  418d86:	f63f ad2d 	bhi.w	4187e4 <_vfiprintf_r+0xe8>
  418d8a:	f818 2b01 	ldrb.w	r2, [r8], #1
  418d8e:	eb04 0484 	add.w	r4, r4, r4, lsl #2
  418d92:	eb01 0444 	add.w	r4, r1, r4, lsl #1
  418d96:	f1a2 0130 	sub.w	r1, r2, #48	; 0x30
  418d9a:	2909      	cmp	r1, #9
  418d9c:	d9f5      	bls.n	418d8a <_vfiprintf_r+0x68e>
  418d9e:	e521      	b.n	4187e4 <_vfiprintf_r+0xe8>
  418da0:	f043 0320 	orr.w	r3, r3, #32
  418da4:	f898 2000 	ldrb.w	r2, [r8]
  418da8:	e51a      	b.n	4187e0 <_vfiprintf_r+0xe4>
  418daa:	9608      	str	r6, [sp, #32]
  418dac:	2800      	cmp	r0, #0
  418dae:	f040 82db 	bne.w	419368 <_vfiprintf_r+0xc6c>
  418db2:	2a00      	cmp	r2, #0
  418db4:	f000 80e7 	beq.w	418f86 <_vfiprintf_r+0x88a>
  418db8:	2101      	movs	r1, #1
  418dba:	f88d 2048 	strb.w	r2, [sp, #72]	; 0x48
  418dbe:	f04f 0200 	mov.w	r2, #0
  418dc2:	9101      	str	r1, [sp, #4]
  418dc4:	f88d 2037 	strb.w	r2, [sp, #55]	; 0x37
  418dc8:	9105      	str	r1, [sp, #20]
  418dca:	f10d 0b48 	add.w	fp, sp, #72	; 0x48
  418dce:	e77b      	b.n	418cc8 <_vfiprintf_r+0x5cc>
  418dd0:	9a07      	ldr	r2, [sp, #28]
  418dd2:	6813      	ldr	r3, [r2, #0]
  418dd4:	3204      	adds	r2, #4
  418dd6:	9207      	str	r2, [sp, #28]
  418dd8:	9a03      	ldr	r2, [sp, #12]
  418dda:	601a      	str	r2, [r3, #0]
  418ddc:	e4cb      	b.n	418776 <_vfiprintf_r+0x7a>
  418dde:	aa0f      	add	r2, sp, #60	; 0x3c
  418de0:	9904      	ldr	r1, [sp, #16]
  418de2:	4620      	mov	r0, r4
  418de4:	f7ff fc4a 	bl	41867c <__sprint_r.part.0>
  418de8:	2800      	cmp	r0, #0
  418dea:	f040 8139 	bne.w	419060 <_vfiprintf_r+0x964>
  418dee:	9910      	ldr	r1, [sp, #64]	; 0x40
  418df0:	9a11      	ldr	r2, [sp, #68]	; 0x44
  418df2:	f101 0c01 	add.w	ip, r1, #1
  418df6:	46ce      	mov	lr, r9
  418df8:	e5ff      	b.n	4189fa <_vfiprintf_r+0x2fe>
  418dfa:	9910      	ldr	r1, [sp, #64]	; 0x40
  418dfc:	9a11      	ldr	r2, [sp, #68]	; 0x44
  418dfe:	1c48      	adds	r0, r1, #1
  418e00:	f89d 5037 	ldrb.w	r5, [sp, #55]	; 0x37
  418e04:	2d00      	cmp	r5, #0
  418e06:	f43f ae22 	beq.w	418a4e <_vfiprintf_r+0x352>
  418e0a:	3201      	adds	r2, #1
  418e0c:	f10d 0537 	add.w	r5, sp, #55	; 0x37
  418e10:	2101      	movs	r1, #1
  418e12:	2807      	cmp	r0, #7
  418e14:	9211      	str	r2, [sp, #68]	; 0x44
  418e16:	9010      	str	r0, [sp, #64]	; 0x40
  418e18:	f8ca 5000 	str.w	r5, [sl]
  418e1c:	f8ca 1004 	str.w	r1, [sl, #4]
  418e20:	f340 8108 	ble.w	419034 <_vfiprintf_r+0x938>
  418e24:	2a00      	cmp	r2, #0
  418e26:	f040 81bc 	bne.w	4191a2 <_vfiprintf_r+0xaa6>
  418e2a:	9b09      	ldr	r3, [sp, #36]	; 0x24
  418e2c:	2b00      	cmp	r3, #0
  418e2e:	f43f ae1f 	beq.w	418a70 <_vfiprintf_r+0x374>
  418e32:	ab0e      	add	r3, sp, #56	; 0x38
  418e34:	2202      	movs	r2, #2
  418e36:	4608      	mov	r0, r1
  418e38:	931c      	str	r3, [sp, #112]	; 0x70
  418e3a:	921d      	str	r2, [sp, #116]	; 0x74
  418e3c:	46ca      	mov	sl, r9
  418e3e:	4601      	mov	r1, r0
  418e40:	f10a 0a08 	add.w	sl, sl, #8
  418e44:	3001      	adds	r0, #1
  418e46:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  418e48:	2b80      	cmp	r3, #128	; 0x80
  418e4a:	f43f ae19 	beq.w	418a80 <_vfiprintf_r+0x384>
  418e4e:	9b05      	ldr	r3, [sp, #20]
  418e50:	1ae4      	subs	r4, r4, r3
  418e52:	2c00      	cmp	r4, #0
  418e54:	dd2e      	ble.n	418eb4 <_vfiprintf_r+0x7b8>
  418e56:	2c10      	cmp	r4, #16
  418e58:	4db3      	ldr	r5, [pc, #716]	; (419128 <_vfiprintf_r+0xa2c>)
  418e5a:	dd1e      	ble.n	418e9a <_vfiprintf_r+0x79e>
  418e5c:	46d6      	mov	lr, sl
  418e5e:	2610      	movs	r6, #16
  418e60:	9f06      	ldr	r7, [sp, #24]
  418e62:	f8dd a010 	ldr.w	sl, [sp, #16]
  418e66:	e006      	b.n	418e76 <_vfiprintf_r+0x77a>
  418e68:	1c88      	adds	r0, r1, #2
  418e6a:	f10e 0e08 	add.w	lr, lr, #8
  418e6e:	4619      	mov	r1, r3
  418e70:	3c10      	subs	r4, #16
  418e72:	2c10      	cmp	r4, #16
  418e74:	dd10      	ble.n	418e98 <_vfiprintf_r+0x79c>
  418e76:	1c4b      	adds	r3, r1, #1
  418e78:	3210      	adds	r2, #16
  418e7a:	2b07      	cmp	r3, #7
  418e7c:	9211      	str	r2, [sp, #68]	; 0x44
  418e7e:	e88e 0060 	stmia.w	lr, {r5, r6}
  418e82:	9310      	str	r3, [sp, #64]	; 0x40
  418e84:	ddf0      	ble.n	418e68 <_vfiprintf_r+0x76c>
  418e86:	2a00      	cmp	r2, #0
  418e88:	d165      	bne.n	418f56 <_vfiprintf_r+0x85a>
  418e8a:	3c10      	subs	r4, #16
  418e8c:	2c10      	cmp	r4, #16
  418e8e:	f04f 0001 	mov.w	r0, #1
  418e92:	4611      	mov	r1, r2
  418e94:	46ce      	mov	lr, r9
  418e96:	dcee      	bgt.n	418e76 <_vfiprintf_r+0x77a>
  418e98:	46f2      	mov	sl, lr
  418e9a:	4422      	add	r2, r4
  418e9c:	2807      	cmp	r0, #7
  418e9e:	9211      	str	r2, [sp, #68]	; 0x44
  418ea0:	f8ca 5000 	str.w	r5, [sl]
  418ea4:	f8ca 4004 	str.w	r4, [sl, #4]
  418ea8:	9010      	str	r0, [sp, #64]	; 0x40
  418eaa:	f300 8085 	bgt.w	418fb8 <_vfiprintf_r+0x8bc>
  418eae:	f10a 0a08 	add.w	sl, sl, #8
  418eb2:	3001      	adds	r0, #1
  418eb4:	9905      	ldr	r1, [sp, #20]
  418eb6:	f8ca b000 	str.w	fp, [sl]
  418eba:	440a      	add	r2, r1
  418ebc:	2807      	cmp	r0, #7
  418ebe:	9211      	str	r2, [sp, #68]	; 0x44
  418ec0:	f8ca 1004 	str.w	r1, [sl, #4]
  418ec4:	9010      	str	r0, [sp, #64]	; 0x40
  418ec6:	f340 8082 	ble.w	418fce <_vfiprintf_r+0x8d2>
  418eca:	2a00      	cmp	r2, #0
  418ecc:	f040 8118 	bne.w	419100 <_vfiprintf_r+0xa04>
  418ed0:	9b02      	ldr	r3, [sp, #8]
  418ed2:	9210      	str	r2, [sp, #64]	; 0x40
  418ed4:	0758      	lsls	r0, r3, #29
  418ed6:	d535      	bpl.n	418f44 <_vfiprintf_r+0x848>
  418ed8:	9b08      	ldr	r3, [sp, #32]
  418eda:	9901      	ldr	r1, [sp, #4]
  418edc:	1a5c      	subs	r4, r3, r1
  418ede:	2c00      	cmp	r4, #0
  418ee0:	f340 80e7 	ble.w	4190b2 <_vfiprintf_r+0x9b6>
  418ee4:	46ca      	mov	sl, r9
  418ee6:	2c10      	cmp	r4, #16
  418ee8:	f340 8218 	ble.w	41931c <_vfiprintf_r+0xc20>
  418eec:	9910      	ldr	r1, [sp, #64]	; 0x40
  418eee:	4e8f      	ldr	r6, [pc, #572]	; (41912c <_vfiprintf_r+0xa30>)
  418ef0:	9f06      	ldr	r7, [sp, #24]
  418ef2:	f8dd b010 	ldr.w	fp, [sp, #16]
  418ef6:	2510      	movs	r5, #16
  418ef8:	e006      	b.n	418f08 <_vfiprintf_r+0x80c>
  418efa:	1c88      	adds	r0, r1, #2
  418efc:	f10a 0a08 	add.w	sl, sl, #8
  418f00:	4619      	mov	r1, r3
  418f02:	3c10      	subs	r4, #16
  418f04:	2c10      	cmp	r4, #16
  418f06:	dd11      	ble.n	418f2c <_vfiprintf_r+0x830>
  418f08:	1c4b      	adds	r3, r1, #1
  418f0a:	3210      	adds	r2, #16
  418f0c:	2b07      	cmp	r3, #7
  418f0e:	9211      	str	r2, [sp, #68]	; 0x44
  418f10:	f8ca 6000 	str.w	r6, [sl]
  418f14:	f8ca 5004 	str.w	r5, [sl, #4]
  418f18:	9310      	str	r3, [sp, #64]	; 0x40
  418f1a:	ddee      	ble.n	418efa <_vfiprintf_r+0x7fe>
  418f1c:	bb42      	cbnz	r2, 418f70 <_vfiprintf_r+0x874>
  418f1e:	3c10      	subs	r4, #16
  418f20:	2c10      	cmp	r4, #16
  418f22:	f04f 0001 	mov.w	r0, #1
  418f26:	4611      	mov	r1, r2
  418f28:	46ca      	mov	sl, r9
  418f2a:	dced      	bgt.n	418f08 <_vfiprintf_r+0x80c>
  418f2c:	4422      	add	r2, r4
  418f2e:	2807      	cmp	r0, #7
  418f30:	9211      	str	r2, [sp, #68]	; 0x44
  418f32:	f8ca 6000 	str.w	r6, [sl]
  418f36:	f8ca 4004 	str.w	r4, [sl, #4]
  418f3a:	9010      	str	r0, [sp, #64]	; 0x40
  418f3c:	dd51      	ble.n	418fe2 <_vfiprintf_r+0x8e6>
  418f3e:	2a00      	cmp	r2, #0
  418f40:	f040 819b 	bne.w	41927a <_vfiprintf_r+0xb7e>
  418f44:	9b03      	ldr	r3, [sp, #12]
  418f46:	9a08      	ldr	r2, [sp, #32]
  418f48:	9901      	ldr	r1, [sp, #4]
  418f4a:	428a      	cmp	r2, r1
  418f4c:	bfac      	ite	ge
  418f4e:	189b      	addge	r3, r3, r2
  418f50:	185b      	addlt	r3, r3, r1
  418f52:	9303      	str	r3, [sp, #12]
  418f54:	e04e      	b.n	418ff4 <_vfiprintf_r+0x8f8>
  418f56:	aa0f      	add	r2, sp, #60	; 0x3c
  418f58:	4651      	mov	r1, sl
  418f5a:	4638      	mov	r0, r7
  418f5c:	f7ff fb8e 	bl	41867c <__sprint_r.part.0>
  418f60:	2800      	cmp	r0, #0
  418f62:	f040 813f 	bne.w	4191e4 <_vfiprintf_r+0xae8>
  418f66:	9910      	ldr	r1, [sp, #64]	; 0x40
  418f68:	9a11      	ldr	r2, [sp, #68]	; 0x44
  418f6a:	1c48      	adds	r0, r1, #1
  418f6c:	46ce      	mov	lr, r9
  418f6e:	e77f      	b.n	418e70 <_vfiprintf_r+0x774>
  418f70:	aa0f      	add	r2, sp, #60	; 0x3c
  418f72:	4659      	mov	r1, fp
  418f74:	4638      	mov	r0, r7
  418f76:	f7ff fb81 	bl	41867c <__sprint_r.part.0>
  418f7a:	b960      	cbnz	r0, 418f96 <_vfiprintf_r+0x89a>
  418f7c:	9910      	ldr	r1, [sp, #64]	; 0x40
  418f7e:	9a11      	ldr	r2, [sp, #68]	; 0x44
  418f80:	1c48      	adds	r0, r1, #1
  418f82:	46ca      	mov	sl, r9
  418f84:	e7bd      	b.n	418f02 <_vfiprintf_r+0x806>
  418f86:	9b11      	ldr	r3, [sp, #68]	; 0x44
  418f88:	f8dd b010 	ldr.w	fp, [sp, #16]
  418f8c:	2b00      	cmp	r3, #0
  418f8e:	f040 81d4 	bne.w	41933a <_vfiprintf_r+0xc3e>
  418f92:	2300      	movs	r3, #0
  418f94:	9310      	str	r3, [sp, #64]	; 0x40
  418f96:	f8db 3064 	ldr.w	r3, [fp, #100]	; 0x64
  418f9a:	f013 0f01 	tst.w	r3, #1
  418f9e:	f8bb 300c 	ldrh.w	r3, [fp, #12]
  418fa2:	d102      	bne.n	418faa <_vfiprintf_r+0x8ae>
  418fa4:	059a      	lsls	r2, r3, #22
  418fa6:	f140 80de 	bpl.w	419166 <_vfiprintf_r+0xa6a>
  418faa:	065b      	lsls	r3, r3, #25
  418fac:	f53f acb2 	bmi.w	418914 <_vfiprintf_r+0x218>
  418fb0:	9803      	ldr	r0, [sp, #12]
  418fb2:	b02d      	add	sp, #180	; 0xb4
  418fb4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  418fb8:	2a00      	cmp	r2, #0
  418fba:	f040 8106 	bne.w	4191ca <_vfiprintf_r+0xace>
  418fbe:	9a05      	ldr	r2, [sp, #20]
  418fc0:	921d      	str	r2, [sp, #116]	; 0x74
  418fc2:	2301      	movs	r3, #1
  418fc4:	9211      	str	r2, [sp, #68]	; 0x44
  418fc6:	f8cd b070 	str.w	fp, [sp, #112]	; 0x70
  418fca:	9310      	str	r3, [sp, #64]	; 0x40
  418fcc:	46ca      	mov	sl, r9
  418fce:	f10a 0a08 	add.w	sl, sl, #8
  418fd2:	9b02      	ldr	r3, [sp, #8]
  418fd4:	0759      	lsls	r1, r3, #29
  418fd6:	d504      	bpl.n	418fe2 <_vfiprintf_r+0x8e6>
  418fd8:	9b08      	ldr	r3, [sp, #32]
  418fda:	9901      	ldr	r1, [sp, #4]
  418fdc:	1a5c      	subs	r4, r3, r1
  418fde:	2c00      	cmp	r4, #0
  418fe0:	dc81      	bgt.n	418ee6 <_vfiprintf_r+0x7ea>
  418fe2:	9b03      	ldr	r3, [sp, #12]
  418fe4:	9908      	ldr	r1, [sp, #32]
  418fe6:	9801      	ldr	r0, [sp, #4]
  418fe8:	4281      	cmp	r1, r0
  418fea:	bfac      	ite	ge
  418fec:	185b      	addge	r3, r3, r1
  418fee:	181b      	addlt	r3, r3, r0
  418ff0:	9303      	str	r3, [sp, #12]
  418ff2:	bb72      	cbnz	r2, 419052 <_vfiprintf_r+0x956>
  418ff4:	2300      	movs	r3, #0
  418ff6:	9310      	str	r3, [sp, #64]	; 0x40
  418ff8:	46ca      	mov	sl, r9
  418ffa:	f7ff bbbc 	b.w	418776 <_vfiprintf_r+0x7a>
  418ffe:	aa0f      	add	r2, sp, #60	; 0x3c
  419000:	9904      	ldr	r1, [sp, #16]
  419002:	4620      	mov	r0, r4
  419004:	f7ff fb3a 	bl	41867c <__sprint_r.part.0>
  419008:	bb50      	cbnz	r0, 419060 <_vfiprintf_r+0x964>
  41900a:	9910      	ldr	r1, [sp, #64]	; 0x40
  41900c:	9a11      	ldr	r2, [sp, #68]	; 0x44
  41900e:	f101 0e01 	add.w	lr, r1, #1
  419012:	46cc      	mov	ip, r9
  419014:	e548      	b.n	418aa8 <_vfiprintf_r+0x3ac>
  419016:	2a00      	cmp	r2, #0
  419018:	f040 8140 	bne.w	41929c <_vfiprintf_r+0xba0>
  41901c:	f89d 1037 	ldrb.w	r1, [sp, #55]	; 0x37
  419020:	2900      	cmp	r1, #0
  419022:	f000 811b 	beq.w	41925c <_vfiprintf_r+0xb60>
  419026:	2201      	movs	r2, #1
  419028:	f10d 0137 	add.w	r1, sp, #55	; 0x37
  41902c:	4610      	mov	r0, r2
  41902e:	921d      	str	r2, [sp, #116]	; 0x74
  419030:	911c      	str	r1, [sp, #112]	; 0x70
  419032:	46ca      	mov	sl, r9
  419034:	4601      	mov	r1, r0
  419036:	f10a 0a08 	add.w	sl, sl, #8
  41903a:	3001      	adds	r0, #1
  41903c:	e507      	b.n	418a4e <_vfiprintf_r+0x352>
  41903e:	9b02      	ldr	r3, [sp, #8]
  419040:	2a01      	cmp	r2, #1
  419042:	f000 8098 	beq.w	419176 <_vfiprintf_r+0xa7a>
  419046:	2a02      	cmp	r2, #2
  419048:	d10d      	bne.n	419066 <_vfiprintf_r+0x96a>
  41904a:	9302      	str	r3, [sp, #8]
  41904c:	2600      	movs	r6, #0
  41904e:	2700      	movs	r7, #0
  419050:	e5b0      	b.n	418bb4 <_vfiprintf_r+0x4b8>
  419052:	aa0f      	add	r2, sp, #60	; 0x3c
  419054:	9904      	ldr	r1, [sp, #16]
  419056:	9806      	ldr	r0, [sp, #24]
  419058:	f7ff fb10 	bl	41867c <__sprint_r.part.0>
  41905c:	2800      	cmp	r0, #0
  41905e:	d0c9      	beq.n	418ff4 <_vfiprintf_r+0x8f8>
  419060:	f8dd b010 	ldr.w	fp, [sp, #16]
  419064:	e797      	b.n	418f96 <_vfiprintf_r+0x89a>
  419066:	9302      	str	r3, [sp, #8]
  419068:	2600      	movs	r6, #0
  41906a:	2700      	movs	r7, #0
  41906c:	4649      	mov	r1, r9
  41906e:	e000      	b.n	419072 <_vfiprintf_r+0x976>
  419070:	4659      	mov	r1, fp
  419072:	08f2      	lsrs	r2, r6, #3
  419074:	ea42 7247 	orr.w	r2, r2, r7, lsl #29
  419078:	08f8      	lsrs	r0, r7, #3
  41907a:	f006 0307 	and.w	r3, r6, #7
  41907e:	4607      	mov	r7, r0
  419080:	4616      	mov	r6, r2
  419082:	3330      	adds	r3, #48	; 0x30
  419084:	ea56 0207 	orrs.w	r2, r6, r7
  419088:	f801 3c01 	strb.w	r3, [r1, #-1]
  41908c:	f101 3bff 	add.w	fp, r1, #4294967295
  419090:	d1ee      	bne.n	419070 <_vfiprintf_r+0x974>
  419092:	9a02      	ldr	r2, [sp, #8]
  419094:	07d6      	lsls	r6, r2, #31
  419096:	f57f ad9d 	bpl.w	418bd4 <_vfiprintf_r+0x4d8>
  41909a:	2b30      	cmp	r3, #48	; 0x30
  41909c:	f43f ad9a 	beq.w	418bd4 <_vfiprintf_r+0x4d8>
  4190a0:	3902      	subs	r1, #2
  4190a2:	2330      	movs	r3, #48	; 0x30
  4190a4:	f80b 3c01 	strb.w	r3, [fp, #-1]
  4190a8:	eba9 0301 	sub.w	r3, r9, r1
  4190ac:	9305      	str	r3, [sp, #20]
  4190ae:	468b      	mov	fp, r1
  4190b0:	e476      	b.n	4189a0 <_vfiprintf_r+0x2a4>
  4190b2:	9b03      	ldr	r3, [sp, #12]
  4190b4:	9a08      	ldr	r2, [sp, #32]
  4190b6:	428a      	cmp	r2, r1
  4190b8:	bfac      	ite	ge
  4190ba:	189b      	addge	r3, r3, r2
  4190bc:	185b      	addlt	r3, r3, r1
  4190be:	9303      	str	r3, [sp, #12]
  4190c0:	e798      	b.n	418ff4 <_vfiprintf_r+0x8f8>
  4190c2:	2202      	movs	r2, #2
  4190c4:	e44d      	b.n	418962 <_vfiprintf_r+0x266>
  4190c6:	2f00      	cmp	r7, #0
  4190c8:	bf08      	it	eq
  4190ca:	2e0a      	cmpeq	r6, #10
  4190cc:	d352      	bcc.n	419174 <_vfiprintf_r+0xa78>
  4190ce:	46cb      	mov	fp, r9
  4190d0:	4630      	mov	r0, r6
  4190d2:	4639      	mov	r1, r7
  4190d4:	220a      	movs	r2, #10
  4190d6:	2300      	movs	r3, #0
  4190d8:	f003 fa7a 	bl	41c5d0 <__aeabi_uldivmod>
  4190dc:	3230      	adds	r2, #48	; 0x30
  4190de:	f80b 2d01 	strb.w	r2, [fp, #-1]!
  4190e2:	4630      	mov	r0, r6
  4190e4:	4639      	mov	r1, r7
  4190e6:	2300      	movs	r3, #0
  4190e8:	220a      	movs	r2, #10
  4190ea:	f003 fa71 	bl	41c5d0 <__aeabi_uldivmod>
  4190ee:	4606      	mov	r6, r0
  4190f0:	460f      	mov	r7, r1
  4190f2:	ea56 0307 	orrs.w	r3, r6, r7
  4190f6:	d1eb      	bne.n	4190d0 <_vfiprintf_r+0x9d4>
  4190f8:	e56c      	b.n	418bd4 <_vfiprintf_r+0x4d8>
  4190fa:	9405      	str	r4, [sp, #20]
  4190fc:	46cb      	mov	fp, r9
  4190fe:	e44f      	b.n	4189a0 <_vfiprintf_r+0x2a4>
  419100:	aa0f      	add	r2, sp, #60	; 0x3c
  419102:	9904      	ldr	r1, [sp, #16]
  419104:	9806      	ldr	r0, [sp, #24]
  419106:	f7ff fab9 	bl	41867c <__sprint_r.part.0>
  41910a:	2800      	cmp	r0, #0
  41910c:	d1a8      	bne.n	419060 <_vfiprintf_r+0x964>
  41910e:	9a11      	ldr	r2, [sp, #68]	; 0x44
  419110:	46ca      	mov	sl, r9
  419112:	e75e      	b.n	418fd2 <_vfiprintf_r+0x8d6>
  419114:	aa0f      	add	r2, sp, #60	; 0x3c
  419116:	9904      	ldr	r1, [sp, #16]
  419118:	9806      	ldr	r0, [sp, #24]
  41911a:	f7ff faaf 	bl	41867c <__sprint_r.part.0>
  41911e:	2800      	cmp	r0, #0
  419120:	d19e      	bne.n	419060 <_vfiprintf_r+0x964>
  419122:	46ca      	mov	sl, r9
  419124:	f7ff bbc0 	b.w	4188a8 <_vfiprintf_r+0x1ac>
  419128:	0041ea44 	.word	0x0041ea44
  41912c:	0041ea34 	.word	0x0041ea34
  419130:	3104      	adds	r1, #4
  419132:	6816      	ldr	r6, [r2, #0]
  419134:	9107      	str	r1, [sp, #28]
  419136:	2201      	movs	r2, #1
  419138:	2700      	movs	r7, #0
  41913a:	e412      	b.n	418962 <_vfiprintf_r+0x266>
  41913c:	9807      	ldr	r0, [sp, #28]
  41913e:	4601      	mov	r1, r0
  419140:	3104      	adds	r1, #4
  419142:	6806      	ldr	r6, [r0, #0]
  419144:	9107      	str	r1, [sp, #28]
  419146:	2700      	movs	r7, #0
  419148:	e40b      	b.n	418962 <_vfiprintf_r+0x266>
  41914a:	680e      	ldr	r6, [r1, #0]
  41914c:	3104      	adds	r1, #4
  41914e:	9107      	str	r1, [sp, #28]
  419150:	2700      	movs	r7, #0
  419152:	e591      	b.n	418c78 <_vfiprintf_r+0x57c>
  419154:	9907      	ldr	r1, [sp, #28]
  419156:	680e      	ldr	r6, [r1, #0]
  419158:	460a      	mov	r2, r1
  41915a:	17f7      	asrs	r7, r6, #31
  41915c:	3204      	adds	r2, #4
  41915e:	9207      	str	r2, [sp, #28]
  419160:	4630      	mov	r0, r6
  419162:	4639      	mov	r1, r7
  419164:	e50f      	b.n	418b86 <_vfiprintf_r+0x48a>
  419166:	f8db 0058 	ldr.w	r0, [fp, #88]	; 0x58
  41916a:	f001 fe4b 	bl	41ae04 <__retarget_lock_release_recursive>
  41916e:	f8bb 300c 	ldrh.w	r3, [fp, #12]
  419172:	e71a      	b.n	418faa <_vfiprintf_r+0x8ae>
  419174:	9b02      	ldr	r3, [sp, #8]
  419176:	9302      	str	r3, [sp, #8]
  419178:	f10d 0bb0 	add.w	fp, sp, #176	; 0xb0
  41917c:	3630      	adds	r6, #48	; 0x30
  41917e:	2301      	movs	r3, #1
  419180:	f80b 6d41 	strb.w	r6, [fp, #-65]!
  419184:	9305      	str	r3, [sp, #20]
  419186:	e40b      	b.n	4189a0 <_vfiprintf_r+0x2a4>
  419188:	aa0f      	add	r2, sp, #60	; 0x3c
  41918a:	9904      	ldr	r1, [sp, #16]
  41918c:	9806      	ldr	r0, [sp, #24]
  41918e:	f7ff fa75 	bl	41867c <__sprint_r.part.0>
  419192:	2800      	cmp	r0, #0
  419194:	f47f af64 	bne.w	419060 <_vfiprintf_r+0x964>
  419198:	9910      	ldr	r1, [sp, #64]	; 0x40
  41919a:	9a11      	ldr	r2, [sp, #68]	; 0x44
  41919c:	1c48      	adds	r0, r1, #1
  41919e:	46ca      	mov	sl, r9
  4191a0:	e651      	b.n	418e46 <_vfiprintf_r+0x74a>
  4191a2:	aa0f      	add	r2, sp, #60	; 0x3c
  4191a4:	9904      	ldr	r1, [sp, #16]
  4191a6:	9806      	ldr	r0, [sp, #24]
  4191a8:	f7ff fa68 	bl	41867c <__sprint_r.part.0>
  4191ac:	2800      	cmp	r0, #0
  4191ae:	f47f af57 	bne.w	419060 <_vfiprintf_r+0x964>
  4191b2:	9910      	ldr	r1, [sp, #64]	; 0x40
  4191b4:	9a11      	ldr	r2, [sp, #68]	; 0x44
  4191b6:	1c48      	adds	r0, r1, #1
  4191b8:	46ca      	mov	sl, r9
  4191ba:	e448      	b.n	418a4e <_vfiprintf_r+0x352>
  4191bc:	2a00      	cmp	r2, #0
  4191be:	f040 8091 	bne.w	4192e4 <_vfiprintf_r+0xbe8>
  4191c2:	2001      	movs	r0, #1
  4191c4:	4611      	mov	r1, r2
  4191c6:	46ca      	mov	sl, r9
  4191c8:	e641      	b.n	418e4e <_vfiprintf_r+0x752>
  4191ca:	aa0f      	add	r2, sp, #60	; 0x3c
  4191cc:	9904      	ldr	r1, [sp, #16]
  4191ce:	9806      	ldr	r0, [sp, #24]
  4191d0:	f7ff fa54 	bl	41867c <__sprint_r.part.0>
  4191d4:	2800      	cmp	r0, #0
  4191d6:	f47f af43 	bne.w	419060 <_vfiprintf_r+0x964>
  4191da:	9810      	ldr	r0, [sp, #64]	; 0x40
  4191dc:	9a11      	ldr	r2, [sp, #68]	; 0x44
  4191de:	3001      	adds	r0, #1
  4191e0:	46ca      	mov	sl, r9
  4191e2:	e667      	b.n	418eb4 <_vfiprintf_r+0x7b8>
  4191e4:	46d3      	mov	fp, sl
  4191e6:	e6d6      	b.n	418f96 <_vfiprintf_r+0x89a>
  4191e8:	9e07      	ldr	r6, [sp, #28]
  4191ea:	3607      	adds	r6, #7
  4191ec:	f026 0207 	bic.w	r2, r6, #7
  4191f0:	f102 0108 	add.w	r1, r2, #8
  4191f4:	e9d2 6700 	ldrd	r6, r7, [r2]
  4191f8:	9107      	str	r1, [sp, #28]
  4191fa:	2201      	movs	r2, #1
  4191fc:	f7ff bbb1 	b.w	418962 <_vfiprintf_r+0x266>
  419200:	9e07      	ldr	r6, [sp, #28]
  419202:	3607      	adds	r6, #7
  419204:	f026 0607 	bic.w	r6, r6, #7
  419208:	e9d6 0100 	ldrd	r0, r1, [r6]
  41920c:	f106 0208 	add.w	r2, r6, #8
  419210:	9207      	str	r2, [sp, #28]
  419212:	4606      	mov	r6, r0
  419214:	460f      	mov	r7, r1
  419216:	e4b6      	b.n	418b86 <_vfiprintf_r+0x48a>
  419218:	9e07      	ldr	r6, [sp, #28]
  41921a:	3607      	adds	r6, #7
  41921c:	f026 0207 	bic.w	r2, r6, #7
  419220:	f102 0108 	add.w	r1, r2, #8
  419224:	e9d2 6700 	ldrd	r6, r7, [r2]
  419228:	9107      	str	r1, [sp, #28]
  41922a:	2200      	movs	r2, #0
  41922c:	f7ff bb99 	b.w	418962 <_vfiprintf_r+0x266>
  419230:	9e07      	ldr	r6, [sp, #28]
  419232:	3607      	adds	r6, #7
  419234:	f026 0107 	bic.w	r1, r6, #7
  419238:	f101 0008 	add.w	r0, r1, #8
  41923c:	9007      	str	r0, [sp, #28]
  41923e:	e9d1 6700 	ldrd	r6, r7, [r1]
  419242:	e519      	b.n	418c78 <_vfiprintf_r+0x57c>
  419244:	46cb      	mov	fp, r9
  419246:	f7ff bbab 	b.w	4189a0 <_vfiprintf_r+0x2a4>
  41924a:	252d      	movs	r5, #45	; 0x2d
  41924c:	4276      	negs	r6, r6
  41924e:	eb67 0747 	sbc.w	r7, r7, r7, lsl #1
  419252:	f88d 5037 	strb.w	r5, [sp, #55]	; 0x37
  419256:	2201      	movs	r2, #1
  419258:	f7ff bb88 	b.w	41896c <_vfiprintf_r+0x270>
  41925c:	9b09      	ldr	r3, [sp, #36]	; 0x24
  41925e:	b9b3      	cbnz	r3, 41928e <_vfiprintf_r+0xb92>
  419260:	4611      	mov	r1, r2
  419262:	2001      	movs	r0, #1
  419264:	46ca      	mov	sl, r9
  419266:	e5f2      	b.n	418e4e <_vfiprintf_r+0x752>
  419268:	f8db 0058 	ldr.w	r0, [fp, #88]	; 0x58
  41926c:	f001 fdca 	bl	41ae04 <__retarget_lock_release_recursive>
  419270:	f04f 33ff 	mov.w	r3, #4294967295
  419274:	9303      	str	r3, [sp, #12]
  419276:	f7ff bb50 	b.w	41891a <_vfiprintf_r+0x21e>
  41927a:	aa0f      	add	r2, sp, #60	; 0x3c
  41927c:	9904      	ldr	r1, [sp, #16]
  41927e:	9806      	ldr	r0, [sp, #24]
  419280:	f7ff f9fc 	bl	41867c <__sprint_r.part.0>
  419284:	2800      	cmp	r0, #0
  419286:	f47f aeeb 	bne.w	419060 <_vfiprintf_r+0x964>
  41928a:	9a11      	ldr	r2, [sp, #68]	; 0x44
  41928c:	e6a9      	b.n	418fe2 <_vfiprintf_r+0x8e6>
  41928e:	ab0e      	add	r3, sp, #56	; 0x38
  419290:	2202      	movs	r2, #2
  419292:	931c      	str	r3, [sp, #112]	; 0x70
  419294:	921d      	str	r2, [sp, #116]	; 0x74
  419296:	2001      	movs	r0, #1
  419298:	46ca      	mov	sl, r9
  41929a:	e5d0      	b.n	418e3e <_vfiprintf_r+0x742>
  41929c:	aa0f      	add	r2, sp, #60	; 0x3c
  41929e:	9904      	ldr	r1, [sp, #16]
  4192a0:	9806      	ldr	r0, [sp, #24]
  4192a2:	f7ff f9eb 	bl	41867c <__sprint_r.part.0>
  4192a6:	2800      	cmp	r0, #0
  4192a8:	f47f aeda 	bne.w	419060 <_vfiprintf_r+0x964>
  4192ac:	9910      	ldr	r1, [sp, #64]	; 0x40
  4192ae:	9a11      	ldr	r2, [sp, #68]	; 0x44
  4192b0:	1c48      	adds	r0, r1, #1
  4192b2:	46ca      	mov	sl, r9
  4192b4:	e5a4      	b.n	418e00 <_vfiprintf_r+0x704>
  4192b6:	9a07      	ldr	r2, [sp, #28]
  4192b8:	9903      	ldr	r1, [sp, #12]
  4192ba:	6813      	ldr	r3, [r2, #0]
  4192bc:	17cd      	asrs	r5, r1, #31
  4192be:	4608      	mov	r0, r1
  4192c0:	3204      	adds	r2, #4
  4192c2:	4629      	mov	r1, r5
  4192c4:	9207      	str	r2, [sp, #28]
  4192c6:	e9c3 0100 	strd	r0, r1, [r3]
  4192ca:	f7ff ba54 	b.w	418776 <_vfiprintf_r+0x7a>
  4192ce:	4658      	mov	r0, fp
  4192d0:	9607      	str	r6, [sp, #28]
  4192d2:	9302      	str	r3, [sp, #8]
  4192d4:	f002 fe54 	bl	41bf80 <strlen>
  4192d8:	2400      	movs	r4, #0
  4192da:	9005      	str	r0, [sp, #20]
  4192dc:	f89d 5037 	ldrb.w	r5, [sp, #55]	; 0x37
  4192e0:	f7ff bb5e 	b.w	4189a0 <_vfiprintf_r+0x2a4>
  4192e4:	aa0f      	add	r2, sp, #60	; 0x3c
  4192e6:	9904      	ldr	r1, [sp, #16]
  4192e8:	9806      	ldr	r0, [sp, #24]
  4192ea:	f7ff f9c7 	bl	41867c <__sprint_r.part.0>
  4192ee:	2800      	cmp	r0, #0
  4192f0:	f47f aeb6 	bne.w	419060 <_vfiprintf_r+0x964>
  4192f4:	9910      	ldr	r1, [sp, #64]	; 0x40
  4192f6:	9a11      	ldr	r2, [sp, #68]	; 0x44
  4192f8:	1c48      	adds	r0, r1, #1
  4192fa:	46ca      	mov	sl, r9
  4192fc:	e5a7      	b.n	418e4e <_vfiprintf_r+0x752>
  4192fe:	9910      	ldr	r1, [sp, #64]	; 0x40
  419300:	9a11      	ldr	r2, [sp, #68]	; 0x44
  419302:	4e20      	ldr	r6, [pc, #128]	; (419384 <_vfiprintf_r+0xc88>)
  419304:	3101      	adds	r1, #1
  419306:	f7ff bb90 	b.w	418a2a <_vfiprintf_r+0x32e>
  41930a:	2c06      	cmp	r4, #6
  41930c:	bf28      	it	cs
  41930e:	2406      	movcs	r4, #6
  419310:	9405      	str	r4, [sp, #20]
  419312:	9607      	str	r6, [sp, #28]
  419314:	9401      	str	r4, [sp, #4]
  419316:	f8df b070 	ldr.w	fp, [pc, #112]	; 419388 <_vfiprintf_r+0xc8c>
  41931a:	e4d5      	b.n	418cc8 <_vfiprintf_r+0x5cc>
  41931c:	9810      	ldr	r0, [sp, #64]	; 0x40
  41931e:	4e19      	ldr	r6, [pc, #100]	; (419384 <_vfiprintf_r+0xc88>)
  419320:	3001      	adds	r0, #1
  419322:	e603      	b.n	418f2c <_vfiprintf_r+0x830>
  419324:	9405      	str	r4, [sp, #20]
  419326:	f89d 5037 	ldrb.w	r5, [sp, #55]	; 0x37
  41932a:	9607      	str	r6, [sp, #28]
  41932c:	9302      	str	r3, [sp, #8]
  41932e:	4604      	mov	r4, r0
  419330:	f7ff bb36 	b.w	4189a0 <_vfiprintf_r+0x2a4>
  419334:	4686      	mov	lr, r0
  419336:	f7ff bbce 	b.w	418ad6 <_vfiprintf_r+0x3da>
  41933a:	9806      	ldr	r0, [sp, #24]
  41933c:	aa0f      	add	r2, sp, #60	; 0x3c
  41933e:	4659      	mov	r1, fp
  419340:	f7ff f99c 	bl	41867c <__sprint_r.part.0>
  419344:	2800      	cmp	r0, #0
  419346:	f43f ae24 	beq.w	418f92 <_vfiprintf_r+0x896>
  41934a:	e624      	b.n	418f96 <_vfiprintf_r+0x89a>
  41934c:	9907      	ldr	r1, [sp, #28]
  41934e:	f898 2001 	ldrb.w	r2, [r8, #1]
  419352:	680c      	ldr	r4, [r1, #0]
  419354:	3104      	adds	r1, #4
  419356:	ea44 74e4 	orr.w	r4, r4, r4, asr #31
  41935a:	46b8      	mov	r8, r7
  41935c:	9107      	str	r1, [sp, #28]
  41935e:	f7ff ba3f 	b.w	4187e0 <_vfiprintf_r+0xe4>
  419362:	f88d 5037 	strb.w	r5, [sp, #55]	; 0x37
  419366:	e43c      	b.n	418be2 <_vfiprintf_r+0x4e6>
  419368:	f88d 5037 	strb.w	r5, [sp, #55]	; 0x37
  41936c:	e521      	b.n	418db2 <_vfiprintf_r+0x6b6>
  41936e:	f88d 5037 	strb.w	r5, [sp, #55]	; 0x37
  419372:	f7ff bbf4 	b.w	418b5e <_vfiprintf_r+0x462>
  419376:	f88d 5037 	strb.w	r5, [sp, #55]	; 0x37
  41937a:	e491      	b.n	418ca0 <_vfiprintf_r+0x5a4>
  41937c:	f88d 5037 	strb.w	r5, [sp, #55]	; 0x37
  419380:	e469      	b.n	418c56 <_vfiprintf_r+0x55a>
  419382:	bf00      	nop
  419384:	0041ea34 	.word	0x0041ea34
  419388:	0041ea08 	.word	0x0041ea08

0041938c <__sbprintf>:
  41938c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  419390:	460c      	mov	r4, r1
  419392:	f5ad 6d8d 	sub.w	sp, sp, #1128	; 0x468
  419396:	8989      	ldrh	r1, [r1, #12]
  419398:	6e66      	ldr	r6, [r4, #100]	; 0x64
  41939a:	89e5      	ldrh	r5, [r4, #14]
  41939c:	9619      	str	r6, [sp, #100]	; 0x64
  41939e:	f021 0102 	bic.w	r1, r1, #2
  4193a2:	4606      	mov	r6, r0
  4193a4:	69e0      	ldr	r0, [r4, #28]
  4193a6:	f8ad 100c 	strh.w	r1, [sp, #12]
  4193aa:	4617      	mov	r7, r2
  4193ac:	f44f 6180 	mov.w	r1, #1024	; 0x400
  4193b0:	6a62      	ldr	r2, [r4, #36]	; 0x24
  4193b2:	f8ad 500e 	strh.w	r5, [sp, #14]
  4193b6:	4698      	mov	r8, r3
  4193b8:	ad1a      	add	r5, sp, #104	; 0x68
  4193ba:	2300      	movs	r3, #0
  4193bc:	9007      	str	r0, [sp, #28]
  4193be:	a816      	add	r0, sp, #88	; 0x58
  4193c0:	9209      	str	r2, [sp, #36]	; 0x24
  4193c2:	9306      	str	r3, [sp, #24]
  4193c4:	9500      	str	r5, [sp, #0]
  4193c6:	9504      	str	r5, [sp, #16]
  4193c8:	9102      	str	r1, [sp, #8]
  4193ca:	9105      	str	r1, [sp, #20]
  4193cc:	f001 fd14 	bl	41adf8 <__retarget_lock_init_recursive>
  4193d0:	4643      	mov	r3, r8
  4193d2:	463a      	mov	r2, r7
  4193d4:	4669      	mov	r1, sp
  4193d6:	4630      	mov	r0, r6
  4193d8:	f7ff f990 	bl	4186fc <_vfiprintf_r>
  4193dc:	1e05      	subs	r5, r0, #0
  4193de:	db07      	blt.n	4193f0 <__sbprintf+0x64>
  4193e0:	4630      	mov	r0, r6
  4193e2:	4669      	mov	r1, sp
  4193e4:	f001 f8e6 	bl	41a5b4 <_fflush_r>
  4193e8:	2800      	cmp	r0, #0
  4193ea:	bf18      	it	ne
  4193ec:	f04f 35ff 	movne.w	r5, #4294967295
  4193f0:	f8bd 300c 	ldrh.w	r3, [sp, #12]
  4193f4:	065b      	lsls	r3, r3, #25
  4193f6:	d503      	bpl.n	419400 <__sbprintf+0x74>
  4193f8:	89a3      	ldrh	r3, [r4, #12]
  4193fa:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  4193fe:	81a3      	strh	r3, [r4, #12]
  419400:	9816      	ldr	r0, [sp, #88]	; 0x58
  419402:	f001 fcfb 	bl	41adfc <__retarget_lock_close_recursive>
  419406:	4628      	mov	r0, r5
  419408:	f50d 6d8d 	add.w	sp, sp, #1128	; 0x468
  41940c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00419410 <__swsetup_r>:
  419410:	b538      	push	{r3, r4, r5, lr}
  419412:	4b30      	ldr	r3, [pc, #192]	; (4194d4 <__swsetup_r+0xc4>)
  419414:	681b      	ldr	r3, [r3, #0]
  419416:	4605      	mov	r5, r0
  419418:	460c      	mov	r4, r1
  41941a:	b113      	cbz	r3, 419422 <__swsetup_r+0x12>
  41941c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  41941e:	2a00      	cmp	r2, #0
  419420:	d038      	beq.n	419494 <__swsetup_r+0x84>
  419422:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
  419426:	b293      	uxth	r3, r2
  419428:	0718      	lsls	r0, r3, #28
  41942a:	d50c      	bpl.n	419446 <__swsetup_r+0x36>
  41942c:	6920      	ldr	r0, [r4, #16]
  41942e:	b1a8      	cbz	r0, 41945c <__swsetup_r+0x4c>
  419430:	f013 0201 	ands.w	r2, r3, #1
  419434:	d01e      	beq.n	419474 <__swsetup_r+0x64>
  419436:	6963      	ldr	r3, [r4, #20]
  419438:	2200      	movs	r2, #0
  41943a:	425b      	negs	r3, r3
  41943c:	61a3      	str	r3, [r4, #24]
  41943e:	60a2      	str	r2, [r4, #8]
  419440:	b1f0      	cbz	r0, 419480 <__swsetup_r+0x70>
  419442:	2000      	movs	r0, #0
  419444:	bd38      	pop	{r3, r4, r5, pc}
  419446:	06d9      	lsls	r1, r3, #27
  419448:	d53c      	bpl.n	4194c4 <__swsetup_r+0xb4>
  41944a:	0758      	lsls	r0, r3, #29
  41944c:	d426      	bmi.n	41949c <__swsetup_r+0x8c>
  41944e:	6920      	ldr	r0, [r4, #16]
  419450:	f042 0308 	orr.w	r3, r2, #8
  419454:	81a3      	strh	r3, [r4, #12]
  419456:	b29b      	uxth	r3, r3
  419458:	2800      	cmp	r0, #0
  41945a:	d1e9      	bne.n	419430 <__swsetup_r+0x20>
  41945c:	f403 7220 	and.w	r2, r3, #640	; 0x280
  419460:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
  419464:	d0e4      	beq.n	419430 <__swsetup_r+0x20>
  419466:	4628      	mov	r0, r5
  419468:	4621      	mov	r1, r4
  41946a:	f001 fcfb 	bl	41ae64 <__smakebuf_r>
  41946e:	89a3      	ldrh	r3, [r4, #12]
  419470:	6920      	ldr	r0, [r4, #16]
  419472:	e7dd      	b.n	419430 <__swsetup_r+0x20>
  419474:	0799      	lsls	r1, r3, #30
  419476:	bf58      	it	pl
  419478:	6962      	ldrpl	r2, [r4, #20]
  41947a:	60a2      	str	r2, [r4, #8]
  41947c:	2800      	cmp	r0, #0
  41947e:	d1e0      	bne.n	419442 <__swsetup_r+0x32>
  419480:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
  419484:	061a      	lsls	r2, r3, #24
  419486:	d5dd      	bpl.n	419444 <__swsetup_r+0x34>
  419488:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  41948c:	81a3      	strh	r3, [r4, #12]
  41948e:	f04f 30ff 	mov.w	r0, #4294967295
  419492:	bd38      	pop	{r3, r4, r5, pc}
  419494:	4618      	mov	r0, r3
  419496:	f001 f8e5 	bl	41a664 <__sinit>
  41949a:	e7c2      	b.n	419422 <__swsetup_r+0x12>
  41949c:	6b21      	ldr	r1, [r4, #48]	; 0x30
  41949e:	b151      	cbz	r1, 4194b6 <__swsetup_r+0xa6>
  4194a0:	f104 0340 	add.w	r3, r4, #64	; 0x40
  4194a4:	4299      	cmp	r1, r3
  4194a6:	d004      	beq.n	4194b2 <__swsetup_r+0xa2>
  4194a8:	4628      	mov	r0, r5
  4194aa:	f001 fa01 	bl	41a8b0 <_free_r>
  4194ae:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
  4194b2:	2300      	movs	r3, #0
  4194b4:	6323      	str	r3, [r4, #48]	; 0x30
  4194b6:	2300      	movs	r3, #0
  4194b8:	6920      	ldr	r0, [r4, #16]
  4194ba:	6063      	str	r3, [r4, #4]
  4194bc:	f022 0224 	bic.w	r2, r2, #36	; 0x24
  4194c0:	6020      	str	r0, [r4, #0]
  4194c2:	e7c5      	b.n	419450 <__swsetup_r+0x40>
  4194c4:	f042 0240 	orr.w	r2, r2, #64	; 0x40
  4194c8:	2309      	movs	r3, #9
  4194ca:	602b      	str	r3, [r5, #0]
  4194cc:	f04f 30ff 	mov.w	r0, #4294967295
  4194d0:	81a2      	strh	r2, [r4, #12]
  4194d2:	bd38      	pop	{r3, r4, r5, pc}
  4194d4:	20000178 	.word	0x20000178

004194d8 <register_fini>:
  4194d8:	4b02      	ldr	r3, [pc, #8]	; (4194e4 <register_fini+0xc>)
  4194da:	b113      	cbz	r3, 4194e2 <register_fini+0xa>
  4194dc:	4802      	ldr	r0, [pc, #8]	; (4194e8 <register_fini+0x10>)
  4194de:	f000 b805 	b.w	4194ec <atexit>
  4194e2:	4770      	bx	lr
  4194e4:	00000000 	.word	0x00000000
  4194e8:	0041a6d5 	.word	0x0041a6d5

004194ec <atexit>:
  4194ec:	2300      	movs	r3, #0
  4194ee:	4601      	mov	r1, r0
  4194f0:	461a      	mov	r2, r3
  4194f2:	4618      	mov	r0, r3
  4194f4:	f002 bed6 	b.w	41c2a4 <__register_exitproc>

004194f8 <quorem>:
  4194f8:	6902      	ldr	r2, [r0, #16]
  4194fa:	690b      	ldr	r3, [r1, #16]
  4194fc:	4293      	cmp	r3, r2
  4194fe:	f300 808d 	bgt.w	41961c <quorem+0x124>
  419502:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  419506:	f103 38ff 	add.w	r8, r3, #4294967295
  41950a:	f101 0714 	add.w	r7, r1, #20
  41950e:	f100 0b14 	add.w	fp, r0, #20
  419512:	f857 2028 	ldr.w	r2, [r7, r8, lsl #2]
  419516:	f85b 3028 	ldr.w	r3, [fp, r8, lsl #2]
  41951a:	ea4f 0488 	mov.w	r4, r8, lsl #2
  41951e:	b083      	sub	sp, #12
  419520:	3201      	adds	r2, #1
  419522:	fbb3 f9f2 	udiv	r9, r3, r2
  419526:	eb0b 0304 	add.w	r3, fp, r4
  41952a:	9400      	str	r4, [sp, #0]
  41952c:	eb07 0a04 	add.w	sl, r7, r4
  419530:	9301      	str	r3, [sp, #4]
  419532:	f1b9 0f00 	cmp.w	r9, #0
  419536:	d039      	beq.n	4195ac <quorem+0xb4>
  419538:	2500      	movs	r5, #0
  41953a:	462e      	mov	r6, r5
  41953c:	46bc      	mov	ip, r7
  41953e:	46de      	mov	lr, fp
  419540:	f85c 4b04 	ldr.w	r4, [ip], #4
  419544:	f8de 3000 	ldr.w	r3, [lr]
  419548:	b2a2      	uxth	r2, r4
  41954a:	fb09 5502 	mla	r5, r9, r2, r5
  41954e:	0c22      	lsrs	r2, r4, #16
  419550:	0c2c      	lsrs	r4, r5, #16
  419552:	fb09 4202 	mla	r2, r9, r2, r4
  419556:	b2ad      	uxth	r5, r5
  419558:	1b75      	subs	r5, r6, r5
  41955a:	b296      	uxth	r6, r2
  41955c:	ebc6 4613 	rsb	r6, r6, r3, lsr #16
  419560:	fa15 f383 	uxtah	r3, r5, r3
  419564:	eb06 4623 	add.w	r6, r6, r3, asr #16
  419568:	b29b      	uxth	r3, r3
  41956a:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
  41956e:	45e2      	cmp	sl, ip
  419570:	ea4f 4512 	mov.w	r5, r2, lsr #16
  419574:	f84e 3b04 	str.w	r3, [lr], #4
  419578:	ea4f 4626 	mov.w	r6, r6, asr #16
  41957c:	d2e0      	bcs.n	419540 <quorem+0x48>
  41957e:	9b00      	ldr	r3, [sp, #0]
  419580:	f85b 3003 	ldr.w	r3, [fp, r3]
  419584:	b993      	cbnz	r3, 4195ac <quorem+0xb4>
  419586:	9c01      	ldr	r4, [sp, #4]
  419588:	1f23      	subs	r3, r4, #4
  41958a:	459b      	cmp	fp, r3
  41958c:	d20c      	bcs.n	4195a8 <quorem+0xb0>
  41958e:	f854 3c04 	ldr.w	r3, [r4, #-4]
  419592:	b94b      	cbnz	r3, 4195a8 <quorem+0xb0>
  419594:	f1a4 0308 	sub.w	r3, r4, #8
  419598:	e002      	b.n	4195a0 <quorem+0xa8>
  41959a:	681a      	ldr	r2, [r3, #0]
  41959c:	3b04      	subs	r3, #4
  41959e:	b91a      	cbnz	r2, 4195a8 <quorem+0xb0>
  4195a0:	459b      	cmp	fp, r3
  4195a2:	f108 38ff 	add.w	r8, r8, #4294967295
  4195a6:	d3f8      	bcc.n	41959a <quorem+0xa2>
  4195a8:	f8c0 8010 	str.w	r8, [r0, #16]
  4195ac:	4604      	mov	r4, r0
  4195ae:	f002 f9d1 	bl	41b954 <__mcmp>
  4195b2:	2800      	cmp	r0, #0
  4195b4:	db2e      	blt.n	419614 <quorem+0x11c>
  4195b6:	f109 0901 	add.w	r9, r9, #1
  4195ba:	465d      	mov	r5, fp
  4195bc:	2300      	movs	r3, #0
  4195be:	f857 1b04 	ldr.w	r1, [r7], #4
  4195c2:	6828      	ldr	r0, [r5, #0]
  4195c4:	b28a      	uxth	r2, r1
  4195c6:	1a9a      	subs	r2, r3, r2
  4195c8:	0c0b      	lsrs	r3, r1, #16
  4195ca:	fa12 f280 	uxtah	r2, r2, r0
  4195ce:	ebc3 4310 	rsb	r3, r3, r0, lsr #16
  4195d2:	eb03 4322 	add.w	r3, r3, r2, asr #16
  4195d6:	b292      	uxth	r2, r2
  4195d8:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
  4195dc:	45ba      	cmp	sl, r7
  4195de:	f845 2b04 	str.w	r2, [r5], #4
  4195e2:	ea4f 4323 	mov.w	r3, r3, asr #16
  4195e6:	d2ea      	bcs.n	4195be <quorem+0xc6>
  4195e8:	f85b 2028 	ldr.w	r2, [fp, r8, lsl #2]
  4195ec:	eb0b 0388 	add.w	r3, fp, r8, lsl #2
  4195f0:	b982      	cbnz	r2, 419614 <quorem+0x11c>
  4195f2:	1f1a      	subs	r2, r3, #4
  4195f4:	4593      	cmp	fp, r2
  4195f6:	d20b      	bcs.n	419610 <quorem+0x118>
  4195f8:	f853 2c04 	ldr.w	r2, [r3, #-4]
  4195fc:	b942      	cbnz	r2, 419610 <quorem+0x118>
  4195fe:	3b08      	subs	r3, #8
  419600:	e002      	b.n	419608 <quorem+0x110>
  419602:	681a      	ldr	r2, [r3, #0]
  419604:	3b04      	subs	r3, #4
  419606:	b91a      	cbnz	r2, 419610 <quorem+0x118>
  419608:	459b      	cmp	fp, r3
  41960a:	f108 38ff 	add.w	r8, r8, #4294967295
  41960e:	d3f8      	bcc.n	419602 <quorem+0x10a>
  419610:	f8c4 8010 	str.w	r8, [r4, #16]
  419614:	4648      	mov	r0, r9
  419616:	b003      	add	sp, #12
  419618:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  41961c:	2000      	movs	r0, #0
  41961e:	4770      	bx	lr

00419620 <_dtoa_r>:
  419620:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  419624:	6c01      	ldr	r1, [r0, #64]	; 0x40
  419626:	b09b      	sub	sp, #108	; 0x6c
  419628:	4604      	mov	r4, r0
  41962a:	9e27      	ldr	r6, [sp, #156]	; 0x9c
  41962c:	4692      	mov	sl, r2
  41962e:	469b      	mov	fp, r3
  419630:	b141      	cbz	r1, 419644 <_dtoa_r+0x24>
  419632:	6c42      	ldr	r2, [r0, #68]	; 0x44
  419634:	604a      	str	r2, [r1, #4]
  419636:	2301      	movs	r3, #1
  419638:	4093      	lsls	r3, r2
  41963a:	608b      	str	r3, [r1, #8]
  41963c:	f001 ffb2 	bl	41b5a4 <_Bfree>
  419640:	2300      	movs	r3, #0
  419642:	6423      	str	r3, [r4, #64]	; 0x40
  419644:	f1bb 0f00 	cmp.w	fp, #0
  419648:	465d      	mov	r5, fp
  41964a:	db35      	blt.n	4196b8 <_dtoa_r+0x98>
  41964c:	2300      	movs	r3, #0
  41964e:	6033      	str	r3, [r6, #0]
  419650:	4b9d      	ldr	r3, [pc, #628]	; (4198c8 <_dtoa_r+0x2a8>)
  419652:	43ab      	bics	r3, r5
  419654:	d015      	beq.n	419682 <_dtoa_r+0x62>
  419656:	4650      	mov	r0, sl
  419658:	4659      	mov	r1, fp
  41965a:	2200      	movs	r2, #0
  41965c:	2300      	movs	r3, #0
  41965e:	f7fd fa93 	bl	416b88 <__aeabi_dcmpeq>
  419662:	4680      	mov	r8, r0
  419664:	2800      	cmp	r0, #0
  419666:	d02d      	beq.n	4196c4 <_dtoa_r+0xa4>
  419668:	9a26      	ldr	r2, [sp, #152]	; 0x98
  41966a:	2301      	movs	r3, #1
  41966c:	6013      	str	r3, [r2, #0]
  41966e:	9b28      	ldr	r3, [sp, #160]	; 0xa0
  419670:	2b00      	cmp	r3, #0
  419672:	f000 80bd 	beq.w	4197f0 <_dtoa_r+0x1d0>
  419676:	4895      	ldr	r0, [pc, #596]	; (4198cc <_dtoa_r+0x2ac>)
  419678:	6018      	str	r0, [r3, #0]
  41967a:	3801      	subs	r0, #1
  41967c:	b01b      	add	sp, #108	; 0x6c
  41967e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  419682:	9a26      	ldr	r2, [sp, #152]	; 0x98
  419684:	f242 730f 	movw	r3, #9999	; 0x270f
  419688:	6013      	str	r3, [r2, #0]
  41968a:	f1ba 0f00 	cmp.w	sl, #0
  41968e:	d10d      	bne.n	4196ac <_dtoa_r+0x8c>
  419690:	f3c5 0513 	ubfx	r5, r5, #0, #20
  419694:	b955      	cbnz	r5, 4196ac <_dtoa_r+0x8c>
  419696:	9b28      	ldr	r3, [sp, #160]	; 0xa0
  419698:	488d      	ldr	r0, [pc, #564]	; (4198d0 <_dtoa_r+0x2b0>)
  41969a:	2b00      	cmp	r3, #0
  41969c:	d0ee      	beq.n	41967c <_dtoa_r+0x5c>
  41969e:	f100 0308 	add.w	r3, r0, #8
  4196a2:	9a28      	ldr	r2, [sp, #160]	; 0xa0
  4196a4:	6013      	str	r3, [r2, #0]
  4196a6:	b01b      	add	sp, #108	; 0x6c
  4196a8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4196ac:	9b28      	ldr	r3, [sp, #160]	; 0xa0
  4196ae:	4889      	ldr	r0, [pc, #548]	; (4198d4 <_dtoa_r+0x2b4>)
  4196b0:	2b00      	cmp	r3, #0
  4196b2:	d0e3      	beq.n	41967c <_dtoa_r+0x5c>
  4196b4:	1cc3      	adds	r3, r0, #3
  4196b6:	e7f4      	b.n	4196a2 <_dtoa_r+0x82>
  4196b8:	2301      	movs	r3, #1
  4196ba:	f02b 4500 	bic.w	r5, fp, #2147483648	; 0x80000000
  4196be:	6033      	str	r3, [r6, #0]
  4196c0:	46ab      	mov	fp, r5
  4196c2:	e7c5      	b.n	419650 <_dtoa_r+0x30>
  4196c4:	aa18      	add	r2, sp, #96	; 0x60
  4196c6:	ab19      	add	r3, sp, #100	; 0x64
  4196c8:	9201      	str	r2, [sp, #4]
  4196ca:	9300      	str	r3, [sp, #0]
  4196cc:	4652      	mov	r2, sl
  4196ce:	465b      	mov	r3, fp
  4196d0:	4620      	mov	r0, r4
  4196d2:	f002 f9df 	bl	41ba94 <__d2b>
  4196d6:	0d2b      	lsrs	r3, r5, #20
  4196d8:	4681      	mov	r9, r0
  4196da:	d071      	beq.n	4197c0 <_dtoa_r+0x1a0>
  4196dc:	f3cb 0213 	ubfx	r2, fp, #0, #20
  4196e0:	f042 517f 	orr.w	r1, r2, #1069547520	; 0x3fc00000
  4196e4:	9f18      	ldr	r7, [sp, #96]	; 0x60
  4196e6:	f8cd 8050 	str.w	r8, [sp, #80]	; 0x50
  4196ea:	4650      	mov	r0, sl
  4196ec:	f2a3 36ff 	subw	r6, r3, #1023	; 0x3ff
  4196f0:	f441 1140 	orr.w	r1, r1, #3145728	; 0x300000
  4196f4:	2200      	movs	r2, #0
  4196f6:	4b78      	ldr	r3, [pc, #480]	; (4198d8 <_dtoa_r+0x2b8>)
  4196f8:	f7fc fe2a 	bl	416350 <__aeabi_dsub>
  4196fc:	a36c      	add	r3, pc, #432	; (adr r3, 4198b0 <_dtoa_r+0x290>)
  4196fe:	e9d3 2300 	ldrd	r2, r3, [r3]
  419702:	f7fc ffd9 	bl	4166b8 <__aeabi_dmul>
  419706:	a36c      	add	r3, pc, #432	; (adr r3, 4198b8 <_dtoa_r+0x298>)
  419708:	e9d3 2300 	ldrd	r2, r3, [r3]
  41970c:	f7fc fe22 	bl	416354 <__adddf3>
  419710:	e9cd 0102 	strd	r0, r1, [sp, #8]
  419714:	4630      	mov	r0, r6
  419716:	f7fc ff69 	bl	4165ec <__aeabi_i2d>
  41971a:	a369      	add	r3, pc, #420	; (adr r3, 4198c0 <_dtoa_r+0x2a0>)
  41971c:	e9d3 2300 	ldrd	r2, r3, [r3]
  419720:	f7fc ffca 	bl	4166b8 <__aeabi_dmul>
  419724:	4602      	mov	r2, r0
  419726:	460b      	mov	r3, r1
  419728:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
  41972c:	f7fc fe12 	bl	416354 <__adddf3>
  419730:	e9cd 0104 	strd	r0, r1, [sp, #16]
  419734:	f002 ff24 	bl	41c580 <__aeabi_d2iz>
  419738:	2200      	movs	r2, #0
  41973a:	9002      	str	r0, [sp, #8]
  41973c:	2300      	movs	r3, #0
  41973e:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
  419742:	f7fd fa2b 	bl	416b9c <__aeabi_dcmplt>
  419746:	2800      	cmp	r0, #0
  419748:	f040 8173 	bne.w	419a32 <_dtoa_r+0x412>
  41974c:	9d02      	ldr	r5, [sp, #8]
  41974e:	2d16      	cmp	r5, #22
  419750:	f200 815d 	bhi.w	419a0e <_dtoa_r+0x3ee>
  419754:	4b61      	ldr	r3, [pc, #388]	; (4198dc <_dtoa_r+0x2bc>)
  419756:	eb03 03c5 	add.w	r3, r3, r5, lsl #3
  41975a:	e9d3 0100 	ldrd	r0, r1, [r3]
  41975e:	4652      	mov	r2, sl
  419760:	465b      	mov	r3, fp
  419762:	f7fd fa39 	bl	416bd8 <__aeabi_dcmpgt>
  419766:	2800      	cmp	r0, #0
  419768:	f000 81c5 	beq.w	419af6 <_dtoa_r+0x4d6>
  41976c:	1e6b      	subs	r3, r5, #1
  41976e:	9302      	str	r3, [sp, #8]
  419770:	2300      	movs	r3, #0
  419772:	930e      	str	r3, [sp, #56]	; 0x38
  419774:	1bbf      	subs	r7, r7, r6
  419776:	1e7b      	subs	r3, r7, #1
  419778:	9306      	str	r3, [sp, #24]
  41977a:	f100 8154 	bmi.w	419a26 <_dtoa_r+0x406>
  41977e:	2300      	movs	r3, #0
  419780:	9308      	str	r3, [sp, #32]
  419782:	9b02      	ldr	r3, [sp, #8]
  419784:	2b00      	cmp	r3, #0
  419786:	f2c0 8145 	blt.w	419a14 <_dtoa_r+0x3f4>
  41978a:	9a06      	ldr	r2, [sp, #24]
  41978c:	930d      	str	r3, [sp, #52]	; 0x34
  41978e:	4611      	mov	r1, r2
  419790:	4419      	add	r1, r3
  419792:	2300      	movs	r3, #0
  419794:	9106      	str	r1, [sp, #24]
  419796:	930c      	str	r3, [sp, #48]	; 0x30
  419798:	9b24      	ldr	r3, [sp, #144]	; 0x90
  41979a:	2b09      	cmp	r3, #9
  41979c:	d82a      	bhi.n	4197f4 <_dtoa_r+0x1d4>
  41979e:	2b05      	cmp	r3, #5
  4197a0:	f340 865b 	ble.w	41a45a <_dtoa_r+0xe3a>
  4197a4:	3b04      	subs	r3, #4
  4197a6:	9324      	str	r3, [sp, #144]	; 0x90
  4197a8:	2500      	movs	r5, #0
  4197aa:	9b24      	ldr	r3, [sp, #144]	; 0x90
  4197ac:	3b02      	subs	r3, #2
  4197ae:	2b03      	cmp	r3, #3
  4197b0:	f200 8642 	bhi.w	41a438 <_dtoa_r+0xe18>
  4197b4:	e8df f013 	tbh	[pc, r3, lsl #1]
  4197b8:	02c903d4 	.word	0x02c903d4
  4197bc:	046103df 	.word	0x046103df
  4197c0:	9f18      	ldr	r7, [sp, #96]	; 0x60
  4197c2:	9e19      	ldr	r6, [sp, #100]	; 0x64
  4197c4:	443e      	add	r6, r7
  4197c6:	f206 4332 	addw	r3, r6, #1074	; 0x432
  4197ca:	2b20      	cmp	r3, #32
  4197cc:	f340 818e 	ble.w	419aec <_dtoa_r+0x4cc>
  4197d0:	f1c3 0340 	rsb	r3, r3, #64	; 0x40
  4197d4:	f206 4012 	addw	r0, r6, #1042	; 0x412
  4197d8:	409d      	lsls	r5, r3
  4197da:	fa2a f000 	lsr.w	r0, sl, r0
  4197de:	4328      	orrs	r0, r5
  4197e0:	f7fc fef4 	bl	4165cc <__aeabi_ui2d>
  4197e4:	2301      	movs	r3, #1
  4197e6:	3e01      	subs	r6, #1
  4197e8:	f1a1 71f8 	sub.w	r1, r1, #32505856	; 0x1f00000
  4197ec:	9314      	str	r3, [sp, #80]	; 0x50
  4197ee:	e781      	b.n	4196f4 <_dtoa_r+0xd4>
  4197f0:	483b      	ldr	r0, [pc, #236]	; (4198e0 <_dtoa_r+0x2c0>)
  4197f2:	e743      	b.n	41967c <_dtoa_r+0x5c>
  4197f4:	2100      	movs	r1, #0
  4197f6:	6461      	str	r1, [r4, #68]	; 0x44
  4197f8:	4620      	mov	r0, r4
  4197fa:	9125      	str	r1, [sp, #148]	; 0x94
  4197fc:	f001 feac 	bl	41b558 <_Balloc>
  419800:	f04f 33ff 	mov.w	r3, #4294967295
  419804:	930a      	str	r3, [sp, #40]	; 0x28
  419806:	9a25      	ldr	r2, [sp, #148]	; 0x94
  419808:	930f      	str	r3, [sp, #60]	; 0x3c
  41980a:	2301      	movs	r3, #1
  41980c:	9004      	str	r0, [sp, #16]
  41980e:	6420      	str	r0, [r4, #64]	; 0x40
  419810:	9224      	str	r2, [sp, #144]	; 0x90
  419812:	930b      	str	r3, [sp, #44]	; 0x2c
  419814:	9b19      	ldr	r3, [sp, #100]	; 0x64
  419816:	2b00      	cmp	r3, #0
  419818:	f2c0 80d9 	blt.w	4199ce <_dtoa_r+0x3ae>
  41981c:	9a02      	ldr	r2, [sp, #8]
  41981e:	2a0e      	cmp	r2, #14
  419820:	f300 80d5 	bgt.w	4199ce <_dtoa_r+0x3ae>
  419824:	4b2d      	ldr	r3, [pc, #180]	; (4198dc <_dtoa_r+0x2bc>)
  419826:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
  41982a:	e9d3 2300 	ldrd	r2, r3, [r3]
  41982e:	e9cd 2308 	strd	r2, r3, [sp, #32]
  419832:	9b25      	ldr	r3, [sp, #148]	; 0x94
  419834:	2b00      	cmp	r3, #0
  419836:	f2c0 83ba 	blt.w	419fae <_dtoa_r+0x98e>
  41983a:	e9dd 5608 	ldrd	r5, r6, [sp, #32]
  41983e:	4650      	mov	r0, sl
  419840:	462a      	mov	r2, r5
  419842:	4633      	mov	r3, r6
  419844:	4659      	mov	r1, fp
  419846:	f7fd f861 	bl	41690c <__aeabi_ddiv>
  41984a:	f002 fe99 	bl	41c580 <__aeabi_d2iz>
  41984e:	4680      	mov	r8, r0
  419850:	f7fc fecc 	bl	4165ec <__aeabi_i2d>
  419854:	462a      	mov	r2, r5
  419856:	4633      	mov	r3, r6
  419858:	f7fc ff2e 	bl	4166b8 <__aeabi_dmul>
  41985c:	460b      	mov	r3, r1
  41985e:	4602      	mov	r2, r0
  419860:	4659      	mov	r1, fp
  419862:	4650      	mov	r0, sl
  419864:	f7fc fd74 	bl	416350 <__aeabi_dsub>
  419868:	9d04      	ldr	r5, [sp, #16]
  41986a:	f108 0330 	add.w	r3, r8, #48	; 0x30
  41986e:	702b      	strb	r3, [r5, #0]
  419870:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  419872:	2b01      	cmp	r3, #1
  419874:	4606      	mov	r6, r0
  419876:	460f      	mov	r7, r1
  419878:	f105 0501 	add.w	r5, r5, #1
  41987c:	d068      	beq.n	419950 <_dtoa_r+0x330>
  41987e:	2200      	movs	r2, #0
  419880:	4b18      	ldr	r3, [pc, #96]	; (4198e4 <_dtoa_r+0x2c4>)
  419882:	f7fc ff19 	bl	4166b8 <__aeabi_dmul>
  419886:	2200      	movs	r2, #0
  419888:	2300      	movs	r3, #0
  41988a:	4606      	mov	r6, r0
  41988c:	460f      	mov	r7, r1
  41988e:	f7fd f97b 	bl	416b88 <__aeabi_dcmpeq>
  419892:	2800      	cmp	r0, #0
  419894:	f040 8088 	bne.w	4199a8 <_dtoa_r+0x388>
  419898:	f8cd 902c 	str.w	r9, [sp, #44]	; 0x2c
  41989c:	f04f 0a00 	mov.w	sl, #0
  4198a0:	f8df b040 	ldr.w	fp, [pc, #64]	; 4198e4 <_dtoa_r+0x2c4>
  4198a4:	940c      	str	r4, [sp, #48]	; 0x30
  4198a6:	e9dd 8908 	ldrd	r8, r9, [sp, #32]
  4198aa:	e028      	b.n	4198fe <_dtoa_r+0x2de>
  4198ac:	f3af 8000 	nop.w
  4198b0:	636f4361 	.word	0x636f4361
  4198b4:	3fd287a7 	.word	0x3fd287a7
  4198b8:	8b60c8b3 	.word	0x8b60c8b3
  4198bc:	3fc68a28 	.word	0x3fc68a28
  4198c0:	509f79fb 	.word	0x509f79fb
  4198c4:	3fd34413 	.word	0x3fd34413
  4198c8:	7ff00000 	.word	0x7ff00000
  4198cc:	0041ea11 	.word	0x0041ea11
  4198d0:	0041ea54 	.word	0x0041ea54
  4198d4:	0041ea60 	.word	0x0041ea60
  4198d8:	3ff80000 	.word	0x3ff80000
  4198dc:	0041eaa0 	.word	0x0041eaa0
  4198e0:	0041ea10 	.word	0x0041ea10
  4198e4:	40240000 	.word	0x40240000
  4198e8:	f7fc fee6 	bl	4166b8 <__aeabi_dmul>
  4198ec:	2200      	movs	r2, #0
  4198ee:	2300      	movs	r3, #0
  4198f0:	4606      	mov	r6, r0
  4198f2:	460f      	mov	r7, r1
  4198f4:	f7fd f948 	bl	416b88 <__aeabi_dcmpeq>
  4198f8:	2800      	cmp	r0, #0
  4198fa:	f040 83c1 	bne.w	41a080 <_dtoa_r+0xa60>
  4198fe:	4642      	mov	r2, r8
  419900:	464b      	mov	r3, r9
  419902:	4630      	mov	r0, r6
  419904:	4639      	mov	r1, r7
  419906:	f7fd f801 	bl	41690c <__aeabi_ddiv>
  41990a:	f002 fe39 	bl	41c580 <__aeabi_d2iz>
  41990e:	4604      	mov	r4, r0
  419910:	f7fc fe6c 	bl	4165ec <__aeabi_i2d>
  419914:	4642      	mov	r2, r8
  419916:	464b      	mov	r3, r9
  419918:	f7fc fece 	bl	4166b8 <__aeabi_dmul>
  41991c:	4602      	mov	r2, r0
  41991e:	460b      	mov	r3, r1
  419920:	4630      	mov	r0, r6
  419922:	4639      	mov	r1, r7
  419924:	f7fc fd14 	bl	416350 <__aeabi_dsub>
  419928:	f104 0e30 	add.w	lr, r4, #48	; 0x30
  41992c:	9e04      	ldr	r6, [sp, #16]
  41992e:	f805 eb01 	strb.w	lr, [r5], #1
  419932:	eba5 0e06 	sub.w	lr, r5, r6
  419936:	9e0a      	ldr	r6, [sp, #40]	; 0x28
  419938:	45b6      	cmp	lr, r6
  41993a:	e9cd 0106 	strd	r0, r1, [sp, #24]
  41993e:	4652      	mov	r2, sl
  419940:	465b      	mov	r3, fp
  419942:	d1d1      	bne.n	4198e8 <_dtoa_r+0x2c8>
  419944:	46a0      	mov	r8, r4
  419946:	f8dd 902c 	ldr.w	r9, [sp, #44]	; 0x2c
  41994a:	9c0c      	ldr	r4, [sp, #48]	; 0x30
  41994c:	4606      	mov	r6, r0
  41994e:	460f      	mov	r7, r1
  419950:	4632      	mov	r2, r6
  419952:	463b      	mov	r3, r7
  419954:	4630      	mov	r0, r6
  419956:	4639      	mov	r1, r7
  419958:	f7fc fcfc 	bl	416354 <__adddf3>
  41995c:	4606      	mov	r6, r0
  41995e:	460f      	mov	r7, r1
  419960:	4602      	mov	r2, r0
  419962:	460b      	mov	r3, r1
  419964:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
  419968:	f7fd f918 	bl	416b9c <__aeabi_dcmplt>
  41996c:	b948      	cbnz	r0, 419982 <_dtoa_r+0x362>
  41996e:	4632      	mov	r2, r6
  419970:	463b      	mov	r3, r7
  419972:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
  419976:	f7fd f907 	bl	416b88 <__aeabi_dcmpeq>
  41997a:	b1a8      	cbz	r0, 4199a8 <_dtoa_r+0x388>
  41997c:	f018 0f01 	tst.w	r8, #1
  419980:	d012      	beq.n	4199a8 <_dtoa_r+0x388>
  419982:	f815 8c01 	ldrb.w	r8, [r5, #-1]
  419986:	9a04      	ldr	r2, [sp, #16]
  419988:	1e6b      	subs	r3, r5, #1
  41998a:	e004      	b.n	419996 <_dtoa_r+0x376>
  41998c:	429a      	cmp	r2, r3
  41998e:	f000 8401 	beq.w	41a194 <_dtoa_r+0xb74>
  419992:	f813 8d01 	ldrb.w	r8, [r3, #-1]!
  419996:	f1b8 0f39 	cmp.w	r8, #57	; 0x39
  41999a:	f103 0501 	add.w	r5, r3, #1
  41999e:	d0f5      	beq.n	41998c <_dtoa_r+0x36c>
  4199a0:	f108 0801 	add.w	r8, r8, #1
  4199a4:	f883 8000 	strb.w	r8, [r3]
  4199a8:	4649      	mov	r1, r9
  4199aa:	4620      	mov	r0, r4
  4199ac:	f001 fdfa 	bl	41b5a4 <_Bfree>
  4199b0:	2200      	movs	r2, #0
  4199b2:	9b02      	ldr	r3, [sp, #8]
  4199b4:	702a      	strb	r2, [r5, #0]
  4199b6:	9a26      	ldr	r2, [sp, #152]	; 0x98
  4199b8:	3301      	adds	r3, #1
  4199ba:	6013      	str	r3, [r2, #0]
  4199bc:	9b28      	ldr	r3, [sp, #160]	; 0xa0
  4199be:	2b00      	cmp	r3, #0
  4199c0:	f000 839e 	beq.w	41a100 <_dtoa_r+0xae0>
  4199c4:	9804      	ldr	r0, [sp, #16]
  4199c6:	601d      	str	r5, [r3, #0]
  4199c8:	b01b      	add	sp, #108	; 0x6c
  4199ca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4199ce:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
  4199d0:	2a00      	cmp	r2, #0
  4199d2:	d03e      	beq.n	419a52 <_dtoa_r+0x432>
  4199d4:	9a24      	ldr	r2, [sp, #144]	; 0x90
  4199d6:	2a01      	cmp	r2, #1
  4199d8:	f340 8311 	ble.w	419ffe <_dtoa_r+0x9de>
  4199dc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  4199de:	9a0c      	ldr	r2, [sp, #48]	; 0x30
  4199e0:	1e5f      	subs	r7, r3, #1
  4199e2:	42ba      	cmp	r2, r7
  4199e4:	f2c0 838f 	blt.w	41a106 <_dtoa_r+0xae6>
  4199e8:	1bd7      	subs	r7, r2, r7
  4199ea:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  4199ec:	2b00      	cmp	r3, #0
  4199ee:	f2c0 848b 	blt.w	41a308 <_dtoa_r+0xce8>
  4199f2:	9d08      	ldr	r5, [sp, #32]
  4199f4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  4199f6:	9a08      	ldr	r2, [sp, #32]
  4199f8:	441a      	add	r2, r3
  4199fa:	9208      	str	r2, [sp, #32]
  4199fc:	9a06      	ldr	r2, [sp, #24]
  4199fe:	2101      	movs	r1, #1
  419a00:	441a      	add	r2, r3
  419a02:	4620      	mov	r0, r4
  419a04:	9206      	str	r2, [sp, #24]
  419a06:	f001 fe67 	bl	41b6d8 <__i2b>
  419a0a:	4606      	mov	r6, r0
  419a0c:	e024      	b.n	419a58 <_dtoa_r+0x438>
  419a0e:	2301      	movs	r3, #1
  419a10:	930e      	str	r3, [sp, #56]	; 0x38
  419a12:	e6af      	b.n	419774 <_dtoa_r+0x154>
  419a14:	9a08      	ldr	r2, [sp, #32]
  419a16:	9b02      	ldr	r3, [sp, #8]
  419a18:	1ad2      	subs	r2, r2, r3
  419a1a:	425b      	negs	r3, r3
  419a1c:	930c      	str	r3, [sp, #48]	; 0x30
  419a1e:	2300      	movs	r3, #0
  419a20:	9208      	str	r2, [sp, #32]
  419a22:	930d      	str	r3, [sp, #52]	; 0x34
  419a24:	e6b8      	b.n	419798 <_dtoa_r+0x178>
  419a26:	f1c7 0301 	rsb	r3, r7, #1
  419a2a:	9308      	str	r3, [sp, #32]
  419a2c:	2300      	movs	r3, #0
  419a2e:	9306      	str	r3, [sp, #24]
  419a30:	e6a7      	b.n	419782 <_dtoa_r+0x162>
  419a32:	9d02      	ldr	r5, [sp, #8]
  419a34:	4628      	mov	r0, r5
  419a36:	f7fc fdd9 	bl	4165ec <__aeabi_i2d>
  419a3a:	4602      	mov	r2, r0
  419a3c:	460b      	mov	r3, r1
  419a3e:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
  419a42:	f7fd f8a1 	bl	416b88 <__aeabi_dcmpeq>
  419a46:	2800      	cmp	r0, #0
  419a48:	f47f ae80 	bne.w	41974c <_dtoa_r+0x12c>
  419a4c:	1e6b      	subs	r3, r5, #1
  419a4e:	9302      	str	r3, [sp, #8]
  419a50:	e67c      	b.n	41974c <_dtoa_r+0x12c>
  419a52:	9f0c      	ldr	r7, [sp, #48]	; 0x30
  419a54:	9d08      	ldr	r5, [sp, #32]
  419a56:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
  419a58:	2d00      	cmp	r5, #0
  419a5a:	dd0c      	ble.n	419a76 <_dtoa_r+0x456>
  419a5c:	9906      	ldr	r1, [sp, #24]
  419a5e:	2900      	cmp	r1, #0
  419a60:	460b      	mov	r3, r1
  419a62:	dd08      	ble.n	419a76 <_dtoa_r+0x456>
  419a64:	42a9      	cmp	r1, r5
  419a66:	9a08      	ldr	r2, [sp, #32]
  419a68:	bfa8      	it	ge
  419a6a:	462b      	movge	r3, r5
  419a6c:	1ad2      	subs	r2, r2, r3
  419a6e:	1aed      	subs	r5, r5, r3
  419a70:	1acb      	subs	r3, r1, r3
  419a72:	9208      	str	r2, [sp, #32]
  419a74:	9306      	str	r3, [sp, #24]
  419a76:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  419a78:	b1d3      	cbz	r3, 419ab0 <_dtoa_r+0x490>
  419a7a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  419a7c:	2b00      	cmp	r3, #0
  419a7e:	f000 82b7 	beq.w	419ff0 <_dtoa_r+0x9d0>
  419a82:	2f00      	cmp	r7, #0
  419a84:	dd10      	ble.n	419aa8 <_dtoa_r+0x488>
  419a86:	4631      	mov	r1, r6
  419a88:	463a      	mov	r2, r7
  419a8a:	4620      	mov	r0, r4
  419a8c:	f001 fec0 	bl	41b810 <__pow5mult>
  419a90:	464a      	mov	r2, r9
  419a92:	4601      	mov	r1, r0
  419a94:	4606      	mov	r6, r0
  419a96:	4620      	mov	r0, r4
  419a98:	f001 fe28 	bl	41b6ec <__multiply>
  419a9c:	4649      	mov	r1, r9
  419a9e:	4680      	mov	r8, r0
  419aa0:	4620      	mov	r0, r4
  419aa2:	f001 fd7f 	bl	41b5a4 <_Bfree>
  419aa6:	46c1      	mov	r9, r8
  419aa8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  419aaa:	1bda      	subs	r2, r3, r7
  419aac:	f040 82a1 	bne.w	419ff2 <_dtoa_r+0x9d2>
  419ab0:	2101      	movs	r1, #1
  419ab2:	4620      	mov	r0, r4
  419ab4:	f001 fe10 	bl	41b6d8 <__i2b>
  419ab8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  419aba:	2b00      	cmp	r3, #0
  419abc:	4680      	mov	r8, r0
  419abe:	dd1c      	ble.n	419afa <_dtoa_r+0x4da>
  419ac0:	4601      	mov	r1, r0
  419ac2:	461a      	mov	r2, r3
  419ac4:	4620      	mov	r0, r4
  419ac6:	f001 fea3 	bl	41b810 <__pow5mult>
  419aca:	9b24      	ldr	r3, [sp, #144]	; 0x90
  419acc:	2b01      	cmp	r3, #1
  419ace:	4680      	mov	r8, r0
  419ad0:	f340 8254 	ble.w	419f7c <_dtoa_r+0x95c>
  419ad4:	2300      	movs	r3, #0
  419ad6:	930c      	str	r3, [sp, #48]	; 0x30
  419ad8:	f8d8 3010 	ldr.w	r3, [r8, #16]
  419adc:	eb08 0383 	add.w	r3, r8, r3, lsl #2
  419ae0:	6918      	ldr	r0, [r3, #16]
  419ae2:	f001 fda9 	bl	41b638 <__hi0bits>
  419ae6:	f1c0 0020 	rsb	r0, r0, #32
  419aea:	e010      	b.n	419b0e <_dtoa_r+0x4ee>
  419aec:	f1c3 0520 	rsb	r5, r3, #32
  419af0:	fa0a f005 	lsl.w	r0, sl, r5
  419af4:	e674      	b.n	4197e0 <_dtoa_r+0x1c0>
  419af6:	900e      	str	r0, [sp, #56]	; 0x38
  419af8:	e63c      	b.n	419774 <_dtoa_r+0x154>
  419afa:	9b24      	ldr	r3, [sp, #144]	; 0x90
  419afc:	2b01      	cmp	r3, #1
  419afe:	f340 8287 	ble.w	41a010 <_dtoa_r+0x9f0>
  419b02:	2300      	movs	r3, #0
  419b04:	930c      	str	r3, [sp, #48]	; 0x30
  419b06:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  419b08:	2001      	movs	r0, #1
  419b0a:	2b00      	cmp	r3, #0
  419b0c:	d1e4      	bne.n	419ad8 <_dtoa_r+0x4b8>
  419b0e:	9a06      	ldr	r2, [sp, #24]
  419b10:	4410      	add	r0, r2
  419b12:	f010 001f 	ands.w	r0, r0, #31
  419b16:	f000 80a1 	beq.w	419c5c <_dtoa_r+0x63c>
  419b1a:	f1c0 0320 	rsb	r3, r0, #32
  419b1e:	2b04      	cmp	r3, #4
  419b20:	f340 849e 	ble.w	41a460 <_dtoa_r+0xe40>
  419b24:	9b08      	ldr	r3, [sp, #32]
  419b26:	f1c0 001c 	rsb	r0, r0, #28
  419b2a:	4403      	add	r3, r0
  419b2c:	9308      	str	r3, [sp, #32]
  419b2e:	4613      	mov	r3, r2
  419b30:	4403      	add	r3, r0
  419b32:	4405      	add	r5, r0
  419b34:	9306      	str	r3, [sp, #24]
  419b36:	9b08      	ldr	r3, [sp, #32]
  419b38:	2b00      	cmp	r3, #0
  419b3a:	dd05      	ble.n	419b48 <_dtoa_r+0x528>
  419b3c:	4649      	mov	r1, r9
  419b3e:	461a      	mov	r2, r3
  419b40:	4620      	mov	r0, r4
  419b42:	f001 feb5 	bl	41b8b0 <__lshift>
  419b46:	4681      	mov	r9, r0
  419b48:	9b06      	ldr	r3, [sp, #24]
  419b4a:	2b00      	cmp	r3, #0
  419b4c:	dd05      	ble.n	419b5a <_dtoa_r+0x53a>
  419b4e:	4641      	mov	r1, r8
  419b50:	461a      	mov	r2, r3
  419b52:	4620      	mov	r0, r4
  419b54:	f001 feac 	bl	41b8b0 <__lshift>
  419b58:	4680      	mov	r8, r0
  419b5a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  419b5c:	2b00      	cmp	r3, #0
  419b5e:	f040 8086 	bne.w	419c6e <_dtoa_r+0x64e>
  419b62:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  419b64:	2b00      	cmp	r3, #0
  419b66:	f340 8266 	ble.w	41a036 <_dtoa_r+0xa16>
  419b6a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  419b6c:	2b00      	cmp	r3, #0
  419b6e:	f000 8098 	beq.w	419ca2 <_dtoa_r+0x682>
  419b72:	2d00      	cmp	r5, #0
  419b74:	dd05      	ble.n	419b82 <_dtoa_r+0x562>
  419b76:	4631      	mov	r1, r6
  419b78:	462a      	mov	r2, r5
  419b7a:	4620      	mov	r0, r4
  419b7c:	f001 fe98 	bl	41b8b0 <__lshift>
  419b80:	4606      	mov	r6, r0
  419b82:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  419b84:	2b00      	cmp	r3, #0
  419b86:	f040 8337 	bne.w	41a1f8 <_dtoa_r+0xbd8>
  419b8a:	9606      	str	r6, [sp, #24]
  419b8c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  419b8e:	9a04      	ldr	r2, [sp, #16]
  419b90:	f8dd b018 	ldr.w	fp, [sp, #24]
  419b94:	3b01      	subs	r3, #1
  419b96:	18d3      	adds	r3, r2, r3
  419b98:	930b      	str	r3, [sp, #44]	; 0x2c
  419b9a:	f00a 0301 	and.w	r3, sl, #1
  419b9e:	930c      	str	r3, [sp, #48]	; 0x30
  419ba0:	4617      	mov	r7, r2
  419ba2:	46c2      	mov	sl, r8
  419ba4:	4651      	mov	r1, sl
  419ba6:	4648      	mov	r0, r9
  419ba8:	f7ff fca6 	bl	4194f8 <quorem>
  419bac:	4631      	mov	r1, r6
  419bae:	4605      	mov	r5, r0
  419bb0:	4648      	mov	r0, r9
  419bb2:	f001 fecf 	bl	41b954 <__mcmp>
  419bb6:	465a      	mov	r2, fp
  419bb8:	900a      	str	r0, [sp, #40]	; 0x28
  419bba:	4651      	mov	r1, sl
  419bbc:	4620      	mov	r0, r4
  419bbe:	f001 fee5 	bl	41b98c <__mdiff>
  419bc2:	68c2      	ldr	r2, [r0, #12]
  419bc4:	4680      	mov	r8, r0
  419bc6:	f105 0330 	add.w	r3, r5, #48	; 0x30
  419bca:	2a00      	cmp	r2, #0
  419bcc:	f040 822b 	bne.w	41a026 <_dtoa_r+0xa06>
  419bd0:	4601      	mov	r1, r0
  419bd2:	4648      	mov	r0, r9
  419bd4:	9308      	str	r3, [sp, #32]
  419bd6:	f001 febd 	bl	41b954 <__mcmp>
  419bda:	4641      	mov	r1, r8
  419bdc:	9006      	str	r0, [sp, #24]
  419bde:	4620      	mov	r0, r4
  419be0:	f001 fce0 	bl	41b5a4 <_Bfree>
  419be4:	9a06      	ldr	r2, [sp, #24]
  419be6:	9b08      	ldr	r3, [sp, #32]
  419be8:	b932      	cbnz	r2, 419bf8 <_dtoa_r+0x5d8>
  419bea:	9924      	ldr	r1, [sp, #144]	; 0x90
  419bec:	b921      	cbnz	r1, 419bf8 <_dtoa_r+0x5d8>
  419bee:	9a0c      	ldr	r2, [sp, #48]	; 0x30
  419bf0:	2a00      	cmp	r2, #0
  419bf2:	f000 83ef 	beq.w	41a3d4 <_dtoa_r+0xdb4>
  419bf6:	9a24      	ldr	r2, [sp, #144]	; 0x90
  419bf8:	990a      	ldr	r1, [sp, #40]	; 0x28
  419bfa:	2900      	cmp	r1, #0
  419bfc:	f2c0 829f 	blt.w	41a13e <_dtoa_r+0xb1e>
  419c00:	d105      	bne.n	419c0e <_dtoa_r+0x5ee>
  419c02:	9924      	ldr	r1, [sp, #144]	; 0x90
  419c04:	b919      	cbnz	r1, 419c0e <_dtoa_r+0x5ee>
  419c06:	990c      	ldr	r1, [sp, #48]	; 0x30
  419c08:	2900      	cmp	r1, #0
  419c0a:	f000 8298 	beq.w	41a13e <_dtoa_r+0xb1e>
  419c0e:	2a00      	cmp	r2, #0
  419c10:	f300 8306 	bgt.w	41a220 <_dtoa_r+0xc00>
  419c14:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
  419c16:	703b      	strb	r3, [r7, #0]
  419c18:	f107 0801 	add.w	r8, r7, #1
  419c1c:	4297      	cmp	r7, r2
  419c1e:	4645      	mov	r5, r8
  419c20:	f000 830c 	beq.w	41a23c <_dtoa_r+0xc1c>
  419c24:	4649      	mov	r1, r9
  419c26:	2300      	movs	r3, #0
  419c28:	220a      	movs	r2, #10
  419c2a:	4620      	mov	r0, r4
  419c2c:	f001 fcc4 	bl	41b5b8 <__multadd>
  419c30:	455e      	cmp	r6, fp
  419c32:	4681      	mov	r9, r0
  419c34:	4631      	mov	r1, r6
  419c36:	f04f 0300 	mov.w	r3, #0
  419c3a:	f04f 020a 	mov.w	r2, #10
  419c3e:	4620      	mov	r0, r4
  419c40:	f000 81eb 	beq.w	41a01a <_dtoa_r+0x9fa>
  419c44:	f001 fcb8 	bl	41b5b8 <__multadd>
  419c48:	4659      	mov	r1, fp
  419c4a:	4606      	mov	r6, r0
  419c4c:	2300      	movs	r3, #0
  419c4e:	220a      	movs	r2, #10
  419c50:	4620      	mov	r0, r4
  419c52:	f001 fcb1 	bl	41b5b8 <__multadd>
  419c56:	4647      	mov	r7, r8
  419c58:	4683      	mov	fp, r0
  419c5a:	e7a3      	b.n	419ba4 <_dtoa_r+0x584>
  419c5c:	201c      	movs	r0, #28
  419c5e:	9b08      	ldr	r3, [sp, #32]
  419c60:	4403      	add	r3, r0
  419c62:	9308      	str	r3, [sp, #32]
  419c64:	9b06      	ldr	r3, [sp, #24]
  419c66:	4403      	add	r3, r0
  419c68:	4405      	add	r5, r0
  419c6a:	9306      	str	r3, [sp, #24]
  419c6c:	e763      	b.n	419b36 <_dtoa_r+0x516>
  419c6e:	4641      	mov	r1, r8
  419c70:	4648      	mov	r0, r9
  419c72:	f001 fe6f 	bl	41b954 <__mcmp>
  419c76:	2800      	cmp	r0, #0
  419c78:	f6bf af73 	bge.w	419b62 <_dtoa_r+0x542>
  419c7c:	9f02      	ldr	r7, [sp, #8]
  419c7e:	4649      	mov	r1, r9
  419c80:	2300      	movs	r3, #0
  419c82:	220a      	movs	r2, #10
  419c84:	4620      	mov	r0, r4
  419c86:	3f01      	subs	r7, #1
  419c88:	9702      	str	r7, [sp, #8]
  419c8a:	f001 fc95 	bl	41b5b8 <__multadd>
  419c8e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  419c90:	4681      	mov	r9, r0
  419c92:	2b00      	cmp	r3, #0
  419c94:	f040 83b6 	bne.w	41a404 <_dtoa_r+0xde4>
  419c98:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  419c9a:	2b00      	cmp	r3, #0
  419c9c:	f340 83bf 	ble.w	41a41e <_dtoa_r+0xdfe>
  419ca0:	930a      	str	r3, [sp, #40]	; 0x28
  419ca2:	f8dd b010 	ldr.w	fp, [sp, #16]
  419ca6:	9f0a      	ldr	r7, [sp, #40]	; 0x28
  419ca8:	465d      	mov	r5, fp
  419caa:	e002      	b.n	419cb2 <_dtoa_r+0x692>
  419cac:	f001 fc84 	bl	41b5b8 <__multadd>
  419cb0:	4681      	mov	r9, r0
  419cb2:	4641      	mov	r1, r8
  419cb4:	4648      	mov	r0, r9
  419cb6:	f7ff fc1f 	bl	4194f8 <quorem>
  419cba:	f100 0a30 	add.w	sl, r0, #48	; 0x30
  419cbe:	f805 ab01 	strb.w	sl, [r5], #1
  419cc2:	eba5 030b 	sub.w	r3, r5, fp
  419cc6:	42bb      	cmp	r3, r7
  419cc8:	f04f 020a 	mov.w	r2, #10
  419ccc:	f04f 0300 	mov.w	r3, #0
  419cd0:	4649      	mov	r1, r9
  419cd2:	4620      	mov	r0, r4
  419cd4:	dbea      	blt.n	419cac <_dtoa_r+0x68c>
  419cd6:	9b04      	ldr	r3, [sp, #16]
  419cd8:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  419cda:	2a01      	cmp	r2, #1
  419cdc:	bfac      	ite	ge
  419cde:	189b      	addge	r3, r3, r2
  419ce0:	3301      	addlt	r3, #1
  419ce2:	461d      	mov	r5, r3
  419ce4:	f04f 0b00 	mov.w	fp, #0
  419ce8:	4649      	mov	r1, r9
  419cea:	2201      	movs	r2, #1
  419cec:	4620      	mov	r0, r4
  419cee:	f001 fddf 	bl	41b8b0 <__lshift>
  419cf2:	4641      	mov	r1, r8
  419cf4:	4681      	mov	r9, r0
  419cf6:	f001 fe2d 	bl	41b954 <__mcmp>
  419cfa:	2800      	cmp	r0, #0
  419cfc:	f340 823d 	ble.w	41a17a <_dtoa_r+0xb5a>
  419d00:	f815 2c01 	ldrb.w	r2, [r5, #-1]
  419d04:	9904      	ldr	r1, [sp, #16]
  419d06:	1e6b      	subs	r3, r5, #1
  419d08:	e004      	b.n	419d14 <_dtoa_r+0x6f4>
  419d0a:	428b      	cmp	r3, r1
  419d0c:	f000 81ae 	beq.w	41a06c <_dtoa_r+0xa4c>
  419d10:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
  419d14:	2a39      	cmp	r2, #57	; 0x39
  419d16:	f103 0501 	add.w	r5, r3, #1
  419d1a:	d0f6      	beq.n	419d0a <_dtoa_r+0x6ea>
  419d1c:	3201      	adds	r2, #1
  419d1e:	701a      	strb	r2, [r3, #0]
  419d20:	4641      	mov	r1, r8
  419d22:	4620      	mov	r0, r4
  419d24:	f001 fc3e 	bl	41b5a4 <_Bfree>
  419d28:	2e00      	cmp	r6, #0
  419d2a:	f43f ae3d 	beq.w	4199a8 <_dtoa_r+0x388>
  419d2e:	f1bb 0f00 	cmp.w	fp, #0
  419d32:	d005      	beq.n	419d40 <_dtoa_r+0x720>
  419d34:	45b3      	cmp	fp, r6
  419d36:	d003      	beq.n	419d40 <_dtoa_r+0x720>
  419d38:	4659      	mov	r1, fp
  419d3a:	4620      	mov	r0, r4
  419d3c:	f001 fc32 	bl	41b5a4 <_Bfree>
  419d40:	4631      	mov	r1, r6
  419d42:	4620      	mov	r0, r4
  419d44:	f001 fc2e 	bl	41b5a4 <_Bfree>
  419d48:	e62e      	b.n	4199a8 <_dtoa_r+0x388>
  419d4a:	2300      	movs	r3, #0
  419d4c:	930b      	str	r3, [sp, #44]	; 0x2c
  419d4e:	9b02      	ldr	r3, [sp, #8]
  419d50:	9a25      	ldr	r2, [sp, #148]	; 0x94
  419d52:	4413      	add	r3, r2
  419d54:	930f      	str	r3, [sp, #60]	; 0x3c
  419d56:	3301      	adds	r3, #1
  419d58:	2b01      	cmp	r3, #1
  419d5a:	461f      	mov	r7, r3
  419d5c:	461e      	mov	r6, r3
  419d5e:	930a      	str	r3, [sp, #40]	; 0x28
  419d60:	bfb8      	it	lt
  419d62:	2701      	movlt	r7, #1
  419d64:	2100      	movs	r1, #0
  419d66:	2f17      	cmp	r7, #23
  419d68:	6461      	str	r1, [r4, #68]	; 0x44
  419d6a:	d90a      	bls.n	419d82 <_dtoa_r+0x762>
  419d6c:	2201      	movs	r2, #1
  419d6e:	2304      	movs	r3, #4
  419d70:	005b      	lsls	r3, r3, #1
  419d72:	f103 0014 	add.w	r0, r3, #20
  419d76:	4287      	cmp	r7, r0
  419d78:	4611      	mov	r1, r2
  419d7a:	f102 0201 	add.w	r2, r2, #1
  419d7e:	d2f7      	bcs.n	419d70 <_dtoa_r+0x750>
  419d80:	6461      	str	r1, [r4, #68]	; 0x44
  419d82:	4620      	mov	r0, r4
  419d84:	f001 fbe8 	bl	41b558 <_Balloc>
  419d88:	2e0e      	cmp	r6, #14
  419d8a:	9004      	str	r0, [sp, #16]
  419d8c:	6420      	str	r0, [r4, #64]	; 0x40
  419d8e:	f63f ad41 	bhi.w	419814 <_dtoa_r+0x1f4>
  419d92:	2d00      	cmp	r5, #0
  419d94:	f43f ad3e 	beq.w	419814 <_dtoa_r+0x1f4>
  419d98:	9902      	ldr	r1, [sp, #8]
  419d9a:	2900      	cmp	r1, #0
  419d9c:	e9cd ab10 	strd	sl, fp, [sp, #64]	; 0x40
  419da0:	f340 8202 	ble.w	41a1a8 <_dtoa_r+0xb88>
  419da4:	4bb8      	ldr	r3, [pc, #736]	; (41a088 <_dtoa_r+0xa68>)
  419da6:	f001 020f 	and.w	r2, r1, #15
  419daa:	110d      	asrs	r5, r1, #4
  419dac:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
  419db0:	06e9      	lsls	r1, r5, #27
  419db2:	e9d3 6700 	ldrd	r6, r7, [r3]
  419db6:	f140 81ae 	bpl.w	41a116 <_dtoa_r+0xaf6>
  419dba:	4bb4      	ldr	r3, [pc, #720]	; (41a08c <_dtoa_r+0xa6c>)
  419dbc:	4650      	mov	r0, sl
  419dbe:	4659      	mov	r1, fp
  419dc0:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
  419dc4:	f7fc fda2 	bl	41690c <__aeabi_ddiv>
  419dc8:	e9cd 0112 	strd	r0, r1, [sp, #72]	; 0x48
  419dcc:	f005 050f 	and.w	r5, r5, #15
  419dd0:	f04f 0a03 	mov.w	sl, #3
  419dd4:	b18d      	cbz	r5, 419dfa <_dtoa_r+0x7da>
  419dd6:	f8df 82b4 	ldr.w	r8, [pc, #692]	; 41a08c <_dtoa_r+0xa6c>
  419dda:	07ea      	lsls	r2, r5, #31
  419ddc:	d509      	bpl.n	419df2 <_dtoa_r+0x7d2>
  419dde:	4630      	mov	r0, r6
  419de0:	4639      	mov	r1, r7
  419de2:	e9d8 2300 	ldrd	r2, r3, [r8]
  419de6:	f7fc fc67 	bl	4166b8 <__aeabi_dmul>
  419dea:	f10a 0a01 	add.w	sl, sl, #1
  419dee:	4606      	mov	r6, r0
  419df0:	460f      	mov	r7, r1
  419df2:	106d      	asrs	r5, r5, #1
  419df4:	f108 0808 	add.w	r8, r8, #8
  419df8:	d1ef      	bne.n	419dda <_dtoa_r+0x7ba>
  419dfa:	463b      	mov	r3, r7
  419dfc:	4632      	mov	r2, r6
  419dfe:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
  419e02:	f7fc fd83 	bl	41690c <__aeabi_ddiv>
  419e06:	4607      	mov	r7, r0
  419e08:	4688      	mov	r8, r1
  419e0a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  419e0c:	b143      	cbz	r3, 419e20 <_dtoa_r+0x800>
  419e0e:	2200      	movs	r2, #0
  419e10:	4b9f      	ldr	r3, [pc, #636]	; (41a090 <_dtoa_r+0xa70>)
  419e12:	4638      	mov	r0, r7
  419e14:	4641      	mov	r1, r8
  419e16:	f7fc fec1 	bl	416b9c <__aeabi_dcmplt>
  419e1a:	2800      	cmp	r0, #0
  419e1c:	f040 8286 	bne.w	41a32c <_dtoa_r+0xd0c>
  419e20:	4650      	mov	r0, sl
  419e22:	f7fc fbe3 	bl	4165ec <__aeabi_i2d>
  419e26:	463a      	mov	r2, r7
  419e28:	4643      	mov	r3, r8
  419e2a:	f7fc fc45 	bl	4166b8 <__aeabi_dmul>
  419e2e:	4b99      	ldr	r3, [pc, #612]	; (41a094 <_dtoa_r+0xa74>)
  419e30:	2200      	movs	r2, #0
  419e32:	f7fc fa8f 	bl	416354 <__adddf3>
  419e36:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  419e38:	4605      	mov	r5, r0
  419e3a:	f1a1 7650 	sub.w	r6, r1, #54525952	; 0x3400000
  419e3e:	2b00      	cmp	r3, #0
  419e40:	f000 813e 	beq.w	41a0c0 <_dtoa_r+0xaa0>
  419e44:	9b02      	ldr	r3, [sp, #8]
  419e46:	9315      	str	r3, [sp, #84]	; 0x54
  419e48:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  419e4a:	9312      	str	r3, [sp, #72]	; 0x48
  419e4c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  419e4e:	2b00      	cmp	r3, #0
  419e50:	f000 81fa 	beq.w	41a248 <_dtoa_r+0xc28>
  419e54:	9a12      	ldr	r2, [sp, #72]	; 0x48
  419e56:	4b8c      	ldr	r3, [pc, #560]	; (41a088 <_dtoa_r+0xa68>)
  419e58:	498f      	ldr	r1, [pc, #572]	; (41a098 <_dtoa_r+0xa78>)
  419e5a:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
  419e5e:	e953 2302 	ldrd	r2, r3, [r3, #-8]
  419e62:	2000      	movs	r0, #0
  419e64:	f7fc fd52 	bl	41690c <__aeabi_ddiv>
  419e68:	462a      	mov	r2, r5
  419e6a:	4633      	mov	r3, r6
  419e6c:	f7fc fa70 	bl	416350 <__aeabi_dsub>
  419e70:	4682      	mov	sl, r0
  419e72:	468b      	mov	fp, r1
  419e74:	4638      	mov	r0, r7
  419e76:	4641      	mov	r1, r8
  419e78:	f002 fb82 	bl	41c580 <__aeabi_d2iz>
  419e7c:	4605      	mov	r5, r0
  419e7e:	f7fc fbb5 	bl	4165ec <__aeabi_i2d>
  419e82:	4602      	mov	r2, r0
  419e84:	460b      	mov	r3, r1
  419e86:	4638      	mov	r0, r7
  419e88:	4641      	mov	r1, r8
  419e8a:	f7fc fa61 	bl	416350 <__aeabi_dsub>
  419e8e:	3530      	adds	r5, #48	; 0x30
  419e90:	fa5f f885 	uxtb.w	r8, r5
  419e94:	9d04      	ldr	r5, [sp, #16]
  419e96:	4606      	mov	r6, r0
  419e98:	460f      	mov	r7, r1
  419e9a:	f885 8000 	strb.w	r8, [r5]
  419e9e:	4602      	mov	r2, r0
  419ea0:	460b      	mov	r3, r1
  419ea2:	4650      	mov	r0, sl
  419ea4:	4659      	mov	r1, fp
  419ea6:	3501      	adds	r5, #1
  419ea8:	f7fc fe96 	bl	416bd8 <__aeabi_dcmpgt>
  419eac:	2800      	cmp	r0, #0
  419eae:	d154      	bne.n	419f5a <_dtoa_r+0x93a>
  419eb0:	4632      	mov	r2, r6
  419eb2:	463b      	mov	r3, r7
  419eb4:	2000      	movs	r0, #0
  419eb6:	4976      	ldr	r1, [pc, #472]	; (41a090 <_dtoa_r+0xa70>)
  419eb8:	f7fc fa4a 	bl	416350 <__aeabi_dsub>
  419ebc:	4602      	mov	r2, r0
  419ebe:	460b      	mov	r3, r1
  419ec0:	4650      	mov	r0, sl
  419ec2:	4659      	mov	r1, fp
  419ec4:	f7fc fe88 	bl	416bd8 <__aeabi_dcmpgt>
  419ec8:	2800      	cmp	r0, #0
  419eca:	f040 8270 	bne.w	41a3ae <_dtoa_r+0xd8e>
  419ece:	9a12      	ldr	r2, [sp, #72]	; 0x48
  419ed0:	2a01      	cmp	r2, #1
  419ed2:	f000 8111 	beq.w	41a0f8 <_dtoa_r+0xad8>
  419ed6:	9b12      	ldr	r3, [sp, #72]	; 0x48
  419ed8:	9a04      	ldr	r2, [sp, #16]
  419eda:	f8cd 9048 	str.w	r9, [sp, #72]	; 0x48
  419ede:	4413      	add	r3, r2
  419ee0:	4699      	mov	r9, r3
  419ee2:	e00d      	b.n	419f00 <_dtoa_r+0x8e0>
  419ee4:	2000      	movs	r0, #0
  419ee6:	496a      	ldr	r1, [pc, #424]	; (41a090 <_dtoa_r+0xa70>)
  419ee8:	f7fc fa32 	bl	416350 <__aeabi_dsub>
  419eec:	4652      	mov	r2, sl
  419eee:	465b      	mov	r3, fp
  419ef0:	f7fc fe54 	bl	416b9c <__aeabi_dcmplt>
  419ef4:	2800      	cmp	r0, #0
  419ef6:	f040 8258 	bne.w	41a3aa <_dtoa_r+0xd8a>
  419efa:	454d      	cmp	r5, r9
  419efc:	f000 80fa 	beq.w	41a0f4 <_dtoa_r+0xad4>
  419f00:	4650      	mov	r0, sl
  419f02:	4659      	mov	r1, fp
  419f04:	2200      	movs	r2, #0
  419f06:	4b65      	ldr	r3, [pc, #404]	; (41a09c <_dtoa_r+0xa7c>)
  419f08:	f7fc fbd6 	bl	4166b8 <__aeabi_dmul>
  419f0c:	2200      	movs	r2, #0
  419f0e:	4b63      	ldr	r3, [pc, #396]	; (41a09c <_dtoa_r+0xa7c>)
  419f10:	4682      	mov	sl, r0
  419f12:	468b      	mov	fp, r1
  419f14:	4630      	mov	r0, r6
  419f16:	4639      	mov	r1, r7
  419f18:	f7fc fbce 	bl	4166b8 <__aeabi_dmul>
  419f1c:	460f      	mov	r7, r1
  419f1e:	4606      	mov	r6, r0
  419f20:	f002 fb2e 	bl	41c580 <__aeabi_d2iz>
  419f24:	4680      	mov	r8, r0
  419f26:	f7fc fb61 	bl	4165ec <__aeabi_i2d>
  419f2a:	4602      	mov	r2, r0
  419f2c:	460b      	mov	r3, r1
  419f2e:	4630      	mov	r0, r6
  419f30:	4639      	mov	r1, r7
  419f32:	f7fc fa0d 	bl	416350 <__aeabi_dsub>
  419f36:	f108 0830 	add.w	r8, r8, #48	; 0x30
  419f3a:	fa5f f888 	uxtb.w	r8, r8
  419f3e:	4652      	mov	r2, sl
  419f40:	465b      	mov	r3, fp
  419f42:	f805 8b01 	strb.w	r8, [r5], #1
  419f46:	4606      	mov	r6, r0
  419f48:	460f      	mov	r7, r1
  419f4a:	f7fc fe27 	bl	416b9c <__aeabi_dcmplt>
  419f4e:	4632      	mov	r2, r6
  419f50:	463b      	mov	r3, r7
  419f52:	2800      	cmp	r0, #0
  419f54:	d0c6      	beq.n	419ee4 <_dtoa_r+0x8c4>
  419f56:	f8dd 9048 	ldr.w	r9, [sp, #72]	; 0x48
  419f5a:	9b15      	ldr	r3, [sp, #84]	; 0x54
  419f5c:	9302      	str	r3, [sp, #8]
  419f5e:	e523      	b.n	4199a8 <_dtoa_r+0x388>
  419f60:	2300      	movs	r3, #0
  419f62:	930b      	str	r3, [sp, #44]	; 0x2c
  419f64:	9b25      	ldr	r3, [sp, #148]	; 0x94
  419f66:	2b00      	cmp	r3, #0
  419f68:	f340 80dc 	ble.w	41a124 <_dtoa_r+0xb04>
  419f6c:	461f      	mov	r7, r3
  419f6e:	461e      	mov	r6, r3
  419f70:	930f      	str	r3, [sp, #60]	; 0x3c
  419f72:	930a      	str	r3, [sp, #40]	; 0x28
  419f74:	e6f6      	b.n	419d64 <_dtoa_r+0x744>
  419f76:	2301      	movs	r3, #1
  419f78:	930b      	str	r3, [sp, #44]	; 0x2c
  419f7a:	e7f3      	b.n	419f64 <_dtoa_r+0x944>
  419f7c:	f1ba 0f00 	cmp.w	sl, #0
  419f80:	f47f ada8 	bne.w	419ad4 <_dtoa_r+0x4b4>
  419f84:	f3cb 0313 	ubfx	r3, fp, #0, #20
  419f88:	2b00      	cmp	r3, #0
  419f8a:	f47f adba 	bne.w	419b02 <_dtoa_r+0x4e2>
  419f8e:	f02b 4700 	bic.w	r7, fp, #2147483648	; 0x80000000
  419f92:	0d3f      	lsrs	r7, r7, #20
  419f94:	053f      	lsls	r7, r7, #20
  419f96:	2f00      	cmp	r7, #0
  419f98:	f000 820d 	beq.w	41a3b6 <_dtoa_r+0xd96>
  419f9c:	9b08      	ldr	r3, [sp, #32]
  419f9e:	3301      	adds	r3, #1
  419fa0:	9308      	str	r3, [sp, #32]
  419fa2:	9b06      	ldr	r3, [sp, #24]
  419fa4:	3301      	adds	r3, #1
  419fa6:	9306      	str	r3, [sp, #24]
  419fa8:	2301      	movs	r3, #1
  419faa:	930c      	str	r3, [sp, #48]	; 0x30
  419fac:	e5ab      	b.n	419b06 <_dtoa_r+0x4e6>
  419fae:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  419fb0:	2b00      	cmp	r3, #0
  419fb2:	f73f ac42 	bgt.w	41983a <_dtoa_r+0x21a>
  419fb6:	f040 8221 	bne.w	41a3fc <_dtoa_r+0xddc>
  419fba:	2200      	movs	r2, #0
  419fbc:	4b38      	ldr	r3, [pc, #224]	; (41a0a0 <_dtoa_r+0xa80>)
  419fbe:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
  419fc2:	f7fc fb79 	bl	4166b8 <__aeabi_dmul>
  419fc6:	4652      	mov	r2, sl
  419fc8:	465b      	mov	r3, fp
  419fca:	f7fc fdfb 	bl	416bc4 <__aeabi_dcmpge>
  419fce:	f8dd 8028 	ldr.w	r8, [sp, #40]	; 0x28
  419fd2:	4646      	mov	r6, r8
  419fd4:	2800      	cmp	r0, #0
  419fd6:	d041      	beq.n	41a05c <_dtoa_r+0xa3c>
  419fd8:	9b25      	ldr	r3, [sp, #148]	; 0x94
  419fda:	9d04      	ldr	r5, [sp, #16]
  419fdc:	43db      	mvns	r3, r3
  419fde:	9302      	str	r3, [sp, #8]
  419fe0:	4641      	mov	r1, r8
  419fe2:	4620      	mov	r0, r4
  419fe4:	f001 fade 	bl	41b5a4 <_Bfree>
  419fe8:	2e00      	cmp	r6, #0
  419fea:	f43f acdd 	beq.w	4199a8 <_dtoa_r+0x388>
  419fee:	e6a7      	b.n	419d40 <_dtoa_r+0x720>
  419ff0:	9a0c      	ldr	r2, [sp, #48]	; 0x30
  419ff2:	4649      	mov	r1, r9
  419ff4:	4620      	mov	r0, r4
  419ff6:	f001 fc0b 	bl	41b810 <__pow5mult>
  419ffa:	4681      	mov	r9, r0
  419ffc:	e558      	b.n	419ab0 <_dtoa_r+0x490>
  419ffe:	9a14      	ldr	r2, [sp, #80]	; 0x50
  41a000:	2a00      	cmp	r2, #0
  41a002:	f000 8187 	beq.w	41a314 <_dtoa_r+0xcf4>
  41a006:	f203 4333 	addw	r3, r3, #1075	; 0x433
  41a00a:	9f0c      	ldr	r7, [sp, #48]	; 0x30
  41a00c:	9d08      	ldr	r5, [sp, #32]
  41a00e:	e4f2      	b.n	4199f6 <_dtoa_r+0x3d6>
  41a010:	f1ba 0f00 	cmp.w	sl, #0
  41a014:	f47f ad75 	bne.w	419b02 <_dtoa_r+0x4e2>
  41a018:	e7b4      	b.n	419f84 <_dtoa_r+0x964>
  41a01a:	f001 facd 	bl	41b5b8 <__multadd>
  41a01e:	4647      	mov	r7, r8
  41a020:	4606      	mov	r6, r0
  41a022:	4683      	mov	fp, r0
  41a024:	e5be      	b.n	419ba4 <_dtoa_r+0x584>
  41a026:	4601      	mov	r1, r0
  41a028:	4620      	mov	r0, r4
  41a02a:	9306      	str	r3, [sp, #24]
  41a02c:	f001 faba 	bl	41b5a4 <_Bfree>
  41a030:	2201      	movs	r2, #1
  41a032:	9b06      	ldr	r3, [sp, #24]
  41a034:	e5e0      	b.n	419bf8 <_dtoa_r+0x5d8>
  41a036:	9b24      	ldr	r3, [sp, #144]	; 0x90
  41a038:	2b02      	cmp	r3, #2
  41a03a:	f77f ad96 	ble.w	419b6a <_dtoa_r+0x54a>
  41a03e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  41a040:	2b00      	cmp	r3, #0
  41a042:	d1c9      	bne.n	419fd8 <_dtoa_r+0x9b8>
  41a044:	4641      	mov	r1, r8
  41a046:	2205      	movs	r2, #5
  41a048:	4620      	mov	r0, r4
  41a04a:	f001 fab5 	bl	41b5b8 <__multadd>
  41a04e:	4601      	mov	r1, r0
  41a050:	4680      	mov	r8, r0
  41a052:	4648      	mov	r0, r9
  41a054:	f001 fc7e 	bl	41b954 <__mcmp>
  41a058:	2800      	cmp	r0, #0
  41a05a:	ddbd      	ble.n	419fd8 <_dtoa_r+0x9b8>
  41a05c:	9a02      	ldr	r2, [sp, #8]
  41a05e:	9904      	ldr	r1, [sp, #16]
  41a060:	2331      	movs	r3, #49	; 0x31
  41a062:	3201      	adds	r2, #1
  41a064:	9202      	str	r2, [sp, #8]
  41a066:	700b      	strb	r3, [r1, #0]
  41a068:	1c4d      	adds	r5, r1, #1
  41a06a:	e7b9      	b.n	419fe0 <_dtoa_r+0x9c0>
  41a06c:	9a02      	ldr	r2, [sp, #8]
  41a06e:	3201      	adds	r2, #1
  41a070:	9202      	str	r2, [sp, #8]
  41a072:	9a04      	ldr	r2, [sp, #16]
  41a074:	2331      	movs	r3, #49	; 0x31
  41a076:	7013      	strb	r3, [r2, #0]
  41a078:	e652      	b.n	419d20 <_dtoa_r+0x700>
  41a07a:	2301      	movs	r3, #1
  41a07c:	930b      	str	r3, [sp, #44]	; 0x2c
  41a07e:	e666      	b.n	419d4e <_dtoa_r+0x72e>
  41a080:	f8dd 902c 	ldr.w	r9, [sp, #44]	; 0x2c
  41a084:	9c0c      	ldr	r4, [sp, #48]	; 0x30
  41a086:	e48f      	b.n	4199a8 <_dtoa_r+0x388>
  41a088:	0041eaa0 	.word	0x0041eaa0
  41a08c:	0041ea78 	.word	0x0041ea78
  41a090:	3ff00000 	.word	0x3ff00000
  41a094:	401c0000 	.word	0x401c0000
  41a098:	3fe00000 	.word	0x3fe00000
  41a09c:	40240000 	.word	0x40240000
  41a0a0:	40140000 	.word	0x40140000
  41a0a4:	4650      	mov	r0, sl
  41a0a6:	f7fc faa1 	bl	4165ec <__aeabi_i2d>
  41a0aa:	463a      	mov	r2, r7
  41a0ac:	4643      	mov	r3, r8
  41a0ae:	f7fc fb03 	bl	4166b8 <__aeabi_dmul>
  41a0b2:	2200      	movs	r2, #0
  41a0b4:	4bc1      	ldr	r3, [pc, #772]	; (41a3bc <_dtoa_r+0xd9c>)
  41a0b6:	f7fc f94d 	bl	416354 <__adddf3>
  41a0ba:	4605      	mov	r5, r0
  41a0bc:	f1a1 7650 	sub.w	r6, r1, #54525952	; 0x3400000
  41a0c0:	4641      	mov	r1, r8
  41a0c2:	2200      	movs	r2, #0
  41a0c4:	4bbe      	ldr	r3, [pc, #760]	; (41a3c0 <_dtoa_r+0xda0>)
  41a0c6:	4638      	mov	r0, r7
  41a0c8:	f7fc f942 	bl	416350 <__aeabi_dsub>
  41a0cc:	462a      	mov	r2, r5
  41a0ce:	4633      	mov	r3, r6
  41a0d0:	4682      	mov	sl, r0
  41a0d2:	468b      	mov	fp, r1
  41a0d4:	f7fc fd80 	bl	416bd8 <__aeabi_dcmpgt>
  41a0d8:	4680      	mov	r8, r0
  41a0da:	2800      	cmp	r0, #0
  41a0dc:	f040 8110 	bne.w	41a300 <_dtoa_r+0xce0>
  41a0e0:	462a      	mov	r2, r5
  41a0e2:	f106 4300 	add.w	r3, r6, #2147483648	; 0x80000000
  41a0e6:	4650      	mov	r0, sl
  41a0e8:	4659      	mov	r1, fp
  41a0ea:	f7fc fd57 	bl	416b9c <__aeabi_dcmplt>
  41a0ee:	b118      	cbz	r0, 41a0f8 <_dtoa_r+0xad8>
  41a0f0:	4646      	mov	r6, r8
  41a0f2:	e771      	b.n	419fd8 <_dtoa_r+0x9b8>
  41a0f4:	f8dd 9048 	ldr.w	r9, [sp, #72]	; 0x48
  41a0f8:	e9dd ab10 	ldrd	sl, fp, [sp, #64]	; 0x40
  41a0fc:	f7ff bb8a 	b.w	419814 <_dtoa_r+0x1f4>
  41a100:	9804      	ldr	r0, [sp, #16]
  41a102:	f7ff babb 	b.w	41967c <_dtoa_r+0x5c>
  41a106:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  41a108:	9a0d      	ldr	r2, [sp, #52]	; 0x34
  41a10a:	970c      	str	r7, [sp, #48]	; 0x30
  41a10c:	1afb      	subs	r3, r7, r3
  41a10e:	441a      	add	r2, r3
  41a110:	920d      	str	r2, [sp, #52]	; 0x34
  41a112:	2700      	movs	r7, #0
  41a114:	e469      	b.n	4199ea <_dtoa_r+0x3ca>
  41a116:	e9dd 2310 	ldrd	r2, r3, [sp, #64]	; 0x40
  41a11a:	f04f 0a02 	mov.w	sl, #2
  41a11e:	e9cd 2312 	strd	r2, r3, [sp, #72]	; 0x48
  41a122:	e657      	b.n	419dd4 <_dtoa_r+0x7b4>
  41a124:	2100      	movs	r1, #0
  41a126:	2301      	movs	r3, #1
  41a128:	6461      	str	r1, [r4, #68]	; 0x44
  41a12a:	4620      	mov	r0, r4
  41a12c:	9325      	str	r3, [sp, #148]	; 0x94
  41a12e:	f001 fa13 	bl	41b558 <_Balloc>
  41a132:	9b25      	ldr	r3, [sp, #148]	; 0x94
  41a134:	9004      	str	r0, [sp, #16]
  41a136:	6420      	str	r0, [r4, #64]	; 0x40
  41a138:	930a      	str	r3, [sp, #40]	; 0x28
  41a13a:	930f      	str	r3, [sp, #60]	; 0x3c
  41a13c:	e629      	b.n	419d92 <_dtoa_r+0x772>
  41a13e:	2a00      	cmp	r2, #0
  41a140:	46d0      	mov	r8, sl
  41a142:	f8cd b018 	str.w	fp, [sp, #24]
  41a146:	469a      	mov	sl, r3
  41a148:	dd11      	ble.n	41a16e <_dtoa_r+0xb4e>
  41a14a:	4649      	mov	r1, r9
  41a14c:	2201      	movs	r2, #1
  41a14e:	4620      	mov	r0, r4
  41a150:	f001 fbae 	bl	41b8b0 <__lshift>
  41a154:	4641      	mov	r1, r8
  41a156:	4681      	mov	r9, r0
  41a158:	f001 fbfc 	bl	41b954 <__mcmp>
  41a15c:	2800      	cmp	r0, #0
  41a15e:	f340 8146 	ble.w	41a3ee <_dtoa_r+0xdce>
  41a162:	f1ba 0f39 	cmp.w	sl, #57	; 0x39
  41a166:	f000 8106 	beq.w	41a376 <_dtoa_r+0xd56>
  41a16a:	f105 0a31 	add.w	sl, r5, #49	; 0x31
  41a16e:	46b3      	mov	fp, r6
  41a170:	f887 a000 	strb.w	sl, [r7]
  41a174:	1c7d      	adds	r5, r7, #1
  41a176:	9e06      	ldr	r6, [sp, #24]
  41a178:	e5d2      	b.n	419d20 <_dtoa_r+0x700>
  41a17a:	d104      	bne.n	41a186 <_dtoa_r+0xb66>
  41a17c:	f01a 0f01 	tst.w	sl, #1
  41a180:	d001      	beq.n	41a186 <_dtoa_r+0xb66>
  41a182:	e5bd      	b.n	419d00 <_dtoa_r+0x6e0>
  41a184:	4615      	mov	r5, r2
  41a186:	f815 3c01 	ldrb.w	r3, [r5, #-1]
  41a18a:	2b30      	cmp	r3, #48	; 0x30
  41a18c:	f105 32ff 	add.w	r2, r5, #4294967295
  41a190:	d0f8      	beq.n	41a184 <_dtoa_r+0xb64>
  41a192:	e5c5      	b.n	419d20 <_dtoa_r+0x700>
  41a194:	9904      	ldr	r1, [sp, #16]
  41a196:	2230      	movs	r2, #48	; 0x30
  41a198:	700a      	strb	r2, [r1, #0]
  41a19a:	9a02      	ldr	r2, [sp, #8]
  41a19c:	f815 8c01 	ldrb.w	r8, [r5, #-1]
  41a1a0:	3201      	adds	r2, #1
  41a1a2:	9202      	str	r2, [sp, #8]
  41a1a4:	f7ff bbfc 	b.w	4199a0 <_dtoa_r+0x380>
  41a1a8:	f000 80bb 	beq.w	41a322 <_dtoa_r+0xd02>
  41a1ac:	9b02      	ldr	r3, [sp, #8]
  41a1ae:	425d      	negs	r5, r3
  41a1b0:	4b84      	ldr	r3, [pc, #528]	; (41a3c4 <_dtoa_r+0xda4>)
  41a1b2:	f005 020f 	and.w	r2, r5, #15
  41a1b6:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
  41a1ba:	e9d3 2300 	ldrd	r2, r3, [r3]
  41a1be:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
  41a1c2:	f7fc fa79 	bl	4166b8 <__aeabi_dmul>
  41a1c6:	112d      	asrs	r5, r5, #4
  41a1c8:	4607      	mov	r7, r0
  41a1ca:	4688      	mov	r8, r1
  41a1cc:	f000 812c 	beq.w	41a428 <_dtoa_r+0xe08>
  41a1d0:	4e7d      	ldr	r6, [pc, #500]	; (41a3c8 <_dtoa_r+0xda8>)
  41a1d2:	f04f 0a02 	mov.w	sl, #2
  41a1d6:	07eb      	lsls	r3, r5, #31
  41a1d8:	d509      	bpl.n	41a1ee <_dtoa_r+0xbce>
  41a1da:	4638      	mov	r0, r7
  41a1dc:	4641      	mov	r1, r8
  41a1de:	e9d6 2300 	ldrd	r2, r3, [r6]
  41a1e2:	f7fc fa69 	bl	4166b8 <__aeabi_dmul>
  41a1e6:	f10a 0a01 	add.w	sl, sl, #1
  41a1ea:	4607      	mov	r7, r0
  41a1ec:	4688      	mov	r8, r1
  41a1ee:	106d      	asrs	r5, r5, #1
  41a1f0:	f106 0608 	add.w	r6, r6, #8
  41a1f4:	d1ef      	bne.n	41a1d6 <_dtoa_r+0xbb6>
  41a1f6:	e608      	b.n	419e0a <_dtoa_r+0x7ea>
  41a1f8:	6871      	ldr	r1, [r6, #4]
  41a1fa:	4620      	mov	r0, r4
  41a1fc:	f001 f9ac 	bl	41b558 <_Balloc>
  41a200:	6933      	ldr	r3, [r6, #16]
  41a202:	3302      	adds	r3, #2
  41a204:	009a      	lsls	r2, r3, #2
  41a206:	4605      	mov	r5, r0
  41a208:	f106 010c 	add.w	r1, r6, #12
  41a20c:	300c      	adds	r0, #12
  41a20e:	f7fc fd79 	bl	416d04 <memcpy>
  41a212:	4629      	mov	r1, r5
  41a214:	2201      	movs	r2, #1
  41a216:	4620      	mov	r0, r4
  41a218:	f001 fb4a 	bl	41b8b0 <__lshift>
  41a21c:	9006      	str	r0, [sp, #24]
  41a21e:	e4b5      	b.n	419b8c <_dtoa_r+0x56c>
  41a220:	2b39      	cmp	r3, #57	; 0x39
  41a222:	f8cd b018 	str.w	fp, [sp, #24]
  41a226:	46d0      	mov	r8, sl
  41a228:	f000 80a5 	beq.w	41a376 <_dtoa_r+0xd56>
  41a22c:	f103 0a01 	add.w	sl, r3, #1
  41a230:	46b3      	mov	fp, r6
  41a232:	f887 a000 	strb.w	sl, [r7]
  41a236:	1c7d      	adds	r5, r7, #1
  41a238:	9e06      	ldr	r6, [sp, #24]
  41a23a:	e571      	b.n	419d20 <_dtoa_r+0x700>
  41a23c:	465a      	mov	r2, fp
  41a23e:	46d0      	mov	r8, sl
  41a240:	46b3      	mov	fp, r6
  41a242:	469a      	mov	sl, r3
  41a244:	4616      	mov	r6, r2
  41a246:	e54f      	b.n	419ce8 <_dtoa_r+0x6c8>
  41a248:	9b12      	ldr	r3, [sp, #72]	; 0x48
  41a24a:	495e      	ldr	r1, [pc, #376]	; (41a3c4 <_dtoa_r+0xda4>)
  41a24c:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
  41a250:	462a      	mov	r2, r5
  41a252:	4633      	mov	r3, r6
  41a254:	e951 0102 	ldrd	r0, r1, [r1, #-8]
  41a258:	f7fc fa2e 	bl	4166b8 <__aeabi_dmul>
  41a25c:	e9cd 0116 	strd	r0, r1, [sp, #88]	; 0x58
  41a260:	4638      	mov	r0, r7
  41a262:	4641      	mov	r1, r8
  41a264:	f002 f98c 	bl	41c580 <__aeabi_d2iz>
  41a268:	4605      	mov	r5, r0
  41a26a:	f7fc f9bf 	bl	4165ec <__aeabi_i2d>
  41a26e:	460b      	mov	r3, r1
  41a270:	4602      	mov	r2, r0
  41a272:	4641      	mov	r1, r8
  41a274:	4638      	mov	r0, r7
  41a276:	f7fc f86b 	bl	416350 <__aeabi_dsub>
  41a27a:	9b12      	ldr	r3, [sp, #72]	; 0x48
  41a27c:	460f      	mov	r7, r1
  41a27e:	9904      	ldr	r1, [sp, #16]
  41a280:	3530      	adds	r5, #48	; 0x30
  41a282:	2b01      	cmp	r3, #1
  41a284:	700d      	strb	r5, [r1, #0]
  41a286:	4606      	mov	r6, r0
  41a288:	f101 0501 	add.w	r5, r1, #1
  41a28c:	d026      	beq.n	41a2dc <_dtoa_r+0xcbc>
  41a28e:	9b12      	ldr	r3, [sp, #72]	; 0x48
  41a290:	9a04      	ldr	r2, [sp, #16]
  41a292:	f8df b13c 	ldr.w	fp, [pc, #316]	; 41a3d0 <_dtoa_r+0xdb0>
  41a296:	f8cd 9048 	str.w	r9, [sp, #72]	; 0x48
  41a29a:	4413      	add	r3, r2
  41a29c:	f04f 0a00 	mov.w	sl, #0
  41a2a0:	4699      	mov	r9, r3
  41a2a2:	4652      	mov	r2, sl
  41a2a4:	465b      	mov	r3, fp
  41a2a6:	4630      	mov	r0, r6
  41a2a8:	4639      	mov	r1, r7
  41a2aa:	f7fc fa05 	bl	4166b8 <__aeabi_dmul>
  41a2ae:	460f      	mov	r7, r1
  41a2b0:	4606      	mov	r6, r0
  41a2b2:	f002 f965 	bl	41c580 <__aeabi_d2iz>
  41a2b6:	4680      	mov	r8, r0
  41a2b8:	f7fc f998 	bl	4165ec <__aeabi_i2d>
  41a2bc:	f108 0830 	add.w	r8, r8, #48	; 0x30
  41a2c0:	4602      	mov	r2, r0
  41a2c2:	460b      	mov	r3, r1
  41a2c4:	4630      	mov	r0, r6
  41a2c6:	4639      	mov	r1, r7
  41a2c8:	f7fc f842 	bl	416350 <__aeabi_dsub>
  41a2cc:	f805 8b01 	strb.w	r8, [r5], #1
  41a2d0:	454d      	cmp	r5, r9
  41a2d2:	4606      	mov	r6, r0
  41a2d4:	460f      	mov	r7, r1
  41a2d6:	d1e4      	bne.n	41a2a2 <_dtoa_r+0xc82>
  41a2d8:	f8dd 9048 	ldr.w	r9, [sp, #72]	; 0x48
  41a2dc:	4b3b      	ldr	r3, [pc, #236]	; (41a3cc <_dtoa_r+0xdac>)
  41a2de:	2200      	movs	r2, #0
  41a2e0:	e9dd 0116 	ldrd	r0, r1, [sp, #88]	; 0x58
  41a2e4:	f7fc f836 	bl	416354 <__adddf3>
  41a2e8:	4632      	mov	r2, r6
  41a2ea:	463b      	mov	r3, r7
  41a2ec:	f7fc fc56 	bl	416b9c <__aeabi_dcmplt>
  41a2f0:	2800      	cmp	r0, #0
  41a2f2:	d046      	beq.n	41a382 <_dtoa_r+0xd62>
  41a2f4:	9b15      	ldr	r3, [sp, #84]	; 0x54
  41a2f6:	9302      	str	r3, [sp, #8]
  41a2f8:	f815 8c01 	ldrb.w	r8, [r5, #-1]
  41a2fc:	f7ff bb43 	b.w	419986 <_dtoa_r+0x366>
  41a300:	f04f 0800 	mov.w	r8, #0
  41a304:	4646      	mov	r6, r8
  41a306:	e6a9      	b.n	41a05c <_dtoa_r+0xa3c>
  41a308:	9b08      	ldr	r3, [sp, #32]
  41a30a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  41a30c:	1a9d      	subs	r5, r3, r2
  41a30e:	2300      	movs	r3, #0
  41a310:	f7ff bb71 	b.w	4199f6 <_dtoa_r+0x3d6>
  41a314:	9b18      	ldr	r3, [sp, #96]	; 0x60
  41a316:	9f0c      	ldr	r7, [sp, #48]	; 0x30
  41a318:	9d08      	ldr	r5, [sp, #32]
  41a31a:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
  41a31e:	f7ff bb6a 	b.w	4199f6 <_dtoa_r+0x3d6>
  41a322:	e9dd 7810 	ldrd	r7, r8, [sp, #64]	; 0x40
  41a326:	f04f 0a02 	mov.w	sl, #2
  41a32a:	e56e      	b.n	419e0a <_dtoa_r+0x7ea>
  41a32c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  41a32e:	2b00      	cmp	r3, #0
  41a330:	f43f aeb8 	beq.w	41a0a4 <_dtoa_r+0xa84>
  41a334:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  41a336:	2b00      	cmp	r3, #0
  41a338:	f77f aede 	ble.w	41a0f8 <_dtoa_r+0xad8>
  41a33c:	2200      	movs	r2, #0
  41a33e:	4b24      	ldr	r3, [pc, #144]	; (41a3d0 <_dtoa_r+0xdb0>)
  41a340:	4638      	mov	r0, r7
  41a342:	4641      	mov	r1, r8
  41a344:	f7fc f9b8 	bl	4166b8 <__aeabi_dmul>
  41a348:	4607      	mov	r7, r0
  41a34a:	4688      	mov	r8, r1
  41a34c:	f10a 0001 	add.w	r0, sl, #1
  41a350:	f7fc f94c 	bl	4165ec <__aeabi_i2d>
  41a354:	463a      	mov	r2, r7
  41a356:	4643      	mov	r3, r8
  41a358:	f7fc f9ae 	bl	4166b8 <__aeabi_dmul>
  41a35c:	2200      	movs	r2, #0
  41a35e:	4b17      	ldr	r3, [pc, #92]	; (41a3bc <_dtoa_r+0xd9c>)
  41a360:	f7fb fff8 	bl	416354 <__adddf3>
  41a364:	9a02      	ldr	r2, [sp, #8]
  41a366:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  41a368:	9312      	str	r3, [sp, #72]	; 0x48
  41a36a:	3a01      	subs	r2, #1
  41a36c:	4605      	mov	r5, r0
  41a36e:	f1a1 7650 	sub.w	r6, r1, #54525952	; 0x3400000
  41a372:	9215      	str	r2, [sp, #84]	; 0x54
  41a374:	e56a      	b.n	419e4c <_dtoa_r+0x82c>
  41a376:	2239      	movs	r2, #57	; 0x39
  41a378:	46b3      	mov	fp, r6
  41a37a:	703a      	strb	r2, [r7, #0]
  41a37c:	9e06      	ldr	r6, [sp, #24]
  41a37e:	1c7d      	adds	r5, r7, #1
  41a380:	e4c0      	b.n	419d04 <_dtoa_r+0x6e4>
  41a382:	e9dd 2316 	ldrd	r2, r3, [sp, #88]	; 0x58
  41a386:	2000      	movs	r0, #0
  41a388:	4910      	ldr	r1, [pc, #64]	; (41a3cc <_dtoa_r+0xdac>)
  41a38a:	f7fb ffe1 	bl	416350 <__aeabi_dsub>
  41a38e:	4632      	mov	r2, r6
  41a390:	463b      	mov	r3, r7
  41a392:	f7fc fc21 	bl	416bd8 <__aeabi_dcmpgt>
  41a396:	b908      	cbnz	r0, 41a39c <_dtoa_r+0xd7c>
  41a398:	e6ae      	b.n	41a0f8 <_dtoa_r+0xad8>
  41a39a:	4615      	mov	r5, r2
  41a39c:	f815 3c01 	ldrb.w	r3, [r5, #-1]
  41a3a0:	2b30      	cmp	r3, #48	; 0x30
  41a3a2:	f105 32ff 	add.w	r2, r5, #4294967295
  41a3a6:	d0f8      	beq.n	41a39a <_dtoa_r+0xd7a>
  41a3a8:	e5d7      	b.n	419f5a <_dtoa_r+0x93a>
  41a3aa:	f8dd 9048 	ldr.w	r9, [sp, #72]	; 0x48
  41a3ae:	9b15      	ldr	r3, [sp, #84]	; 0x54
  41a3b0:	9302      	str	r3, [sp, #8]
  41a3b2:	f7ff bae8 	b.w	419986 <_dtoa_r+0x366>
  41a3b6:	970c      	str	r7, [sp, #48]	; 0x30
  41a3b8:	f7ff bba5 	b.w	419b06 <_dtoa_r+0x4e6>
  41a3bc:	401c0000 	.word	0x401c0000
  41a3c0:	40140000 	.word	0x40140000
  41a3c4:	0041eaa0 	.word	0x0041eaa0
  41a3c8:	0041ea78 	.word	0x0041ea78
  41a3cc:	3fe00000 	.word	0x3fe00000
  41a3d0:	40240000 	.word	0x40240000
  41a3d4:	2b39      	cmp	r3, #57	; 0x39
  41a3d6:	f8cd b018 	str.w	fp, [sp, #24]
  41a3da:	46d0      	mov	r8, sl
  41a3dc:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
  41a3e0:	469a      	mov	sl, r3
  41a3e2:	d0c8      	beq.n	41a376 <_dtoa_r+0xd56>
  41a3e4:	f1bb 0f00 	cmp.w	fp, #0
  41a3e8:	f73f aebf 	bgt.w	41a16a <_dtoa_r+0xb4a>
  41a3ec:	e6bf      	b.n	41a16e <_dtoa_r+0xb4e>
  41a3ee:	f47f aebe 	bne.w	41a16e <_dtoa_r+0xb4e>
  41a3f2:	f01a 0f01 	tst.w	sl, #1
  41a3f6:	f43f aeba 	beq.w	41a16e <_dtoa_r+0xb4e>
  41a3fa:	e6b2      	b.n	41a162 <_dtoa_r+0xb42>
  41a3fc:	f04f 0800 	mov.w	r8, #0
  41a400:	4646      	mov	r6, r8
  41a402:	e5e9      	b.n	419fd8 <_dtoa_r+0x9b8>
  41a404:	4631      	mov	r1, r6
  41a406:	2300      	movs	r3, #0
  41a408:	220a      	movs	r2, #10
  41a40a:	4620      	mov	r0, r4
  41a40c:	f001 f8d4 	bl	41b5b8 <__multadd>
  41a410:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  41a412:	2b00      	cmp	r3, #0
  41a414:	4606      	mov	r6, r0
  41a416:	dd0a      	ble.n	41a42e <_dtoa_r+0xe0e>
  41a418:	930a      	str	r3, [sp, #40]	; 0x28
  41a41a:	f7ff bbaa 	b.w	419b72 <_dtoa_r+0x552>
  41a41e:	9b24      	ldr	r3, [sp, #144]	; 0x90
  41a420:	2b02      	cmp	r3, #2
  41a422:	dc23      	bgt.n	41a46c <_dtoa_r+0xe4c>
  41a424:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  41a426:	e43b      	b.n	419ca0 <_dtoa_r+0x680>
  41a428:	f04f 0a02 	mov.w	sl, #2
  41a42c:	e4ed      	b.n	419e0a <_dtoa_r+0x7ea>
  41a42e:	9b24      	ldr	r3, [sp, #144]	; 0x90
  41a430:	2b02      	cmp	r3, #2
  41a432:	dc1b      	bgt.n	41a46c <_dtoa_r+0xe4c>
  41a434:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  41a436:	e7ef      	b.n	41a418 <_dtoa_r+0xdf8>
  41a438:	2500      	movs	r5, #0
  41a43a:	6465      	str	r5, [r4, #68]	; 0x44
  41a43c:	4629      	mov	r1, r5
  41a43e:	4620      	mov	r0, r4
  41a440:	f001 f88a 	bl	41b558 <_Balloc>
  41a444:	f04f 33ff 	mov.w	r3, #4294967295
  41a448:	930a      	str	r3, [sp, #40]	; 0x28
  41a44a:	930f      	str	r3, [sp, #60]	; 0x3c
  41a44c:	2301      	movs	r3, #1
  41a44e:	9004      	str	r0, [sp, #16]
  41a450:	9525      	str	r5, [sp, #148]	; 0x94
  41a452:	6420      	str	r0, [r4, #64]	; 0x40
  41a454:	930b      	str	r3, [sp, #44]	; 0x2c
  41a456:	f7ff b9dd 	b.w	419814 <_dtoa_r+0x1f4>
  41a45a:	2501      	movs	r5, #1
  41a45c:	f7ff b9a5 	b.w	4197aa <_dtoa_r+0x18a>
  41a460:	f43f ab69 	beq.w	419b36 <_dtoa_r+0x516>
  41a464:	f1c0 003c 	rsb	r0, r0, #60	; 0x3c
  41a468:	f7ff bbf9 	b.w	419c5e <_dtoa_r+0x63e>
  41a46c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  41a46e:	930a      	str	r3, [sp, #40]	; 0x28
  41a470:	e5e5      	b.n	41a03e <_dtoa_r+0xa1e>
  41a472:	bf00      	nop

0041a474 <__sflush_r>:
  41a474:	f9b1 300c 	ldrsh.w	r3, [r1, #12]
  41a478:	b29a      	uxth	r2, r3
  41a47a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  41a47e:	460d      	mov	r5, r1
  41a480:	0711      	lsls	r1, r2, #28
  41a482:	4680      	mov	r8, r0
  41a484:	d43a      	bmi.n	41a4fc <__sflush_r+0x88>
  41a486:	686a      	ldr	r2, [r5, #4]
  41a488:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
  41a48c:	2a00      	cmp	r2, #0
  41a48e:	81ab      	strh	r3, [r5, #12]
  41a490:	dd6f      	ble.n	41a572 <__sflush_r+0xfe>
  41a492:	6aac      	ldr	r4, [r5, #40]	; 0x28
  41a494:	2c00      	cmp	r4, #0
  41a496:	d049      	beq.n	41a52c <__sflush_r+0xb8>
  41a498:	2200      	movs	r2, #0
  41a49a:	b29b      	uxth	r3, r3
  41a49c:	f8d8 6000 	ldr.w	r6, [r8]
  41a4a0:	f8c8 2000 	str.w	r2, [r8]
  41a4a4:	f413 5280 	ands.w	r2, r3, #4096	; 0x1000
  41a4a8:	d067      	beq.n	41a57a <__sflush_r+0x106>
  41a4aa:	6d2a      	ldr	r2, [r5, #80]	; 0x50
  41a4ac:	075f      	lsls	r7, r3, #29
  41a4ae:	d505      	bpl.n	41a4bc <__sflush_r+0x48>
  41a4b0:	6869      	ldr	r1, [r5, #4]
  41a4b2:	6b2b      	ldr	r3, [r5, #48]	; 0x30
  41a4b4:	1a52      	subs	r2, r2, r1
  41a4b6:	b10b      	cbz	r3, 41a4bc <__sflush_r+0x48>
  41a4b8:	6beb      	ldr	r3, [r5, #60]	; 0x3c
  41a4ba:	1ad2      	subs	r2, r2, r3
  41a4bc:	2300      	movs	r3, #0
  41a4be:	69e9      	ldr	r1, [r5, #28]
  41a4c0:	4640      	mov	r0, r8
  41a4c2:	47a0      	blx	r4
  41a4c4:	1c44      	adds	r4, r0, #1
  41a4c6:	d03c      	beq.n	41a542 <__sflush_r+0xce>
  41a4c8:	f9b5 300c 	ldrsh.w	r3, [r5, #12]
  41a4cc:	692a      	ldr	r2, [r5, #16]
  41a4ce:	602a      	str	r2, [r5, #0]
  41a4d0:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
  41a4d4:	2200      	movs	r2, #0
  41a4d6:	81ab      	strh	r3, [r5, #12]
  41a4d8:	04db      	lsls	r3, r3, #19
  41a4da:	606a      	str	r2, [r5, #4]
  41a4dc:	d447      	bmi.n	41a56e <__sflush_r+0xfa>
  41a4de:	6b29      	ldr	r1, [r5, #48]	; 0x30
  41a4e0:	f8c8 6000 	str.w	r6, [r8]
  41a4e4:	b311      	cbz	r1, 41a52c <__sflush_r+0xb8>
  41a4e6:	f105 0340 	add.w	r3, r5, #64	; 0x40
  41a4ea:	4299      	cmp	r1, r3
  41a4ec:	d002      	beq.n	41a4f4 <__sflush_r+0x80>
  41a4ee:	4640      	mov	r0, r8
  41a4f0:	f000 f9de 	bl	41a8b0 <_free_r>
  41a4f4:	2000      	movs	r0, #0
  41a4f6:	6328      	str	r0, [r5, #48]	; 0x30
  41a4f8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  41a4fc:	692e      	ldr	r6, [r5, #16]
  41a4fe:	b1ae      	cbz	r6, 41a52c <__sflush_r+0xb8>
  41a500:	682c      	ldr	r4, [r5, #0]
  41a502:	602e      	str	r6, [r5, #0]
  41a504:	0791      	lsls	r1, r2, #30
  41a506:	bf0c      	ite	eq
  41a508:	696b      	ldreq	r3, [r5, #20]
  41a50a:	2300      	movne	r3, #0
  41a50c:	1ba4      	subs	r4, r4, r6
  41a50e:	60ab      	str	r3, [r5, #8]
  41a510:	e00a      	b.n	41a528 <__sflush_r+0xb4>
  41a512:	4623      	mov	r3, r4
  41a514:	4632      	mov	r2, r6
  41a516:	6a6f      	ldr	r7, [r5, #36]	; 0x24
  41a518:	69e9      	ldr	r1, [r5, #28]
  41a51a:	4640      	mov	r0, r8
  41a51c:	47b8      	blx	r7
  41a51e:	2800      	cmp	r0, #0
  41a520:	eba4 0400 	sub.w	r4, r4, r0
  41a524:	4406      	add	r6, r0
  41a526:	dd04      	ble.n	41a532 <__sflush_r+0xbe>
  41a528:	2c00      	cmp	r4, #0
  41a52a:	dcf2      	bgt.n	41a512 <__sflush_r+0x9e>
  41a52c:	2000      	movs	r0, #0
  41a52e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  41a532:	89ab      	ldrh	r3, [r5, #12]
  41a534:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  41a538:	81ab      	strh	r3, [r5, #12]
  41a53a:	f04f 30ff 	mov.w	r0, #4294967295
  41a53e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  41a542:	f8d8 4000 	ldr.w	r4, [r8]
  41a546:	2c1d      	cmp	r4, #29
  41a548:	d8f3      	bhi.n	41a532 <__sflush_r+0xbe>
  41a54a:	4b19      	ldr	r3, [pc, #100]	; (41a5b0 <__sflush_r+0x13c>)
  41a54c:	40e3      	lsrs	r3, r4
  41a54e:	43db      	mvns	r3, r3
  41a550:	f013 0301 	ands.w	r3, r3, #1
  41a554:	d1ed      	bne.n	41a532 <__sflush_r+0xbe>
  41a556:	f9b5 200c 	ldrsh.w	r2, [r5, #12]
  41a55a:	606b      	str	r3, [r5, #4]
  41a55c:	f422 6300 	bic.w	r3, r2, #2048	; 0x800
  41a560:	6929      	ldr	r1, [r5, #16]
  41a562:	81ab      	strh	r3, [r5, #12]
  41a564:	04da      	lsls	r2, r3, #19
  41a566:	6029      	str	r1, [r5, #0]
  41a568:	d5b9      	bpl.n	41a4de <__sflush_r+0x6a>
  41a56a:	2c00      	cmp	r4, #0
  41a56c:	d1b7      	bne.n	41a4de <__sflush_r+0x6a>
  41a56e:	6528      	str	r0, [r5, #80]	; 0x50
  41a570:	e7b5      	b.n	41a4de <__sflush_r+0x6a>
  41a572:	6bea      	ldr	r2, [r5, #60]	; 0x3c
  41a574:	2a00      	cmp	r2, #0
  41a576:	dc8c      	bgt.n	41a492 <__sflush_r+0x1e>
  41a578:	e7d8      	b.n	41a52c <__sflush_r+0xb8>
  41a57a:	2301      	movs	r3, #1
  41a57c:	69e9      	ldr	r1, [r5, #28]
  41a57e:	4640      	mov	r0, r8
  41a580:	47a0      	blx	r4
  41a582:	1c43      	adds	r3, r0, #1
  41a584:	4602      	mov	r2, r0
  41a586:	d002      	beq.n	41a58e <__sflush_r+0x11a>
  41a588:	89ab      	ldrh	r3, [r5, #12]
  41a58a:	6aac      	ldr	r4, [r5, #40]	; 0x28
  41a58c:	e78e      	b.n	41a4ac <__sflush_r+0x38>
  41a58e:	f8d8 3000 	ldr.w	r3, [r8]
  41a592:	2b00      	cmp	r3, #0
  41a594:	d0f8      	beq.n	41a588 <__sflush_r+0x114>
  41a596:	2b1d      	cmp	r3, #29
  41a598:	d001      	beq.n	41a59e <__sflush_r+0x12a>
  41a59a:	2b16      	cmp	r3, #22
  41a59c:	d102      	bne.n	41a5a4 <__sflush_r+0x130>
  41a59e:	f8c8 6000 	str.w	r6, [r8]
  41a5a2:	e7c3      	b.n	41a52c <__sflush_r+0xb8>
  41a5a4:	89ab      	ldrh	r3, [r5, #12]
  41a5a6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  41a5aa:	81ab      	strh	r3, [r5, #12]
  41a5ac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  41a5b0:	20400001 	.word	0x20400001

0041a5b4 <_fflush_r>:
  41a5b4:	b538      	push	{r3, r4, r5, lr}
  41a5b6:	460d      	mov	r5, r1
  41a5b8:	4604      	mov	r4, r0
  41a5ba:	b108      	cbz	r0, 41a5c0 <_fflush_r+0xc>
  41a5bc:	6b83      	ldr	r3, [r0, #56]	; 0x38
  41a5be:	b1bb      	cbz	r3, 41a5f0 <_fflush_r+0x3c>
  41a5c0:	f9b5 000c 	ldrsh.w	r0, [r5, #12]
  41a5c4:	b188      	cbz	r0, 41a5ea <_fflush_r+0x36>
  41a5c6:	6e6b      	ldr	r3, [r5, #100]	; 0x64
  41a5c8:	07db      	lsls	r3, r3, #31
  41a5ca:	d401      	bmi.n	41a5d0 <_fflush_r+0x1c>
  41a5cc:	0581      	lsls	r1, r0, #22
  41a5ce:	d517      	bpl.n	41a600 <_fflush_r+0x4c>
  41a5d0:	4620      	mov	r0, r4
  41a5d2:	4629      	mov	r1, r5
  41a5d4:	f7ff ff4e 	bl	41a474 <__sflush_r>
  41a5d8:	6e6b      	ldr	r3, [r5, #100]	; 0x64
  41a5da:	07da      	lsls	r2, r3, #31
  41a5dc:	4604      	mov	r4, r0
  41a5de:	d402      	bmi.n	41a5e6 <_fflush_r+0x32>
  41a5e0:	89ab      	ldrh	r3, [r5, #12]
  41a5e2:	059b      	lsls	r3, r3, #22
  41a5e4:	d507      	bpl.n	41a5f6 <_fflush_r+0x42>
  41a5e6:	4620      	mov	r0, r4
  41a5e8:	bd38      	pop	{r3, r4, r5, pc}
  41a5ea:	4604      	mov	r4, r0
  41a5ec:	4620      	mov	r0, r4
  41a5ee:	bd38      	pop	{r3, r4, r5, pc}
  41a5f0:	f000 f838 	bl	41a664 <__sinit>
  41a5f4:	e7e4      	b.n	41a5c0 <_fflush_r+0xc>
  41a5f6:	6da8      	ldr	r0, [r5, #88]	; 0x58
  41a5f8:	f000 fc04 	bl	41ae04 <__retarget_lock_release_recursive>
  41a5fc:	4620      	mov	r0, r4
  41a5fe:	bd38      	pop	{r3, r4, r5, pc}
  41a600:	6da8      	ldr	r0, [r5, #88]	; 0x58
  41a602:	f000 fbfd 	bl	41ae00 <__retarget_lock_acquire_recursive>
  41a606:	e7e3      	b.n	41a5d0 <_fflush_r+0x1c>

0041a608 <_cleanup_r>:
  41a608:	4901      	ldr	r1, [pc, #4]	; (41a610 <_cleanup_r+0x8>)
  41a60a:	f000 bbaf 	b.w	41ad6c <_fwalk_reent>
  41a60e:	bf00      	nop
  41a610:	0041c3ed 	.word	0x0041c3ed

0041a614 <std.isra.0>:
  41a614:	b510      	push	{r4, lr}
  41a616:	2300      	movs	r3, #0
  41a618:	4604      	mov	r4, r0
  41a61a:	8181      	strh	r1, [r0, #12]
  41a61c:	81c2      	strh	r2, [r0, #14]
  41a61e:	6003      	str	r3, [r0, #0]
  41a620:	6043      	str	r3, [r0, #4]
  41a622:	6083      	str	r3, [r0, #8]
  41a624:	6643      	str	r3, [r0, #100]	; 0x64
  41a626:	6103      	str	r3, [r0, #16]
  41a628:	6143      	str	r3, [r0, #20]
  41a62a:	6183      	str	r3, [r0, #24]
  41a62c:	4619      	mov	r1, r3
  41a62e:	2208      	movs	r2, #8
  41a630:	305c      	adds	r0, #92	; 0x5c
  41a632:	f7fc fc65 	bl	416f00 <memset>
  41a636:	4807      	ldr	r0, [pc, #28]	; (41a654 <std.isra.0+0x40>)
  41a638:	4907      	ldr	r1, [pc, #28]	; (41a658 <std.isra.0+0x44>)
  41a63a:	4a08      	ldr	r2, [pc, #32]	; (41a65c <std.isra.0+0x48>)
  41a63c:	4b08      	ldr	r3, [pc, #32]	; (41a660 <std.isra.0+0x4c>)
  41a63e:	6220      	str	r0, [r4, #32]
  41a640:	61e4      	str	r4, [r4, #28]
  41a642:	6261      	str	r1, [r4, #36]	; 0x24
  41a644:	62a2      	str	r2, [r4, #40]	; 0x28
  41a646:	62e3      	str	r3, [r4, #44]	; 0x2c
  41a648:	f104 0058 	add.w	r0, r4, #88	; 0x58
  41a64c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  41a650:	f000 bbd2 	b.w	41adf8 <__retarget_lock_init_recursive>
  41a654:	0041bebd 	.word	0x0041bebd
  41a658:	0041bee1 	.word	0x0041bee1
  41a65c:	0041bf1d 	.word	0x0041bf1d
  41a660:	0041bf3d 	.word	0x0041bf3d

0041a664 <__sinit>:
  41a664:	b510      	push	{r4, lr}
  41a666:	4604      	mov	r4, r0
  41a668:	4812      	ldr	r0, [pc, #72]	; (41a6b4 <__sinit+0x50>)
  41a66a:	f000 fbc9 	bl	41ae00 <__retarget_lock_acquire_recursive>
  41a66e:	6ba2      	ldr	r2, [r4, #56]	; 0x38
  41a670:	b9d2      	cbnz	r2, 41a6a8 <__sinit+0x44>
  41a672:	f504 733b 	add.w	r3, r4, #748	; 0x2ec
  41a676:	4810      	ldr	r0, [pc, #64]	; (41a6b8 <__sinit+0x54>)
  41a678:	f8c4 32e8 	str.w	r3, [r4, #744]	; 0x2e8
  41a67c:	2103      	movs	r1, #3
  41a67e:	f8c4 22e0 	str.w	r2, [r4, #736]	; 0x2e0
  41a682:	63e0      	str	r0, [r4, #60]	; 0x3c
  41a684:	f8c4 12e4 	str.w	r1, [r4, #740]	; 0x2e4
  41a688:	6860      	ldr	r0, [r4, #4]
  41a68a:	2104      	movs	r1, #4
  41a68c:	f7ff ffc2 	bl	41a614 <std.isra.0>
  41a690:	2201      	movs	r2, #1
  41a692:	2109      	movs	r1, #9
  41a694:	68a0      	ldr	r0, [r4, #8]
  41a696:	f7ff ffbd 	bl	41a614 <std.isra.0>
  41a69a:	2202      	movs	r2, #2
  41a69c:	2112      	movs	r1, #18
  41a69e:	68e0      	ldr	r0, [r4, #12]
  41a6a0:	f7ff ffb8 	bl	41a614 <std.isra.0>
  41a6a4:	2301      	movs	r3, #1
  41a6a6:	63a3      	str	r3, [r4, #56]	; 0x38
  41a6a8:	4802      	ldr	r0, [pc, #8]	; (41a6b4 <__sinit+0x50>)
  41a6aa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  41a6ae:	f000 bba9 	b.w	41ae04 <__retarget_lock_release_recursive>
  41a6b2:	bf00      	nop
  41a6b4:	2000bd00 	.word	0x2000bd00
  41a6b8:	0041a609 	.word	0x0041a609

0041a6bc <__sfp_lock_acquire>:
  41a6bc:	4801      	ldr	r0, [pc, #4]	; (41a6c4 <__sfp_lock_acquire+0x8>)
  41a6be:	f000 bb9f 	b.w	41ae00 <__retarget_lock_acquire_recursive>
  41a6c2:	bf00      	nop
  41a6c4:	2000bd14 	.word	0x2000bd14

0041a6c8 <__sfp_lock_release>:
  41a6c8:	4801      	ldr	r0, [pc, #4]	; (41a6d0 <__sfp_lock_release+0x8>)
  41a6ca:	f000 bb9b 	b.w	41ae04 <__retarget_lock_release_recursive>
  41a6ce:	bf00      	nop
  41a6d0:	2000bd14 	.word	0x2000bd14

0041a6d4 <__libc_fini_array>:
  41a6d4:	b538      	push	{r3, r4, r5, lr}
  41a6d6:	4c0a      	ldr	r4, [pc, #40]	; (41a700 <__libc_fini_array+0x2c>)
  41a6d8:	4d0a      	ldr	r5, [pc, #40]	; (41a704 <__libc_fini_array+0x30>)
  41a6da:	1b64      	subs	r4, r4, r5
  41a6dc:	10a4      	asrs	r4, r4, #2
  41a6de:	d00a      	beq.n	41a6f6 <__libc_fini_array+0x22>
  41a6e0:	f104 4380 	add.w	r3, r4, #1073741824	; 0x40000000
  41a6e4:	3b01      	subs	r3, #1
  41a6e6:	eb05 0583 	add.w	r5, r5, r3, lsl #2
  41a6ea:	3c01      	subs	r4, #1
  41a6ec:	f855 3904 	ldr.w	r3, [r5], #-4
  41a6f0:	4798      	blx	r3
  41a6f2:	2c00      	cmp	r4, #0
  41a6f4:	d1f9      	bne.n	41a6ea <__libc_fini_array+0x16>
  41a6f6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  41a6fa:	f004 bac7 	b.w	41ec8c <_fini>
  41a6fe:	bf00      	nop
  41a700:	0041ec9c 	.word	0x0041ec9c
  41a704:	0041ec98 	.word	0x0041ec98

0041a708 <__fputwc>:
  41a708:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  41a70c:	b082      	sub	sp, #8
  41a70e:	4680      	mov	r8, r0
  41a710:	4689      	mov	r9, r1
  41a712:	4614      	mov	r4, r2
  41a714:	f000 fb54 	bl	41adc0 <__locale_mb_cur_max>
  41a718:	2801      	cmp	r0, #1
  41a71a:	d036      	beq.n	41a78a <__fputwc+0x82>
  41a71c:	464a      	mov	r2, r9
  41a71e:	f104 035c 	add.w	r3, r4, #92	; 0x5c
  41a722:	a901      	add	r1, sp, #4
  41a724:	4640      	mov	r0, r8
  41a726:	f001 fd6f 	bl	41c208 <_wcrtomb_r>
  41a72a:	1c42      	adds	r2, r0, #1
  41a72c:	4606      	mov	r6, r0
  41a72e:	d025      	beq.n	41a77c <__fputwc+0x74>
  41a730:	b3a8      	cbz	r0, 41a79e <__fputwc+0x96>
  41a732:	f89d e004 	ldrb.w	lr, [sp, #4]
  41a736:	2500      	movs	r5, #0
  41a738:	f10d 0a04 	add.w	sl, sp, #4
  41a73c:	e009      	b.n	41a752 <__fputwc+0x4a>
  41a73e:	6823      	ldr	r3, [r4, #0]
  41a740:	1c5a      	adds	r2, r3, #1
  41a742:	6022      	str	r2, [r4, #0]
  41a744:	f883 e000 	strb.w	lr, [r3]
  41a748:	3501      	adds	r5, #1
  41a74a:	42b5      	cmp	r5, r6
  41a74c:	d227      	bcs.n	41a79e <__fputwc+0x96>
  41a74e:	f815 e00a 	ldrb.w	lr, [r5, sl]
  41a752:	68a3      	ldr	r3, [r4, #8]
  41a754:	3b01      	subs	r3, #1
  41a756:	2b00      	cmp	r3, #0
  41a758:	60a3      	str	r3, [r4, #8]
  41a75a:	daf0      	bge.n	41a73e <__fputwc+0x36>
  41a75c:	69a7      	ldr	r7, [r4, #24]
  41a75e:	42bb      	cmp	r3, r7
  41a760:	4671      	mov	r1, lr
  41a762:	4622      	mov	r2, r4
  41a764:	4640      	mov	r0, r8
  41a766:	db02      	blt.n	41a76e <__fputwc+0x66>
  41a768:	f1be 0f0a 	cmp.w	lr, #10
  41a76c:	d1e7      	bne.n	41a73e <__fputwc+0x36>
  41a76e:	f001 fcf3 	bl	41c158 <__swbuf_r>
  41a772:	1c43      	adds	r3, r0, #1
  41a774:	d1e8      	bne.n	41a748 <__fputwc+0x40>
  41a776:	b002      	add	sp, #8
  41a778:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  41a77c:	89a3      	ldrh	r3, [r4, #12]
  41a77e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  41a782:	81a3      	strh	r3, [r4, #12]
  41a784:	b002      	add	sp, #8
  41a786:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  41a78a:	f109 33ff 	add.w	r3, r9, #4294967295
  41a78e:	2bfe      	cmp	r3, #254	; 0xfe
  41a790:	d8c4      	bhi.n	41a71c <__fputwc+0x14>
  41a792:	fa5f fe89 	uxtb.w	lr, r9
  41a796:	4606      	mov	r6, r0
  41a798:	f88d e004 	strb.w	lr, [sp, #4]
  41a79c:	e7cb      	b.n	41a736 <__fputwc+0x2e>
  41a79e:	4648      	mov	r0, r9
  41a7a0:	b002      	add	sp, #8
  41a7a2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  41a7a6:	bf00      	nop

0041a7a8 <_fputwc_r>:
  41a7a8:	b530      	push	{r4, r5, lr}
  41a7aa:	6e53      	ldr	r3, [r2, #100]	; 0x64
  41a7ac:	f013 0f01 	tst.w	r3, #1
  41a7b0:	f9b2 300c 	ldrsh.w	r3, [r2, #12]
  41a7b4:	4614      	mov	r4, r2
  41a7b6:	b083      	sub	sp, #12
  41a7b8:	4605      	mov	r5, r0
  41a7ba:	b29a      	uxth	r2, r3
  41a7bc:	d101      	bne.n	41a7c2 <_fputwc_r+0x1a>
  41a7be:	0590      	lsls	r0, r2, #22
  41a7c0:	d51c      	bpl.n	41a7fc <_fputwc_r+0x54>
  41a7c2:	0490      	lsls	r0, r2, #18
  41a7c4:	d406      	bmi.n	41a7d4 <_fputwc_r+0x2c>
  41a7c6:	6e62      	ldr	r2, [r4, #100]	; 0x64
  41a7c8:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
  41a7cc:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
  41a7d0:	81a3      	strh	r3, [r4, #12]
  41a7d2:	6662      	str	r2, [r4, #100]	; 0x64
  41a7d4:	4628      	mov	r0, r5
  41a7d6:	4622      	mov	r2, r4
  41a7d8:	f7ff ff96 	bl	41a708 <__fputwc>
  41a7dc:	6e63      	ldr	r3, [r4, #100]	; 0x64
  41a7de:	07da      	lsls	r2, r3, #31
  41a7e0:	4605      	mov	r5, r0
  41a7e2:	d402      	bmi.n	41a7ea <_fputwc_r+0x42>
  41a7e4:	89a3      	ldrh	r3, [r4, #12]
  41a7e6:	059b      	lsls	r3, r3, #22
  41a7e8:	d502      	bpl.n	41a7f0 <_fputwc_r+0x48>
  41a7ea:	4628      	mov	r0, r5
  41a7ec:	b003      	add	sp, #12
  41a7ee:	bd30      	pop	{r4, r5, pc}
  41a7f0:	6da0      	ldr	r0, [r4, #88]	; 0x58
  41a7f2:	f000 fb07 	bl	41ae04 <__retarget_lock_release_recursive>
  41a7f6:	4628      	mov	r0, r5
  41a7f8:	b003      	add	sp, #12
  41a7fa:	bd30      	pop	{r4, r5, pc}
  41a7fc:	6da0      	ldr	r0, [r4, #88]	; 0x58
  41a7fe:	9101      	str	r1, [sp, #4]
  41a800:	f000 fafe 	bl	41ae00 <__retarget_lock_acquire_recursive>
  41a804:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
  41a808:	9901      	ldr	r1, [sp, #4]
  41a80a:	b29a      	uxth	r2, r3
  41a80c:	e7d9      	b.n	41a7c2 <_fputwc_r+0x1a>
  41a80e:	bf00      	nop

0041a810 <_malloc_trim_r>:
  41a810:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  41a812:	4f24      	ldr	r7, [pc, #144]	; (41a8a4 <_malloc_trim_r+0x94>)
  41a814:	460c      	mov	r4, r1
  41a816:	4606      	mov	r6, r0
  41a818:	f000 fe92 	bl	41b540 <__malloc_lock>
  41a81c:	68bb      	ldr	r3, [r7, #8]
  41a81e:	685d      	ldr	r5, [r3, #4]
  41a820:	f5c4 617e 	rsb	r1, r4, #4064	; 0xfe0
  41a824:	310f      	adds	r1, #15
  41a826:	f025 0503 	bic.w	r5, r5, #3
  41a82a:	4429      	add	r1, r5
  41a82c:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
  41a830:	f021 010f 	bic.w	r1, r1, #15
  41a834:	f5a1 5480 	sub.w	r4, r1, #4096	; 0x1000
  41a838:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
  41a83c:	db07      	blt.n	41a84e <_malloc_trim_r+0x3e>
  41a83e:	2100      	movs	r1, #0
  41a840:	4630      	mov	r0, r6
  41a842:	f001 fb29 	bl	41be98 <_sbrk_r>
  41a846:	68bb      	ldr	r3, [r7, #8]
  41a848:	442b      	add	r3, r5
  41a84a:	4298      	cmp	r0, r3
  41a84c:	d004      	beq.n	41a858 <_malloc_trim_r+0x48>
  41a84e:	4630      	mov	r0, r6
  41a850:	f000 fe7c 	bl	41b54c <__malloc_unlock>
  41a854:	2000      	movs	r0, #0
  41a856:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  41a858:	4261      	negs	r1, r4
  41a85a:	4630      	mov	r0, r6
  41a85c:	f001 fb1c 	bl	41be98 <_sbrk_r>
  41a860:	3001      	adds	r0, #1
  41a862:	d00d      	beq.n	41a880 <_malloc_trim_r+0x70>
  41a864:	4b10      	ldr	r3, [pc, #64]	; (41a8a8 <_malloc_trim_r+0x98>)
  41a866:	68ba      	ldr	r2, [r7, #8]
  41a868:	6819      	ldr	r1, [r3, #0]
  41a86a:	1b2d      	subs	r5, r5, r4
  41a86c:	f045 0501 	orr.w	r5, r5, #1
  41a870:	4630      	mov	r0, r6
  41a872:	1b09      	subs	r1, r1, r4
  41a874:	6055      	str	r5, [r2, #4]
  41a876:	6019      	str	r1, [r3, #0]
  41a878:	f000 fe68 	bl	41b54c <__malloc_unlock>
  41a87c:	2001      	movs	r0, #1
  41a87e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  41a880:	2100      	movs	r1, #0
  41a882:	4630      	mov	r0, r6
  41a884:	f001 fb08 	bl	41be98 <_sbrk_r>
  41a888:	68ba      	ldr	r2, [r7, #8]
  41a88a:	1a83      	subs	r3, r0, r2
  41a88c:	2b0f      	cmp	r3, #15
  41a88e:	ddde      	ble.n	41a84e <_malloc_trim_r+0x3e>
  41a890:	4c06      	ldr	r4, [pc, #24]	; (41a8ac <_malloc_trim_r+0x9c>)
  41a892:	4905      	ldr	r1, [pc, #20]	; (41a8a8 <_malloc_trim_r+0x98>)
  41a894:	6824      	ldr	r4, [r4, #0]
  41a896:	f043 0301 	orr.w	r3, r3, #1
  41a89a:	1b00      	subs	r0, r0, r4
  41a89c:	6053      	str	r3, [r2, #4]
  41a89e:	6008      	str	r0, [r1, #0]
  41a8a0:	e7d5      	b.n	41a84e <_malloc_trim_r+0x3e>
  41a8a2:	bf00      	nop
  41a8a4:	20000718 	.word	0x20000718
  41a8a8:	2000b54c 	.word	0x2000b54c
  41a8ac:	20000b20 	.word	0x20000b20

0041a8b0 <_free_r>:
  41a8b0:	2900      	cmp	r1, #0
  41a8b2:	d044      	beq.n	41a93e <_free_r+0x8e>
  41a8b4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  41a8b8:	460d      	mov	r5, r1
  41a8ba:	4680      	mov	r8, r0
  41a8bc:	f000 fe40 	bl	41b540 <__malloc_lock>
  41a8c0:	f855 7c04 	ldr.w	r7, [r5, #-4]
  41a8c4:	4969      	ldr	r1, [pc, #420]	; (41aa6c <_free_r+0x1bc>)
  41a8c6:	f027 0301 	bic.w	r3, r7, #1
  41a8ca:	f1a5 0408 	sub.w	r4, r5, #8
  41a8ce:	18e2      	adds	r2, r4, r3
  41a8d0:	688e      	ldr	r6, [r1, #8]
  41a8d2:	6850      	ldr	r0, [r2, #4]
  41a8d4:	42b2      	cmp	r2, r6
  41a8d6:	f020 0003 	bic.w	r0, r0, #3
  41a8da:	d05e      	beq.n	41a99a <_free_r+0xea>
  41a8dc:	07fe      	lsls	r6, r7, #31
  41a8de:	6050      	str	r0, [r2, #4]
  41a8e0:	d40b      	bmi.n	41a8fa <_free_r+0x4a>
  41a8e2:	f855 7c08 	ldr.w	r7, [r5, #-8]
  41a8e6:	1be4      	subs	r4, r4, r7
  41a8e8:	f101 0e08 	add.w	lr, r1, #8
  41a8ec:	68a5      	ldr	r5, [r4, #8]
  41a8ee:	4575      	cmp	r5, lr
  41a8f0:	443b      	add	r3, r7
  41a8f2:	d06d      	beq.n	41a9d0 <_free_r+0x120>
  41a8f4:	68e7      	ldr	r7, [r4, #12]
  41a8f6:	60ef      	str	r7, [r5, #12]
  41a8f8:	60bd      	str	r5, [r7, #8]
  41a8fa:	1815      	adds	r5, r2, r0
  41a8fc:	686d      	ldr	r5, [r5, #4]
  41a8fe:	07ed      	lsls	r5, r5, #31
  41a900:	d53e      	bpl.n	41a980 <_free_r+0xd0>
  41a902:	f043 0201 	orr.w	r2, r3, #1
  41a906:	6062      	str	r2, [r4, #4]
  41a908:	50e3      	str	r3, [r4, r3]
  41a90a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
  41a90e:	d217      	bcs.n	41a940 <_free_r+0x90>
  41a910:	08db      	lsrs	r3, r3, #3
  41a912:	1c58      	adds	r0, r3, #1
  41a914:	109a      	asrs	r2, r3, #2
  41a916:	684d      	ldr	r5, [r1, #4]
  41a918:	f851 7030 	ldr.w	r7, [r1, r0, lsl #3]
  41a91c:	60a7      	str	r7, [r4, #8]
  41a91e:	2301      	movs	r3, #1
  41a920:	4093      	lsls	r3, r2
  41a922:	eb01 02c0 	add.w	r2, r1, r0, lsl #3
  41a926:	432b      	orrs	r3, r5
  41a928:	3a08      	subs	r2, #8
  41a92a:	60e2      	str	r2, [r4, #12]
  41a92c:	604b      	str	r3, [r1, #4]
  41a92e:	f841 4030 	str.w	r4, [r1, r0, lsl #3]
  41a932:	60fc      	str	r4, [r7, #12]
  41a934:	4640      	mov	r0, r8
  41a936:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  41a93a:	f000 be07 	b.w	41b54c <__malloc_unlock>
  41a93e:	4770      	bx	lr
  41a940:	0a5a      	lsrs	r2, r3, #9
  41a942:	2a04      	cmp	r2, #4
  41a944:	d852      	bhi.n	41a9ec <_free_r+0x13c>
  41a946:	099a      	lsrs	r2, r3, #6
  41a948:	f102 0739 	add.w	r7, r2, #57	; 0x39
  41a94c:	00ff      	lsls	r7, r7, #3
  41a94e:	f102 0538 	add.w	r5, r2, #56	; 0x38
  41a952:	19c8      	adds	r0, r1, r7
  41a954:	59ca      	ldr	r2, [r1, r7]
  41a956:	3808      	subs	r0, #8
  41a958:	4290      	cmp	r0, r2
  41a95a:	d04f      	beq.n	41a9fc <_free_r+0x14c>
  41a95c:	6851      	ldr	r1, [r2, #4]
  41a95e:	f021 0103 	bic.w	r1, r1, #3
  41a962:	428b      	cmp	r3, r1
  41a964:	d232      	bcs.n	41a9cc <_free_r+0x11c>
  41a966:	6892      	ldr	r2, [r2, #8]
  41a968:	4290      	cmp	r0, r2
  41a96a:	d1f7      	bne.n	41a95c <_free_r+0xac>
  41a96c:	68c3      	ldr	r3, [r0, #12]
  41a96e:	60a0      	str	r0, [r4, #8]
  41a970:	60e3      	str	r3, [r4, #12]
  41a972:	609c      	str	r4, [r3, #8]
  41a974:	60c4      	str	r4, [r0, #12]
  41a976:	4640      	mov	r0, r8
  41a978:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  41a97c:	f000 bde6 	b.w	41b54c <__malloc_unlock>
  41a980:	6895      	ldr	r5, [r2, #8]
  41a982:	4f3b      	ldr	r7, [pc, #236]	; (41aa70 <_free_r+0x1c0>)
  41a984:	42bd      	cmp	r5, r7
  41a986:	4403      	add	r3, r0
  41a988:	d040      	beq.n	41aa0c <_free_r+0x15c>
  41a98a:	68d0      	ldr	r0, [r2, #12]
  41a98c:	60e8      	str	r0, [r5, #12]
  41a98e:	f043 0201 	orr.w	r2, r3, #1
  41a992:	6085      	str	r5, [r0, #8]
  41a994:	6062      	str	r2, [r4, #4]
  41a996:	50e3      	str	r3, [r4, r3]
  41a998:	e7b7      	b.n	41a90a <_free_r+0x5a>
  41a99a:	07ff      	lsls	r7, r7, #31
  41a99c:	4403      	add	r3, r0
  41a99e:	d407      	bmi.n	41a9b0 <_free_r+0x100>
  41a9a0:	f855 2c08 	ldr.w	r2, [r5, #-8]
  41a9a4:	1aa4      	subs	r4, r4, r2
  41a9a6:	4413      	add	r3, r2
  41a9a8:	68a0      	ldr	r0, [r4, #8]
  41a9aa:	68e2      	ldr	r2, [r4, #12]
  41a9ac:	60c2      	str	r2, [r0, #12]
  41a9ae:	6090      	str	r0, [r2, #8]
  41a9b0:	4a30      	ldr	r2, [pc, #192]	; (41aa74 <_free_r+0x1c4>)
  41a9b2:	6812      	ldr	r2, [r2, #0]
  41a9b4:	f043 0001 	orr.w	r0, r3, #1
  41a9b8:	4293      	cmp	r3, r2
  41a9ba:	6060      	str	r0, [r4, #4]
  41a9bc:	608c      	str	r4, [r1, #8]
  41a9be:	d3b9      	bcc.n	41a934 <_free_r+0x84>
  41a9c0:	4b2d      	ldr	r3, [pc, #180]	; (41aa78 <_free_r+0x1c8>)
  41a9c2:	4640      	mov	r0, r8
  41a9c4:	6819      	ldr	r1, [r3, #0]
  41a9c6:	f7ff ff23 	bl	41a810 <_malloc_trim_r>
  41a9ca:	e7b3      	b.n	41a934 <_free_r+0x84>
  41a9cc:	4610      	mov	r0, r2
  41a9ce:	e7cd      	b.n	41a96c <_free_r+0xbc>
  41a9d0:	1811      	adds	r1, r2, r0
  41a9d2:	6849      	ldr	r1, [r1, #4]
  41a9d4:	07c9      	lsls	r1, r1, #31
  41a9d6:	d444      	bmi.n	41aa62 <_free_r+0x1b2>
  41a9d8:	6891      	ldr	r1, [r2, #8]
  41a9da:	68d2      	ldr	r2, [r2, #12]
  41a9dc:	60ca      	str	r2, [r1, #12]
  41a9de:	4403      	add	r3, r0
  41a9e0:	f043 0001 	orr.w	r0, r3, #1
  41a9e4:	6091      	str	r1, [r2, #8]
  41a9e6:	6060      	str	r0, [r4, #4]
  41a9e8:	50e3      	str	r3, [r4, r3]
  41a9ea:	e7a3      	b.n	41a934 <_free_r+0x84>
  41a9ec:	2a14      	cmp	r2, #20
  41a9ee:	d816      	bhi.n	41aa1e <_free_r+0x16e>
  41a9f0:	f102 075c 	add.w	r7, r2, #92	; 0x5c
  41a9f4:	00ff      	lsls	r7, r7, #3
  41a9f6:	f102 055b 	add.w	r5, r2, #91	; 0x5b
  41a9fa:	e7aa      	b.n	41a952 <_free_r+0xa2>
  41a9fc:	10aa      	asrs	r2, r5, #2
  41a9fe:	2301      	movs	r3, #1
  41aa00:	684d      	ldr	r5, [r1, #4]
  41aa02:	4093      	lsls	r3, r2
  41aa04:	432b      	orrs	r3, r5
  41aa06:	604b      	str	r3, [r1, #4]
  41aa08:	4603      	mov	r3, r0
  41aa0a:	e7b0      	b.n	41a96e <_free_r+0xbe>
  41aa0c:	f043 0201 	orr.w	r2, r3, #1
  41aa10:	614c      	str	r4, [r1, #20]
  41aa12:	610c      	str	r4, [r1, #16]
  41aa14:	60e5      	str	r5, [r4, #12]
  41aa16:	60a5      	str	r5, [r4, #8]
  41aa18:	6062      	str	r2, [r4, #4]
  41aa1a:	50e3      	str	r3, [r4, r3]
  41aa1c:	e78a      	b.n	41a934 <_free_r+0x84>
  41aa1e:	2a54      	cmp	r2, #84	; 0x54
  41aa20:	d806      	bhi.n	41aa30 <_free_r+0x180>
  41aa22:	0b1a      	lsrs	r2, r3, #12
  41aa24:	f102 076f 	add.w	r7, r2, #111	; 0x6f
  41aa28:	00ff      	lsls	r7, r7, #3
  41aa2a:	f102 056e 	add.w	r5, r2, #110	; 0x6e
  41aa2e:	e790      	b.n	41a952 <_free_r+0xa2>
  41aa30:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
  41aa34:	d806      	bhi.n	41aa44 <_free_r+0x194>
  41aa36:	0bda      	lsrs	r2, r3, #15
  41aa38:	f102 0778 	add.w	r7, r2, #120	; 0x78
  41aa3c:	00ff      	lsls	r7, r7, #3
  41aa3e:	f102 0577 	add.w	r5, r2, #119	; 0x77
  41aa42:	e786      	b.n	41a952 <_free_r+0xa2>
  41aa44:	f240 5054 	movw	r0, #1364	; 0x554
  41aa48:	4282      	cmp	r2, r0
  41aa4a:	d806      	bhi.n	41aa5a <_free_r+0x1aa>
  41aa4c:	0c9a      	lsrs	r2, r3, #18
  41aa4e:	f102 077d 	add.w	r7, r2, #125	; 0x7d
  41aa52:	00ff      	lsls	r7, r7, #3
  41aa54:	f102 057c 	add.w	r5, r2, #124	; 0x7c
  41aa58:	e77b      	b.n	41a952 <_free_r+0xa2>
  41aa5a:	f44f 777e 	mov.w	r7, #1016	; 0x3f8
  41aa5e:	257e      	movs	r5, #126	; 0x7e
  41aa60:	e777      	b.n	41a952 <_free_r+0xa2>
  41aa62:	f043 0101 	orr.w	r1, r3, #1
  41aa66:	6061      	str	r1, [r4, #4]
  41aa68:	6013      	str	r3, [r2, #0]
  41aa6a:	e763      	b.n	41a934 <_free_r+0x84>
  41aa6c:	20000718 	.word	0x20000718
  41aa70:	20000720 	.word	0x20000720
  41aa74:	20000b24 	.word	0x20000b24
  41aa78:	2000b57c 	.word	0x2000b57c

0041aa7c <__sfvwrite_r>:
  41aa7c:	6893      	ldr	r3, [r2, #8]
  41aa7e:	2b00      	cmp	r3, #0
  41aa80:	d073      	beq.n	41ab6a <__sfvwrite_r+0xee>
  41aa82:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  41aa86:	898b      	ldrh	r3, [r1, #12]
  41aa88:	b083      	sub	sp, #12
  41aa8a:	460c      	mov	r4, r1
  41aa8c:	0719      	lsls	r1, r3, #28
  41aa8e:	9000      	str	r0, [sp, #0]
  41aa90:	4616      	mov	r6, r2
  41aa92:	d526      	bpl.n	41aae2 <__sfvwrite_r+0x66>
  41aa94:	6922      	ldr	r2, [r4, #16]
  41aa96:	b322      	cbz	r2, 41aae2 <__sfvwrite_r+0x66>
  41aa98:	f013 0002 	ands.w	r0, r3, #2
  41aa9c:	6835      	ldr	r5, [r6, #0]
  41aa9e:	d02c      	beq.n	41aafa <__sfvwrite_r+0x7e>
  41aaa0:	f04f 0900 	mov.w	r9, #0
  41aaa4:	4fb0      	ldr	r7, [pc, #704]	; (41ad68 <__sfvwrite_r+0x2ec>)
  41aaa6:	46c8      	mov	r8, r9
  41aaa8:	46b2      	mov	sl, r6
  41aaaa:	45b8      	cmp	r8, r7
  41aaac:	4643      	mov	r3, r8
  41aaae:	464a      	mov	r2, r9
  41aab0:	bf28      	it	cs
  41aab2:	463b      	movcs	r3, r7
  41aab4:	9800      	ldr	r0, [sp, #0]
  41aab6:	f1b8 0f00 	cmp.w	r8, #0
  41aaba:	d050      	beq.n	41ab5e <__sfvwrite_r+0xe2>
  41aabc:	69e1      	ldr	r1, [r4, #28]
  41aabe:	6a66      	ldr	r6, [r4, #36]	; 0x24
  41aac0:	47b0      	blx	r6
  41aac2:	2800      	cmp	r0, #0
  41aac4:	dd58      	ble.n	41ab78 <__sfvwrite_r+0xfc>
  41aac6:	f8da 3008 	ldr.w	r3, [sl, #8]
  41aaca:	1a1b      	subs	r3, r3, r0
  41aacc:	4481      	add	r9, r0
  41aace:	eba8 0800 	sub.w	r8, r8, r0
  41aad2:	f8ca 3008 	str.w	r3, [sl, #8]
  41aad6:	2b00      	cmp	r3, #0
  41aad8:	d1e7      	bne.n	41aaaa <__sfvwrite_r+0x2e>
  41aada:	2000      	movs	r0, #0
  41aadc:	b003      	add	sp, #12
  41aade:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  41aae2:	4621      	mov	r1, r4
  41aae4:	9800      	ldr	r0, [sp, #0]
  41aae6:	f7fe fc93 	bl	419410 <__swsetup_r>
  41aaea:	2800      	cmp	r0, #0
  41aaec:	f040 8133 	bne.w	41ad56 <__sfvwrite_r+0x2da>
  41aaf0:	89a3      	ldrh	r3, [r4, #12]
  41aaf2:	6835      	ldr	r5, [r6, #0]
  41aaf4:	f013 0002 	ands.w	r0, r3, #2
  41aaf8:	d1d2      	bne.n	41aaa0 <__sfvwrite_r+0x24>
  41aafa:	f013 0901 	ands.w	r9, r3, #1
  41aafe:	d145      	bne.n	41ab8c <__sfvwrite_r+0x110>
  41ab00:	464f      	mov	r7, r9
  41ab02:	9601      	str	r6, [sp, #4]
  41ab04:	b337      	cbz	r7, 41ab54 <__sfvwrite_r+0xd8>
  41ab06:	059a      	lsls	r2, r3, #22
  41ab08:	f8d4 8008 	ldr.w	r8, [r4, #8]
  41ab0c:	f140 8083 	bpl.w	41ac16 <__sfvwrite_r+0x19a>
  41ab10:	4547      	cmp	r7, r8
  41ab12:	46c3      	mov	fp, r8
  41ab14:	f0c0 80ab 	bcc.w	41ac6e <__sfvwrite_r+0x1f2>
  41ab18:	f413 6f90 	tst.w	r3, #1152	; 0x480
  41ab1c:	f040 80ac 	bne.w	41ac78 <__sfvwrite_r+0x1fc>
  41ab20:	6820      	ldr	r0, [r4, #0]
  41ab22:	46ba      	mov	sl, r7
  41ab24:	465a      	mov	r2, fp
  41ab26:	4649      	mov	r1, r9
  41ab28:	f7fc f986 	bl	416e38 <memmove>
  41ab2c:	68a2      	ldr	r2, [r4, #8]
  41ab2e:	6823      	ldr	r3, [r4, #0]
  41ab30:	eba2 0208 	sub.w	r2, r2, r8
  41ab34:	445b      	add	r3, fp
  41ab36:	60a2      	str	r2, [r4, #8]
  41ab38:	6023      	str	r3, [r4, #0]
  41ab3a:	9a01      	ldr	r2, [sp, #4]
  41ab3c:	6893      	ldr	r3, [r2, #8]
  41ab3e:	eba3 030a 	sub.w	r3, r3, sl
  41ab42:	44d1      	add	r9, sl
  41ab44:	eba7 070a 	sub.w	r7, r7, sl
  41ab48:	6093      	str	r3, [r2, #8]
  41ab4a:	2b00      	cmp	r3, #0
  41ab4c:	d0c5      	beq.n	41aada <__sfvwrite_r+0x5e>
  41ab4e:	89a3      	ldrh	r3, [r4, #12]
  41ab50:	2f00      	cmp	r7, #0
  41ab52:	d1d8      	bne.n	41ab06 <__sfvwrite_r+0x8a>
  41ab54:	f8d5 9000 	ldr.w	r9, [r5]
  41ab58:	686f      	ldr	r7, [r5, #4]
  41ab5a:	3508      	adds	r5, #8
  41ab5c:	e7d2      	b.n	41ab04 <__sfvwrite_r+0x88>
  41ab5e:	f8d5 9000 	ldr.w	r9, [r5]
  41ab62:	f8d5 8004 	ldr.w	r8, [r5, #4]
  41ab66:	3508      	adds	r5, #8
  41ab68:	e79f      	b.n	41aaaa <__sfvwrite_r+0x2e>
  41ab6a:	2000      	movs	r0, #0
  41ab6c:	4770      	bx	lr
  41ab6e:	4621      	mov	r1, r4
  41ab70:	9800      	ldr	r0, [sp, #0]
  41ab72:	f7ff fd1f 	bl	41a5b4 <_fflush_r>
  41ab76:	b370      	cbz	r0, 41abd6 <__sfvwrite_r+0x15a>
  41ab78:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
  41ab7c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  41ab80:	f04f 30ff 	mov.w	r0, #4294967295
  41ab84:	81a3      	strh	r3, [r4, #12]
  41ab86:	b003      	add	sp, #12
  41ab88:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  41ab8c:	4681      	mov	r9, r0
  41ab8e:	4633      	mov	r3, r6
  41ab90:	464e      	mov	r6, r9
  41ab92:	46a8      	mov	r8, r5
  41ab94:	469a      	mov	sl, r3
  41ab96:	464d      	mov	r5, r9
  41ab98:	b34e      	cbz	r6, 41abee <__sfvwrite_r+0x172>
  41ab9a:	b380      	cbz	r0, 41abfe <__sfvwrite_r+0x182>
  41ab9c:	6820      	ldr	r0, [r4, #0]
  41ab9e:	6923      	ldr	r3, [r4, #16]
  41aba0:	6962      	ldr	r2, [r4, #20]
  41aba2:	45b1      	cmp	r9, r6
  41aba4:	46cb      	mov	fp, r9
  41aba6:	bf28      	it	cs
  41aba8:	46b3      	movcs	fp, r6
  41abaa:	4298      	cmp	r0, r3
  41abac:	465f      	mov	r7, fp
  41abae:	d904      	bls.n	41abba <__sfvwrite_r+0x13e>
  41abb0:	68a3      	ldr	r3, [r4, #8]
  41abb2:	4413      	add	r3, r2
  41abb4:	459b      	cmp	fp, r3
  41abb6:	f300 80a6 	bgt.w	41ad06 <__sfvwrite_r+0x28a>
  41abba:	4593      	cmp	fp, r2
  41abbc:	db4b      	blt.n	41ac56 <__sfvwrite_r+0x1da>
  41abbe:	4613      	mov	r3, r2
  41abc0:	6a67      	ldr	r7, [r4, #36]	; 0x24
  41abc2:	69e1      	ldr	r1, [r4, #28]
  41abc4:	9800      	ldr	r0, [sp, #0]
  41abc6:	462a      	mov	r2, r5
  41abc8:	47b8      	blx	r7
  41abca:	1e07      	subs	r7, r0, #0
  41abcc:	ddd4      	ble.n	41ab78 <__sfvwrite_r+0xfc>
  41abce:	ebb9 0907 	subs.w	r9, r9, r7
  41abd2:	d0cc      	beq.n	41ab6e <__sfvwrite_r+0xf2>
  41abd4:	2001      	movs	r0, #1
  41abd6:	f8da 3008 	ldr.w	r3, [sl, #8]
  41abda:	1bdb      	subs	r3, r3, r7
  41abdc:	443d      	add	r5, r7
  41abde:	1bf6      	subs	r6, r6, r7
  41abe0:	f8ca 3008 	str.w	r3, [sl, #8]
  41abe4:	2b00      	cmp	r3, #0
  41abe6:	f43f af78 	beq.w	41aada <__sfvwrite_r+0x5e>
  41abea:	2e00      	cmp	r6, #0
  41abec:	d1d5      	bne.n	41ab9a <__sfvwrite_r+0x11e>
  41abee:	f108 0308 	add.w	r3, r8, #8
  41abf2:	e913 0060 	ldmdb	r3, {r5, r6}
  41abf6:	4698      	mov	r8, r3
  41abf8:	3308      	adds	r3, #8
  41abfa:	2e00      	cmp	r6, #0
  41abfc:	d0f9      	beq.n	41abf2 <__sfvwrite_r+0x176>
  41abfe:	4632      	mov	r2, r6
  41ac00:	210a      	movs	r1, #10
  41ac02:	4628      	mov	r0, r5
  41ac04:	f000 fc4c 	bl	41b4a0 <memchr>
  41ac08:	2800      	cmp	r0, #0
  41ac0a:	f000 80a1 	beq.w	41ad50 <__sfvwrite_r+0x2d4>
  41ac0e:	3001      	adds	r0, #1
  41ac10:	eba0 0905 	sub.w	r9, r0, r5
  41ac14:	e7c2      	b.n	41ab9c <__sfvwrite_r+0x120>
  41ac16:	6820      	ldr	r0, [r4, #0]
  41ac18:	6923      	ldr	r3, [r4, #16]
  41ac1a:	4298      	cmp	r0, r3
  41ac1c:	d802      	bhi.n	41ac24 <__sfvwrite_r+0x1a8>
  41ac1e:	6963      	ldr	r3, [r4, #20]
  41ac20:	429f      	cmp	r7, r3
  41ac22:	d25d      	bcs.n	41ace0 <__sfvwrite_r+0x264>
  41ac24:	45b8      	cmp	r8, r7
  41ac26:	bf28      	it	cs
  41ac28:	46b8      	movcs	r8, r7
  41ac2a:	4642      	mov	r2, r8
  41ac2c:	4649      	mov	r1, r9
  41ac2e:	f7fc f903 	bl	416e38 <memmove>
  41ac32:	68a3      	ldr	r3, [r4, #8]
  41ac34:	6822      	ldr	r2, [r4, #0]
  41ac36:	eba3 0308 	sub.w	r3, r3, r8
  41ac3a:	4442      	add	r2, r8
  41ac3c:	60a3      	str	r3, [r4, #8]
  41ac3e:	6022      	str	r2, [r4, #0]
  41ac40:	b10b      	cbz	r3, 41ac46 <__sfvwrite_r+0x1ca>
  41ac42:	46c2      	mov	sl, r8
  41ac44:	e779      	b.n	41ab3a <__sfvwrite_r+0xbe>
  41ac46:	4621      	mov	r1, r4
  41ac48:	9800      	ldr	r0, [sp, #0]
  41ac4a:	f7ff fcb3 	bl	41a5b4 <_fflush_r>
  41ac4e:	2800      	cmp	r0, #0
  41ac50:	d192      	bne.n	41ab78 <__sfvwrite_r+0xfc>
  41ac52:	46c2      	mov	sl, r8
  41ac54:	e771      	b.n	41ab3a <__sfvwrite_r+0xbe>
  41ac56:	465a      	mov	r2, fp
  41ac58:	4629      	mov	r1, r5
  41ac5a:	f7fc f8ed 	bl	416e38 <memmove>
  41ac5e:	68a2      	ldr	r2, [r4, #8]
  41ac60:	6823      	ldr	r3, [r4, #0]
  41ac62:	eba2 020b 	sub.w	r2, r2, fp
  41ac66:	445b      	add	r3, fp
  41ac68:	60a2      	str	r2, [r4, #8]
  41ac6a:	6023      	str	r3, [r4, #0]
  41ac6c:	e7af      	b.n	41abce <__sfvwrite_r+0x152>
  41ac6e:	6820      	ldr	r0, [r4, #0]
  41ac70:	46b8      	mov	r8, r7
  41ac72:	46ba      	mov	sl, r7
  41ac74:	46bb      	mov	fp, r7
  41ac76:	e755      	b.n	41ab24 <__sfvwrite_r+0xa8>
  41ac78:	6962      	ldr	r2, [r4, #20]
  41ac7a:	6820      	ldr	r0, [r4, #0]
  41ac7c:	6921      	ldr	r1, [r4, #16]
  41ac7e:	eb02 0842 	add.w	r8, r2, r2, lsl #1
  41ac82:	eba0 0a01 	sub.w	sl, r0, r1
  41ac86:	eb08 78d8 	add.w	r8, r8, r8, lsr #31
  41ac8a:	f10a 0001 	add.w	r0, sl, #1
  41ac8e:	ea4f 0868 	mov.w	r8, r8, asr #1
  41ac92:	4438      	add	r0, r7
  41ac94:	4540      	cmp	r0, r8
  41ac96:	4642      	mov	r2, r8
  41ac98:	bf84      	itt	hi
  41ac9a:	4680      	movhi	r8, r0
  41ac9c:	4642      	movhi	r2, r8
  41ac9e:	055b      	lsls	r3, r3, #21
  41aca0:	d544      	bpl.n	41ad2c <__sfvwrite_r+0x2b0>
  41aca2:	4611      	mov	r1, r2
  41aca4:	9800      	ldr	r0, [sp, #0]
  41aca6:	f000 f92f 	bl	41af08 <_malloc_r>
  41acaa:	4683      	mov	fp, r0
  41acac:	2800      	cmp	r0, #0
  41acae:	d055      	beq.n	41ad5c <__sfvwrite_r+0x2e0>
  41acb0:	4652      	mov	r2, sl
  41acb2:	6921      	ldr	r1, [r4, #16]
  41acb4:	f7fc f826 	bl	416d04 <memcpy>
  41acb8:	89a3      	ldrh	r3, [r4, #12]
  41acba:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
  41acbe:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  41acc2:	81a3      	strh	r3, [r4, #12]
  41acc4:	eb0b 000a 	add.w	r0, fp, sl
  41acc8:	eba8 030a 	sub.w	r3, r8, sl
  41accc:	f8c4 b010 	str.w	fp, [r4, #16]
  41acd0:	f8c4 8014 	str.w	r8, [r4, #20]
  41acd4:	6020      	str	r0, [r4, #0]
  41acd6:	60a3      	str	r3, [r4, #8]
  41acd8:	46b8      	mov	r8, r7
  41acda:	46ba      	mov	sl, r7
  41acdc:	46bb      	mov	fp, r7
  41acde:	e721      	b.n	41ab24 <__sfvwrite_r+0xa8>
  41ace0:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
  41ace4:	42b9      	cmp	r1, r7
  41ace6:	bf28      	it	cs
  41ace8:	4639      	movcs	r1, r7
  41acea:	464a      	mov	r2, r9
  41acec:	fb91 f1f3 	sdiv	r1, r1, r3
  41acf0:	9800      	ldr	r0, [sp, #0]
  41acf2:	6a66      	ldr	r6, [r4, #36]	; 0x24
  41acf4:	fb03 f301 	mul.w	r3, r3, r1
  41acf8:	69e1      	ldr	r1, [r4, #28]
  41acfa:	47b0      	blx	r6
  41acfc:	f1b0 0a00 	subs.w	sl, r0, #0
  41ad00:	f73f af1b 	bgt.w	41ab3a <__sfvwrite_r+0xbe>
  41ad04:	e738      	b.n	41ab78 <__sfvwrite_r+0xfc>
  41ad06:	461a      	mov	r2, r3
  41ad08:	4629      	mov	r1, r5
  41ad0a:	9301      	str	r3, [sp, #4]
  41ad0c:	f7fc f894 	bl	416e38 <memmove>
  41ad10:	6822      	ldr	r2, [r4, #0]
  41ad12:	9b01      	ldr	r3, [sp, #4]
  41ad14:	9800      	ldr	r0, [sp, #0]
  41ad16:	441a      	add	r2, r3
  41ad18:	6022      	str	r2, [r4, #0]
  41ad1a:	4621      	mov	r1, r4
  41ad1c:	f7ff fc4a 	bl	41a5b4 <_fflush_r>
  41ad20:	9b01      	ldr	r3, [sp, #4]
  41ad22:	2800      	cmp	r0, #0
  41ad24:	f47f af28 	bne.w	41ab78 <__sfvwrite_r+0xfc>
  41ad28:	461f      	mov	r7, r3
  41ad2a:	e750      	b.n	41abce <__sfvwrite_r+0x152>
  41ad2c:	9800      	ldr	r0, [sp, #0]
  41ad2e:	f000 ff0d 	bl	41bb4c <_realloc_r>
  41ad32:	4683      	mov	fp, r0
  41ad34:	2800      	cmp	r0, #0
  41ad36:	d1c5      	bne.n	41acc4 <__sfvwrite_r+0x248>
  41ad38:	9d00      	ldr	r5, [sp, #0]
  41ad3a:	6921      	ldr	r1, [r4, #16]
  41ad3c:	4628      	mov	r0, r5
  41ad3e:	f7ff fdb7 	bl	41a8b0 <_free_r>
  41ad42:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
  41ad46:	220c      	movs	r2, #12
  41ad48:	f023 0380 	bic.w	r3, r3, #128	; 0x80
  41ad4c:	602a      	str	r2, [r5, #0]
  41ad4e:	e715      	b.n	41ab7c <__sfvwrite_r+0x100>
  41ad50:	f106 0901 	add.w	r9, r6, #1
  41ad54:	e722      	b.n	41ab9c <__sfvwrite_r+0x120>
  41ad56:	f04f 30ff 	mov.w	r0, #4294967295
  41ad5a:	e6bf      	b.n	41aadc <__sfvwrite_r+0x60>
  41ad5c:	9a00      	ldr	r2, [sp, #0]
  41ad5e:	230c      	movs	r3, #12
  41ad60:	6013      	str	r3, [r2, #0]
  41ad62:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
  41ad66:	e709      	b.n	41ab7c <__sfvwrite_r+0x100>
  41ad68:	7ffffc00 	.word	0x7ffffc00

0041ad6c <_fwalk_reent>:
  41ad6c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  41ad70:	f510 7738 	adds.w	r7, r0, #736	; 0x2e0
  41ad74:	d01f      	beq.n	41adb6 <_fwalk_reent+0x4a>
  41ad76:	4688      	mov	r8, r1
  41ad78:	4606      	mov	r6, r0
  41ad7a:	f04f 0900 	mov.w	r9, #0
  41ad7e:	687d      	ldr	r5, [r7, #4]
  41ad80:	68bc      	ldr	r4, [r7, #8]
  41ad82:	3d01      	subs	r5, #1
  41ad84:	d411      	bmi.n	41adaa <_fwalk_reent+0x3e>
  41ad86:	89a3      	ldrh	r3, [r4, #12]
  41ad88:	2b01      	cmp	r3, #1
  41ad8a:	f105 35ff 	add.w	r5, r5, #4294967295
  41ad8e:	d908      	bls.n	41ada2 <_fwalk_reent+0x36>
  41ad90:	f9b4 300e 	ldrsh.w	r3, [r4, #14]
  41ad94:	3301      	adds	r3, #1
  41ad96:	4621      	mov	r1, r4
  41ad98:	4630      	mov	r0, r6
  41ad9a:	d002      	beq.n	41ada2 <_fwalk_reent+0x36>
  41ad9c:	47c0      	blx	r8
  41ad9e:	ea49 0900 	orr.w	r9, r9, r0
  41ada2:	1c6b      	adds	r3, r5, #1
  41ada4:	f104 0468 	add.w	r4, r4, #104	; 0x68
  41ada8:	d1ed      	bne.n	41ad86 <_fwalk_reent+0x1a>
  41adaa:	683f      	ldr	r7, [r7, #0]
  41adac:	2f00      	cmp	r7, #0
  41adae:	d1e6      	bne.n	41ad7e <_fwalk_reent+0x12>
  41adb0:	4648      	mov	r0, r9
  41adb2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  41adb6:	46b9      	mov	r9, r7
  41adb8:	4648      	mov	r0, r9
  41adba:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  41adbe:	bf00      	nop

0041adc0 <__locale_mb_cur_max>:
  41adc0:	4b04      	ldr	r3, [pc, #16]	; (41add4 <__locale_mb_cur_max+0x14>)
  41adc2:	4a05      	ldr	r2, [pc, #20]	; (41add8 <__locale_mb_cur_max+0x18>)
  41adc4:	681b      	ldr	r3, [r3, #0]
  41adc6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  41adc8:	2b00      	cmp	r3, #0
  41adca:	bf08      	it	eq
  41adcc:	4613      	moveq	r3, r2
  41adce:	f893 0128 	ldrb.w	r0, [r3, #296]	; 0x128
  41add2:	4770      	bx	lr
  41add4:	20000178 	.word	0x20000178
  41add8:	200005ac 	.word	0x200005ac

0041addc <_localeconv_r>:
  41addc:	4a04      	ldr	r2, [pc, #16]	; (41adf0 <_localeconv_r+0x14>)
  41adde:	4b05      	ldr	r3, [pc, #20]	; (41adf4 <_localeconv_r+0x18>)
  41ade0:	6812      	ldr	r2, [r2, #0]
  41ade2:	6b50      	ldr	r0, [r2, #52]	; 0x34
  41ade4:	2800      	cmp	r0, #0
  41ade6:	bf08      	it	eq
  41ade8:	4618      	moveq	r0, r3
  41adea:	30f0      	adds	r0, #240	; 0xf0
  41adec:	4770      	bx	lr
  41adee:	bf00      	nop
  41adf0:	20000178 	.word	0x20000178
  41adf4:	200005ac 	.word	0x200005ac

0041adf8 <__retarget_lock_init_recursive>:
  41adf8:	4770      	bx	lr
  41adfa:	bf00      	nop

0041adfc <__retarget_lock_close_recursive>:
  41adfc:	4770      	bx	lr
  41adfe:	bf00      	nop

0041ae00 <__retarget_lock_acquire_recursive>:
  41ae00:	4770      	bx	lr
  41ae02:	bf00      	nop

0041ae04 <__retarget_lock_release_recursive>:
  41ae04:	4770      	bx	lr
  41ae06:	bf00      	nop

0041ae08 <__swhatbuf_r>:
  41ae08:	b570      	push	{r4, r5, r6, lr}
  41ae0a:	460c      	mov	r4, r1
  41ae0c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  41ae10:	2900      	cmp	r1, #0
  41ae12:	b090      	sub	sp, #64	; 0x40
  41ae14:	4615      	mov	r5, r2
  41ae16:	461e      	mov	r6, r3
  41ae18:	db14      	blt.n	41ae44 <__swhatbuf_r+0x3c>
  41ae1a:	aa01      	add	r2, sp, #4
  41ae1c:	f001 fb48 	bl	41c4b0 <_fstat_r>
  41ae20:	2800      	cmp	r0, #0
  41ae22:	db0f      	blt.n	41ae44 <__swhatbuf_r+0x3c>
  41ae24:	9a02      	ldr	r2, [sp, #8]
  41ae26:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
  41ae2a:	f5a2 5200 	sub.w	r2, r2, #8192	; 0x2000
  41ae2e:	fab2 f282 	clz	r2, r2
  41ae32:	0952      	lsrs	r2, r2, #5
  41ae34:	f44f 6380 	mov.w	r3, #1024	; 0x400
  41ae38:	f44f 6000 	mov.w	r0, #2048	; 0x800
  41ae3c:	6032      	str	r2, [r6, #0]
  41ae3e:	602b      	str	r3, [r5, #0]
  41ae40:	b010      	add	sp, #64	; 0x40
  41ae42:	bd70      	pop	{r4, r5, r6, pc}
  41ae44:	89a2      	ldrh	r2, [r4, #12]
  41ae46:	2300      	movs	r3, #0
  41ae48:	f012 0080 	ands.w	r0, r2, #128	; 0x80
  41ae4c:	6033      	str	r3, [r6, #0]
  41ae4e:	d004      	beq.n	41ae5a <__swhatbuf_r+0x52>
  41ae50:	2240      	movs	r2, #64	; 0x40
  41ae52:	4618      	mov	r0, r3
  41ae54:	602a      	str	r2, [r5, #0]
  41ae56:	b010      	add	sp, #64	; 0x40
  41ae58:	bd70      	pop	{r4, r5, r6, pc}
  41ae5a:	f44f 6380 	mov.w	r3, #1024	; 0x400
  41ae5e:	602b      	str	r3, [r5, #0]
  41ae60:	b010      	add	sp, #64	; 0x40
  41ae62:	bd70      	pop	{r4, r5, r6, pc}

0041ae64 <__smakebuf_r>:
  41ae64:	898a      	ldrh	r2, [r1, #12]
  41ae66:	0792      	lsls	r2, r2, #30
  41ae68:	460b      	mov	r3, r1
  41ae6a:	d506      	bpl.n	41ae7a <__smakebuf_r+0x16>
  41ae6c:	f101 0243 	add.w	r2, r1, #67	; 0x43
  41ae70:	2101      	movs	r1, #1
  41ae72:	601a      	str	r2, [r3, #0]
  41ae74:	611a      	str	r2, [r3, #16]
  41ae76:	6159      	str	r1, [r3, #20]
  41ae78:	4770      	bx	lr
  41ae7a:	b5f0      	push	{r4, r5, r6, r7, lr}
  41ae7c:	b083      	sub	sp, #12
  41ae7e:	ab01      	add	r3, sp, #4
  41ae80:	466a      	mov	r2, sp
  41ae82:	460c      	mov	r4, r1
  41ae84:	4606      	mov	r6, r0
  41ae86:	f7ff ffbf 	bl	41ae08 <__swhatbuf_r>
  41ae8a:	9900      	ldr	r1, [sp, #0]
  41ae8c:	4605      	mov	r5, r0
  41ae8e:	4630      	mov	r0, r6
  41ae90:	f000 f83a 	bl	41af08 <_malloc_r>
  41ae94:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
  41ae98:	b1d8      	cbz	r0, 41aed2 <__smakebuf_r+0x6e>
  41ae9a:	9a01      	ldr	r2, [sp, #4]
  41ae9c:	4f15      	ldr	r7, [pc, #84]	; (41aef4 <__smakebuf_r+0x90>)
  41ae9e:	9900      	ldr	r1, [sp, #0]
  41aea0:	63f7      	str	r7, [r6, #60]	; 0x3c
  41aea2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  41aea6:	81a3      	strh	r3, [r4, #12]
  41aea8:	6020      	str	r0, [r4, #0]
  41aeaa:	6120      	str	r0, [r4, #16]
  41aeac:	6161      	str	r1, [r4, #20]
  41aeae:	b91a      	cbnz	r2, 41aeb8 <__smakebuf_r+0x54>
  41aeb0:	432b      	orrs	r3, r5
  41aeb2:	81a3      	strh	r3, [r4, #12]
  41aeb4:	b003      	add	sp, #12
  41aeb6:	bdf0      	pop	{r4, r5, r6, r7, pc}
  41aeb8:	4630      	mov	r0, r6
  41aeba:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
  41aebe:	f001 fb0b 	bl	41c4d8 <_isatty_r>
  41aec2:	b1a0      	cbz	r0, 41aeee <__smakebuf_r+0x8a>
  41aec4:	89a3      	ldrh	r3, [r4, #12]
  41aec6:	f023 0303 	bic.w	r3, r3, #3
  41aeca:	f043 0301 	orr.w	r3, r3, #1
  41aece:	b21b      	sxth	r3, r3
  41aed0:	e7ee      	b.n	41aeb0 <__smakebuf_r+0x4c>
  41aed2:	059a      	lsls	r2, r3, #22
  41aed4:	d4ee      	bmi.n	41aeb4 <__smakebuf_r+0x50>
  41aed6:	f023 0303 	bic.w	r3, r3, #3
  41aeda:	f104 0243 	add.w	r2, r4, #67	; 0x43
  41aede:	f043 0302 	orr.w	r3, r3, #2
  41aee2:	2101      	movs	r1, #1
  41aee4:	81a3      	strh	r3, [r4, #12]
  41aee6:	6022      	str	r2, [r4, #0]
  41aee8:	6122      	str	r2, [r4, #16]
  41aeea:	6161      	str	r1, [r4, #20]
  41aeec:	e7e2      	b.n	41aeb4 <__smakebuf_r+0x50>
  41aeee:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
  41aef2:	e7dd      	b.n	41aeb0 <__smakebuf_r+0x4c>
  41aef4:	0041a609 	.word	0x0041a609

0041aef8 <malloc>:
  41aef8:	4b02      	ldr	r3, [pc, #8]	; (41af04 <malloc+0xc>)
  41aefa:	4601      	mov	r1, r0
  41aefc:	6818      	ldr	r0, [r3, #0]
  41aefe:	f000 b803 	b.w	41af08 <_malloc_r>
  41af02:	bf00      	nop
  41af04:	20000178 	.word	0x20000178

0041af08 <_malloc_r>:
  41af08:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  41af0c:	f101 060b 	add.w	r6, r1, #11
  41af10:	2e16      	cmp	r6, #22
  41af12:	b083      	sub	sp, #12
  41af14:	4605      	mov	r5, r0
  41af16:	f240 809e 	bls.w	41b056 <_malloc_r+0x14e>
  41af1a:	f036 0607 	bics.w	r6, r6, #7
  41af1e:	f100 80bd 	bmi.w	41b09c <_malloc_r+0x194>
  41af22:	42b1      	cmp	r1, r6
  41af24:	f200 80ba 	bhi.w	41b09c <_malloc_r+0x194>
  41af28:	f000 fb0a 	bl	41b540 <__malloc_lock>
  41af2c:	f5b6 7ffc 	cmp.w	r6, #504	; 0x1f8
  41af30:	f0c0 8293 	bcc.w	41b45a <_malloc_r+0x552>
  41af34:	0a73      	lsrs	r3, r6, #9
  41af36:	f000 80b8 	beq.w	41b0aa <_malloc_r+0x1a2>
  41af3a:	2b04      	cmp	r3, #4
  41af3c:	f200 8179 	bhi.w	41b232 <_malloc_r+0x32a>
  41af40:	09b3      	lsrs	r3, r6, #6
  41af42:	f103 0039 	add.w	r0, r3, #57	; 0x39
  41af46:	f103 0e38 	add.w	lr, r3, #56	; 0x38
  41af4a:	00c3      	lsls	r3, r0, #3
  41af4c:	4fbf      	ldr	r7, [pc, #764]	; (41b24c <_malloc_r+0x344>)
  41af4e:	443b      	add	r3, r7
  41af50:	f1a3 0108 	sub.w	r1, r3, #8
  41af54:	685c      	ldr	r4, [r3, #4]
  41af56:	42a1      	cmp	r1, r4
  41af58:	d106      	bne.n	41af68 <_malloc_r+0x60>
  41af5a:	e00c      	b.n	41af76 <_malloc_r+0x6e>
  41af5c:	2a00      	cmp	r2, #0
  41af5e:	f280 80aa 	bge.w	41b0b6 <_malloc_r+0x1ae>
  41af62:	68e4      	ldr	r4, [r4, #12]
  41af64:	42a1      	cmp	r1, r4
  41af66:	d006      	beq.n	41af76 <_malloc_r+0x6e>
  41af68:	6863      	ldr	r3, [r4, #4]
  41af6a:	f023 0303 	bic.w	r3, r3, #3
  41af6e:	1b9a      	subs	r2, r3, r6
  41af70:	2a0f      	cmp	r2, #15
  41af72:	ddf3      	ble.n	41af5c <_malloc_r+0x54>
  41af74:	4670      	mov	r0, lr
  41af76:	693c      	ldr	r4, [r7, #16]
  41af78:	f8df e2e4 	ldr.w	lr, [pc, #740]	; 41b260 <_malloc_r+0x358>
  41af7c:	4574      	cmp	r4, lr
  41af7e:	f000 81ab 	beq.w	41b2d8 <_malloc_r+0x3d0>
  41af82:	6863      	ldr	r3, [r4, #4]
  41af84:	f023 0303 	bic.w	r3, r3, #3
  41af88:	1b9a      	subs	r2, r3, r6
  41af8a:	2a0f      	cmp	r2, #15
  41af8c:	f300 8190 	bgt.w	41b2b0 <_malloc_r+0x3a8>
  41af90:	2a00      	cmp	r2, #0
  41af92:	f8c7 e014 	str.w	lr, [r7, #20]
  41af96:	f8c7 e010 	str.w	lr, [r7, #16]
  41af9a:	f280 809d 	bge.w	41b0d8 <_malloc_r+0x1d0>
  41af9e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
  41afa2:	f080 8161 	bcs.w	41b268 <_malloc_r+0x360>
  41afa6:	08db      	lsrs	r3, r3, #3
  41afa8:	f103 0c01 	add.w	ip, r3, #1
  41afac:	1099      	asrs	r1, r3, #2
  41afae:	687a      	ldr	r2, [r7, #4]
  41afb0:	f857 803c 	ldr.w	r8, [r7, ip, lsl #3]
  41afb4:	f8c4 8008 	str.w	r8, [r4, #8]
  41afb8:	2301      	movs	r3, #1
  41afba:	408b      	lsls	r3, r1
  41afbc:	eb07 01cc 	add.w	r1, r7, ip, lsl #3
  41afc0:	4313      	orrs	r3, r2
  41afc2:	3908      	subs	r1, #8
  41afc4:	60e1      	str	r1, [r4, #12]
  41afc6:	607b      	str	r3, [r7, #4]
  41afc8:	f847 403c 	str.w	r4, [r7, ip, lsl #3]
  41afcc:	f8c8 400c 	str.w	r4, [r8, #12]
  41afd0:	1082      	asrs	r2, r0, #2
  41afd2:	2401      	movs	r4, #1
  41afd4:	4094      	lsls	r4, r2
  41afd6:	429c      	cmp	r4, r3
  41afd8:	f200 808b 	bhi.w	41b0f2 <_malloc_r+0x1ea>
  41afdc:	421c      	tst	r4, r3
  41afde:	d106      	bne.n	41afee <_malloc_r+0xe6>
  41afe0:	f020 0003 	bic.w	r0, r0, #3
  41afe4:	0064      	lsls	r4, r4, #1
  41afe6:	421c      	tst	r4, r3
  41afe8:	f100 0004 	add.w	r0, r0, #4
  41afec:	d0fa      	beq.n	41afe4 <_malloc_r+0xdc>
  41afee:	eb07 09c0 	add.w	r9, r7, r0, lsl #3
  41aff2:	46cc      	mov	ip, r9
  41aff4:	4680      	mov	r8, r0
  41aff6:	f8dc 300c 	ldr.w	r3, [ip, #12]
  41affa:	459c      	cmp	ip, r3
  41affc:	d107      	bne.n	41b00e <_malloc_r+0x106>
  41affe:	e16d      	b.n	41b2dc <_malloc_r+0x3d4>
  41b000:	2a00      	cmp	r2, #0
  41b002:	f280 817b 	bge.w	41b2fc <_malloc_r+0x3f4>
  41b006:	68db      	ldr	r3, [r3, #12]
  41b008:	459c      	cmp	ip, r3
  41b00a:	f000 8167 	beq.w	41b2dc <_malloc_r+0x3d4>
  41b00e:	6859      	ldr	r1, [r3, #4]
  41b010:	f021 0103 	bic.w	r1, r1, #3
  41b014:	1b8a      	subs	r2, r1, r6
  41b016:	2a0f      	cmp	r2, #15
  41b018:	ddf2      	ble.n	41b000 <_malloc_r+0xf8>
  41b01a:	f8d3 c00c 	ldr.w	ip, [r3, #12]
  41b01e:	f8d3 8008 	ldr.w	r8, [r3, #8]
  41b022:	9300      	str	r3, [sp, #0]
  41b024:	199c      	adds	r4, r3, r6
  41b026:	4628      	mov	r0, r5
  41b028:	f046 0601 	orr.w	r6, r6, #1
  41b02c:	f042 0501 	orr.w	r5, r2, #1
  41b030:	605e      	str	r6, [r3, #4]
  41b032:	f8c8 c00c 	str.w	ip, [r8, #12]
  41b036:	f8cc 8008 	str.w	r8, [ip, #8]
  41b03a:	617c      	str	r4, [r7, #20]
  41b03c:	613c      	str	r4, [r7, #16]
  41b03e:	f8c4 e00c 	str.w	lr, [r4, #12]
  41b042:	f8c4 e008 	str.w	lr, [r4, #8]
  41b046:	6065      	str	r5, [r4, #4]
  41b048:	505a      	str	r2, [r3, r1]
  41b04a:	f000 fa7f 	bl	41b54c <__malloc_unlock>
  41b04e:	9b00      	ldr	r3, [sp, #0]
  41b050:	f103 0408 	add.w	r4, r3, #8
  41b054:	e01e      	b.n	41b094 <_malloc_r+0x18c>
  41b056:	2910      	cmp	r1, #16
  41b058:	d820      	bhi.n	41b09c <_malloc_r+0x194>
  41b05a:	f000 fa71 	bl	41b540 <__malloc_lock>
  41b05e:	2610      	movs	r6, #16
  41b060:	2318      	movs	r3, #24
  41b062:	2002      	movs	r0, #2
  41b064:	4f79      	ldr	r7, [pc, #484]	; (41b24c <_malloc_r+0x344>)
  41b066:	443b      	add	r3, r7
  41b068:	f1a3 0208 	sub.w	r2, r3, #8
  41b06c:	685c      	ldr	r4, [r3, #4]
  41b06e:	4294      	cmp	r4, r2
  41b070:	f000 813d 	beq.w	41b2ee <_malloc_r+0x3e6>
  41b074:	6863      	ldr	r3, [r4, #4]
  41b076:	68e1      	ldr	r1, [r4, #12]
  41b078:	68a6      	ldr	r6, [r4, #8]
  41b07a:	f023 0303 	bic.w	r3, r3, #3
  41b07e:	4423      	add	r3, r4
  41b080:	4628      	mov	r0, r5
  41b082:	685a      	ldr	r2, [r3, #4]
  41b084:	60f1      	str	r1, [r6, #12]
  41b086:	f042 0201 	orr.w	r2, r2, #1
  41b08a:	608e      	str	r6, [r1, #8]
  41b08c:	605a      	str	r2, [r3, #4]
  41b08e:	f000 fa5d 	bl	41b54c <__malloc_unlock>
  41b092:	3408      	adds	r4, #8
  41b094:	4620      	mov	r0, r4
  41b096:	b003      	add	sp, #12
  41b098:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  41b09c:	2400      	movs	r4, #0
  41b09e:	230c      	movs	r3, #12
  41b0a0:	4620      	mov	r0, r4
  41b0a2:	602b      	str	r3, [r5, #0]
  41b0a4:	b003      	add	sp, #12
  41b0a6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  41b0aa:	2040      	movs	r0, #64	; 0x40
  41b0ac:	f44f 7300 	mov.w	r3, #512	; 0x200
  41b0b0:	f04f 0e3f 	mov.w	lr, #63	; 0x3f
  41b0b4:	e74a      	b.n	41af4c <_malloc_r+0x44>
  41b0b6:	4423      	add	r3, r4
  41b0b8:	68e1      	ldr	r1, [r4, #12]
  41b0ba:	685a      	ldr	r2, [r3, #4]
  41b0bc:	68a6      	ldr	r6, [r4, #8]
  41b0be:	f042 0201 	orr.w	r2, r2, #1
  41b0c2:	60f1      	str	r1, [r6, #12]
  41b0c4:	4628      	mov	r0, r5
  41b0c6:	608e      	str	r6, [r1, #8]
  41b0c8:	605a      	str	r2, [r3, #4]
  41b0ca:	f000 fa3f 	bl	41b54c <__malloc_unlock>
  41b0ce:	3408      	adds	r4, #8
  41b0d0:	4620      	mov	r0, r4
  41b0d2:	b003      	add	sp, #12
  41b0d4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  41b0d8:	4423      	add	r3, r4
  41b0da:	4628      	mov	r0, r5
  41b0dc:	685a      	ldr	r2, [r3, #4]
  41b0de:	f042 0201 	orr.w	r2, r2, #1
  41b0e2:	605a      	str	r2, [r3, #4]
  41b0e4:	f000 fa32 	bl	41b54c <__malloc_unlock>
  41b0e8:	3408      	adds	r4, #8
  41b0ea:	4620      	mov	r0, r4
  41b0ec:	b003      	add	sp, #12
  41b0ee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  41b0f2:	68bc      	ldr	r4, [r7, #8]
  41b0f4:	6863      	ldr	r3, [r4, #4]
  41b0f6:	f023 0803 	bic.w	r8, r3, #3
  41b0fa:	45b0      	cmp	r8, r6
  41b0fc:	d304      	bcc.n	41b108 <_malloc_r+0x200>
  41b0fe:	eba8 0306 	sub.w	r3, r8, r6
  41b102:	2b0f      	cmp	r3, #15
  41b104:	f300 8085 	bgt.w	41b212 <_malloc_r+0x30a>
  41b108:	f8df 9158 	ldr.w	r9, [pc, #344]	; 41b264 <_malloc_r+0x35c>
  41b10c:	4b50      	ldr	r3, [pc, #320]	; (41b250 <_malloc_r+0x348>)
  41b10e:	f8d9 2000 	ldr.w	r2, [r9]
  41b112:	681b      	ldr	r3, [r3, #0]
  41b114:	3201      	adds	r2, #1
  41b116:	4433      	add	r3, r6
  41b118:	eb04 0a08 	add.w	sl, r4, r8
  41b11c:	f000 8155 	beq.w	41b3ca <_malloc_r+0x4c2>
  41b120:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
  41b124:	330f      	adds	r3, #15
  41b126:	f423 6b7f 	bic.w	fp, r3, #4080	; 0xff0
  41b12a:	f02b 0b0f 	bic.w	fp, fp, #15
  41b12e:	4659      	mov	r1, fp
  41b130:	4628      	mov	r0, r5
  41b132:	f000 feb1 	bl	41be98 <_sbrk_r>
  41b136:	1c41      	adds	r1, r0, #1
  41b138:	4602      	mov	r2, r0
  41b13a:	f000 80fc 	beq.w	41b336 <_malloc_r+0x42e>
  41b13e:	4582      	cmp	sl, r0
  41b140:	f200 80f7 	bhi.w	41b332 <_malloc_r+0x42a>
  41b144:	4b43      	ldr	r3, [pc, #268]	; (41b254 <_malloc_r+0x34c>)
  41b146:	6819      	ldr	r1, [r3, #0]
  41b148:	4459      	add	r1, fp
  41b14a:	6019      	str	r1, [r3, #0]
  41b14c:	f000 814d 	beq.w	41b3ea <_malloc_r+0x4e2>
  41b150:	f8d9 0000 	ldr.w	r0, [r9]
  41b154:	3001      	adds	r0, #1
  41b156:	bf1b      	ittet	ne
  41b158:	eba2 0a0a 	subne.w	sl, r2, sl
  41b15c:	4451      	addne	r1, sl
  41b15e:	f8c9 2000 	streq.w	r2, [r9]
  41b162:	6019      	strne	r1, [r3, #0]
  41b164:	f012 0107 	ands.w	r1, r2, #7
  41b168:	f000 8115 	beq.w	41b396 <_malloc_r+0x48e>
  41b16c:	f1c1 0008 	rsb	r0, r1, #8
  41b170:	f5c1 5180 	rsb	r1, r1, #4096	; 0x1000
  41b174:	4402      	add	r2, r0
  41b176:	3108      	adds	r1, #8
  41b178:	eb02 090b 	add.w	r9, r2, fp
  41b17c:	f3c9 090b 	ubfx	r9, r9, #0, #12
  41b180:	eba1 0909 	sub.w	r9, r1, r9
  41b184:	4649      	mov	r1, r9
  41b186:	4628      	mov	r0, r5
  41b188:	9301      	str	r3, [sp, #4]
  41b18a:	9200      	str	r2, [sp, #0]
  41b18c:	f000 fe84 	bl	41be98 <_sbrk_r>
  41b190:	1c43      	adds	r3, r0, #1
  41b192:	e89d 000c 	ldmia.w	sp, {r2, r3}
  41b196:	f000 8143 	beq.w	41b420 <_malloc_r+0x518>
  41b19a:	1a80      	subs	r0, r0, r2
  41b19c:	4448      	add	r0, r9
  41b19e:	f040 0001 	orr.w	r0, r0, #1
  41b1a2:	6819      	ldr	r1, [r3, #0]
  41b1a4:	60ba      	str	r2, [r7, #8]
  41b1a6:	4449      	add	r1, r9
  41b1a8:	42bc      	cmp	r4, r7
  41b1aa:	6050      	str	r0, [r2, #4]
  41b1ac:	6019      	str	r1, [r3, #0]
  41b1ae:	d017      	beq.n	41b1e0 <_malloc_r+0x2d8>
  41b1b0:	f1b8 0f0f 	cmp.w	r8, #15
  41b1b4:	f240 80fb 	bls.w	41b3ae <_malloc_r+0x4a6>
  41b1b8:	6860      	ldr	r0, [r4, #4]
  41b1ba:	f1a8 020c 	sub.w	r2, r8, #12
  41b1be:	f022 0207 	bic.w	r2, r2, #7
  41b1c2:	eb04 0e02 	add.w	lr, r4, r2
  41b1c6:	f000 0001 	and.w	r0, r0, #1
  41b1ca:	f04f 0c05 	mov.w	ip, #5
  41b1ce:	4310      	orrs	r0, r2
  41b1d0:	2a0f      	cmp	r2, #15
  41b1d2:	6060      	str	r0, [r4, #4]
  41b1d4:	f8ce c004 	str.w	ip, [lr, #4]
  41b1d8:	f8ce c008 	str.w	ip, [lr, #8]
  41b1dc:	f200 8117 	bhi.w	41b40e <_malloc_r+0x506>
  41b1e0:	4b1d      	ldr	r3, [pc, #116]	; (41b258 <_malloc_r+0x350>)
  41b1e2:	68bc      	ldr	r4, [r7, #8]
  41b1e4:	681a      	ldr	r2, [r3, #0]
  41b1e6:	4291      	cmp	r1, r2
  41b1e8:	bf88      	it	hi
  41b1ea:	6019      	strhi	r1, [r3, #0]
  41b1ec:	4b1b      	ldr	r3, [pc, #108]	; (41b25c <_malloc_r+0x354>)
  41b1ee:	681a      	ldr	r2, [r3, #0]
  41b1f0:	4291      	cmp	r1, r2
  41b1f2:	6862      	ldr	r2, [r4, #4]
  41b1f4:	bf88      	it	hi
  41b1f6:	6019      	strhi	r1, [r3, #0]
  41b1f8:	f022 0203 	bic.w	r2, r2, #3
  41b1fc:	4296      	cmp	r6, r2
  41b1fe:	eba2 0306 	sub.w	r3, r2, r6
  41b202:	d801      	bhi.n	41b208 <_malloc_r+0x300>
  41b204:	2b0f      	cmp	r3, #15
  41b206:	dc04      	bgt.n	41b212 <_malloc_r+0x30a>
  41b208:	4628      	mov	r0, r5
  41b20a:	f000 f99f 	bl	41b54c <__malloc_unlock>
  41b20e:	2400      	movs	r4, #0
  41b210:	e740      	b.n	41b094 <_malloc_r+0x18c>
  41b212:	19a2      	adds	r2, r4, r6
  41b214:	f043 0301 	orr.w	r3, r3, #1
  41b218:	f046 0601 	orr.w	r6, r6, #1
  41b21c:	6066      	str	r6, [r4, #4]
  41b21e:	4628      	mov	r0, r5
  41b220:	60ba      	str	r2, [r7, #8]
  41b222:	6053      	str	r3, [r2, #4]
  41b224:	f000 f992 	bl	41b54c <__malloc_unlock>
  41b228:	3408      	adds	r4, #8
  41b22a:	4620      	mov	r0, r4
  41b22c:	b003      	add	sp, #12
  41b22e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  41b232:	2b14      	cmp	r3, #20
  41b234:	d971      	bls.n	41b31a <_malloc_r+0x412>
  41b236:	2b54      	cmp	r3, #84	; 0x54
  41b238:	f200 80a3 	bhi.w	41b382 <_malloc_r+0x47a>
  41b23c:	0b33      	lsrs	r3, r6, #12
  41b23e:	f103 006f 	add.w	r0, r3, #111	; 0x6f
  41b242:	f103 0e6e 	add.w	lr, r3, #110	; 0x6e
  41b246:	00c3      	lsls	r3, r0, #3
  41b248:	e680      	b.n	41af4c <_malloc_r+0x44>
  41b24a:	bf00      	nop
  41b24c:	20000718 	.word	0x20000718
  41b250:	2000b57c 	.word	0x2000b57c
  41b254:	2000b54c 	.word	0x2000b54c
  41b258:	2000b574 	.word	0x2000b574
  41b25c:	2000b578 	.word	0x2000b578
  41b260:	20000720 	.word	0x20000720
  41b264:	20000b20 	.word	0x20000b20
  41b268:	0a5a      	lsrs	r2, r3, #9
  41b26a:	2a04      	cmp	r2, #4
  41b26c:	d95b      	bls.n	41b326 <_malloc_r+0x41e>
  41b26e:	2a14      	cmp	r2, #20
  41b270:	f200 80ae 	bhi.w	41b3d0 <_malloc_r+0x4c8>
  41b274:	f102 015c 	add.w	r1, r2, #92	; 0x5c
  41b278:	00c9      	lsls	r1, r1, #3
  41b27a:	325b      	adds	r2, #91	; 0x5b
  41b27c:	eb07 0c01 	add.w	ip, r7, r1
  41b280:	5879      	ldr	r1, [r7, r1]
  41b282:	f1ac 0c08 	sub.w	ip, ip, #8
  41b286:	458c      	cmp	ip, r1
  41b288:	f000 8088 	beq.w	41b39c <_malloc_r+0x494>
  41b28c:	684a      	ldr	r2, [r1, #4]
  41b28e:	f022 0203 	bic.w	r2, r2, #3
  41b292:	4293      	cmp	r3, r2
  41b294:	d273      	bcs.n	41b37e <_malloc_r+0x476>
  41b296:	6889      	ldr	r1, [r1, #8]
  41b298:	458c      	cmp	ip, r1
  41b29a:	d1f7      	bne.n	41b28c <_malloc_r+0x384>
  41b29c:	f8dc 200c 	ldr.w	r2, [ip, #12]
  41b2a0:	687b      	ldr	r3, [r7, #4]
  41b2a2:	60e2      	str	r2, [r4, #12]
  41b2a4:	f8c4 c008 	str.w	ip, [r4, #8]
  41b2a8:	6094      	str	r4, [r2, #8]
  41b2aa:	f8cc 400c 	str.w	r4, [ip, #12]
  41b2ae:	e68f      	b.n	41afd0 <_malloc_r+0xc8>
  41b2b0:	19a1      	adds	r1, r4, r6
  41b2b2:	f046 0c01 	orr.w	ip, r6, #1
  41b2b6:	f042 0601 	orr.w	r6, r2, #1
  41b2ba:	f8c4 c004 	str.w	ip, [r4, #4]
  41b2be:	4628      	mov	r0, r5
  41b2c0:	6179      	str	r1, [r7, #20]
  41b2c2:	6139      	str	r1, [r7, #16]
  41b2c4:	f8c1 e00c 	str.w	lr, [r1, #12]
  41b2c8:	f8c1 e008 	str.w	lr, [r1, #8]
  41b2cc:	604e      	str	r6, [r1, #4]
  41b2ce:	50e2      	str	r2, [r4, r3]
  41b2d0:	f000 f93c 	bl	41b54c <__malloc_unlock>
  41b2d4:	3408      	adds	r4, #8
  41b2d6:	e6dd      	b.n	41b094 <_malloc_r+0x18c>
  41b2d8:	687b      	ldr	r3, [r7, #4]
  41b2da:	e679      	b.n	41afd0 <_malloc_r+0xc8>
  41b2dc:	f108 0801 	add.w	r8, r8, #1
  41b2e0:	f018 0f03 	tst.w	r8, #3
  41b2e4:	f10c 0c08 	add.w	ip, ip, #8
  41b2e8:	f47f ae85 	bne.w	41aff6 <_malloc_r+0xee>
  41b2ec:	e02d      	b.n	41b34a <_malloc_r+0x442>
  41b2ee:	68dc      	ldr	r4, [r3, #12]
  41b2f0:	42a3      	cmp	r3, r4
  41b2f2:	bf08      	it	eq
  41b2f4:	3002      	addeq	r0, #2
  41b2f6:	f43f ae3e 	beq.w	41af76 <_malloc_r+0x6e>
  41b2fa:	e6bb      	b.n	41b074 <_malloc_r+0x16c>
  41b2fc:	4419      	add	r1, r3
  41b2fe:	461c      	mov	r4, r3
  41b300:	684a      	ldr	r2, [r1, #4]
  41b302:	68db      	ldr	r3, [r3, #12]
  41b304:	f854 6f08 	ldr.w	r6, [r4, #8]!
  41b308:	f042 0201 	orr.w	r2, r2, #1
  41b30c:	604a      	str	r2, [r1, #4]
  41b30e:	4628      	mov	r0, r5
  41b310:	60f3      	str	r3, [r6, #12]
  41b312:	609e      	str	r6, [r3, #8]
  41b314:	f000 f91a 	bl	41b54c <__malloc_unlock>
  41b318:	e6bc      	b.n	41b094 <_malloc_r+0x18c>
  41b31a:	f103 005c 	add.w	r0, r3, #92	; 0x5c
  41b31e:	f103 0e5b 	add.w	lr, r3, #91	; 0x5b
  41b322:	00c3      	lsls	r3, r0, #3
  41b324:	e612      	b.n	41af4c <_malloc_r+0x44>
  41b326:	099a      	lsrs	r2, r3, #6
  41b328:	f102 0139 	add.w	r1, r2, #57	; 0x39
  41b32c:	00c9      	lsls	r1, r1, #3
  41b32e:	3238      	adds	r2, #56	; 0x38
  41b330:	e7a4      	b.n	41b27c <_malloc_r+0x374>
  41b332:	42bc      	cmp	r4, r7
  41b334:	d054      	beq.n	41b3e0 <_malloc_r+0x4d8>
  41b336:	68bc      	ldr	r4, [r7, #8]
  41b338:	6862      	ldr	r2, [r4, #4]
  41b33a:	f022 0203 	bic.w	r2, r2, #3
  41b33e:	e75d      	b.n	41b1fc <_malloc_r+0x2f4>
  41b340:	f859 3908 	ldr.w	r3, [r9], #-8
  41b344:	4599      	cmp	r9, r3
  41b346:	f040 8086 	bne.w	41b456 <_malloc_r+0x54e>
  41b34a:	f010 0f03 	tst.w	r0, #3
  41b34e:	f100 30ff 	add.w	r0, r0, #4294967295
  41b352:	d1f5      	bne.n	41b340 <_malloc_r+0x438>
  41b354:	687b      	ldr	r3, [r7, #4]
  41b356:	ea23 0304 	bic.w	r3, r3, r4
  41b35a:	607b      	str	r3, [r7, #4]
  41b35c:	0064      	lsls	r4, r4, #1
  41b35e:	429c      	cmp	r4, r3
  41b360:	f63f aec7 	bhi.w	41b0f2 <_malloc_r+0x1ea>
  41b364:	2c00      	cmp	r4, #0
  41b366:	f43f aec4 	beq.w	41b0f2 <_malloc_r+0x1ea>
  41b36a:	421c      	tst	r4, r3
  41b36c:	4640      	mov	r0, r8
  41b36e:	f47f ae3e 	bne.w	41afee <_malloc_r+0xe6>
  41b372:	0064      	lsls	r4, r4, #1
  41b374:	421c      	tst	r4, r3
  41b376:	f100 0004 	add.w	r0, r0, #4
  41b37a:	d0fa      	beq.n	41b372 <_malloc_r+0x46a>
  41b37c:	e637      	b.n	41afee <_malloc_r+0xe6>
  41b37e:	468c      	mov	ip, r1
  41b380:	e78c      	b.n	41b29c <_malloc_r+0x394>
  41b382:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
  41b386:	d815      	bhi.n	41b3b4 <_malloc_r+0x4ac>
  41b388:	0bf3      	lsrs	r3, r6, #15
  41b38a:	f103 0078 	add.w	r0, r3, #120	; 0x78
  41b38e:	f103 0e77 	add.w	lr, r3, #119	; 0x77
  41b392:	00c3      	lsls	r3, r0, #3
  41b394:	e5da      	b.n	41af4c <_malloc_r+0x44>
  41b396:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  41b39a:	e6ed      	b.n	41b178 <_malloc_r+0x270>
  41b39c:	687b      	ldr	r3, [r7, #4]
  41b39e:	1092      	asrs	r2, r2, #2
  41b3a0:	2101      	movs	r1, #1
  41b3a2:	fa01 f202 	lsl.w	r2, r1, r2
  41b3a6:	4313      	orrs	r3, r2
  41b3a8:	607b      	str	r3, [r7, #4]
  41b3aa:	4662      	mov	r2, ip
  41b3ac:	e779      	b.n	41b2a2 <_malloc_r+0x39a>
  41b3ae:	2301      	movs	r3, #1
  41b3b0:	6053      	str	r3, [r2, #4]
  41b3b2:	e729      	b.n	41b208 <_malloc_r+0x300>
  41b3b4:	f240 5254 	movw	r2, #1364	; 0x554
  41b3b8:	4293      	cmp	r3, r2
  41b3ba:	d822      	bhi.n	41b402 <_malloc_r+0x4fa>
  41b3bc:	0cb3      	lsrs	r3, r6, #18
  41b3be:	f103 007d 	add.w	r0, r3, #125	; 0x7d
  41b3c2:	f103 0e7c 	add.w	lr, r3, #124	; 0x7c
  41b3c6:	00c3      	lsls	r3, r0, #3
  41b3c8:	e5c0      	b.n	41af4c <_malloc_r+0x44>
  41b3ca:	f103 0b10 	add.w	fp, r3, #16
  41b3ce:	e6ae      	b.n	41b12e <_malloc_r+0x226>
  41b3d0:	2a54      	cmp	r2, #84	; 0x54
  41b3d2:	d829      	bhi.n	41b428 <_malloc_r+0x520>
  41b3d4:	0b1a      	lsrs	r2, r3, #12
  41b3d6:	f102 016f 	add.w	r1, r2, #111	; 0x6f
  41b3da:	00c9      	lsls	r1, r1, #3
  41b3dc:	326e      	adds	r2, #110	; 0x6e
  41b3de:	e74d      	b.n	41b27c <_malloc_r+0x374>
  41b3e0:	4b20      	ldr	r3, [pc, #128]	; (41b464 <_malloc_r+0x55c>)
  41b3e2:	6819      	ldr	r1, [r3, #0]
  41b3e4:	4459      	add	r1, fp
  41b3e6:	6019      	str	r1, [r3, #0]
  41b3e8:	e6b2      	b.n	41b150 <_malloc_r+0x248>
  41b3ea:	f3ca 000b 	ubfx	r0, sl, #0, #12
  41b3ee:	2800      	cmp	r0, #0
  41b3f0:	f47f aeae 	bne.w	41b150 <_malloc_r+0x248>
  41b3f4:	eb08 030b 	add.w	r3, r8, fp
  41b3f8:	68ba      	ldr	r2, [r7, #8]
  41b3fa:	f043 0301 	orr.w	r3, r3, #1
  41b3fe:	6053      	str	r3, [r2, #4]
  41b400:	e6ee      	b.n	41b1e0 <_malloc_r+0x2d8>
  41b402:	207f      	movs	r0, #127	; 0x7f
  41b404:	f44f 737e 	mov.w	r3, #1016	; 0x3f8
  41b408:	f04f 0e7e 	mov.w	lr, #126	; 0x7e
  41b40c:	e59e      	b.n	41af4c <_malloc_r+0x44>
  41b40e:	f104 0108 	add.w	r1, r4, #8
  41b412:	4628      	mov	r0, r5
  41b414:	9300      	str	r3, [sp, #0]
  41b416:	f7ff fa4b 	bl	41a8b0 <_free_r>
  41b41a:	9b00      	ldr	r3, [sp, #0]
  41b41c:	6819      	ldr	r1, [r3, #0]
  41b41e:	e6df      	b.n	41b1e0 <_malloc_r+0x2d8>
  41b420:	2001      	movs	r0, #1
  41b422:	f04f 0900 	mov.w	r9, #0
  41b426:	e6bc      	b.n	41b1a2 <_malloc_r+0x29a>
  41b428:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
  41b42c:	d805      	bhi.n	41b43a <_malloc_r+0x532>
  41b42e:	0bda      	lsrs	r2, r3, #15
  41b430:	f102 0178 	add.w	r1, r2, #120	; 0x78
  41b434:	00c9      	lsls	r1, r1, #3
  41b436:	3277      	adds	r2, #119	; 0x77
  41b438:	e720      	b.n	41b27c <_malloc_r+0x374>
  41b43a:	f240 5154 	movw	r1, #1364	; 0x554
  41b43e:	428a      	cmp	r2, r1
  41b440:	d805      	bhi.n	41b44e <_malloc_r+0x546>
  41b442:	0c9a      	lsrs	r2, r3, #18
  41b444:	f102 017d 	add.w	r1, r2, #125	; 0x7d
  41b448:	00c9      	lsls	r1, r1, #3
  41b44a:	327c      	adds	r2, #124	; 0x7c
  41b44c:	e716      	b.n	41b27c <_malloc_r+0x374>
  41b44e:	f44f 717e 	mov.w	r1, #1016	; 0x3f8
  41b452:	227e      	movs	r2, #126	; 0x7e
  41b454:	e712      	b.n	41b27c <_malloc_r+0x374>
  41b456:	687b      	ldr	r3, [r7, #4]
  41b458:	e780      	b.n	41b35c <_malloc_r+0x454>
  41b45a:	08f0      	lsrs	r0, r6, #3
  41b45c:	f106 0308 	add.w	r3, r6, #8
  41b460:	e600      	b.n	41b064 <_malloc_r+0x15c>
  41b462:	bf00      	nop
  41b464:	2000b54c 	.word	0x2000b54c

0041b468 <__ascii_mbtowc>:
  41b468:	b082      	sub	sp, #8
  41b46a:	b149      	cbz	r1, 41b480 <__ascii_mbtowc+0x18>
  41b46c:	b15a      	cbz	r2, 41b486 <__ascii_mbtowc+0x1e>
  41b46e:	b16b      	cbz	r3, 41b48c <__ascii_mbtowc+0x24>
  41b470:	7813      	ldrb	r3, [r2, #0]
  41b472:	600b      	str	r3, [r1, #0]
  41b474:	7812      	ldrb	r2, [r2, #0]
  41b476:	1c10      	adds	r0, r2, #0
  41b478:	bf18      	it	ne
  41b47a:	2001      	movne	r0, #1
  41b47c:	b002      	add	sp, #8
  41b47e:	4770      	bx	lr
  41b480:	a901      	add	r1, sp, #4
  41b482:	2a00      	cmp	r2, #0
  41b484:	d1f3      	bne.n	41b46e <__ascii_mbtowc+0x6>
  41b486:	4610      	mov	r0, r2
  41b488:	b002      	add	sp, #8
  41b48a:	4770      	bx	lr
  41b48c:	f06f 0001 	mvn.w	r0, #1
  41b490:	e7f4      	b.n	41b47c <__ascii_mbtowc+0x14>
  41b492:	bf00      	nop
	...

0041b4a0 <memchr>:
  41b4a0:	f001 01ff 	and.w	r1, r1, #255	; 0xff
  41b4a4:	2a10      	cmp	r2, #16
  41b4a6:	db2b      	blt.n	41b500 <memchr+0x60>
  41b4a8:	f010 0f07 	tst.w	r0, #7
  41b4ac:	d008      	beq.n	41b4c0 <memchr+0x20>
  41b4ae:	f810 3b01 	ldrb.w	r3, [r0], #1
  41b4b2:	3a01      	subs	r2, #1
  41b4b4:	428b      	cmp	r3, r1
  41b4b6:	d02d      	beq.n	41b514 <memchr+0x74>
  41b4b8:	f010 0f07 	tst.w	r0, #7
  41b4bc:	b342      	cbz	r2, 41b510 <memchr+0x70>
  41b4be:	d1f6      	bne.n	41b4ae <memchr+0xe>
  41b4c0:	b4f0      	push	{r4, r5, r6, r7}
  41b4c2:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
  41b4c6:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
  41b4ca:	f022 0407 	bic.w	r4, r2, #7
  41b4ce:	f07f 0700 	mvns.w	r7, #0
  41b4d2:	2300      	movs	r3, #0
  41b4d4:	e8f0 5602 	ldrd	r5, r6, [r0], #8
  41b4d8:	3c08      	subs	r4, #8
  41b4da:	ea85 0501 	eor.w	r5, r5, r1
  41b4de:	ea86 0601 	eor.w	r6, r6, r1
  41b4e2:	fa85 f547 	uadd8	r5, r5, r7
  41b4e6:	faa3 f587 	sel	r5, r3, r7
  41b4ea:	fa86 f647 	uadd8	r6, r6, r7
  41b4ee:	faa5 f687 	sel	r6, r5, r7
  41b4f2:	b98e      	cbnz	r6, 41b518 <memchr+0x78>
  41b4f4:	d1ee      	bne.n	41b4d4 <memchr+0x34>
  41b4f6:	bcf0      	pop	{r4, r5, r6, r7}
  41b4f8:	f001 01ff 	and.w	r1, r1, #255	; 0xff
  41b4fc:	f002 0207 	and.w	r2, r2, #7
  41b500:	b132      	cbz	r2, 41b510 <memchr+0x70>
  41b502:	f810 3b01 	ldrb.w	r3, [r0], #1
  41b506:	3a01      	subs	r2, #1
  41b508:	ea83 0301 	eor.w	r3, r3, r1
  41b50c:	b113      	cbz	r3, 41b514 <memchr+0x74>
  41b50e:	d1f8      	bne.n	41b502 <memchr+0x62>
  41b510:	2000      	movs	r0, #0
  41b512:	4770      	bx	lr
  41b514:	3801      	subs	r0, #1
  41b516:	4770      	bx	lr
  41b518:	2d00      	cmp	r5, #0
  41b51a:	bf06      	itte	eq
  41b51c:	4635      	moveq	r5, r6
  41b51e:	3803      	subeq	r0, #3
  41b520:	3807      	subne	r0, #7
  41b522:	f015 0f01 	tst.w	r5, #1
  41b526:	d107      	bne.n	41b538 <memchr+0x98>
  41b528:	3001      	adds	r0, #1
  41b52a:	f415 7f80 	tst.w	r5, #256	; 0x100
  41b52e:	bf02      	ittt	eq
  41b530:	3001      	addeq	r0, #1
  41b532:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
  41b536:	3001      	addeq	r0, #1
  41b538:	bcf0      	pop	{r4, r5, r6, r7}
  41b53a:	3801      	subs	r0, #1
  41b53c:	4770      	bx	lr
  41b53e:	bf00      	nop

0041b540 <__malloc_lock>:
  41b540:	4801      	ldr	r0, [pc, #4]	; (41b548 <__malloc_lock+0x8>)
  41b542:	f7ff bc5d 	b.w	41ae00 <__retarget_lock_acquire_recursive>
  41b546:	bf00      	nop
  41b548:	2000bd04 	.word	0x2000bd04

0041b54c <__malloc_unlock>:
  41b54c:	4801      	ldr	r0, [pc, #4]	; (41b554 <__malloc_unlock+0x8>)
  41b54e:	f7ff bc59 	b.w	41ae04 <__retarget_lock_release_recursive>
  41b552:	bf00      	nop
  41b554:	2000bd04 	.word	0x2000bd04

0041b558 <_Balloc>:
  41b558:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
  41b55a:	b570      	push	{r4, r5, r6, lr}
  41b55c:	4605      	mov	r5, r0
  41b55e:	460c      	mov	r4, r1
  41b560:	b14b      	cbz	r3, 41b576 <_Balloc+0x1e>
  41b562:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
  41b566:	b180      	cbz	r0, 41b58a <_Balloc+0x32>
  41b568:	6802      	ldr	r2, [r0, #0]
  41b56a:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
  41b56e:	2300      	movs	r3, #0
  41b570:	6103      	str	r3, [r0, #16]
  41b572:	60c3      	str	r3, [r0, #12]
  41b574:	bd70      	pop	{r4, r5, r6, pc}
  41b576:	2221      	movs	r2, #33	; 0x21
  41b578:	2104      	movs	r1, #4
  41b57a:	f000 fef5 	bl	41c368 <_calloc_r>
  41b57e:	64e8      	str	r0, [r5, #76]	; 0x4c
  41b580:	4603      	mov	r3, r0
  41b582:	2800      	cmp	r0, #0
  41b584:	d1ed      	bne.n	41b562 <_Balloc+0xa>
  41b586:	2000      	movs	r0, #0
  41b588:	bd70      	pop	{r4, r5, r6, pc}
  41b58a:	2101      	movs	r1, #1
  41b58c:	fa01 f604 	lsl.w	r6, r1, r4
  41b590:	1d72      	adds	r2, r6, #5
  41b592:	4628      	mov	r0, r5
  41b594:	0092      	lsls	r2, r2, #2
  41b596:	f000 fee7 	bl	41c368 <_calloc_r>
  41b59a:	2800      	cmp	r0, #0
  41b59c:	d0f3      	beq.n	41b586 <_Balloc+0x2e>
  41b59e:	6044      	str	r4, [r0, #4]
  41b5a0:	6086      	str	r6, [r0, #8]
  41b5a2:	e7e4      	b.n	41b56e <_Balloc+0x16>

0041b5a4 <_Bfree>:
  41b5a4:	b131      	cbz	r1, 41b5b4 <_Bfree+0x10>
  41b5a6:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
  41b5a8:	684a      	ldr	r2, [r1, #4]
  41b5aa:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
  41b5ae:	6008      	str	r0, [r1, #0]
  41b5b0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  41b5b4:	4770      	bx	lr
  41b5b6:	bf00      	nop

0041b5b8 <__multadd>:
  41b5b8:	b5f0      	push	{r4, r5, r6, r7, lr}
  41b5ba:	690c      	ldr	r4, [r1, #16]
  41b5bc:	b083      	sub	sp, #12
  41b5be:	460d      	mov	r5, r1
  41b5c0:	4606      	mov	r6, r0
  41b5c2:	f101 0e14 	add.w	lr, r1, #20
  41b5c6:	2700      	movs	r7, #0
  41b5c8:	f8de 0000 	ldr.w	r0, [lr]
  41b5cc:	b281      	uxth	r1, r0
  41b5ce:	fb02 3301 	mla	r3, r2, r1, r3
  41b5d2:	0c01      	lsrs	r1, r0, #16
  41b5d4:	0c18      	lsrs	r0, r3, #16
  41b5d6:	fb02 0101 	mla	r1, r2, r1, r0
  41b5da:	b29b      	uxth	r3, r3
  41b5dc:	3701      	adds	r7, #1
  41b5de:	eb03 4301 	add.w	r3, r3, r1, lsl #16
  41b5e2:	42bc      	cmp	r4, r7
  41b5e4:	f84e 3b04 	str.w	r3, [lr], #4
  41b5e8:	ea4f 4311 	mov.w	r3, r1, lsr #16
  41b5ec:	dcec      	bgt.n	41b5c8 <__multadd+0x10>
  41b5ee:	b13b      	cbz	r3, 41b600 <__multadd+0x48>
  41b5f0:	68aa      	ldr	r2, [r5, #8]
  41b5f2:	4294      	cmp	r4, r2
  41b5f4:	da07      	bge.n	41b606 <__multadd+0x4e>
  41b5f6:	eb05 0284 	add.w	r2, r5, r4, lsl #2
  41b5fa:	3401      	adds	r4, #1
  41b5fc:	6153      	str	r3, [r2, #20]
  41b5fe:	612c      	str	r4, [r5, #16]
  41b600:	4628      	mov	r0, r5
  41b602:	b003      	add	sp, #12
  41b604:	bdf0      	pop	{r4, r5, r6, r7, pc}
  41b606:	6869      	ldr	r1, [r5, #4]
  41b608:	9301      	str	r3, [sp, #4]
  41b60a:	3101      	adds	r1, #1
  41b60c:	4630      	mov	r0, r6
  41b60e:	f7ff ffa3 	bl	41b558 <_Balloc>
  41b612:	692a      	ldr	r2, [r5, #16]
  41b614:	3202      	adds	r2, #2
  41b616:	f105 010c 	add.w	r1, r5, #12
  41b61a:	4607      	mov	r7, r0
  41b61c:	0092      	lsls	r2, r2, #2
  41b61e:	300c      	adds	r0, #12
  41b620:	f7fb fb70 	bl	416d04 <memcpy>
  41b624:	6cf2      	ldr	r2, [r6, #76]	; 0x4c
  41b626:	6869      	ldr	r1, [r5, #4]
  41b628:	9b01      	ldr	r3, [sp, #4]
  41b62a:	f852 0021 	ldr.w	r0, [r2, r1, lsl #2]
  41b62e:	6028      	str	r0, [r5, #0]
  41b630:	f842 5021 	str.w	r5, [r2, r1, lsl #2]
  41b634:	463d      	mov	r5, r7
  41b636:	e7de      	b.n	41b5f6 <__multadd+0x3e>

0041b638 <__hi0bits>:
  41b638:	0c02      	lsrs	r2, r0, #16
  41b63a:	0412      	lsls	r2, r2, #16
  41b63c:	4603      	mov	r3, r0
  41b63e:	b9b2      	cbnz	r2, 41b66e <__hi0bits+0x36>
  41b640:	0403      	lsls	r3, r0, #16
  41b642:	2010      	movs	r0, #16
  41b644:	f013 4f7f 	tst.w	r3, #4278190080	; 0xff000000
  41b648:	bf04      	itt	eq
  41b64a:	021b      	lsleq	r3, r3, #8
  41b64c:	3008      	addeq	r0, #8
  41b64e:	f013 4f70 	tst.w	r3, #4026531840	; 0xf0000000
  41b652:	bf04      	itt	eq
  41b654:	011b      	lsleq	r3, r3, #4
  41b656:	3004      	addeq	r0, #4
  41b658:	f013 4f40 	tst.w	r3, #3221225472	; 0xc0000000
  41b65c:	bf04      	itt	eq
  41b65e:	009b      	lsleq	r3, r3, #2
  41b660:	3002      	addeq	r0, #2
  41b662:	2b00      	cmp	r3, #0
  41b664:	db02      	blt.n	41b66c <__hi0bits+0x34>
  41b666:	005b      	lsls	r3, r3, #1
  41b668:	d403      	bmi.n	41b672 <__hi0bits+0x3a>
  41b66a:	2020      	movs	r0, #32
  41b66c:	4770      	bx	lr
  41b66e:	2000      	movs	r0, #0
  41b670:	e7e8      	b.n	41b644 <__hi0bits+0xc>
  41b672:	3001      	adds	r0, #1
  41b674:	4770      	bx	lr
  41b676:	bf00      	nop

0041b678 <__lo0bits>:
  41b678:	6803      	ldr	r3, [r0, #0]
  41b67a:	f013 0207 	ands.w	r2, r3, #7
  41b67e:	4601      	mov	r1, r0
  41b680:	d007      	beq.n	41b692 <__lo0bits+0x1a>
  41b682:	07da      	lsls	r2, r3, #31
  41b684:	d421      	bmi.n	41b6ca <__lo0bits+0x52>
  41b686:	0798      	lsls	r0, r3, #30
  41b688:	d421      	bmi.n	41b6ce <__lo0bits+0x56>
  41b68a:	089b      	lsrs	r3, r3, #2
  41b68c:	600b      	str	r3, [r1, #0]
  41b68e:	2002      	movs	r0, #2
  41b690:	4770      	bx	lr
  41b692:	b298      	uxth	r0, r3
  41b694:	b198      	cbz	r0, 41b6be <__lo0bits+0x46>
  41b696:	4610      	mov	r0, r2
  41b698:	f013 0fff 	tst.w	r3, #255	; 0xff
  41b69c:	bf04      	itt	eq
  41b69e:	0a1b      	lsreq	r3, r3, #8
  41b6a0:	3008      	addeq	r0, #8
  41b6a2:	071a      	lsls	r2, r3, #28
  41b6a4:	bf04      	itt	eq
  41b6a6:	091b      	lsreq	r3, r3, #4
  41b6a8:	3004      	addeq	r0, #4
  41b6aa:	079a      	lsls	r2, r3, #30
  41b6ac:	bf04      	itt	eq
  41b6ae:	089b      	lsreq	r3, r3, #2
  41b6b0:	3002      	addeq	r0, #2
  41b6b2:	07da      	lsls	r2, r3, #31
  41b6b4:	d407      	bmi.n	41b6c6 <__lo0bits+0x4e>
  41b6b6:	085b      	lsrs	r3, r3, #1
  41b6b8:	d104      	bne.n	41b6c4 <__lo0bits+0x4c>
  41b6ba:	2020      	movs	r0, #32
  41b6bc:	4770      	bx	lr
  41b6be:	0c1b      	lsrs	r3, r3, #16
  41b6c0:	2010      	movs	r0, #16
  41b6c2:	e7e9      	b.n	41b698 <__lo0bits+0x20>
  41b6c4:	3001      	adds	r0, #1
  41b6c6:	600b      	str	r3, [r1, #0]
  41b6c8:	4770      	bx	lr
  41b6ca:	2000      	movs	r0, #0
  41b6cc:	4770      	bx	lr
  41b6ce:	085b      	lsrs	r3, r3, #1
  41b6d0:	600b      	str	r3, [r1, #0]
  41b6d2:	2001      	movs	r0, #1
  41b6d4:	4770      	bx	lr
  41b6d6:	bf00      	nop

0041b6d8 <__i2b>:
  41b6d8:	b510      	push	{r4, lr}
  41b6da:	460c      	mov	r4, r1
  41b6dc:	2101      	movs	r1, #1
  41b6de:	f7ff ff3b 	bl	41b558 <_Balloc>
  41b6e2:	2201      	movs	r2, #1
  41b6e4:	6144      	str	r4, [r0, #20]
  41b6e6:	6102      	str	r2, [r0, #16]
  41b6e8:	bd10      	pop	{r4, pc}
  41b6ea:	bf00      	nop

0041b6ec <__multiply>:
  41b6ec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  41b6f0:	690c      	ldr	r4, [r1, #16]
  41b6f2:	6915      	ldr	r5, [r2, #16]
  41b6f4:	42ac      	cmp	r4, r5
  41b6f6:	b083      	sub	sp, #12
  41b6f8:	468b      	mov	fp, r1
  41b6fa:	4616      	mov	r6, r2
  41b6fc:	da04      	bge.n	41b708 <__multiply+0x1c>
  41b6fe:	4622      	mov	r2, r4
  41b700:	46b3      	mov	fp, r6
  41b702:	462c      	mov	r4, r5
  41b704:	460e      	mov	r6, r1
  41b706:	4615      	mov	r5, r2
  41b708:	f8db 3008 	ldr.w	r3, [fp, #8]
  41b70c:	f8db 1004 	ldr.w	r1, [fp, #4]
  41b710:	eb04 0805 	add.w	r8, r4, r5
  41b714:	4598      	cmp	r8, r3
  41b716:	bfc8      	it	gt
  41b718:	3101      	addgt	r1, #1
  41b71a:	f7ff ff1d 	bl	41b558 <_Balloc>
  41b71e:	f100 0914 	add.w	r9, r0, #20
  41b722:	eb09 0a88 	add.w	sl, r9, r8, lsl #2
  41b726:	45d1      	cmp	r9, sl
  41b728:	9000      	str	r0, [sp, #0]
  41b72a:	d205      	bcs.n	41b738 <__multiply+0x4c>
  41b72c:	464b      	mov	r3, r9
  41b72e:	2100      	movs	r1, #0
  41b730:	f843 1b04 	str.w	r1, [r3], #4
  41b734:	459a      	cmp	sl, r3
  41b736:	d8fb      	bhi.n	41b730 <__multiply+0x44>
  41b738:	f106 0c14 	add.w	ip, r6, #20
  41b73c:	eb0c 0385 	add.w	r3, ip, r5, lsl #2
  41b740:	f10b 0b14 	add.w	fp, fp, #20
  41b744:	459c      	cmp	ip, r3
  41b746:	eb0b 0e84 	add.w	lr, fp, r4, lsl #2
  41b74a:	d24c      	bcs.n	41b7e6 <__multiply+0xfa>
  41b74c:	f8cd a004 	str.w	sl, [sp, #4]
  41b750:	469a      	mov	sl, r3
  41b752:	f8dc 5000 	ldr.w	r5, [ip]
  41b756:	b2af      	uxth	r7, r5
  41b758:	b1ef      	cbz	r7, 41b796 <__multiply+0xaa>
  41b75a:	2100      	movs	r1, #0
  41b75c:	464d      	mov	r5, r9
  41b75e:	465e      	mov	r6, fp
  41b760:	460c      	mov	r4, r1
  41b762:	f856 2b04 	ldr.w	r2, [r6], #4
  41b766:	6828      	ldr	r0, [r5, #0]
  41b768:	b293      	uxth	r3, r2
  41b76a:	b281      	uxth	r1, r0
  41b76c:	fb07 1303 	mla	r3, r7, r3, r1
  41b770:	0c12      	lsrs	r2, r2, #16
  41b772:	0c01      	lsrs	r1, r0, #16
  41b774:	4423      	add	r3, r4
  41b776:	fb07 1102 	mla	r1, r7, r2, r1
  41b77a:	eb01 4113 	add.w	r1, r1, r3, lsr #16
  41b77e:	b29b      	uxth	r3, r3
  41b780:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
  41b784:	45b6      	cmp	lr, r6
  41b786:	f845 3b04 	str.w	r3, [r5], #4
  41b78a:	ea4f 4411 	mov.w	r4, r1, lsr #16
  41b78e:	d8e8      	bhi.n	41b762 <__multiply+0x76>
  41b790:	602c      	str	r4, [r5, #0]
  41b792:	f8dc 5000 	ldr.w	r5, [ip]
  41b796:	0c2d      	lsrs	r5, r5, #16
  41b798:	d01d      	beq.n	41b7d6 <__multiply+0xea>
  41b79a:	f8d9 3000 	ldr.w	r3, [r9]
  41b79e:	4648      	mov	r0, r9
  41b7a0:	461c      	mov	r4, r3
  41b7a2:	4659      	mov	r1, fp
  41b7a4:	2200      	movs	r2, #0
  41b7a6:	880e      	ldrh	r6, [r1, #0]
  41b7a8:	0c24      	lsrs	r4, r4, #16
  41b7aa:	fb05 4406 	mla	r4, r5, r6, r4
  41b7ae:	4422      	add	r2, r4
  41b7b0:	b29b      	uxth	r3, r3
  41b7b2:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  41b7b6:	f840 3b04 	str.w	r3, [r0], #4
  41b7ba:	f851 3b04 	ldr.w	r3, [r1], #4
  41b7be:	6804      	ldr	r4, [r0, #0]
  41b7c0:	0c1b      	lsrs	r3, r3, #16
  41b7c2:	b2a6      	uxth	r6, r4
  41b7c4:	fb05 6303 	mla	r3, r5, r3, r6
  41b7c8:	eb03 4312 	add.w	r3, r3, r2, lsr #16
  41b7cc:	458e      	cmp	lr, r1
  41b7ce:	ea4f 4213 	mov.w	r2, r3, lsr #16
  41b7d2:	d8e8      	bhi.n	41b7a6 <__multiply+0xba>
  41b7d4:	6003      	str	r3, [r0, #0]
  41b7d6:	f10c 0c04 	add.w	ip, ip, #4
  41b7da:	45e2      	cmp	sl, ip
  41b7dc:	f109 0904 	add.w	r9, r9, #4
  41b7e0:	d8b7      	bhi.n	41b752 <__multiply+0x66>
  41b7e2:	f8dd a004 	ldr.w	sl, [sp, #4]
  41b7e6:	f1b8 0f00 	cmp.w	r8, #0
  41b7ea:	dd0b      	ble.n	41b804 <__multiply+0x118>
  41b7ec:	f85a 3c04 	ldr.w	r3, [sl, #-4]
  41b7f0:	f1aa 0a04 	sub.w	sl, sl, #4
  41b7f4:	b11b      	cbz	r3, 41b7fe <__multiply+0x112>
  41b7f6:	e005      	b.n	41b804 <__multiply+0x118>
  41b7f8:	f85a 3d04 	ldr.w	r3, [sl, #-4]!
  41b7fc:	b913      	cbnz	r3, 41b804 <__multiply+0x118>
  41b7fe:	f1b8 0801 	subs.w	r8, r8, #1
  41b802:	d1f9      	bne.n	41b7f8 <__multiply+0x10c>
  41b804:	9800      	ldr	r0, [sp, #0]
  41b806:	f8c0 8010 	str.w	r8, [r0, #16]
  41b80a:	b003      	add	sp, #12
  41b80c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0041b810 <__pow5mult>:
  41b810:	f012 0303 	ands.w	r3, r2, #3
  41b814:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  41b818:	4614      	mov	r4, r2
  41b81a:	4607      	mov	r7, r0
  41b81c:	d12e      	bne.n	41b87c <__pow5mult+0x6c>
  41b81e:	460d      	mov	r5, r1
  41b820:	10a4      	asrs	r4, r4, #2
  41b822:	d01c      	beq.n	41b85e <__pow5mult+0x4e>
  41b824:	6cbe      	ldr	r6, [r7, #72]	; 0x48
  41b826:	b396      	cbz	r6, 41b88e <__pow5mult+0x7e>
  41b828:	07e3      	lsls	r3, r4, #31
  41b82a:	f04f 0800 	mov.w	r8, #0
  41b82e:	d406      	bmi.n	41b83e <__pow5mult+0x2e>
  41b830:	1064      	asrs	r4, r4, #1
  41b832:	d014      	beq.n	41b85e <__pow5mult+0x4e>
  41b834:	6830      	ldr	r0, [r6, #0]
  41b836:	b1a8      	cbz	r0, 41b864 <__pow5mult+0x54>
  41b838:	4606      	mov	r6, r0
  41b83a:	07e3      	lsls	r3, r4, #31
  41b83c:	d5f8      	bpl.n	41b830 <__pow5mult+0x20>
  41b83e:	4632      	mov	r2, r6
  41b840:	4629      	mov	r1, r5
  41b842:	4638      	mov	r0, r7
  41b844:	f7ff ff52 	bl	41b6ec <__multiply>
  41b848:	b1b5      	cbz	r5, 41b878 <__pow5mult+0x68>
  41b84a:	686a      	ldr	r2, [r5, #4]
  41b84c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  41b84e:	1064      	asrs	r4, r4, #1
  41b850:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
  41b854:	6029      	str	r1, [r5, #0]
  41b856:	f843 5022 	str.w	r5, [r3, r2, lsl #2]
  41b85a:	4605      	mov	r5, r0
  41b85c:	d1ea      	bne.n	41b834 <__pow5mult+0x24>
  41b85e:	4628      	mov	r0, r5
  41b860:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  41b864:	4632      	mov	r2, r6
  41b866:	4631      	mov	r1, r6
  41b868:	4638      	mov	r0, r7
  41b86a:	f7ff ff3f 	bl	41b6ec <__multiply>
  41b86e:	6030      	str	r0, [r6, #0]
  41b870:	f8c0 8000 	str.w	r8, [r0]
  41b874:	4606      	mov	r6, r0
  41b876:	e7e0      	b.n	41b83a <__pow5mult+0x2a>
  41b878:	4605      	mov	r5, r0
  41b87a:	e7d9      	b.n	41b830 <__pow5mult+0x20>
  41b87c:	1e5a      	subs	r2, r3, #1
  41b87e:	4d0b      	ldr	r5, [pc, #44]	; (41b8ac <__pow5mult+0x9c>)
  41b880:	2300      	movs	r3, #0
  41b882:	f855 2022 	ldr.w	r2, [r5, r2, lsl #2]
  41b886:	f7ff fe97 	bl	41b5b8 <__multadd>
  41b88a:	4605      	mov	r5, r0
  41b88c:	e7c8      	b.n	41b820 <__pow5mult+0x10>
  41b88e:	2101      	movs	r1, #1
  41b890:	4638      	mov	r0, r7
  41b892:	f7ff fe61 	bl	41b558 <_Balloc>
  41b896:	f240 2171 	movw	r1, #625	; 0x271
  41b89a:	2201      	movs	r2, #1
  41b89c:	2300      	movs	r3, #0
  41b89e:	6141      	str	r1, [r0, #20]
  41b8a0:	6102      	str	r2, [r0, #16]
  41b8a2:	4606      	mov	r6, r0
  41b8a4:	64b8      	str	r0, [r7, #72]	; 0x48
  41b8a6:	6003      	str	r3, [r0, #0]
  41b8a8:	e7be      	b.n	41b828 <__pow5mult+0x18>
  41b8aa:	bf00      	nop
  41b8ac:	0041eb68 	.word	0x0041eb68

0041b8b0 <__lshift>:
  41b8b0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  41b8b4:	4691      	mov	r9, r2
  41b8b6:	690a      	ldr	r2, [r1, #16]
  41b8b8:	688b      	ldr	r3, [r1, #8]
  41b8ba:	ea4f 1469 	mov.w	r4, r9, asr #5
  41b8be:	eb04 0802 	add.w	r8, r4, r2
  41b8c2:	f108 0501 	add.w	r5, r8, #1
  41b8c6:	429d      	cmp	r5, r3
  41b8c8:	460e      	mov	r6, r1
  41b8ca:	4607      	mov	r7, r0
  41b8cc:	6849      	ldr	r1, [r1, #4]
  41b8ce:	dd04      	ble.n	41b8da <__lshift+0x2a>
  41b8d0:	005b      	lsls	r3, r3, #1
  41b8d2:	429d      	cmp	r5, r3
  41b8d4:	f101 0101 	add.w	r1, r1, #1
  41b8d8:	dcfa      	bgt.n	41b8d0 <__lshift+0x20>
  41b8da:	4638      	mov	r0, r7
  41b8dc:	f7ff fe3c 	bl	41b558 <_Balloc>
  41b8e0:	2c00      	cmp	r4, #0
  41b8e2:	f100 0314 	add.w	r3, r0, #20
  41b8e6:	dd06      	ble.n	41b8f6 <__lshift+0x46>
  41b8e8:	eb03 0284 	add.w	r2, r3, r4, lsl #2
  41b8ec:	2100      	movs	r1, #0
  41b8ee:	f843 1b04 	str.w	r1, [r3], #4
  41b8f2:	429a      	cmp	r2, r3
  41b8f4:	d1fb      	bne.n	41b8ee <__lshift+0x3e>
  41b8f6:	6934      	ldr	r4, [r6, #16]
  41b8f8:	f106 0114 	add.w	r1, r6, #20
  41b8fc:	f019 091f 	ands.w	r9, r9, #31
  41b900:	eb01 0e84 	add.w	lr, r1, r4, lsl #2
  41b904:	d01d      	beq.n	41b942 <__lshift+0x92>
  41b906:	f1c9 0c20 	rsb	ip, r9, #32
  41b90a:	2200      	movs	r2, #0
  41b90c:	680c      	ldr	r4, [r1, #0]
  41b90e:	fa04 f409 	lsl.w	r4, r4, r9
  41b912:	4314      	orrs	r4, r2
  41b914:	f843 4b04 	str.w	r4, [r3], #4
  41b918:	f851 2b04 	ldr.w	r2, [r1], #4
  41b91c:	458e      	cmp	lr, r1
  41b91e:	fa22 f20c 	lsr.w	r2, r2, ip
  41b922:	d8f3      	bhi.n	41b90c <__lshift+0x5c>
  41b924:	601a      	str	r2, [r3, #0]
  41b926:	b10a      	cbz	r2, 41b92c <__lshift+0x7c>
  41b928:	f108 0502 	add.w	r5, r8, #2
  41b92c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  41b92e:	6872      	ldr	r2, [r6, #4]
  41b930:	3d01      	subs	r5, #1
  41b932:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
  41b936:	6105      	str	r5, [r0, #16]
  41b938:	6031      	str	r1, [r6, #0]
  41b93a:	f843 6022 	str.w	r6, [r3, r2, lsl #2]
  41b93e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  41b942:	3b04      	subs	r3, #4
  41b944:	f851 2b04 	ldr.w	r2, [r1], #4
  41b948:	f843 2f04 	str.w	r2, [r3, #4]!
  41b94c:	458e      	cmp	lr, r1
  41b94e:	d8f9      	bhi.n	41b944 <__lshift+0x94>
  41b950:	e7ec      	b.n	41b92c <__lshift+0x7c>
  41b952:	bf00      	nop

0041b954 <__mcmp>:
  41b954:	b430      	push	{r4, r5}
  41b956:	690b      	ldr	r3, [r1, #16]
  41b958:	4605      	mov	r5, r0
  41b95a:	6900      	ldr	r0, [r0, #16]
  41b95c:	1ac0      	subs	r0, r0, r3
  41b95e:	d10f      	bne.n	41b980 <__mcmp+0x2c>
  41b960:	009b      	lsls	r3, r3, #2
  41b962:	3514      	adds	r5, #20
  41b964:	3114      	adds	r1, #20
  41b966:	4419      	add	r1, r3
  41b968:	442b      	add	r3, r5
  41b96a:	e001      	b.n	41b970 <__mcmp+0x1c>
  41b96c:	429d      	cmp	r5, r3
  41b96e:	d207      	bcs.n	41b980 <__mcmp+0x2c>
  41b970:	f853 4d04 	ldr.w	r4, [r3, #-4]!
  41b974:	f851 2d04 	ldr.w	r2, [r1, #-4]!
  41b978:	4294      	cmp	r4, r2
  41b97a:	d0f7      	beq.n	41b96c <__mcmp+0x18>
  41b97c:	d302      	bcc.n	41b984 <__mcmp+0x30>
  41b97e:	2001      	movs	r0, #1
  41b980:	bc30      	pop	{r4, r5}
  41b982:	4770      	bx	lr
  41b984:	f04f 30ff 	mov.w	r0, #4294967295
  41b988:	e7fa      	b.n	41b980 <__mcmp+0x2c>
  41b98a:	bf00      	nop

0041b98c <__mdiff>:
  41b98c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  41b990:	690f      	ldr	r7, [r1, #16]
  41b992:	460e      	mov	r6, r1
  41b994:	6911      	ldr	r1, [r2, #16]
  41b996:	1a7f      	subs	r7, r7, r1
  41b998:	2f00      	cmp	r7, #0
  41b99a:	4690      	mov	r8, r2
  41b99c:	d117      	bne.n	41b9ce <__mdiff+0x42>
  41b99e:	0089      	lsls	r1, r1, #2
  41b9a0:	f106 0514 	add.w	r5, r6, #20
  41b9a4:	f102 0e14 	add.w	lr, r2, #20
  41b9a8:	186b      	adds	r3, r5, r1
  41b9aa:	4471      	add	r1, lr
  41b9ac:	e001      	b.n	41b9b2 <__mdiff+0x26>
  41b9ae:	429d      	cmp	r5, r3
  41b9b0:	d25c      	bcs.n	41ba6c <__mdiff+0xe0>
  41b9b2:	f853 2d04 	ldr.w	r2, [r3, #-4]!
  41b9b6:	f851 4d04 	ldr.w	r4, [r1, #-4]!
  41b9ba:	42a2      	cmp	r2, r4
  41b9bc:	d0f7      	beq.n	41b9ae <__mdiff+0x22>
  41b9be:	d25e      	bcs.n	41ba7e <__mdiff+0xf2>
  41b9c0:	4633      	mov	r3, r6
  41b9c2:	462c      	mov	r4, r5
  41b9c4:	4646      	mov	r6, r8
  41b9c6:	4675      	mov	r5, lr
  41b9c8:	4698      	mov	r8, r3
  41b9ca:	2701      	movs	r7, #1
  41b9cc:	e005      	b.n	41b9da <__mdiff+0x4e>
  41b9ce:	db58      	blt.n	41ba82 <__mdiff+0xf6>
  41b9d0:	f106 0514 	add.w	r5, r6, #20
  41b9d4:	f108 0414 	add.w	r4, r8, #20
  41b9d8:	2700      	movs	r7, #0
  41b9da:	6871      	ldr	r1, [r6, #4]
  41b9dc:	f7ff fdbc 	bl	41b558 <_Balloc>
  41b9e0:	f8d8 3010 	ldr.w	r3, [r8, #16]
  41b9e4:	6936      	ldr	r6, [r6, #16]
  41b9e6:	60c7      	str	r7, [r0, #12]
  41b9e8:	eb04 0c83 	add.w	ip, r4, r3, lsl #2
  41b9ec:	46a6      	mov	lr, r4
  41b9ee:	eb05 0786 	add.w	r7, r5, r6, lsl #2
  41b9f2:	f100 0414 	add.w	r4, r0, #20
  41b9f6:	2300      	movs	r3, #0
  41b9f8:	f85e 1b04 	ldr.w	r1, [lr], #4
  41b9fc:	f855 8b04 	ldr.w	r8, [r5], #4
  41ba00:	b28a      	uxth	r2, r1
  41ba02:	fa13 f388 	uxtah	r3, r3, r8
  41ba06:	0c09      	lsrs	r1, r1, #16
  41ba08:	1a9a      	subs	r2, r3, r2
  41ba0a:	ebc1 4318 	rsb	r3, r1, r8, lsr #16
  41ba0e:	eb03 4322 	add.w	r3, r3, r2, asr #16
  41ba12:	b292      	uxth	r2, r2
  41ba14:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
  41ba18:	45f4      	cmp	ip, lr
  41ba1a:	f844 2b04 	str.w	r2, [r4], #4
  41ba1e:	ea4f 4323 	mov.w	r3, r3, asr #16
  41ba22:	d8e9      	bhi.n	41b9f8 <__mdiff+0x6c>
  41ba24:	42af      	cmp	r7, r5
  41ba26:	d917      	bls.n	41ba58 <__mdiff+0xcc>
  41ba28:	46a4      	mov	ip, r4
  41ba2a:	46ae      	mov	lr, r5
  41ba2c:	f85e 2b04 	ldr.w	r2, [lr], #4
  41ba30:	fa13 f382 	uxtah	r3, r3, r2
  41ba34:	1419      	asrs	r1, r3, #16
  41ba36:	eb01 4112 	add.w	r1, r1, r2, lsr #16
  41ba3a:	b29b      	uxth	r3, r3
  41ba3c:	ea43 4201 	orr.w	r2, r3, r1, lsl #16
  41ba40:	4577      	cmp	r7, lr
  41ba42:	f84c 2b04 	str.w	r2, [ip], #4
  41ba46:	ea4f 4321 	mov.w	r3, r1, asr #16
  41ba4a:	d8ef      	bhi.n	41ba2c <__mdiff+0xa0>
  41ba4c:	43ed      	mvns	r5, r5
  41ba4e:	442f      	add	r7, r5
  41ba50:	f027 0703 	bic.w	r7, r7, #3
  41ba54:	3704      	adds	r7, #4
  41ba56:	443c      	add	r4, r7
  41ba58:	3c04      	subs	r4, #4
  41ba5a:	b922      	cbnz	r2, 41ba66 <__mdiff+0xda>
  41ba5c:	f854 3d04 	ldr.w	r3, [r4, #-4]!
  41ba60:	3e01      	subs	r6, #1
  41ba62:	2b00      	cmp	r3, #0
  41ba64:	d0fa      	beq.n	41ba5c <__mdiff+0xd0>
  41ba66:	6106      	str	r6, [r0, #16]
  41ba68:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  41ba6c:	2100      	movs	r1, #0
  41ba6e:	f7ff fd73 	bl	41b558 <_Balloc>
  41ba72:	2201      	movs	r2, #1
  41ba74:	2300      	movs	r3, #0
  41ba76:	6102      	str	r2, [r0, #16]
  41ba78:	6143      	str	r3, [r0, #20]
  41ba7a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  41ba7e:	4674      	mov	r4, lr
  41ba80:	e7ab      	b.n	41b9da <__mdiff+0x4e>
  41ba82:	4633      	mov	r3, r6
  41ba84:	f106 0414 	add.w	r4, r6, #20
  41ba88:	f102 0514 	add.w	r5, r2, #20
  41ba8c:	4616      	mov	r6, r2
  41ba8e:	2701      	movs	r7, #1
  41ba90:	4698      	mov	r8, r3
  41ba92:	e7a2      	b.n	41b9da <__mdiff+0x4e>

0041ba94 <__d2b>:
  41ba94:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  41ba98:	b082      	sub	sp, #8
  41ba9a:	2101      	movs	r1, #1
  41ba9c:	461c      	mov	r4, r3
  41ba9e:	f3c3 570a 	ubfx	r7, r3, #20, #11
  41baa2:	4615      	mov	r5, r2
  41baa4:	9e08      	ldr	r6, [sp, #32]
  41baa6:	f7ff fd57 	bl	41b558 <_Balloc>
  41baaa:	f3c4 0413 	ubfx	r4, r4, #0, #20
  41baae:	4680      	mov	r8, r0
  41bab0:	b10f      	cbz	r7, 41bab6 <__d2b+0x22>
  41bab2:	f444 1480 	orr.w	r4, r4, #1048576	; 0x100000
  41bab6:	9401      	str	r4, [sp, #4]
  41bab8:	b31d      	cbz	r5, 41bb02 <__d2b+0x6e>
  41baba:	a802      	add	r0, sp, #8
  41babc:	f840 5d08 	str.w	r5, [r0, #-8]!
  41bac0:	f7ff fdda 	bl	41b678 <__lo0bits>
  41bac4:	2800      	cmp	r0, #0
  41bac6:	d134      	bne.n	41bb32 <__d2b+0x9e>
  41bac8:	e89d 000c 	ldmia.w	sp, {r2, r3}
  41bacc:	f8c8 2014 	str.w	r2, [r8, #20]
  41bad0:	2b00      	cmp	r3, #0
  41bad2:	bf0c      	ite	eq
  41bad4:	2101      	moveq	r1, #1
  41bad6:	2102      	movne	r1, #2
  41bad8:	f8c8 3018 	str.w	r3, [r8, #24]
  41badc:	f8c8 1010 	str.w	r1, [r8, #16]
  41bae0:	b9df      	cbnz	r7, 41bb1a <__d2b+0x86>
  41bae2:	eb08 0381 	add.w	r3, r8, r1, lsl #2
  41bae6:	f2a0 4032 	subw	r0, r0, #1074	; 0x432
  41baea:	6030      	str	r0, [r6, #0]
  41baec:	6918      	ldr	r0, [r3, #16]
  41baee:	f7ff fda3 	bl	41b638 <__hi0bits>
  41baf2:	9b09      	ldr	r3, [sp, #36]	; 0x24
  41baf4:	ebc0 1041 	rsb	r0, r0, r1, lsl #5
  41baf8:	6018      	str	r0, [r3, #0]
  41bafa:	4640      	mov	r0, r8
  41bafc:	b002      	add	sp, #8
  41bafe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  41bb02:	a801      	add	r0, sp, #4
  41bb04:	f7ff fdb8 	bl	41b678 <__lo0bits>
  41bb08:	9b01      	ldr	r3, [sp, #4]
  41bb0a:	f8c8 3014 	str.w	r3, [r8, #20]
  41bb0e:	2101      	movs	r1, #1
  41bb10:	3020      	adds	r0, #32
  41bb12:	f8c8 1010 	str.w	r1, [r8, #16]
  41bb16:	2f00      	cmp	r7, #0
  41bb18:	d0e3      	beq.n	41bae2 <__d2b+0x4e>
  41bb1a:	9b09      	ldr	r3, [sp, #36]	; 0x24
  41bb1c:	f2a7 4733 	subw	r7, r7, #1075	; 0x433
  41bb20:	4407      	add	r7, r0
  41bb22:	f1c0 0035 	rsb	r0, r0, #53	; 0x35
  41bb26:	6037      	str	r7, [r6, #0]
  41bb28:	6018      	str	r0, [r3, #0]
  41bb2a:	4640      	mov	r0, r8
  41bb2c:	b002      	add	sp, #8
  41bb2e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  41bb32:	e89d 000a 	ldmia.w	sp, {r1, r3}
  41bb36:	f1c0 0220 	rsb	r2, r0, #32
  41bb3a:	fa03 f202 	lsl.w	r2, r3, r2
  41bb3e:	430a      	orrs	r2, r1
  41bb40:	40c3      	lsrs	r3, r0
  41bb42:	9301      	str	r3, [sp, #4]
  41bb44:	f8c8 2014 	str.w	r2, [r8, #20]
  41bb48:	e7c2      	b.n	41bad0 <__d2b+0x3c>
  41bb4a:	bf00      	nop

0041bb4c <_realloc_r>:
  41bb4c:	2900      	cmp	r1, #0
  41bb4e:	f000 8095 	beq.w	41bc7c <_realloc_r+0x130>
  41bb52:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  41bb56:	460d      	mov	r5, r1
  41bb58:	4616      	mov	r6, r2
  41bb5a:	b083      	sub	sp, #12
  41bb5c:	4680      	mov	r8, r0
  41bb5e:	f106 070b 	add.w	r7, r6, #11
  41bb62:	f7ff fced 	bl	41b540 <__malloc_lock>
  41bb66:	f855 ec04 	ldr.w	lr, [r5, #-4]
  41bb6a:	2f16      	cmp	r7, #22
  41bb6c:	f02e 0403 	bic.w	r4, lr, #3
  41bb70:	f1a5 0908 	sub.w	r9, r5, #8
  41bb74:	d83c      	bhi.n	41bbf0 <_realloc_r+0xa4>
  41bb76:	2210      	movs	r2, #16
  41bb78:	4617      	mov	r7, r2
  41bb7a:	42be      	cmp	r6, r7
  41bb7c:	d83d      	bhi.n	41bbfa <_realloc_r+0xae>
  41bb7e:	4294      	cmp	r4, r2
  41bb80:	da43      	bge.n	41bc0a <_realloc_r+0xbe>
  41bb82:	4bc4      	ldr	r3, [pc, #784]	; (41be94 <_realloc_r+0x348>)
  41bb84:	6899      	ldr	r1, [r3, #8]
  41bb86:	eb09 0004 	add.w	r0, r9, r4
  41bb8a:	4288      	cmp	r0, r1
  41bb8c:	f000 80b4 	beq.w	41bcf8 <_realloc_r+0x1ac>
  41bb90:	6843      	ldr	r3, [r0, #4]
  41bb92:	f023 0101 	bic.w	r1, r3, #1
  41bb96:	4401      	add	r1, r0
  41bb98:	6849      	ldr	r1, [r1, #4]
  41bb9a:	07c9      	lsls	r1, r1, #31
  41bb9c:	d54c      	bpl.n	41bc38 <_realloc_r+0xec>
  41bb9e:	f01e 0f01 	tst.w	lr, #1
  41bba2:	f000 809b 	beq.w	41bcdc <_realloc_r+0x190>
  41bba6:	4631      	mov	r1, r6
  41bba8:	4640      	mov	r0, r8
  41bbaa:	f7ff f9ad 	bl	41af08 <_malloc_r>
  41bbae:	4606      	mov	r6, r0
  41bbb0:	2800      	cmp	r0, #0
  41bbb2:	d03a      	beq.n	41bc2a <_realloc_r+0xde>
  41bbb4:	f855 3c04 	ldr.w	r3, [r5, #-4]
  41bbb8:	f023 0301 	bic.w	r3, r3, #1
  41bbbc:	444b      	add	r3, r9
  41bbbe:	f1a0 0208 	sub.w	r2, r0, #8
  41bbc2:	429a      	cmp	r2, r3
  41bbc4:	f000 8121 	beq.w	41be0a <_realloc_r+0x2be>
  41bbc8:	1f22      	subs	r2, r4, #4
  41bbca:	2a24      	cmp	r2, #36	; 0x24
  41bbcc:	f200 8107 	bhi.w	41bdde <_realloc_r+0x292>
  41bbd0:	2a13      	cmp	r2, #19
  41bbd2:	f200 80db 	bhi.w	41bd8c <_realloc_r+0x240>
  41bbd6:	4603      	mov	r3, r0
  41bbd8:	462a      	mov	r2, r5
  41bbda:	6811      	ldr	r1, [r2, #0]
  41bbdc:	6019      	str	r1, [r3, #0]
  41bbde:	6851      	ldr	r1, [r2, #4]
  41bbe0:	6059      	str	r1, [r3, #4]
  41bbe2:	6892      	ldr	r2, [r2, #8]
  41bbe4:	609a      	str	r2, [r3, #8]
  41bbe6:	4629      	mov	r1, r5
  41bbe8:	4640      	mov	r0, r8
  41bbea:	f7fe fe61 	bl	41a8b0 <_free_r>
  41bbee:	e01c      	b.n	41bc2a <_realloc_r+0xde>
  41bbf0:	f027 0707 	bic.w	r7, r7, #7
  41bbf4:	2f00      	cmp	r7, #0
  41bbf6:	463a      	mov	r2, r7
  41bbf8:	dabf      	bge.n	41bb7a <_realloc_r+0x2e>
  41bbfa:	2600      	movs	r6, #0
  41bbfc:	230c      	movs	r3, #12
  41bbfe:	4630      	mov	r0, r6
  41bc00:	f8c8 3000 	str.w	r3, [r8]
  41bc04:	b003      	add	sp, #12
  41bc06:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  41bc0a:	462e      	mov	r6, r5
  41bc0c:	1be3      	subs	r3, r4, r7
  41bc0e:	2b0f      	cmp	r3, #15
  41bc10:	d81e      	bhi.n	41bc50 <_realloc_r+0x104>
  41bc12:	f8d9 3004 	ldr.w	r3, [r9, #4]
  41bc16:	f003 0301 	and.w	r3, r3, #1
  41bc1a:	4323      	orrs	r3, r4
  41bc1c:	444c      	add	r4, r9
  41bc1e:	f8c9 3004 	str.w	r3, [r9, #4]
  41bc22:	6863      	ldr	r3, [r4, #4]
  41bc24:	f043 0301 	orr.w	r3, r3, #1
  41bc28:	6063      	str	r3, [r4, #4]
  41bc2a:	4640      	mov	r0, r8
  41bc2c:	f7ff fc8e 	bl	41b54c <__malloc_unlock>
  41bc30:	4630      	mov	r0, r6
  41bc32:	b003      	add	sp, #12
  41bc34:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  41bc38:	f023 0303 	bic.w	r3, r3, #3
  41bc3c:	18e1      	adds	r1, r4, r3
  41bc3e:	4291      	cmp	r1, r2
  41bc40:	db1f      	blt.n	41bc82 <_realloc_r+0x136>
  41bc42:	68c3      	ldr	r3, [r0, #12]
  41bc44:	6882      	ldr	r2, [r0, #8]
  41bc46:	462e      	mov	r6, r5
  41bc48:	60d3      	str	r3, [r2, #12]
  41bc4a:	460c      	mov	r4, r1
  41bc4c:	609a      	str	r2, [r3, #8]
  41bc4e:	e7dd      	b.n	41bc0c <_realloc_r+0xc0>
  41bc50:	f8d9 2004 	ldr.w	r2, [r9, #4]
  41bc54:	eb09 0107 	add.w	r1, r9, r7
  41bc58:	f002 0201 	and.w	r2, r2, #1
  41bc5c:	444c      	add	r4, r9
  41bc5e:	f043 0301 	orr.w	r3, r3, #1
  41bc62:	4317      	orrs	r7, r2
  41bc64:	f8c9 7004 	str.w	r7, [r9, #4]
  41bc68:	604b      	str	r3, [r1, #4]
  41bc6a:	6863      	ldr	r3, [r4, #4]
  41bc6c:	f043 0301 	orr.w	r3, r3, #1
  41bc70:	3108      	adds	r1, #8
  41bc72:	6063      	str	r3, [r4, #4]
  41bc74:	4640      	mov	r0, r8
  41bc76:	f7fe fe1b 	bl	41a8b0 <_free_r>
  41bc7a:	e7d6      	b.n	41bc2a <_realloc_r+0xde>
  41bc7c:	4611      	mov	r1, r2
  41bc7e:	f7ff b943 	b.w	41af08 <_malloc_r>
  41bc82:	f01e 0f01 	tst.w	lr, #1
  41bc86:	d18e      	bne.n	41bba6 <_realloc_r+0x5a>
  41bc88:	f855 1c08 	ldr.w	r1, [r5, #-8]
  41bc8c:	eba9 0a01 	sub.w	sl, r9, r1
  41bc90:	f8da 1004 	ldr.w	r1, [sl, #4]
  41bc94:	f021 0103 	bic.w	r1, r1, #3
  41bc98:	440b      	add	r3, r1
  41bc9a:	4423      	add	r3, r4
  41bc9c:	4293      	cmp	r3, r2
  41bc9e:	db25      	blt.n	41bcec <_realloc_r+0x1a0>
  41bca0:	68c2      	ldr	r2, [r0, #12]
  41bca2:	6881      	ldr	r1, [r0, #8]
  41bca4:	4656      	mov	r6, sl
  41bca6:	60ca      	str	r2, [r1, #12]
  41bca8:	6091      	str	r1, [r2, #8]
  41bcaa:	f8da 100c 	ldr.w	r1, [sl, #12]
  41bcae:	f856 0f08 	ldr.w	r0, [r6, #8]!
  41bcb2:	1f22      	subs	r2, r4, #4
  41bcb4:	2a24      	cmp	r2, #36	; 0x24
  41bcb6:	60c1      	str	r1, [r0, #12]
  41bcb8:	6088      	str	r0, [r1, #8]
  41bcba:	f200 8094 	bhi.w	41bde6 <_realloc_r+0x29a>
  41bcbe:	2a13      	cmp	r2, #19
  41bcc0:	d96f      	bls.n	41bda2 <_realloc_r+0x256>
  41bcc2:	6829      	ldr	r1, [r5, #0]
  41bcc4:	f8ca 1008 	str.w	r1, [sl, #8]
  41bcc8:	6869      	ldr	r1, [r5, #4]
  41bcca:	f8ca 100c 	str.w	r1, [sl, #12]
  41bcce:	2a1b      	cmp	r2, #27
  41bcd0:	f200 80a2 	bhi.w	41be18 <_realloc_r+0x2cc>
  41bcd4:	3508      	adds	r5, #8
  41bcd6:	f10a 0210 	add.w	r2, sl, #16
  41bcda:	e063      	b.n	41bda4 <_realloc_r+0x258>
  41bcdc:	f855 3c08 	ldr.w	r3, [r5, #-8]
  41bce0:	eba9 0a03 	sub.w	sl, r9, r3
  41bce4:	f8da 1004 	ldr.w	r1, [sl, #4]
  41bce8:	f021 0103 	bic.w	r1, r1, #3
  41bcec:	1863      	adds	r3, r4, r1
  41bcee:	4293      	cmp	r3, r2
  41bcf0:	f6ff af59 	blt.w	41bba6 <_realloc_r+0x5a>
  41bcf4:	4656      	mov	r6, sl
  41bcf6:	e7d8      	b.n	41bcaa <_realloc_r+0x15e>
  41bcf8:	6841      	ldr	r1, [r0, #4]
  41bcfa:	f021 0b03 	bic.w	fp, r1, #3
  41bcfe:	44a3      	add	fp, r4
  41bd00:	f107 0010 	add.w	r0, r7, #16
  41bd04:	4583      	cmp	fp, r0
  41bd06:	da56      	bge.n	41bdb6 <_realloc_r+0x26a>
  41bd08:	f01e 0f01 	tst.w	lr, #1
  41bd0c:	f47f af4b 	bne.w	41bba6 <_realloc_r+0x5a>
  41bd10:	f855 1c08 	ldr.w	r1, [r5, #-8]
  41bd14:	eba9 0a01 	sub.w	sl, r9, r1
  41bd18:	f8da 1004 	ldr.w	r1, [sl, #4]
  41bd1c:	f021 0103 	bic.w	r1, r1, #3
  41bd20:	448b      	add	fp, r1
  41bd22:	4558      	cmp	r0, fp
  41bd24:	dce2      	bgt.n	41bcec <_realloc_r+0x1a0>
  41bd26:	4656      	mov	r6, sl
  41bd28:	f8da 100c 	ldr.w	r1, [sl, #12]
  41bd2c:	f856 0f08 	ldr.w	r0, [r6, #8]!
  41bd30:	1f22      	subs	r2, r4, #4
  41bd32:	2a24      	cmp	r2, #36	; 0x24
  41bd34:	60c1      	str	r1, [r0, #12]
  41bd36:	6088      	str	r0, [r1, #8]
  41bd38:	f200 808f 	bhi.w	41be5a <_realloc_r+0x30e>
  41bd3c:	2a13      	cmp	r2, #19
  41bd3e:	f240 808a 	bls.w	41be56 <_realloc_r+0x30a>
  41bd42:	6829      	ldr	r1, [r5, #0]
  41bd44:	f8ca 1008 	str.w	r1, [sl, #8]
  41bd48:	6869      	ldr	r1, [r5, #4]
  41bd4a:	f8ca 100c 	str.w	r1, [sl, #12]
  41bd4e:	2a1b      	cmp	r2, #27
  41bd50:	f200 808a 	bhi.w	41be68 <_realloc_r+0x31c>
  41bd54:	3508      	adds	r5, #8
  41bd56:	f10a 0210 	add.w	r2, sl, #16
  41bd5a:	6829      	ldr	r1, [r5, #0]
  41bd5c:	6011      	str	r1, [r2, #0]
  41bd5e:	6869      	ldr	r1, [r5, #4]
  41bd60:	6051      	str	r1, [r2, #4]
  41bd62:	68a9      	ldr	r1, [r5, #8]
  41bd64:	6091      	str	r1, [r2, #8]
  41bd66:	eb0a 0107 	add.w	r1, sl, r7
  41bd6a:	ebab 0207 	sub.w	r2, fp, r7
  41bd6e:	f042 0201 	orr.w	r2, r2, #1
  41bd72:	6099      	str	r1, [r3, #8]
  41bd74:	604a      	str	r2, [r1, #4]
  41bd76:	f8da 3004 	ldr.w	r3, [sl, #4]
  41bd7a:	f003 0301 	and.w	r3, r3, #1
  41bd7e:	431f      	orrs	r7, r3
  41bd80:	4640      	mov	r0, r8
  41bd82:	f8ca 7004 	str.w	r7, [sl, #4]
  41bd86:	f7ff fbe1 	bl	41b54c <__malloc_unlock>
  41bd8a:	e751      	b.n	41bc30 <_realloc_r+0xe4>
  41bd8c:	682b      	ldr	r3, [r5, #0]
  41bd8e:	6003      	str	r3, [r0, #0]
  41bd90:	686b      	ldr	r3, [r5, #4]
  41bd92:	6043      	str	r3, [r0, #4]
  41bd94:	2a1b      	cmp	r2, #27
  41bd96:	d82d      	bhi.n	41bdf4 <_realloc_r+0x2a8>
  41bd98:	f100 0308 	add.w	r3, r0, #8
  41bd9c:	f105 0208 	add.w	r2, r5, #8
  41bda0:	e71b      	b.n	41bbda <_realloc_r+0x8e>
  41bda2:	4632      	mov	r2, r6
  41bda4:	6829      	ldr	r1, [r5, #0]
  41bda6:	6011      	str	r1, [r2, #0]
  41bda8:	6869      	ldr	r1, [r5, #4]
  41bdaa:	6051      	str	r1, [r2, #4]
  41bdac:	68a9      	ldr	r1, [r5, #8]
  41bdae:	6091      	str	r1, [r2, #8]
  41bdb0:	461c      	mov	r4, r3
  41bdb2:	46d1      	mov	r9, sl
  41bdb4:	e72a      	b.n	41bc0c <_realloc_r+0xc0>
  41bdb6:	eb09 0107 	add.w	r1, r9, r7
  41bdba:	ebab 0b07 	sub.w	fp, fp, r7
  41bdbe:	f04b 0201 	orr.w	r2, fp, #1
  41bdc2:	6099      	str	r1, [r3, #8]
  41bdc4:	604a      	str	r2, [r1, #4]
  41bdc6:	f855 3c04 	ldr.w	r3, [r5, #-4]
  41bdca:	f003 0301 	and.w	r3, r3, #1
  41bdce:	431f      	orrs	r7, r3
  41bdd0:	4640      	mov	r0, r8
  41bdd2:	f845 7c04 	str.w	r7, [r5, #-4]
  41bdd6:	f7ff fbb9 	bl	41b54c <__malloc_unlock>
  41bdda:	462e      	mov	r6, r5
  41bddc:	e728      	b.n	41bc30 <_realloc_r+0xe4>
  41bdde:	4629      	mov	r1, r5
  41bde0:	f7fb f82a 	bl	416e38 <memmove>
  41bde4:	e6ff      	b.n	41bbe6 <_realloc_r+0x9a>
  41bde6:	4629      	mov	r1, r5
  41bde8:	4630      	mov	r0, r6
  41bdea:	461c      	mov	r4, r3
  41bdec:	46d1      	mov	r9, sl
  41bdee:	f7fb f823 	bl	416e38 <memmove>
  41bdf2:	e70b      	b.n	41bc0c <_realloc_r+0xc0>
  41bdf4:	68ab      	ldr	r3, [r5, #8]
  41bdf6:	6083      	str	r3, [r0, #8]
  41bdf8:	68eb      	ldr	r3, [r5, #12]
  41bdfa:	60c3      	str	r3, [r0, #12]
  41bdfc:	2a24      	cmp	r2, #36	; 0x24
  41bdfe:	d017      	beq.n	41be30 <_realloc_r+0x2e4>
  41be00:	f100 0310 	add.w	r3, r0, #16
  41be04:	f105 0210 	add.w	r2, r5, #16
  41be08:	e6e7      	b.n	41bbda <_realloc_r+0x8e>
  41be0a:	f850 3c04 	ldr.w	r3, [r0, #-4]
  41be0e:	f023 0303 	bic.w	r3, r3, #3
  41be12:	441c      	add	r4, r3
  41be14:	462e      	mov	r6, r5
  41be16:	e6f9      	b.n	41bc0c <_realloc_r+0xc0>
  41be18:	68a9      	ldr	r1, [r5, #8]
  41be1a:	f8ca 1010 	str.w	r1, [sl, #16]
  41be1e:	68e9      	ldr	r1, [r5, #12]
  41be20:	f8ca 1014 	str.w	r1, [sl, #20]
  41be24:	2a24      	cmp	r2, #36	; 0x24
  41be26:	d00c      	beq.n	41be42 <_realloc_r+0x2f6>
  41be28:	3510      	adds	r5, #16
  41be2a:	f10a 0218 	add.w	r2, sl, #24
  41be2e:	e7b9      	b.n	41bda4 <_realloc_r+0x258>
  41be30:	692b      	ldr	r3, [r5, #16]
  41be32:	6103      	str	r3, [r0, #16]
  41be34:	696b      	ldr	r3, [r5, #20]
  41be36:	6143      	str	r3, [r0, #20]
  41be38:	f105 0218 	add.w	r2, r5, #24
  41be3c:	f100 0318 	add.w	r3, r0, #24
  41be40:	e6cb      	b.n	41bbda <_realloc_r+0x8e>
  41be42:	692a      	ldr	r2, [r5, #16]
  41be44:	f8ca 2018 	str.w	r2, [sl, #24]
  41be48:	696a      	ldr	r2, [r5, #20]
  41be4a:	f8ca 201c 	str.w	r2, [sl, #28]
  41be4e:	3518      	adds	r5, #24
  41be50:	f10a 0220 	add.w	r2, sl, #32
  41be54:	e7a6      	b.n	41bda4 <_realloc_r+0x258>
  41be56:	4632      	mov	r2, r6
  41be58:	e77f      	b.n	41bd5a <_realloc_r+0x20e>
  41be5a:	4629      	mov	r1, r5
  41be5c:	4630      	mov	r0, r6
  41be5e:	9301      	str	r3, [sp, #4]
  41be60:	f7fa ffea 	bl	416e38 <memmove>
  41be64:	9b01      	ldr	r3, [sp, #4]
  41be66:	e77e      	b.n	41bd66 <_realloc_r+0x21a>
  41be68:	68a9      	ldr	r1, [r5, #8]
  41be6a:	f8ca 1010 	str.w	r1, [sl, #16]
  41be6e:	68e9      	ldr	r1, [r5, #12]
  41be70:	f8ca 1014 	str.w	r1, [sl, #20]
  41be74:	2a24      	cmp	r2, #36	; 0x24
  41be76:	d003      	beq.n	41be80 <_realloc_r+0x334>
  41be78:	3510      	adds	r5, #16
  41be7a:	f10a 0218 	add.w	r2, sl, #24
  41be7e:	e76c      	b.n	41bd5a <_realloc_r+0x20e>
  41be80:	692a      	ldr	r2, [r5, #16]
  41be82:	f8ca 2018 	str.w	r2, [sl, #24]
  41be86:	696a      	ldr	r2, [r5, #20]
  41be88:	f8ca 201c 	str.w	r2, [sl, #28]
  41be8c:	3518      	adds	r5, #24
  41be8e:	f10a 0220 	add.w	r2, sl, #32
  41be92:	e762      	b.n	41bd5a <_realloc_r+0x20e>
  41be94:	20000718 	.word	0x20000718

0041be98 <_sbrk_r>:
  41be98:	b538      	push	{r3, r4, r5, lr}
  41be9a:	4c07      	ldr	r4, [pc, #28]	; (41beb8 <_sbrk_r+0x20>)
  41be9c:	2300      	movs	r3, #0
  41be9e:	4605      	mov	r5, r0
  41bea0:	4608      	mov	r0, r1
  41bea2:	6023      	str	r3, [r4, #0]
  41bea4:	f7eb f878 	bl	406f98 <_sbrk>
  41bea8:	1c43      	adds	r3, r0, #1
  41beaa:	d000      	beq.n	41beae <_sbrk_r+0x16>
  41beac:	bd38      	pop	{r3, r4, r5, pc}
  41beae:	6823      	ldr	r3, [r4, #0]
  41beb0:	2b00      	cmp	r3, #0
  41beb2:	d0fb      	beq.n	41beac <_sbrk_r+0x14>
  41beb4:	602b      	str	r3, [r5, #0]
  41beb6:	bd38      	pop	{r3, r4, r5, pc}
  41beb8:	2000bd18 	.word	0x2000bd18

0041bebc <__sread>:
  41bebc:	b510      	push	{r4, lr}
  41bebe:	460c      	mov	r4, r1
  41bec0:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  41bec4:	f000 fb30 	bl	41c528 <_read_r>
  41bec8:	2800      	cmp	r0, #0
  41beca:	db03      	blt.n	41bed4 <__sread+0x18>
  41becc:	6d23      	ldr	r3, [r4, #80]	; 0x50
  41bece:	4403      	add	r3, r0
  41bed0:	6523      	str	r3, [r4, #80]	; 0x50
  41bed2:	bd10      	pop	{r4, pc}
  41bed4:	89a3      	ldrh	r3, [r4, #12]
  41bed6:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
  41beda:	81a3      	strh	r3, [r4, #12]
  41bedc:	bd10      	pop	{r4, pc}
  41bede:	bf00      	nop

0041bee0 <__swrite>:
  41bee0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  41bee4:	4616      	mov	r6, r2
  41bee6:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
  41beea:	461f      	mov	r7, r3
  41beec:	05d3      	lsls	r3, r2, #23
  41beee:	460c      	mov	r4, r1
  41bef0:	4605      	mov	r5, r0
  41bef2:	d507      	bpl.n	41bf04 <__swrite+0x24>
  41bef4:	2200      	movs	r2, #0
  41bef6:	2302      	movs	r3, #2
  41bef8:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  41befc:	f000 fafe 	bl	41c4fc <_lseek_r>
  41bf00:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
  41bf04:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
  41bf08:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
  41bf0c:	81a2      	strh	r2, [r4, #12]
  41bf0e:	463b      	mov	r3, r7
  41bf10:	4632      	mov	r2, r6
  41bf12:	4628      	mov	r0, r5
  41bf14:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  41bf18:	f000 b9ae 	b.w	41c278 <_write_r>

0041bf1c <__sseek>:
  41bf1c:	b510      	push	{r4, lr}
  41bf1e:	460c      	mov	r4, r1
  41bf20:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  41bf24:	f000 faea 	bl	41c4fc <_lseek_r>
  41bf28:	89a3      	ldrh	r3, [r4, #12]
  41bf2a:	1c42      	adds	r2, r0, #1
  41bf2c:	bf0e      	itee	eq
  41bf2e:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
  41bf32:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
  41bf36:	6520      	strne	r0, [r4, #80]	; 0x50
  41bf38:	81a3      	strh	r3, [r4, #12]
  41bf3a:	bd10      	pop	{r4, pc}

0041bf3c <__sclose>:
  41bf3c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  41bf40:	f000 ba42 	b.w	41c3c8 <_close_r>
	...

0041bf80 <strlen>:
  41bf80:	f890 f000 	pld	[r0]
  41bf84:	e96d 4502 	strd	r4, r5, [sp, #-8]!
  41bf88:	f020 0107 	bic.w	r1, r0, #7
  41bf8c:	f06f 0c00 	mvn.w	ip, #0
  41bf90:	f010 0407 	ands.w	r4, r0, #7
  41bf94:	f891 f020 	pld	[r1, #32]
  41bf98:	f040 8049 	bne.w	41c02e <strlen+0xae>
  41bf9c:	f04f 0400 	mov.w	r4, #0
  41bfa0:	f06f 0007 	mvn.w	r0, #7
  41bfa4:	e9d1 2300 	ldrd	r2, r3, [r1]
  41bfa8:	f891 f040 	pld	[r1, #64]	; 0x40
  41bfac:	f100 0008 	add.w	r0, r0, #8
  41bfb0:	fa82 f24c 	uadd8	r2, r2, ip
  41bfb4:	faa4 f28c 	sel	r2, r4, ip
  41bfb8:	fa83 f34c 	uadd8	r3, r3, ip
  41bfbc:	faa2 f38c 	sel	r3, r2, ip
  41bfc0:	bb4b      	cbnz	r3, 41c016 <strlen+0x96>
  41bfc2:	e9d1 2302 	ldrd	r2, r3, [r1, #8]
  41bfc6:	fa82 f24c 	uadd8	r2, r2, ip
  41bfca:	f100 0008 	add.w	r0, r0, #8
  41bfce:	faa4 f28c 	sel	r2, r4, ip
  41bfd2:	fa83 f34c 	uadd8	r3, r3, ip
  41bfd6:	faa2 f38c 	sel	r3, r2, ip
  41bfda:	b9e3      	cbnz	r3, 41c016 <strlen+0x96>
  41bfdc:	e9d1 2304 	ldrd	r2, r3, [r1, #16]
  41bfe0:	fa82 f24c 	uadd8	r2, r2, ip
  41bfe4:	f100 0008 	add.w	r0, r0, #8
  41bfe8:	faa4 f28c 	sel	r2, r4, ip
  41bfec:	fa83 f34c 	uadd8	r3, r3, ip
  41bff0:	faa2 f38c 	sel	r3, r2, ip
  41bff4:	b97b      	cbnz	r3, 41c016 <strlen+0x96>
  41bff6:	e9d1 2306 	ldrd	r2, r3, [r1, #24]
  41bffa:	f101 0120 	add.w	r1, r1, #32
  41bffe:	fa82 f24c 	uadd8	r2, r2, ip
  41c002:	f100 0008 	add.w	r0, r0, #8
  41c006:	faa4 f28c 	sel	r2, r4, ip
  41c00a:	fa83 f34c 	uadd8	r3, r3, ip
  41c00e:	faa2 f38c 	sel	r3, r2, ip
  41c012:	2b00      	cmp	r3, #0
  41c014:	d0c6      	beq.n	41bfa4 <strlen+0x24>
  41c016:	2a00      	cmp	r2, #0
  41c018:	bf04      	itt	eq
  41c01a:	3004      	addeq	r0, #4
  41c01c:	461a      	moveq	r2, r3
  41c01e:	ba12      	rev	r2, r2
  41c020:	fab2 f282 	clz	r2, r2
  41c024:	e8fd 4502 	ldrd	r4, r5, [sp], #8
  41c028:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
  41c02c:	4770      	bx	lr
  41c02e:	e9d1 2300 	ldrd	r2, r3, [r1]
  41c032:	f004 0503 	and.w	r5, r4, #3
  41c036:	f1c4 0000 	rsb	r0, r4, #0
  41c03a:	ea4f 05c5 	mov.w	r5, r5, lsl #3
  41c03e:	f014 0f04 	tst.w	r4, #4
  41c042:	f891 f040 	pld	[r1, #64]	; 0x40
  41c046:	fa0c f505 	lsl.w	r5, ip, r5
  41c04a:	ea62 0205 	orn	r2, r2, r5
  41c04e:	bf1c      	itt	ne
  41c050:	ea63 0305 	ornne	r3, r3, r5
  41c054:	4662      	movne	r2, ip
  41c056:	f04f 0400 	mov.w	r4, #0
  41c05a:	e7a9      	b.n	41bfb0 <strlen+0x30>

0041c05c <__ssprint_r>:
  41c05c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  41c060:	6893      	ldr	r3, [r2, #8]
  41c062:	b083      	sub	sp, #12
  41c064:	4690      	mov	r8, r2
  41c066:	2b00      	cmp	r3, #0
  41c068:	d070      	beq.n	41c14c <__ssprint_r+0xf0>
  41c06a:	4682      	mov	sl, r0
  41c06c:	460c      	mov	r4, r1
  41c06e:	6817      	ldr	r7, [r2, #0]
  41c070:	688d      	ldr	r5, [r1, #8]
  41c072:	6808      	ldr	r0, [r1, #0]
  41c074:	e042      	b.n	41c0fc <__ssprint_r+0xa0>
  41c076:	89a3      	ldrh	r3, [r4, #12]
  41c078:	f413 6f90 	tst.w	r3, #1152	; 0x480
  41c07c:	d02e      	beq.n	41c0dc <__ssprint_r+0x80>
  41c07e:	6965      	ldr	r5, [r4, #20]
  41c080:	6921      	ldr	r1, [r4, #16]
  41c082:	eb05 0545 	add.w	r5, r5, r5, lsl #1
  41c086:	eba0 0b01 	sub.w	fp, r0, r1
  41c08a:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
  41c08e:	f10b 0001 	add.w	r0, fp, #1
  41c092:	106d      	asrs	r5, r5, #1
  41c094:	4430      	add	r0, r6
  41c096:	42a8      	cmp	r0, r5
  41c098:	462a      	mov	r2, r5
  41c09a:	bf84      	itt	hi
  41c09c:	4605      	movhi	r5, r0
  41c09e:	462a      	movhi	r2, r5
  41c0a0:	055b      	lsls	r3, r3, #21
  41c0a2:	d538      	bpl.n	41c116 <__ssprint_r+0xba>
  41c0a4:	4611      	mov	r1, r2
  41c0a6:	4650      	mov	r0, sl
  41c0a8:	f7fe ff2e 	bl	41af08 <_malloc_r>
  41c0ac:	2800      	cmp	r0, #0
  41c0ae:	d03c      	beq.n	41c12a <__ssprint_r+0xce>
  41c0b0:	465a      	mov	r2, fp
  41c0b2:	6921      	ldr	r1, [r4, #16]
  41c0b4:	9001      	str	r0, [sp, #4]
  41c0b6:	f7fa fe25 	bl	416d04 <memcpy>
  41c0ba:	89a2      	ldrh	r2, [r4, #12]
  41c0bc:	9b01      	ldr	r3, [sp, #4]
  41c0be:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
  41c0c2:	f042 0280 	orr.w	r2, r2, #128	; 0x80
  41c0c6:	81a2      	strh	r2, [r4, #12]
  41c0c8:	eba5 020b 	sub.w	r2, r5, fp
  41c0cc:	eb03 000b 	add.w	r0, r3, fp
  41c0d0:	6165      	str	r5, [r4, #20]
  41c0d2:	6123      	str	r3, [r4, #16]
  41c0d4:	6020      	str	r0, [r4, #0]
  41c0d6:	60a2      	str	r2, [r4, #8]
  41c0d8:	4635      	mov	r5, r6
  41c0da:	46b3      	mov	fp, r6
  41c0dc:	465a      	mov	r2, fp
  41c0de:	4649      	mov	r1, r9
  41c0e0:	f7fa feaa 	bl	416e38 <memmove>
  41c0e4:	f8d8 3008 	ldr.w	r3, [r8, #8]
  41c0e8:	68a2      	ldr	r2, [r4, #8]
  41c0ea:	6820      	ldr	r0, [r4, #0]
  41c0ec:	1b55      	subs	r5, r2, r5
  41c0ee:	4458      	add	r0, fp
  41c0f0:	1b9e      	subs	r6, r3, r6
  41c0f2:	60a5      	str	r5, [r4, #8]
  41c0f4:	6020      	str	r0, [r4, #0]
  41c0f6:	f8c8 6008 	str.w	r6, [r8, #8]
  41c0fa:	b33e      	cbz	r6, 41c14c <__ssprint_r+0xf0>
  41c0fc:	687e      	ldr	r6, [r7, #4]
  41c0fe:	463b      	mov	r3, r7
  41c100:	3708      	adds	r7, #8
  41c102:	2e00      	cmp	r6, #0
  41c104:	d0fa      	beq.n	41c0fc <__ssprint_r+0xa0>
  41c106:	42ae      	cmp	r6, r5
  41c108:	f8d3 9000 	ldr.w	r9, [r3]
  41c10c:	46ab      	mov	fp, r5
  41c10e:	d2b2      	bcs.n	41c076 <__ssprint_r+0x1a>
  41c110:	4635      	mov	r5, r6
  41c112:	46b3      	mov	fp, r6
  41c114:	e7e2      	b.n	41c0dc <__ssprint_r+0x80>
  41c116:	4650      	mov	r0, sl
  41c118:	f7ff fd18 	bl	41bb4c <_realloc_r>
  41c11c:	4603      	mov	r3, r0
  41c11e:	2800      	cmp	r0, #0
  41c120:	d1d2      	bne.n	41c0c8 <__ssprint_r+0x6c>
  41c122:	6921      	ldr	r1, [r4, #16]
  41c124:	4650      	mov	r0, sl
  41c126:	f7fe fbc3 	bl	41a8b0 <_free_r>
  41c12a:	230c      	movs	r3, #12
  41c12c:	f8ca 3000 	str.w	r3, [sl]
  41c130:	89a3      	ldrh	r3, [r4, #12]
  41c132:	2200      	movs	r2, #0
  41c134:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  41c138:	f04f 30ff 	mov.w	r0, #4294967295
  41c13c:	81a3      	strh	r3, [r4, #12]
  41c13e:	f8c8 2008 	str.w	r2, [r8, #8]
  41c142:	f8c8 2004 	str.w	r2, [r8, #4]
  41c146:	b003      	add	sp, #12
  41c148:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  41c14c:	2000      	movs	r0, #0
  41c14e:	f8c8 0004 	str.w	r0, [r8, #4]
  41c152:	b003      	add	sp, #12
  41c154:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0041c158 <__swbuf_r>:
  41c158:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  41c15a:	460d      	mov	r5, r1
  41c15c:	4614      	mov	r4, r2
  41c15e:	4606      	mov	r6, r0
  41c160:	b110      	cbz	r0, 41c168 <__swbuf_r+0x10>
  41c162:	6b83      	ldr	r3, [r0, #56]	; 0x38
  41c164:	2b00      	cmp	r3, #0
  41c166:	d04b      	beq.n	41c200 <__swbuf_r+0xa8>
  41c168:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
  41c16c:	69a3      	ldr	r3, [r4, #24]
  41c16e:	60a3      	str	r3, [r4, #8]
  41c170:	b291      	uxth	r1, r2
  41c172:	0708      	lsls	r0, r1, #28
  41c174:	d539      	bpl.n	41c1ea <__swbuf_r+0x92>
  41c176:	6923      	ldr	r3, [r4, #16]
  41c178:	2b00      	cmp	r3, #0
  41c17a:	d036      	beq.n	41c1ea <__swbuf_r+0x92>
  41c17c:	b2ed      	uxtb	r5, r5
  41c17e:	0489      	lsls	r1, r1, #18
  41c180:	462f      	mov	r7, r5
  41c182:	d515      	bpl.n	41c1b0 <__swbuf_r+0x58>
  41c184:	6822      	ldr	r2, [r4, #0]
  41c186:	6961      	ldr	r1, [r4, #20]
  41c188:	1ad3      	subs	r3, r2, r3
  41c18a:	428b      	cmp	r3, r1
  41c18c:	da1c      	bge.n	41c1c8 <__swbuf_r+0x70>
  41c18e:	3301      	adds	r3, #1
  41c190:	68a1      	ldr	r1, [r4, #8]
  41c192:	1c50      	adds	r0, r2, #1
  41c194:	3901      	subs	r1, #1
  41c196:	60a1      	str	r1, [r4, #8]
  41c198:	6020      	str	r0, [r4, #0]
  41c19a:	7015      	strb	r5, [r2, #0]
  41c19c:	6962      	ldr	r2, [r4, #20]
  41c19e:	429a      	cmp	r2, r3
  41c1a0:	d01a      	beq.n	41c1d8 <__swbuf_r+0x80>
  41c1a2:	89a3      	ldrh	r3, [r4, #12]
  41c1a4:	07db      	lsls	r3, r3, #31
  41c1a6:	d501      	bpl.n	41c1ac <__swbuf_r+0x54>
  41c1a8:	2d0a      	cmp	r5, #10
  41c1aa:	d015      	beq.n	41c1d8 <__swbuf_r+0x80>
  41c1ac:	4638      	mov	r0, r7
  41c1ae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  41c1b0:	6e61      	ldr	r1, [r4, #100]	; 0x64
  41c1b2:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
  41c1b6:	f421 5100 	bic.w	r1, r1, #8192	; 0x2000
  41c1ba:	81a2      	strh	r2, [r4, #12]
  41c1bc:	6822      	ldr	r2, [r4, #0]
  41c1be:	6661      	str	r1, [r4, #100]	; 0x64
  41c1c0:	6961      	ldr	r1, [r4, #20]
  41c1c2:	1ad3      	subs	r3, r2, r3
  41c1c4:	428b      	cmp	r3, r1
  41c1c6:	dbe2      	blt.n	41c18e <__swbuf_r+0x36>
  41c1c8:	4621      	mov	r1, r4
  41c1ca:	4630      	mov	r0, r6
  41c1cc:	f7fe f9f2 	bl	41a5b4 <_fflush_r>
  41c1d0:	b940      	cbnz	r0, 41c1e4 <__swbuf_r+0x8c>
  41c1d2:	6822      	ldr	r2, [r4, #0]
  41c1d4:	2301      	movs	r3, #1
  41c1d6:	e7db      	b.n	41c190 <__swbuf_r+0x38>
  41c1d8:	4621      	mov	r1, r4
  41c1da:	4630      	mov	r0, r6
  41c1dc:	f7fe f9ea 	bl	41a5b4 <_fflush_r>
  41c1e0:	2800      	cmp	r0, #0
  41c1e2:	d0e3      	beq.n	41c1ac <__swbuf_r+0x54>
  41c1e4:	f04f 37ff 	mov.w	r7, #4294967295
  41c1e8:	e7e0      	b.n	41c1ac <__swbuf_r+0x54>
  41c1ea:	4621      	mov	r1, r4
  41c1ec:	4630      	mov	r0, r6
  41c1ee:	f7fd f90f 	bl	419410 <__swsetup_r>
  41c1f2:	2800      	cmp	r0, #0
  41c1f4:	d1f6      	bne.n	41c1e4 <__swbuf_r+0x8c>
  41c1f6:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
  41c1fa:	6923      	ldr	r3, [r4, #16]
  41c1fc:	b291      	uxth	r1, r2
  41c1fe:	e7bd      	b.n	41c17c <__swbuf_r+0x24>
  41c200:	f7fe fa30 	bl	41a664 <__sinit>
  41c204:	e7b0      	b.n	41c168 <__swbuf_r+0x10>
  41c206:	bf00      	nop

0041c208 <_wcrtomb_r>:
  41c208:	b5f0      	push	{r4, r5, r6, r7, lr}
  41c20a:	4606      	mov	r6, r0
  41c20c:	b085      	sub	sp, #20
  41c20e:	461f      	mov	r7, r3
  41c210:	b189      	cbz	r1, 41c236 <_wcrtomb_r+0x2e>
  41c212:	4c10      	ldr	r4, [pc, #64]	; (41c254 <_wcrtomb_r+0x4c>)
  41c214:	4d10      	ldr	r5, [pc, #64]	; (41c258 <_wcrtomb_r+0x50>)
  41c216:	6824      	ldr	r4, [r4, #0]
  41c218:	6b64      	ldr	r4, [r4, #52]	; 0x34
  41c21a:	2c00      	cmp	r4, #0
  41c21c:	bf08      	it	eq
  41c21e:	462c      	moveq	r4, r5
  41c220:	f8d4 40e0 	ldr.w	r4, [r4, #224]	; 0xe0
  41c224:	47a0      	blx	r4
  41c226:	1c43      	adds	r3, r0, #1
  41c228:	d103      	bne.n	41c232 <_wcrtomb_r+0x2a>
  41c22a:	2200      	movs	r2, #0
  41c22c:	238a      	movs	r3, #138	; 0x8a
  41c22e:	603a      	str	r2, [r7, #0]
  41c230:	6033      	str	r3, [r6, #0]
  41c232:	b005      	add	sp, #20
  41c234:	bdf0      	pop	{r4, r5, r6, r7, pc}
  41c236:	460c      	mov	r4, r1
  41c238:	4906      	ldr	r1, [pc, #24]	; (41c254 <_wcrtomb_r+0x4c>)
  41c23a:	4a07      	ldr	r2, [pc, #28]	; (41c258 <_wcrtomb_r+0x50>)
  41c23c:	6809      	ldr	r1, [r1, #0]
  41c23e:	6b49      	ldr	r1, [r1, #52]	; 0x34
  41c240:	2900      	cmp	r1, #0
  41c242:	bf08      	it	eq
  41c244:	4611      	moveq	r1, r2
  41c246:	4622      	mov	r2, r4
  41c248:	f8d1 40e0 	ldr.w	r4, [r1, #224]	; 0xe0
  41c24c:	a901      	add	r1, sp, #4
  41c24e:	47a0      	blx	r4
  41c250:	e7e9      	b.n	41c226 <_wcrtomb_r+0x1e>
  41c252:	bf00      	nop
  41c254:	20000178 	.word	0x20000178
  41c258:	200005ac 	.word	0x200005ac

0041c25c <__ascii_wctomb>:
  41c25c:	b121      	cbz	r1, 41c268 <__ascii_wctomb+0xc>
  41c25e:	2aff      	cmp	r2, #255	; 0xff
  41c260:	d804      	bhi.n	41c26c <__ascii_wctomb+0x10>
  41c262:	700a      	strb	r2, [r1, #0]
  41c264:	2001      	movs	r0, #1
  41c266:	4770      	bx	lr
  41c268:	4608      	mov	r0, r1
  41c26a:	4770      	bx	lr
  41c26c:	238a      	movs	r3, #138	; 0x8a
  41c26e:	6003      	str	r3, [r0, #0]
  41c270:	f04f 30ff 	mov.w	r0, #4294967295
  41c274:	4770      	bx	lr
  41c276:	bf00      	nop

0041c278 <_write_r>:
  41c278:	b570      	push	{r4, r5, r6, lr}
  41c27a:	460d      	mov	r5, r1
  41c27c:	4c08      	ldr	r4, [pc, #32]	; (41c2a0 <_write_r+0x28>)
  41c27e:	4611      	mov	r1, r2
  41c280:	4606      	mov	r6, r0
  41c282:	461a      	mov	r2, r3
  41c284:	4628      	mov	r0, r5
  41c286:	2300      	movs	r3, #0
  41c288:	6023      	str	r3, [r4, #0]
  41c28a:	f7e6 fb37 	bl	4028fc <_write>
  41c28e:	1c43      	adds	r3, r0, #1
  41c290:	d000      	beq.n	41c294 <_write_r+0x1c>
  41c292:	bd70      	pop	{r4, r5, r6, pc}
  41c294:	6823      	ldr	r3, [r4, #0]
  41c296:	2b00      	cmp	r3, #0
  41c298:	d0fb      	beq.n	41c292 <_write_r+0x1a>
  41c29a:	6033      	str	r3, [r6, #0]
  41c29c:	bd70      	pop	{r4, r5, r6, pc}
  41c29e:	bf00      	nop
  41c2a0:	2000bd18 	.word	0x2000bd18

0041c2a4 <__register_exitproc>:
  41c2a4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  41c2a8:	4d2c      	ldr	r5, [pc, #176]	; (41c35c <__register_exitproc+0xb8>)
  41c2aa:	4606      	mov	r6, r0
  41c2ac:	6828      	ldr	r0, [r5, #0]
  41c2ae:	4698      	mov	r8, r3
  41c2b0:	460f      	mov	r7, r1
  41c2b2:	4691      	mov	r9, r2
  41c2b4:	f7fe fda4 	bl	41ae00 <__retarget_lock_acquire_recursive>
  41c2b8:	4b29      	ldr	r3, [pc, #164]	; (41c360 <__register_exitproc+0xbc>)
  41c2ba:	681c      	ldr	r4, [r3, #0]
  41c2bc:	f8d4 3148 	ldr.w	r3, [r4, #328]	; 0x148
  41c2c0:	2b00      	cmp	r3, #0
  41c2c2:	d03e      	beq.n	41c342 <__register_exitproc+0x9e>
  41c2c4:	685a      	ldr	r2, [r3, #4]
  41c2c6:	2a1f      	cmp	r2, #31
  41c2c8:	dc1c      	bgt.n	41c304 <__register_exitproc+0x60>
  41c2ca:	f102 0e01 	add.w	lr, r2, #1
  41c2ce:	b176      	cbz	r6, 41c2ee <__register_exitproc+0x4a>
  41c2d0:	eb03 0182 	add.w	r1, r3, r2, lsl #2
  41c2d4:	2401      	movs	r4, #1
  41c2d6:	f8c1 9088 	str.w	r9, [r1, #136]	; 0x88
  41c2da:	f8d3 0188 	ldr.w	r0, [r3, #392]	; 0x188
  41c2de:	4094      	lsls	r4, r2
  41c2e0:	4320      	orrs	r0, r4
  41c2e2:	2e02      	cmp	r6, #2
  41c2e4:	f8c3 0188 	str.w	r0, [r3, #392]	; 0x188
  41c2e8:	f8c1 8108 	str.w	r8, [r1, #264]	; 0x108
  41c2ec:	d023      	beq.n	41c336 <__register_exitproc+0x92>
  41c2ee:	3202      	adds	r2, #2
  41c2f0:	f8c3 e004 	str.w	lr, [r3, #4]
  41c2f4:	6828      	ldr	r0, [r5, #0]
  41c2f6:	f843 7022 	str.w	r7, [r3, r2, lsl #2]
  41c2fa:	f7fe fd83 	bl	41ae04 <__retarget_lock_release_recursive>
  41c2fe:	2000      	movs	r0, #0
  41c300:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  41c304:	4b17      	ldr	r3, [pc, #92]	; (41c364 <__register_exitproc+0xc0>)
  41c306:	b30b      	cbz	r3, 41c34c <__register_exitproc+0xa8>
  41c308:	f44f 70c8 	mov.w	r0, #400	; 0x190
  41c30c:	f7fe fdf4 	bl	41aef8 <malloc>
  41c310:	4603      	mov	r3, r0
  41c312:	b1d8      	cbz	r0, 41c34c <__register_exitproc+0xa8>
  41c314:	f8d4 2148 	ldr.w	r2, [r4, #328]	; 0x148
  41c318:	6002      	str	r2, [r0, #0]
  41c31a:	2100      	movs	r1, #0
  41c31c:	6041      	str	r1, [r0, #4]
  41c31e:	460a      	mov	r2, r1
  41c320:	f8c4 0148 	str.w	r0, [r4, #328]	; 0x148
  41c324:	f04f 0e01 	mov.w	lr, #1
  41c328:	f8c0 1188 	str.w	r1, [r0, #392]	; 0x188
  41c32c:	f8c0 118c 	str.w	r1, [r0, #396]	; 0x18c
  41c330:	2e00      	cmp	r6, #0
  41c332:	d0dc      	beq.n	41c2ee <__register_exitproc+0x4a>
  41c334:	e7cc      	b.n	41c2d0 <__register_exitproc+0x2c>
  41c336:	f8d3 118c 	ldr.w	r1, [r3, #396]	; 0x18c
  41c33a:	430c      	orrs	r4, r1
  41c33c:	f8c3 418c 	str.w	r4, [r3, #396]	; 0x18c
  41c340:	e7d5      	b.n	41c2ee <__register_exitproc+0x4a>
  41c342:	f504 73a6 	add.w	r3, r4, #332	; 0x14c
  41c346:	f8c4 3148 	str.w	r3, [r4, #328]	; 0x148
  41c34a:	e7bb      	b.n	41c2c4 <__register_exitproc+0x20>
  41c34c:	6828      	ldr	r0, [r5, #0]
  41c34e:	f7fe fd59 	bl	41ae04 <__retarget_lock_release_recursive>
  41c352:	f04f 30ff 	mov.w	r0, #4294967295
  41c356:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  41c35a:	bf00      	nop
  41c35c:	200005a8 	.word	0x200005a8
  41c360:	0041e9cc 	.word	0x0041e9cc
  41c364:	0041aef9 	.word	0x0041aef9

0041c368 <_calloc_r>:
  41c368:	b510      	push	{r4, lr}
  41c36a:	fb02 f101 	mul.w	r1, r2, r1
  41c36e:	f7fe fdcb 	bl	41af08 <_malloc_r>
  41c372:	4604      	mov	r4, r0
  41c374:	b1d8      	cbz	r0, 41c3ae <_calloc_r+0x46>
  41c376:	f850 2c04 	ldr.w	r2, [r0, #-4]
  41c37a:	f022 0203 	bic.w	r2, r2, #3
  41c37e:	3a04      	subs	r2, #4
  41c380:	2a24      	cmp	r2, #36	; 0x24
  41c382:	d818      	bhi.n	41c3b6 <_calloc_r+0x4e>
  41c384:	2a13      	cmp	r2, #19
  41c386:	d914      	bls.n	41c3b2 <_calloc_r+0x4a>
  41c388:	2300      	movs	r3, #0
  41c38a:	2a1b      	cmp	r2, #27
  41c38c:	6003      	str	r3, [r0, #0]
  41c38e:	6043      	str	r3, [r0, #4]
  41c390:	d916      	bls.n	41c3c0 <_calloc_r+0x58>
  41c392:	2a24      	cmp	r2, #36	; 0x24
  41c394:	6083      	str	r3, [r0, #8]
  41c396:	60c3      	str	r3, [r0, #12]
  41c398:	bf11      	iteee	ne
  41c39a:	f100 0210 	addne.w	r2, r0, #16
  41c39e:	6103      	streq	r3, [r0, #16]
  41c3a0:	6143      	streq	r3, [r0, #20]
  41c3a2:	f100 0218 	addeq.w	r2, r0, #24
  41c3a6:	2300      	movs	r3, #0
  41c3a8:	6013      	str	r3, [r2, #0]
  41c3aa:	6053      	str	r3, [r2, #4]
  41c3ac:	6093      	str	r3, [r2, #8]
  41c3ae:	4620      	mov	r0, r4
  41c3b0:	bd10      	pop	{r4, pc}
  41c3b2:	4602      	mov	r2, r0
  41c3b4:	e7f7      	b.n	41c3a6 <_calloc_r+0x3e>
  41c3b6:	2100      	movs	r1, #0
  41c3b8:	f7fa fda2 	bl	416f00 <memset>
  41c3bc:	4620      	mov	r0, r4
  41c3be:	bd10      	pop	{r4, pc}
  41c3c0:	f100 0208 	add.w	r2, r0, #8
  41c3c4:	e7ef      	b.n	41c3a6 <_calloc_r+0x3e>
  41c3c6:	bf00      	nop

0041c3c8 <_close_r>:
  41c3c8:	b538      	push	{r3, r4, r5, lr}
  41c3ca:	4c07      	ldr	r4, [pc, #28]	; (41c3e8 <_close_r+0x20>)
  41c3cc:	2300      	movs	r3, #0
  41c3ce:	4605      	mov	r5, r0
  41c3d0:	4608      	mov	r0, r1
  41c3d2:	6023      	str	r3, [r4, #0]
  41c3d4:	f7ea fe0c 	bl	406ff0 <_close>
  41c3d8:	1c43      	adds	r3, r0, #1
  41c3da:	d000      	beq.n	41c3de <_close_r+0x16>
  41c3dc:	bd38      	pop	{r3, r4, r5, pc}
  41c3de:	6823      	ldr	r3, [r4, #0]
  41c3e0:	2b00      	cmp	r3, #0
  41c3e2:	d0fb      	beq.n	41c3dc <_close_r+0x14>
  41c3e4:	602b      	str	r3, [r5, #0]
  41c3e6:	bd38      	pop	{r3, r4, r5, pc}
  41c3e8:	2000bd18 	.word	0x2000bd18

0041c3ec <_fclose_r>:
  41c3ec:	b570      	push	{r4, r5, r6, lr}
  41c3ee:	b159      	cbz	r1, 41c408 <_fclose_r+0x1c>
  41c3f0:	4605      	mov	r5, r0
  41c3f2:	460c      	mov	r4, r1
  41c3f4:	b110      	cbz	r0, 41c3fc <_fclose_r+0x10>
  41c3f6:	6b83      	ldr	r3, [r0, #56]	; 0x38
  41c3f8:	2b00      	cmp	r3, #0
  41c3fa:	d03c      	beq.n	41c476 <_fclose_r+0x8a>
  41c3fc:	6e63      	ldr	r3, [r4, #100]	; 0x64
  41c3fe:	07d8      	lsls	r0, r3, #31
  41c400:	d505      	bpl.n	41c40e <_fclose_r+0x22>
  41c402:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
  41c406:	b92b      	cbnz	r3, 41c414 <_fclose_r+0x28>
  41c408:	2600      	movs	r6, #0
  41c40a:	4630      	mov	r0, r6
  41c40c:	bd70      	pop	{r4, r5, r6, pc}
  41c40e:	89a3      	ldrh	r3, [r4, #12]
  41c410:	0599      	lsls	r1, r3, #22
  41c412:	d53c      	bpl.n	41c48e <_fclose_r+0xa2>
  41c414:	4621      	mov	r1, r4
  41c416:	4628      	mov	r0, r5
  41c418:	f7fe f82c 	bl	41a474 <__sflush_r>
  41c41c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  41c41e:	4606      	mov	r6, r0
  41c420:	b133      	cbz	r3, 41c430 <_fclose_r+0x44>
  41c422:	69e1      	ldr	r1, [r4, #28]
  41c424:	4628      	mov	r0, r5
  41c426:	4798      	blx	r3
  41c428:	2800      	cmp	r0, #0
  41c42a:	bfb8      	it	lt
  41c42c:	f04f 36ff 	movlt.w	r6, #4294967295
  41c430:	89a3      	ldrh	r3, [r4, #12]
  41c432:	061a      	lsls	r2, r3, #24
  41c434:	d422      	bmi.n	41c47c <_fclose_r+0x90>
  41c436:	6b21      	ldr	r1, [r4, #48]	; 0x30
  41c438:	b141      	cbz	r1, 41c44c <_fclose_r+0x60>
  41c43a:	f104 0340 	add.w	r3, r4, #64	; 0x40
  41c43e:	4299      	cmp	r1, r3
  41c440:	d002      	beq.n	41c448 <_fclose_r+0x5c>
  41c442:	4628      	mov	r0, r5
  41c444:	f7fe fa34 	bl	41a8b0 <_free_r>
  41c448:	2300      	movs	r3, #0
  41c44a:	6323      	str	r3, [r4, #48]	; 0x30
  41c44c:	6c61      	ldr	r1, [r4, #68]	; 0x44
  41c44e:	b121      	cbz	r1, 41c45a <_fclose_r+0x6e>
  41c450:	4628      	mov	r0, r5
  41c452:	f7fe fa2d 	bl	41a8b0 <_free_r>
  41c456:	2300      	movs	r3, #0
  41c458:	6463      	str	r3, [r4, #68]	; 0x44
  41c45a:	f7fe f92f 	bl	41a6bc <__sfp_lock_acquire>
  41c45e:	6e63      	ldr	r3, [r4, #100]	; 0x64
  41c460:	2200      	movs	r2, #0
  41c462:	07db      	lsls	r3, r3, #31
  41c464:	81a2      	strh	r2, [r4, #12]
  41c466:	d50e      	bpl.n	41c486 <_fclose_r+0x9a>
  41c468:	6da0      	ldr	r0, [r4, #88]	; 0x58
  41c46a:	f7fe fcc7 	bl	41adfc <__retarget_lock_close_recursive>
  41c46e:	f7fe f92b 	bl	41a6c8 <__sfp_lock_release>
  41c472:	4630      	mov	r0, r6
  41c474:	bd70      	pop	{r4, r5, r6, pc}
  41c476:	f7fe f8f5 	bl	41a664 <__sinit>
  41c47a:	e7bf      	b.n	41c3fc <_fclose_r+0x10>
  41c47c:	6921      	ldr	r1, [r4, #16]
  41c47e:	4628      	mov	r0, r5
  41c480:	f7fe fa16 	bl	41a8b0 <_free_r>
  41c484:	e7d7      	b.n	41c436 <_fclose_r+0x4a>
  41c486:	6da0      	ldr	r0, [r4, #88]	; 0x58
  41c488:	f7fe fcbc 	bl	41ae04 <__retarget_lock_release_recursive>
  41c48c:	e7ec      	b.n	41c468 <_fclose_r+0x7c>
  41c48e:	6da0      	ldr	r0, [r4, #88]	; 0x58
  41c490:	f7fe fcb6 	bl	41ae00 <__retarget_lock_acquire_recursive>
  41c494:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
  41c498:	2b00      	cmp	r3, #0
  41c49a:	d1bb      	bne.n	41c414 <_fclose_r+0x28>
  41c49c:	6e66      	ldr	r6, [r4, #100]	; 0x64
  41c49e:	f016 0601 	ands.w	r6, r6, #1
  41c4a2:	d1b1      	bne.n	41c408 <_fclose_r+0x1c>
  41c4a4:	6da0      	ldr	r0, [r4, #88]	; 0x58
  41c4a6:	f7fe fcad 	bl	41ae04 <__retarget_lock_release_recursive>
  41c4aa:	4630      	mov	r0, r6
  41c4ac:	bd70      	pop	{r4, r5, r6, pc}
  41c4ae:	bf00      	nop

0041c4b0 <_fstat_r>:
  41c4b0:	b538      	push	{r3, r4, r5, lr}
  41c4b2:	460b      	mov	r3, r1
  41c4b4:	4c07      	ldr	r4, [pc, #28]	; (41c4d4 <_fstat_r+0x24>)
  41c4b6:	4605      	mov	r5, r0
  41c4b8:	4611      	mov	r1, r2
  41c4ba:	4618      	mov	r0, r3
  41c4bc:	2300      	movs	r3, #0
  41c4be:	6023      	str	r3, [r4, #0]
  41c4c0:	f7ea fda2 	bl	407008 <_fstat>
  41c4c4:	1c43      	adds	r3, r0, #1
  41c4c6:	d000      	beq.n	41c4ca <_fstat_r+0x1a>
  41c4c8:	bd38      	pop	{r3, r4, r5, pc}
  41c4ca:	6823      	ldr	r3, [r4, #0]
  41c4cc:	2b00      	cmp	r3, #0
  41c4ce:	d0fb      	beq.n	41c4c8 <_fstat_r+0x18>
  41c4d0:	602b      	str	r3, [r5, #0]
  41c4d2:	bd38      	pop	{r3, r4, r5, pc}
  41c4d4:	2000bd18 	.word	0x2000bd18

0041c4d8 <_isatty_r>:
  41c4d8:	b538      	push	{r3, r4, r5, lr}
  41c4da:	4c07      	ldr	r4, [pc, #28]	; (41c4f8 <_isatty_r+0x20>)
  41c4dc:	2300      	movs	r3, #0
  41c4de:	4605      	mov	r5, r0
  41c4e0:	4608      	mov	r0, r1
  41c4e2:	6023      	str	r3, [r4, #0]
  41c4e4:	f7ea fda0 	bl	407028 <_isatty>
  41c4e8:	1c43      	adds	r3, r0, #1
  41c4ea:	d000      	beq.n	41c4ee <_isatty_r+0x16>
  41c4ec:	bd38      	pop	{r3, r4, r5, pc}
  41c4ee:	6823      	ldr	r3, [r4, #0]
  41c4f0:	2b00      	cmp	r3, #0
  41c4f2:	d0fb      	beq.n	41c4ec <_isatty_r+0x14>
  41c4f4:	602b      	str	r3, [r5, #0]
  41c4f6:	bd38      	pop	{r3, r4, r5, pc}
  41c4f8:	2000bd18 	.word	0x2000bd18

0041c4fc <_lseek_r>:
  41c4fc:	b570      	push	{r4, r5, r6, lr}
  41c4fe:	460d      	mov	r5, r1
  41c500:	4c08      	ldr	r4, [pc, #32]	; (41c524 <_lseek_r+0x28>)
  41c502:	4611      	mov	r1, r2
  41c504:	4606      	mov	r6, r0
  41c506:	461a      	mov	r2, r3
  41c508:	4628      	mov	r0, r5
  41c50a:	2300      	movs	r3, #0
  41c50c:	6023      	str	r3, [r4, #0]
  41c50e:	f7ea fd96 	bl	40703e <_lseek>
  41c512:	1c43      	adds	r3, r0, #1
  41c514:	d000      	beq.n	41c518 <_lseek_r+0x1c>
  41c516:	bd70      	pop	{r4, r5, r6, pc}
  41c518:	6823      	ldr	r3, [r4, #0]
  41c51a:	2b00      	cmp	r3, #0
  41c51c:	d0fb      	beq.n	41c516 <_lseek_r+0x1a>
  41c51e:	6033      	str	r3, [r6, #0]
  41c520:	bd70      	pop	{r4, r5, r6, pc}
  41c522:	bf00      	nop
  41c524:	2000bd18 	.word	0x2000bd18

0041c528 <_read_r>:
  41c528:	b570      	push	{r4, r5, r6, lr}
  41c52a:	460d      	mov	r5, r1
  41c52c:	4c08      	ldr	r4, [pc, #32]	; (41c550 <_read_r+0x28>)
  41c52e:	4611      	mov	r1, r2
  41c530:	4606      	mov	r6, r0
  41c532:	461a      	mov	r2, r3
  41c534:	4628      	mov	r0, r5
  41c536:	2300      	movs	r3, #0
  41c538:	6023      	str	r3, [r4, #0]
  41c53a:	f7e6 f9b5 	bl	4028a8 <_read>
  41c53e:	1c43      	adds	r3, r0, #1
  41c540:	d000      	beq.n	41c544 <_read_r+0x1c>
  41c542:	bd70      	pop	{r4, r5, r6, pc}
  41c544:	6823      	ldr	r3, [r4, #0]
  41c546:	2b00      	cmp	r3, #0
  41c548:	d0fb      	beq.n	41c542 <_read_r+0x1a>
  41c54a:	6033      	str	r3, [r6, #0]
  41c54c:	bd70      	pop	{r4, r5, r6, pc}
  41c54e:	bf00      	nop
  41c550:	2000bd18 	.word	0x2000bd18

0041c554 <__aeabi_dcmpun>:
  41c554:	ea4f 0c41 	mov.w	ip, r1, lsl #1
  41c558:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
  41c55c:	d102      	bne.n	41c564 <__aeabi_dcmpun+0x10>
  41c55e:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
  41c562:	d10a      	bne.n	41c57a <__aeabi_dcmpun+0x26>
  41c564:	ea4f 0c43 	mov.w	ip, r3, lsl #1
  41c568:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
  41c56c:	d102      	bne.n	41c574 <__aeabi_dcmpun+0x20>
  41c56e:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
  41c572:	d102      	bne.n	41c57a <__aeabi_dcmpun+0x26>
  41c574:	f04f 0000 	mov.w	r0, #0
  41c578:	4770      	bx	lr
  41c57a:	f04f 0001 	mov.w	r0, #1
  41c57e:	4770      	bx	lr

0041c580 <__aeabi_d2iz>:
  41c580:	ea4f 0241 	mov.w	r2, r1, lsl #1
  41c584:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
  41c588:	d215      	bcs.n	41c5b6 <__aeabi_d2iz+0x36>
  41c58a:	d511      	bpl.n	41c5b0 <__aeabi_d2iz+0x30>
  41c58c:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
  41c590:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
  41c594:	d912      	bls.n	41c5bc <__aeabi_d2iz+0x3c>
  41c596:	ea4f 23c1 	mov.w	r3, r1, lsl #11
  41c59a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
  41c59e:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
  41c5a2:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
  41c5a6:	fa23 f002 	lsr.w	r0, r3, r2
  41c5aa:	bf18      	it	ne
  41c5ac:	4240      	negne	r0, r0
  41c5ae:	4770      	bx	lr
  41c5b0:	f04f 0000 	mov.w	r0, #0
  41c5b4:	4770      	bx	lr
  41c5b6:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
  41c5ba:	d105      	bne.n	41c5c8 <__aeabi_d2iz+0x48>
  41c5bc:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
  41c5c0:	bf08      	it	eq
  41c5c2:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
  41c5c6:	4770      	bx	lr
  41c5c8:	f04f 0000 	mov.w	r0, #0
  41c5cc:	4770      	bx	lr
  41c5ce:	bf00      	nop

0041c5d0 <__aeabi_uldivmod>:
  41c5d0:	b953      	cbnz	r3, 41c5e8 <__aeabi_uldivmod+0x18>
  41c5d2:	b94a      	cbnz	r2, 41c5e8 <__aeabi_uldivmod+0x18>
  41c5d4:	2900      	cmp	r1, #0
  41c5d6:	bf08      	it	eq
  41c5d8:	2800      	cmpeq	r0, #0
  41c5da:	bf1c      	itt	ne
  41c5dc:	f04f 31ff 	movne.w	r1, #4294967295
  41c5e0:	f04f 30ff 	movne.w	r0, #4294967295
  41c5e4:	f000 b97a 	b.w	41c8dc <__aeabi_idiv0>
  41c5e8:	f1ad 0c08 	sub.w	ip, sp, #8
  41c5ec:	e96d ce04 	strd	ip, lr, [sp, #-16]!
  41c5f0:	f000 f806 	bl	41c600 <__udivmoddi4>
  41c5f4:	f8dd e004 	ldr.w	lr, [sp, #4]
  41c5f8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
  41c5fc:	b004      	add	sp, #16
  41c5fe:	4770      	bx	lr

0041c600 <__udivmoddi4>:
  41c600:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  41c604:	468c      	mov	ip, r1
  41c606:	460d      	mov	r5, r1
  41c608:	4604      	mov	r4, r0
  41c60a:	9e08      	ldr	r6, [sp, #32]
  41c60c:	2b00      	cmp	r3, #0
  41c60e:	d151      	bne.n	41c6b4 <__udivmoddi4+0xb4>
  41c610:	428a      	cmp	r2, r1
  41c612:	4617      	mov	r7, r2
  41c614:	d96d      	bls.n	41c6f2 <__udivmoddi4+0xf2>
  41c616:	fab2 fe82 	clz	lr, r2
  41c61a:	f1be 0f00 	cmp.w	lr, #0
  41c61e:	d00b      	beq.n	41c638 <__udivmoddi4+0x38>
  41c620:	f1ce 0c20 	rsb	ip, lr, #32
  41c624:	fa01 f50e 	lsl.w	r5, r1, lr
  41c628:	fa20 fc0c 	lsr.w	ip, r0, ip
  41c62c:	fa02 f70e 	lsl.w	r7, r2, lr
  41c630:	ea4c 0c05 	orr.w	ip, ip, r5
  41c634:	fa00 f40e 	lsl.w	r4, r0, lr
  41c638:	ea4f 4a17 	mov.w	sl, r7, lsr #16
  41c63c:	0c25      	lsrs	r5, r4, #16
  41c63e:	fbbc f8fa 	udiv	r8, ip, sl
  41c642:	fa1f f987 	uxth.w	r9, r7
  41c646:	fb0a cc18 	mls	ip, sl, r8, ip
  41c64a:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
  41c64e:	fb08 f309 	mul.w	r3, r8, r9
  41c652:	42ab      	cmp	r3, r5
  41c654:	d90a      	bls.n	41c66c <__udivmoddi4+0x6c>
  41c656:	19ed      	adds	r5, r5, r7
  41c658:	f108 32ff 	add.w	r2, r8, #4294967295
  41c65c:	f080 8123 	bcs.w	41c8a6 <__udivmoddi4+0x2a6>
  41c660:	42ab      	cmp	r3, r5
  41c662:	f240 8120 	bls.w	41c8a6 <__udivmoddi4+0x2a6>
  41c666:	f1a8 0802 	sub.w	r8, r8, #2
  41c66a:	443d      	add	r5, r7
  41c66c:	1aed      	subs	r5, r5, r3
  41c66e:	b2a4      	uxth	r4, r4
  41c670:	fbb5 f0fa 	udiv	r0, r5, sl
  41c674:	fb0a 5510 	mls	r5, sl, r0, r5
  41c678:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
  41c67c:	fb00 f909 	mul.w	r9, r0, r9
  41c680:	45a1      	cmp	r9, r4
  41c682:	d909      	bls.n	41c698 <__udivmoddi4+0x98>
  41c684:	19e4      	adds	r4, r4, r7
  41c686:	f100 33ff 	add.w	r3, r0, #4294967295
  41c68a:	f080 810a 	bcs.w	41c8a2 <__udivmoddi4+0x2a2>
  41c68e:	45a1      	cmp	r9, r4
  41c690:	f240 8107 	bls.w	41c8a2 <__udivmoddi4+0x2a2>
  41c694:	3802      	subs	r0, #2
  41c696:	443c      	add	r4, r7
  41c698:	eba4 0409 	sub.w	r4, r4, r9
  41c69c:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
  41c6a0:	2100      	movs	r1, #0
  41c6a2:	2e00      	cmp	r6, #0
  41c6a4:	d061      	beq.n	41c76a <__udivmoddi4+0x16a>
  41c6a6:	fa24 f40e 	lsr.w	r4, r4, lr
  41c6aa:	2300      	movs	r3, #0
  41c6ac:	6034      	str	r4, [r6, #0]
  41c6ae:	6073      	str	r3, [r6, #4]
  41c6b0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  41c6b4:	428b      	cmp	r3, r1
  41c6b6:	d907      	bls.n	41c6c8 <__udivmoddi4+0xc8>
  41c6b8:	2e00      	cmp	r6, #0
  41c6ba:	d054      	beq.n	41c766 <__udivmoddi4+0x166>
  41c6bc:	2100      	movs	r1, #0
  41c6be:	e886 0021 	stmia.w	r6, {r0, r5}
  41c6c2:	4608      	mov	r0, r1
  41c6c4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  41c6c8:	fab3 f183 	clz	r1, r3
  41c6cc:	2900      	cmp	r1, #0
  41c6ce:	f040 808e 	bne.w	41c7ee <__udivmoddi4+0x1ee>
  41c6d2:	42ab      	cmp	r3, r5
  41c6d4:	d302      	bcc.n	41c6dc <__udivmoddi4+0xdc>
  41c6d6:	4282      	cmp	r2, r0
  41c6d8:	f200 80fa 	bhi.w	41c8d0 <__udivmoddi4+0x2d0>
  41c6dc:	1a84      	subs	r4, r0, r2
  41c6de:	eb65 0503 	sbc.w	r5, r5, r3
  41c6e2:	2001      	movs	r0, #1
  41c6e4:	46ac      	mov	ip, r5
  41c6e6:	2e00      	cmp	r6, #0
  41c6e8:	d03f      	beq.n	41c76a <__udivmoddi4+0x16a>
  41c6ea:	e886 1010 	stmia.w	r6, {r4, ip}
  41c6ee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  41c6f2:	b912      	cbnz	r2, 41c6fa <__udivmoddi4+0xfa>
  41c6f4:	2701      	movs	r7, #1
  41c6f6:	fbb7 f7f2 	udiv	r7, r7, r2
  41c6fa:	fab7 fe87 	clz	lr, r7
  41c6fe:	f1be 0f00 	cmp.w	lr, #0
  41c702:	d134      	bne.n	41c76e <__udivmoddi4+0x16e>
  41c704:	1beb      	subs	r3, r5, r7
  41c706:	0c3a      	lsrs	r2, r7, #16
  41c708:	fa1f fc87 	uxth.w	ip, r7
  41c70c:	2101      	movs	r1, #1
  41c70e:	fbb3 f8f2 	udiv	r8, r3, r2
  41c712:	0c25      	lsrs	r5, r4, #16
  41c714:	fb02 3318 	mls	r3, r2, r8, r3
  41c718:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
  41c71c:	fb0c f308 	mul.w	r3, ip, r8
  41c720:	42ab      	cmp	r3, r5
  41c722:	d907      	bls.n	41c734 <__udivmoddi4+0x134>
  41c724:	19ed      	adds	r5, r5, r7
  41c726:	f108 30ff 	add.w	r0, r8, #4294967295
  41c72a:	d202      	bcs.n	41c732 <__udivmoddi4+0x132>
  41c72c:	42ab      	cmp	r3, r5
  41c72e:	f200 80d1 	bhi.w	41c8d4 <__udivmoddi4+0x2d4>
  41c732:	4680      	mov	r8, r0
  41c734:	1aed      	subs	r5, r5, r3
  41c736:	b2a3      	uxth	r3, r4
  41c738:	fbb5 f0f2 	udiv	r0, r5, r2
  41c73c:	fb02 5510 	mls	r5, r2, r0, r5
  41c740:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
  41c744:	fb0c fc00 	mul.w	ip, ip, r0
  41c748:	45a4      	cmp	ip, r4
  41c74a:	d907      	bls.n	41c75c <__udivmoddi4+0x15c>
  41c74c:	19e4      	adds	r4, r4, r7
  41c74e:	f100 33ff 	add.w	r3, r0, #4294967295
  41c752:	d202      	bcs.n	41c75a <__udivmoddi4+0x15a>
  41c754:	45a4      	cmp	ip, r4
  41c756:	f200 80b8 	bhi.w	41c8ca <__udivmoddi4+0x2ca>
  41c75a:	4618      	mov	r0, r3
  41c75c:	eba4 040c 	sub.w	r4, r4, ip
  41c760:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
  41c764:	e79d      	b.n	41c6a2 <__udivmoddi4+0xa2>
  41c766:	4631      	mov	r1, r6
  41c768:	4630      	mov	r0, r6
  41c76a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  41c76e:	f1ce 0420 	rsb	r4, lr, #32
  41c772:	fa05 f30e 	lsl.w	r3, r5, lr
  41c776:	fa07 f70e 	lsl.w	r7, r7, lr
  41c77a:	fa20 f804 	lsr.w	r8, r0, r4
  41c77e:	0c3a      	lsrs	r2, r7, #16
  41c780:	fa25 f404 	lsr.w	r4, r5, r4
  41c784:	ea48 0803 	orr.w	r8, r8, r3
  41c788:	fbb4 f1f2 	udiv	r1, r4, r2
  41c78c:	ea4f 4518 	mov.w	r5, r8, lsr #16
  41c790:	fb02 4411 	mls	r4, r2, r1, r4
  41c794:	fa1f fc87 	uxth.w	ip, r7
  41c798:	ea45 4504 	orr.w	r5, r5, r4, lsl #16
  41c79c:	fb01 f30c 	mul.w	r3, r1, ip
  41c7a0:	42ab      	cmp	r3, r5
  41c7a2:	fa00 f40e 	lsl.w	r4, r0, lr
  41c7a6:	d909      	bls.n	41c7bc <__udivmoddi4+0x1bc>
  41c7a8:	19ed      	adds	r5, r5, r7
  41c7aa:	f101 30ff 	add.w	r0, r1, #4294967295
  41c7ae:	f080 808a 	bcs.w	41c8c6 <__udivmoddi4+0x2c6>
  41c7b2:	42ab      	cmp	r3, r5
  41c7b4:	f240 8087 	bls.w	41c8c6 <__udivmoddi4+0x2c6>
  41c7b8:	3902      	subs	r1, #2
  41c7ba:	443d      	add	r5, r7
  41c7bc:	1aeb      	subs	r3, r5, r3
  41c7be:	fa1f f588 	uxth.w	r5, r8
  41c7c2:	fbb3 f0f2 	udiv	r0, r3, r2
  41c7c6:	fb02 3310 	mls	r3, r2, r0, r3
  41c7ca:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
  41c7ce:	fb00 f30c 	mul.w	r3, r0, ip
  41c7d2:	42ab      	cmp	r3, r5
  41c7d4:	d907      	bls.n	41c7e6 <__udivmoddi4+0x1e6>
  41c7d6:	19ed      	adds	r5, r5, r7
  41c7d8:	f100 38ff 	add.w	r8, r0, #4294967295
  41c7dc:	d26f      	bcs.n	41c8be <__udivmoddi4+0x2be>
  41c7de:	42ab      	cmp	r3, r5
  41c7e0:	d96d      	bls.n	41c8be <__udivmoddi4+0x2be>
  41c7e2:	3802      	subs	r0, #2
  41c7e4:	443d      	add	r5, r7
  41c7e6:	1aeb      	subs	r3, r5, r3
  41c7e8:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
  41c7ec:	e78f      	b.n	41c70e <__udivmoddi4+0x10e>
  41c7ee:	f1c1 0720 	rsb	r7, r1, #32
  41c7f2:	fa22 f807 	lsr.w	r8, r2, r7
  41c7f6:	408b      	lsls	r3, r1
  41c7f8:	fa05 f401 	lsl.w	r4, r5, r1
  41c7fc:	ea48 0303 	orr.w	r3, r8, r3
  41c800:	fa20 fe07 	lsr.w	lr, r0, r7
  41c804:	ea4f 4c13 	mov.w	ip, r3, lsr #16
  41c808:	40fd      	lsrs	r5, r7
  41c80a:	ea4e 0e04 	orr.w	lr, lr, r4
  41c80e:	fbb5 f9fc 	udiv	r9, r5, ip
  41c812:	ea4f 441e 	mov.w	r4, lr, lsr #16
  41c816:	fb0c 5519 	mls	r5, ip, r9, r5
  41c81a:	fa1f f883 	uxth.w	r8, r3
  41c81e:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
  41c822:	fb09 f408 	mul.w	r4, r9, r8
  41c826:	42ac      	cmp	r4, r5
  41c828:	fa02 f201 	lsl.w	r2, r2, r1
  41c82c:	fa00 fa01 	lsl.w	sl, r0, r1
  41c830:	d908      	bls.n	41c844 <__udivmoddi4+0x244>
  41c832:	18ed      	adds	r5, r5, r3
  41c834:	f109 30ff 	add.w	r0, r9, #4294967295
  41c838:	d243      	bcs.n	41c8c2 <__udivmoddi4+0x2c2>
  41c83a:	42ac      	cmp	r4, r5
  41c83c:	d941      	bls.n	41c8c2 <__udivmoddi4+0x2c2>
  41c83e:	f1a9 0902 	sub.w	r9, r9, #2
  41c842:	441d      	add	r5, r3
  41c844:	1b2d      	subs	r5, r5, r4
  41c846:	fa1f fe8e 	uxth.w	lr, lr
  41c84a:	fbb5 f0fc 	udiv	r0, r5, ip
  41c84e:	fb0c 5510 	mls	r5, ip, r0, r5
  41c852:	ea4e 4405 	orr.w	r4, lr, r5, lsl #16
  41c856:	fb00 f808 	mul.w	r8, r0, r8
  41c85a:	45a0      	cmp	r8, r4
  41c85c:	d907      	bls.n	41c86e <__udivmoddi4+0x26e>
  41c85e:	18e4      	adds	r4, r4, r3
  41c860:	f100 35ff 	add.w	r5, r0, #4294967295
  41c864:	d229      	bcs.n	41c8ba <__udivmoddi4+0x2ba>
  41c866:	45a0      	cmp	r8, r4
  41c868:	d927      	bls.n	41c8ba <__udivmoddi4+0x2ba>
  41c86a:	3802      	subs	r0, #2
  41c86c:	441c      	add	r4, r3
  41c86e:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
  41c872:	eba4 0408 	sub.w	r4, r4, r8
  41c876:	fba0 8902 	umull	r8, r9, r0, r2
  41c87a:	454c      	cmp	r4, r9
  41c87c:	46c6      	mov	lr, r8
  41c87e:	464d      	mov	r5, r9
  41c880:	d315      	bcc.n	41c8ae <__udivmoddi4+0x2ae>
  41c882:	d012      	beq.n	41c8aa <__udivmoddi4+0x2aa>
  41c884:	b156      	cbz	r6, 41c89c <__udivmoddi4+0x29c>
  41c886:	ebba 030e 	subs.w	r3, sl, lr
  41c88a:	eb64 0405 	sbc.w	r4, r4, r5
  41c88e:	fa04 f707 	lsl.w	r7, r4, r7
  41c892:	40cb      	lsrs	r3, r1
  41c894:	431f      	orrs	r7, r3
  41c896:	40cc      	lsrs	r4, r1
  41c898:	6037      	str	r7, [r6, #0]
  41c89a:	6074      	str	r4, [r6, #4]
  41c89c:	2100      	movs	r1, #0
  41c89e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  41c8a2:	4618      	mov	r0, r3
  41c8a4:	e6f8      	b.n	41c698 <__udivmoddi4+0x98>
  41c8a6:	4690      	mov	r8, r2
  41c8a8:	e6e0      	b.n	41c66c <__udivmoddi4+0x6c>
  41c8aa:	45c2      	cmp	sl, r8
  41c8ac:	d2ea      	bcs.n	41c884 <__udivmoddi4+0x284>
  41c8ae:	ebb8 0e02 	subs.w	lr, r8, r2
  41c8b2:	eb69 0503 	sbc.w	r5, r9, r3
  41c8b6:	3801      	subs	r0, #1
  41c8b8:	e7e4      	b.n	41c884 <__udivmoddi4+0x284>
  41c8ba:	4628      	mov	r0, r5
  41c8bc:	e7d7      	b.n	41c86e <__udivmoddi4+0x26e>
  41c8be:	4640      	mov	r0, r8
  41c8c0:	e791      	b.n	41c7e6 <__udivmoddi4+0x1e6>
  41c8c2:	4681      	mov	r9, r0
  41c8c4:	e7be      	b.n	41c844 <__udivmoddi4+0x244>
  41c8c6:	4601      	mov	r1, r0
  41c8c8:	e778      	b.n	41c7bc <__udivmoddi4+0x1bc>
  41c8ca:	3802      	subs	r0, #2
  41c8cc:	443c      	add	r4, r7
  41c8ce:	e745      	b.n	41c75c <__udivmoddi4+0x15c>
  41c8d0:	4608      	mov	r0, r1
  41c8d2:	e708      	b.n	41c6e6 <__udivmoddi4+0xe6>
  41c8d4:	f1a8 0802 	sub.w	r8, r8, #2
  41c8d8:	443d      	add	r5, r7
  41c8da:	e72b      	b.n	41c734 <__udivmoddi4+0x134>

0041c8dc <__aeabi_idiv0>:
  41c8dc:	4770      	bx	lr
  41c8de:	bf00      	nop
  41c8e0:	2d6e4f22 	.word	0x2d6e4f22
  41c8e4:	70696843 	.word	0x70696843
  41c8e8:	72695620 	.word	0x72695620
  41c8ec:	6c617574 	.word	0x6c617574
  41c8f0:	6d654d20 	.word	0x6d654d20
  41c8f4:	2279726f 	.word	0x2279726f
  41c8f8:	00000000 	.word	0x00000000

0041c8fc <lun_desc>:
  41c8fc:	00400785 004007a5 004007f1 004007d1     ..@...@...@...@.
  41c90c:	004007e1 00400899 004008c1 0041c8e0     ..@...@...@...A.
  41c91c:	31333231 32313332 33323133 00000000     123123123123....

0041c92c <xDefaultPartARPPacketHeader>:
  41c92c:	ffffffff 0000ffff 00000000 01000608     ................
  41c93c:	04060008 00000100 00000000 00000000     ................
	...
  41c954:	732f2e2e 412f6372 742f4653 64726968     ../src/ASF/third
  41c964:	74726170 72462f79 54526565 462f534f     party/FreeRTOS/F
  41c974:	52656572 2d534f54 73756c50 756f532f     reeRTOS-Plus/Sou
  41c984:	2f656372 65657246 534f5452 756c502d     rce/FreeRTOS-Plu
  41c994:	43542d73 72462f50 54526565 415f534f     s-TCP/FreeRTOS_A
  41c9a4:	632e5052 00000000 5252450a 203a524f     RP.c.....ERROR: 
  41c9b4:	25207325 00000a64 20707241 646c3225     %s %d...Arp %2ld
  41c9c4:	3325203a 202d2075 6c363125 20706978     : %3u - %16lxip 
  41c9d4:	3025203a 253a7832 3a783230 78323025     : %02x:%02x:%02x
  41c9e4:	25203a20 3a783230 78323025 3230253a      : %02x:%02x:%02
  41c9f4:	00000a78 20707241 20736168 20646c25     x...Arp has %ld 
  41ca04:	72746e65 0a736569 00000000              entries.....

0041ca10 <xBroadcastMACAddress>:
  41ca10:	ffffffff 0000ffff 49767270 73615450     ........prvIPTas
  41ca20:	7473206b 65747261 00000a64 732f2e2e     k started...../s
  41ca30:	412f6372 742f4653 64726968 74726170     rc/ASF/thirdpart
  41ca40:	72462f79 54526565 462f534f 52656572     y/FreeRTOS/FreeR
  41ca50:	2d534f54 73756c50 756f532f 2f656372     TOS-Plus/Source/
  41ca60:	65657246 534f5452 756c502d 43542d73     FreeRTOS-Plus-TC
  41ca70:	72462f50 54526565 495f534f 00632e50     P/FreeRTOS_IP.c.
  41ca80:	5252450a 203a524f 25207325 00000a64     .ERROR: %s %d...
  41ca90:	742d5049 006b7361 65657246 534f5452     IP-task.FreeRTOS
  41caa0:	4950495f 3a74696e 654e7820 726f7774     _IPInit: xNetwor
  41cab0:	6675426b 73726566 74696e49 696c6169     kBuffersInitiali
  41cac0:	29286573 69616620 0a64656c 00000000     se() failed.....
  41cad0:	65657246 534f5452 4950495f 3a74696e     FreeRTOS_IPInit:
  41cae0:	74654e20 6b726f77 65766520 7120746e      Network event q
  41caf0:	65756575 756f6320 6e20646c 6220746f     ueue could not b
  41cb00:	72632065 65746165 00000a64 6e655378     e created...xSen
  41cb10:	65764564 7453746e 74637572 50496f54     dEventStructToIP
  41cb20:	6b736154 4143203a 4f4e204e 44412054     Task: CAN NOT AD
  41cb30:	64252044 0000000a 00504455 00504354     D %d....UDP.TCP.
  41cb40:	504d4349 00000000 504d4749 00000000     ICMP....IGMP....
  41cb50:	65477375 6172656e 72506574 636f746f     usGenerateProtoc
  41cb60:	68436c6f 736b6365 255b6d75 203a5d73     olChecksum[%s]: 
  41cb70:	206e656c 61766e69 3a64696c 756c2520     len invalid: %lu
  41cb80:	0000000a 65477375 6172656e 72506574     ....usGeneratePr
  41cb90:	636f746f 68436c6f 736b6365 255b6d75     otocolChecksum[%
  41cba0:	203a5d73 20637263 70617773 3025203a     s]: crc swap: %0
  41cbb0:	000a5834 65477375 6172656e 72506574     4X..usGeneratePr
  41cbc0:	636f746f 68436c6f 736b6365 255b6d75     otocolChecksum[%
  41cbd0:	203a5d73 25204449 3a583430 6f726620     s]: ID %04X: fro
  41cbe0:	6c25206d 20706978 25206f74 7069786c     m %lxip to %lxip
  41cbf0:	64616220 63726320 3025203a 000a5834      bad crc: %04X..

0041cc00 <xNetworkDownEvent.10460>:
	...
  41cc08:	732f2e2e 412f6372 742f4653 64726968     ../src/ASF/third
  41cc18:	74726170 72462f79 54526565 462f534f     party/FreeRTOS/F
  41cc28:	52656572 2d534f54 73756c50 756f532f     reeRTOS-Plus/Sou
  41cc38:	2f656372 65657246 534f5452 756c502d     rce/FreeRTOS-Plu
  41cc48:	43542d73 72462f50 54526565 535f534f     s-TCP/FreeRTOS_S
  41cc58:	656b636f 632e7374 00000000 5252450a     ockets.c.....ERR
  41cc68:	203a524f 25207325 00000a64 46767270     OR: %s %d...prvF
  41cc78:	53646e69 63656c65 53646574 656b636f     indSelectedSocke
  41cc88:	66203a74 656c6961 00000a64 636f5376     t: failed...vSoc
  41cc98:	4274656b 3a646e69 636f5320 2074656b     ketBind: Socket 
  41cca8:	65726c61 20796461 6e756f62 6f742064     already bound to
  41ccb8:	0a642520 00000000 65657246 534f5452      %d.....FreeRTOS
  41ccc8:	6e69625f 73203a64 20646e65 6e657665     _bind: send even
  41ccd8:	61662074 64656c69 0000000a 00004354     t failed....TC..
  41cce8:	00004455 636f5376 4274656b 3a646e69     UD..vSocketBind:
  41ccf8:	50732520 726f7020 64252074 206e6920      %sP port %d in 
  41cd08:	0a657375 00000000 636f5376 4274656b     use.....vSocketB
  41cd18:	3a646e69 636f5320 2074656b 61206f6e     ind: Socket no a
  41cd28:	0a726464 00000000 65657246 534f5452     ddr.....FreeRTOS
  41cd38:	6f6c635f 6f736573 74656b63 6166203a     _closesocket: fa
  41cd48:	64656c69 0000000a 65657246 534f5452     iled....FreeRTOS
  41cd58:	6f6c635f 6f736573 74656b63 2075255b     _closesocket[%u 
  41cd68:	25206f74 7069786c 5d75253a 7562203a     to %lxip:%u]: bu
  41cd78:	72656666 6c252073 6f732075 20736b63     ffers %lu socks 
  41cd88:	0a756c25 00000000 00000000 006e6572     %lu.........ren.
  41cd98:	74736f4c 6f53203a 74656b63 20752520     Lost: Socket %u 
  41cda8:	20776f6e 20736168 2f207525 20752520     now has %u / %u 
  41cdb8:	6c696863 0a732564 00000000 45455246     child%s.....FREE
  41cdc8:	534f5452 5f4f535f 5f544553 5f574f4c     RTOS_SO_SET_LOW_
  41cdd8:	48474948 5441575f 203a5245 6e6f7277     HIGH_WATER: wron
  41cde8:	6f732067 74656b63 70797420 00000a65     g socket type...
  41cdf8:	45455246 534f5452 5f4f535f 5f544553     FREERTOS_SO_SET_
  41ce08:	5f574f4c 48474948 5441575f 203a5245     LOW_HIGH_WATER: 
  41ce18:	20646162 756c6176 000a7365 00444e53     bad values..SND.
  41ce28:	00564352 20746553 255f4f53 46554273     RCV.Set SO_%sBUF
  41ce38:	7277203a 20676e6f 6b636f73 74207465     : wrong socket t
  41ce48:	0a657079 00000000 20746553 255f4f53     ype.....Set SO_%
  41ce58:	46554273 7562203a 72656666 726c6120     sBUF: buffer alr
  41ce68:	79646165 65726320 64657461 0000000a     eady created....
  41ce78:	20746553 575f4f53 505f4e49 3a504f52     Set SO_WIN_PROP:
  41ce88:	6f727720 7320676e 656b636f 79742074      wrong socket ty
  41ce98:	000a6570 20746553 575f4f53 505f4e49     pe..Set SO_WIN_P
  41cea8:	3a504f52 66756220 20726566 65726c61     ROP: buffer alre
  41ceb8:	20796461 61657263 0a646574 00000000     ady created.....
  41cec8:	65657246 534f5452 6e6f635f 7463656e     FreeRTOS_connect
  41ced8:	7525203a 206f7420 69786c25 75253a70     : %u to %lxip:%u
  41cee8:	0000000a 65657246 534f5452 6e65735f     ....FreeRTOS_sen
  41cef8:	25203a64 3e2d2075 786c2520 253a7069     d: %u -> %lxip:%
  41cf08:	6e203a64 7073206f 0a656361 00000000     d: no space.....
  41cf18:	54767270 72435043 65746165 65727453     prvTCPCreateStre
  41cf28:	203a6d61 6c6c616d 6620636f 656c6961     am: malloc faile
  41cf38:	00000a64 54767270 72435043 65746165     d...prvTCPCreate
  41cf48:	65727453 203a6d61 53786325 61657274     Stream: %cxStrea
  41cf58:	7263206d 65746165 6c252064 79622075     m created %lu by
  41cf68:	20736574 746f7428 25206c61 0a29756c     tes (total %lu).
  41cf78:	00000000 5043546c 52646441 74616478     ....lTCPAddRxdat
  41cf88:	61203a61 6c252074 25203a64 252f646c     a: at %ld: %ld/%
  41cf98:	6220756c 73657479 61742820 25206c69     lu bytes (tail %
  41cfa8:	6820756c 20646165 20756c25 63617073     lu head %lu spac
  41cfb8:	6c252065 72662075 20746e6f 29756c25     e %lu front %lu)
  41cfc8:	0000000a 53554c50 5043542d 746f6e20     ....PLUS-TCP not
  41cfd8:	696e6920 6c616974 64657a69 0000000a      initialized....
  41cfe8:	746f7250 726f5020 50492074 6d65522d     Prot Port IP-Rem
  41cff8:	0965746f 3a202020 726f5020 52202074     ote.   : Port  R
  41d008:	5320542f 75746174 20200973 696c4120     /T Status.   Ali
  41d018:	20206576 756f6d74 68432074 0a646c69     ve  tmout Child.
  41d028:	00000000 2f642520 00006425 20504354     .... %d/%d..TCP 
  41d038:	20643525 36312d25 7069786c 6435253a     %5d %-16lxip:%5d
  41d048:	2f642520 25206425 2e33312d 20733331      %d/%d %-13.13s 
  41d058:	756c3625 75362520 000a7325 20504455     %6lu %6u%s..UDP 
  41d068:	74726f50 75352520 0000000a 65657246     Port %5u....Free
  41d078:	534f5452 74656e5f 74617473 6c25203a     RTOS_netstat: %l
  41d088:	6f732075 74656b63 6c252073 203c2075     u sockets %lu < 
  41d098:	20756c25 6425203c 66756220 73726566     %lu < %d buffers
  41d0a8:	65726620 00000a65 4f4c4365 00444553      free...eCLOSED.
  41d0b8:	50435465 53494c5f 004e4554 4e4f4365     eTCP_LISTEN.eCON
  41d0c8:	5443454e 4e59535f 00000000 4e595365     NECT_SYN....eSYN
  41d0d8:	5249465f 00005453 4e595365 4345525f     _FIRST..eSYN_REC
  41d0e8:	45564945 00000044 54534565 494c4241     EIVED...eESTABLI
  41d0f8:	44454853 00000000 4e494665 4941575f     SHED....eFIN_WAI
  41d108:	00315f54 4e494665 4941575f 00325f54     T_1.eFIN_WAIT_2.
  41d118:	4f4c4365 575f4553 00544941 4f4c4365     eCLOSE_WAIT.eCLO
  41d128:	474e4953 00000000 53414c65 43415f54     SING....eLAST_AC
  41d138:	0000004b 4d495465 41575f45 00005449     K...eTIME_WAIT..
  41d148:	4b4e5565 4e574f4e 00000000 63616e49     eUNKNOWN....Inac
  41d158:	65766974 636f7320 2074656b 736f6c63     tive socket clos
  41d168:	203a6465 74726f70 20752520 206d6572     ed: port %u rem 
  41d178:	69786c25 75253a70 61747320 20737574     %lxip:%u status 
  41d188:	000a7325 646e6553 2d75255b 5d75253e     %s..Send[%u->%u]
  41d198:	6c656420 4b434120 756c2520 51455320      del ACK %lu SEQ
  41d1a8:	756c2520 656c2820 7525206e 00000a29      %lu (len %u)...
  41d1b8:	6e6e6f43 3a746365 76696720 20676e69     Connect: giving 
  41d1c8:	25207075 7069786c 0a75253a 00000000     up %lxip:%u.....
  41d1d8:	504f5453 00000000 00204f47 203a7325     STOP....GO .%s: 
  41d1e8:	69786c25 75253a70 255b203a 3c20756c     %lxip:%u: [%lu <
  41d1f8:	756c2520 6977205d 7a69536e 6c252065      %lu] winSize %l
  41d208:	00000a64 70707553 73736572 4e494620     d...Suppress FIN
  41d218:	726f6620 756c2520 25202b20 3c20756c      for %lu + %lu <
  41d228:	756c2520 0000000a 696d694c 28207374      %lu....Limits (
  41d238:	6e697375 203a2967 20504354 206e6957     using): TCP Win 
  41d248:	657a6973 756c2520 74615720 25207265     size %lu Water %
  41d258:	3c20756c 6c25203d 3d3c2075 756c2520     lu <= %lu <= %lu
  41d268:	0000000a 20505241 20726f66 69786c25     ....ARP for %lxi
  41d278:	75282070 676e6973 786c2520 3a297069     p (using %lxip):
  41d288:	3d637220 25206425 3a583230 58323025      rc=%d %02X:%02X
  41d298:	3230253a 30252058 253a5832 3a583230     :%02X %02X:%02X:
  41d2a8:	58323025 0000000a 63256325 63256325     %02X....%c%c%c%c
  41d2b8:	63256325 63256325 00006325 2053534d     %c%c%c%c%c..MSS 
  41d2c8:	6e616863 25206567 3e2d2075 756c2520     change %u -> %lu
  41d2d8:	0000000a 6e616843 6d206567 25207373     ....Change mss %
  41d2e8:	3e3d2064 756c2520 0000000a 57767270     d => %lu....prvW
  41d2f8:	63536e69 46656c61 6f746361 75203a72     inScaleFactor: u
  41d308:	57785278 69536e69 2520657a 4d20756c     xRxWinSize %lu M
  41d318:	25205353 4620756c 6f746361 75252072     SS %lu Factor %u
  41d328:	0000000a 732f2e2e 412f6372 742f4653     ....../src/ASF/t
  41d338:	64726968 74726170 72462f79 54526565     hirdparty/FreeRT
  41d348:	462f534f 52656572 2d534f54 73756c50     OS/FreeRTOS-Plus
  41d358:	756f532f 2f656372 65657246 534f5452     /Source/FreeRTOS
  41d368:	756c502d 43542d73 72462f50 54526565     -Plus-TCP/FreeRT
  41d378:	545f534f 495f5043 00632e50 5252450a     OS_TCP_IP.c..ERR
  41d388:	203a524f 25207325 00000a64 50435476     OR: %s %d...vTCP
  41d398:	74617453 61684365 3a65676e 6f6c4320     StateChange: Clo
  41d3a8:	676e6973 636f7320 0a74656b 00000000     sing socket.....
  41d3b8:	6b636f53 25207465 3e2d2064 786c2520     Socket %d -> %lx
  41d3c8:	253a7069 74532075 20657461 3e2d7325     ip:%u State %s->
  41d3d8:	000a7325 74537875 6d616572 66667542     %s..uxStreamBuff
  41d3e8:	65477265 70203a74 2520736f 6f20756c     erGet: pos %lu o
  41d3f8:	20736666 20756c25 796c6e6f 756c2520     ffs %lu only %lu
  41d408:	203d2120 0a756c25 00000000 63656843      != %lu.....Chec
  41d418:	6f6c436b 25206573 3c20756c 6c25203d     kClose %lu <= %l
  41d428:	25282075 3c20756c 6c25203d 3d3c2075     u (%lu <= %lu <=
  41d438:	756c2520 00000a29 6e6e6f43 5b746365      %lu)...Connect[
  41d448:	69786c25 75253a70 6e203a5d 20747865     %lxip:%u]: next 
  41d458:	656d6974 2074756f 203a7525 20756c25     timeout %u: %lu 
  41d468:	000a736d 3a504354 6e657320 49462064     ms..TCP: send FI
  41d478:	43412b4e 6128204b 25206b63 202c756c     N+ACK (ack %lu, 
  41d488:	2f727563 2074786e 2f756c25 29756c25     cur/nxt %lu/%lu)
  41d498:	72756f20 4e716553 6c252072 207c2075      ourSeqNr %lu | 
  41d4a8:	25207852 000a756c 5043546c 52646441     Rx %lu..lTCPAddR
  41d4b8:	74616478 73203a61 65726f74 6c252064     xdata: stored %l
  41d4c8:	202f2064 20756c25 65747962 0a3f3f73     d / %lu bytes??.
  41d4d8:	00000000 4b434153 2c64255b 3a5d6425     ....SACK[%d,%d]:
  41d4e8:	74706f20 206e656c 20756c25 646e6573      optlen %lu send
  41d4f8:	20676e69 20756c25 6c25202d 00000a75     ing %lu - %lu...
  41d508:	3a53534d 6e657320 676e6964 0a642520     MSS: sending %d.
  41d518:	00000000 203a7325 67616c66 30252073     ....%s: flags %0
  41d528:	65205834 63657078 2c646574 746f6e20     4X expected, not
  41d538:	34302520 00000a58 69746361 00006576      %04X...active..
  41d548:	73736170 00657669 3a504354 20732520     passive.TCP: %s 
  41d558:	3d206425 6c25203e 3a706978 73206425     %d => %lxip:%d s
  41d568:	45207465 42415453 63732820 6e696c61     et ESTAB (scalin
  41d578:	75252067 00000a29 75666552 676e6973     g %u)...Refusing
  41d588:	4e494620 2c75255b 3a5d7525 43785220      FIN[%u,%u]: RxC
  41d598:	6c706d6f 756c2520 20787420 656e6f64     ompl %lu tx done
  41d5a8:	646c2520 0000000a 75666552 676e6973      %ld....Refusing
  41d5b8:	4e494620 7852203a 746f6e20 6d6f6320      FIN: Rx not com
  41d5c8:	74656c70 6c252065 63282064 25207275     plete %ld (cur %
  41d5d8:	6820756c 20686769 29756c25 0000000a     lu high %lu)....
  41d5e8:	3a504354 4e494620 63657220 65766965     TCP: FIN receive
  41d5f8:	6d202c64 6c437961 2065736f 6c25203d     d, mayClose = %l
  41d608:	52282064 6c252078 654c2075 6c25206e     d (Rx %lu Len %l
  41d618:	54202c64 6c252078 000a2975 646e6553     d, Tx %lu)..Send
  41d628:	2d75255b 5d75253e 6c656420 4b434120     [%u->%u] del ACK
  41d638:	756c2520 51455320 756c2520 656c2820      %lu SEQ %lu (le
  41d648:	6c25206e 74202975 74756f6d 20752520     n %lu) tmout %u 
  41d658:	6c252064 00000a75 646e6553 2d75255b     d %lu...Send[%u-
  41d668:	5d75253e 6d6d6920 4b434120 756c2520     >%u] imm ACK %lu
  41d678:	51455320 756c2520 656c2820 6c25206e      SEQ %lu (len %l
  41d688:	000a2975 4e595365 4345525f 45564945     u)..eSYN_RECEIVE
  41d698:	41203a44 65204b43 63657078 2c646574     D: ACK expected,
  41d6a8:	746f6e20 4e595320 6570203a 6d207265      not SYN: peer m
  41d6b8:	65737369 756f2064 59532072 43412b4e     issed our SYN+AC
  41d6c8:	00000a4b 53767270 656b636f 74655374     K...prvSocketSet
  41d6d8:	3a53534d 756c2520 74796220 66207365     MSS: %lu bytes f
  41d6e8:	2520726f 7069786c 0a75253a 00000000     or %lxip:%u.....
  41d6f8:	3a504354 206f4e20 69746361 73206576     TCP: No active s
  41d708:	656b636f 6e6f2074 726f7020 64252074     ocket on port %d
  41d718:	6c252820 3a706978 0a296425 00000000      (%lxip:%d).....
  41d728:	3a504354 72655320 20726576 276e6163     TCP: Server can'
  41d738:	61682074 656c646e 616c6620 203a7367     t handle flags: 
  41d748:	66207325 206d6f72 69786c25 75253a70     %s from %lxip:%u
  41d758:	206f7420 74726f70 0a752520 00000000      to port %u.....
  41d768:	3a504354 54535220 63657220 65766965     TCP: RST receive
  41d778:	72662064 25206d6f 7069786c 2075253a     d from %lxip:%u 
  41d788:	20726f66 000a7525 3a504354 4e595320     for %u..TCP: SYN
  41d798:	656e7520 63657078 20646574 6d6f7266      unexpected from
  41d7a8:	786c2520 253a7069 00000a75 00000000      %lxip:%u.......
  41d7b8:	006e6572 63656843 53203a6b 656b636f     ren.Check: Socke
  41d7c8:	75252074 726c6120 79646165 73616820     t %u already has
  41d7d8:	20752520 7525202f 69686320 7325646c      %u / %u child%s
  41d7e8:	0000000a 3a504354 73694c20 3a6e6574     ....TCP: Listen:
  41d7f8:	77656e20 636f7320 2074656b 6c696166      new socket fail
  41d808:	000a6465 6e696147 6f53203a 74656b63     ed..Gain: Socket
  41d818:	20752520 20776f6e 20736168 2f207525      %u now has %u /
  41d828:	20752520 6c696863 0a732564 00000000      %u child%s.....
  41d838:	3a504354 73694c20 3a6e6574 77656e20     TCP: Listen: new
  41d848:	636f7320 2074656b 646e6962 72726520      socket bind err
  41d858:	000a726f 50435478 63656843 77654e6b     or..xTCPCheckNew
  41d868:	65696c43 305b746e 63203a5d 6e65696c     Client[0]: clien
  41d878:	6e6f2074 726f7020 75252074 0000000a     t on port %u....
  41d888:	43767270 74616572 63655365 73726f74     prvCreateSectors
  41d898:	616d203a 636f6c6c 756c2520 69616620     : malloc %lu fai
  41d8a8:	0a64656c 00000000 50435478 646e6957     led.....xTCPWind
  41d8b8:	6325776f 77654e78 7245203a 3a726f72     ow%cxNew: Error:
  41d8c8:	6c6c6120 67657320 746e656d 636f2073      all segments oc
  41d8d8:	69707563 000a6465 732f2e2e 412f6372     cupied..../src/A
  41d8e8:	742f4653 64726968 74726170 72462f79     SF/thirdparty/Fr
  41d8f8:	54526565 462f534f 52656572 2d534f54     eeRTOS/FreeRTOS-
  41d908:	73756c50 756f532f 2f656372 65657246     Plus/Source/Free
  41d918:	534f5452 756c502d 43542d73 72462f50     RTOS-Plus-TCP/Fr
  41d928:	54526565 545f534f 575f5043 632e4e49     eeRTOS_TCP_WIN.c
  41d938:	00000000 5252450a 203a524f 25207325     .....ERROR: %s %
  41d948:	00000a64 50435478 646e6957 7852776f     d...xTCPWindowRx
  41d958:	74706d45 63203a79 25207275 6820756c     Empty: cur %lu h
  41d968:	65686769 25207473 2820756c 74706d65     ighest %lu (empt
  41d978:	000a2979 50435476 646e6957 7243776f     y)..vTCPWindowCr
  41d988:	65746165 6f66203a 69572072 6e654c6e     eate: for WinLen
  41d998:	52203d20 78542f78 6c25203a 6c252f75      = Rx/Tx: %lu/%l
  41d9a8:	00000a75 50435478 646e6957 7852776f     u...xTCPWindowRx
  41d9b8:	666e6f43 5b6d7269 3a5d7525 61657320     Confirm[%u]: sea
  41d9c8:	20686372 20756c25 6c252b28 6c253d64     rch %lu (+%ld=%l
  41d9d8:	66202975 646e756f 756c2520 252b2820     u) found %lu (+%
  41d9e8:	253d646c 0a29756c 00000000 5043546c     ld=%lu).....lTCP
  41d9f8:	646e6957 7852776f 63656843 52203a6b     WindowRxCheck: R
  41da08:	73756665 6c252065 79622075 2c736574     efuse %lu bytes,
  41da18:	65756420 206f7420 6b63616c 20666f20      due to lack of 
  41da28:	63617073 25282065 0a29756c 00000000     space (%lu).....
  41da38:	5043546c 646e6957 7852776f 63656843     lTCPWindowRxChec
  41da48:	64255b6b 5d64252c 6572203a 6e617274     k[%d,%d]: retran
  41da58:	756c2520 6f462820 20646e75 20756c25      %lu (Found %lu 
  41da68:	65747962 74612073 756c2520 746e6320     bytes at %lu cnt
  41da78:	646c2520 00000a29 5043546c 646e6957      %ld)...lTCPWind
  41da88:	7852776f 63656843 52203a6b 73756665     owRxCheck: Refus
  41da98:	6c252065 6c252b75 79622075 2c736574     e %lu+%lu bytes,
  41daa8:	65756420 206f7420 6b63616c 20666f20      due to lack of 
  41dab8:	63617073 25282065 0a29756c 00000000     space (%lu).....
  41dac8:	5043546c 646e6957 7852776f 63656843     lTCPWindowRxChec
  41dad8:	64255b6b 5d64252c 6573203a 20726e71     k[%d,%d]: seqnr 
  41dae8:	20756c25 20707865 20756c25 73696428     %lu exp %lu (dis
  41daf8:	6c252074 53202964 204b4341 25206f74     t %ld) SACK to %
  41db08:	000a756c 5043546c 646e6957 7852776f     lu..lTCPWindowRx
  41db18:	63656843 75255b6b 5d75252c 6573203a     Check[%u,%u]: se
  41db28:	20726e71 20756c25 746e6328 756c2520     qnr %lu (cnt %lu
  41db38:	00000a29 5043546c 646e6957 7854776f     )...lTCPWindowTx
  41db48:	3a646441 64644120 6c342520 79622075     Add: Add %4lu by
  41db58:	20736574 20726f66 4e716573 6c252072     tes for seqNr %l
  41db68:	656c2075 3425206e 2820756c 2074786e     u len %4lu (nxt 
  41db78:	29756c25 736f7020 756c2520 0000000a     %lu) pos %lu....
  41db88:	5043546c 646e6957 7854776f 3a646441     lTCPWindowTxAdd:
  41db98:	77654e20 6c342520 79622064 20736574      New %4ld bytes 
  41dba8:	20726f66 4e716573 6c252072 656c2075     for seqNr %lu le
  41dbb8:	3425206e 2820756c 2074786e 29756c25     n %4lu (nxt %lu)
  41dbc8:	736f7020 756c2520 0000000a 5043546c      pos %lu....lTCP
  41dbd8:	646e6957 7854776f 3a646441 726f5320     WindowTxAdd: Sor
  41dbe8:	61207972 62206c6c 65666675 66207372     ry all buffers f
  41dbf8:	206c6c75 6e616328 206c6563 20646c25     ull (cancel %ld 
  41dc08:	65747962 000a2973 43546c75 6e695750     bytes)..ulTCPWin
  41dc18:	54776f64 74654778 2c75255b 3a5d7525     dowTxGet[%u,%u]:
  41dc28:	69615720 65755174 25206575 6220646c      WaitQueue %ld b
  41dc38:	73657479 726f6620 71657320 636e6575     ytes for sequenc
  41dc48:	756e2065 7265626d 756c2520 6c252820     e number %lu (%l
  41dc58:	000a2958 43546c75 6e695750 54776f64     X)..ulTCPWindowT
  41dc68:	74654778 2c75255b 3a5d7525 696d5820     xGet[%u,%u]: Xmi
  41dc78:	65755174 25206575 6220646c 73657479     tQueue %ld bytes
  41dc88:	726f6620 71657320 636e6575 756e2065      for sequence nu
  41dc98:	7265626d 756c2520 73772820 756c2520     mber %lu (ws %lu
  41dca8:	00000a29 43546c75 6e695750 54776f64     )...ulTCPWindowT
  41dcb8:	74654778 2c75255b 3a5d7525 69725020     xGet[%u,%u]: Pri
  41dcc8:	6575516f 25206575 6220646c 73657479     oQueue %ld bytes
  41dcd8:	726f6620 71657320 636e6575 756e2065      for sequence nu
  41dce8:	7265626d 756c2520 73772820 756c2520     mber %lu (ws %lu
  41dcf8:	00000a29 43546c75 6e695750 54776f64     )...ulTCPWindowT
  41dd08:	74654778 2075255b 6425202d 43203a5d     xGet[%u - %d]: C
  41dd18:	676e6168 78542065 6e697720 3a776f64     hange Tx window:
  41dd28:	756c2520 203e2d20 000a7525 54767270      %lu -> %u..prvT
  41dd38:	69575043 776f646e 68437854 416b6365     CPWindowTxCheckA
  41dd48:	255b6b63 75252e75 25203a5d 2d20756c     ck[%u.%u]: %lu -
  41dd58:	756c2520 72615020 6c616974 71657320      %lu Partial seq
  41dd68:	636e6575 756e2065 7265626d 756c2520     uence number %lu
  41dd78:	25202d20 000a756c 54767270 69575043      - %lu..prvTCPWi
  41dd88:	776f646e 68437854 416b6365 203a6b63     ndowTxCheckAck: 
  41dd98:	20756c25 6c25202d 65522075 20796461     %lu - %lu Ready 
  41dda8:	75716573 65636e65 6d756e20 20726562     sequence number 
  41ddb8:	0a756c25 00000000 54767270 69575043     %lu.....prvTCPWi
  41ddc8:	776f646e 74736146 72746552 6d736e61     ndowFastRetransm
  41ddd8:	203a7469 75716552 20657565 75716573     it: Requeue sequ
  41dde8:	65636e65 6d756e20 20726562 20756c25     ence number %lu 
  41ddf8:	6c25203c 00000a75 43546c75 6e695750     < %lu...ulTCPWin
  41de08:	54776f64 63615378 75255b6b 5d75252c     dowTxSack[%u,%u]
  41de18:	7266203a 25206d6f 7420756c 6c25206f     : from %lu to %l
  41de28:	61282075 3d206b63 756c2520 00000a29     u (ack = %lu)...
  41de38:	732f2e2e 412f6372 742f4653 64726968     ../src/ASF/third
  41de48:	74726170 72462f79 54526565 462f534f     party/FreeRTOS/F
  41de58:	52656572 2d534f54 73756c50 756f532f     reeRTOS-Plus/Sou
  41de68:	2f656372 65657246 534f5452 756c502d     rce/FreeRTOS-Plu
  41de78:	43542d73 72462f50 54526565 555f534f     s-TCP/FreeRTOS_U
  41de88:	495f5044 00632e50 5252450a 203a524f     DP_IP.c..ERROR: 
  41de98:	25207325 00000a64                       %s %d...

0041dea0 <xBufferAllocFixedSize>:
  41dea0:	00000000 732f2e2e 412f6372 742f4653     ....../src/ASF/t
  41deb0:	64726968 74726170 72462f79 54526565     hirdparty/FreeRT
  41dec0:	462f534f 52656572 2d534f54 73756c50     OS/FreeRTOS-Plus
  41ded0:	756f532f 2f656372 65657246 534f5452     /Source/FreeRTOS
  41dee0:	756c502d 43542d73 6f702f50 62617472     -Plus-TCP/portab
  41def0:	422f656c 65666675 6e614d72 6d656761     le/BufferManagem
  41df00:	2f746e65 66667542 6c417265 61636f6c     ent/BufferAlloca
  41df10:	6e6f6974 632e325f 00000000 5252450a     tion_2.c.....ERR
  41df20:	203a524f 25207325 00000a64              OR: %s %d...

0041df2c <llmnr_mac_address>:
  41df2c:	005e0001 0000fc00 43414d45 00000000     ..^.....EMAC....
  41df3c:	732f2e2e 412f6372 742f4653 64726968     ../src/ASF/third
  41df4c:	74726170 72462f79 54526565 462f534f     party/FreeRTOS/F
  41df5c:	52656572 2d534f54 73756c50 756f532f     reeRTOS-Plus/Sou
  41df6c:	2f656372 65657246 534f5452 756c502d     rce/FreeRTOS-Plu
  41df7c:	43542d73 6f702f50 62617472 4e2f656c     s-TCP/portable/N
  41df8c:	6f777465 6e496b72 66726574 2f656361     etworkInterface/
  41df9c:	7774654e 496b726f 7265746e 65636166     NetworkInterface
  41dfac:	0000632e 5252450a 203a524f 25207325     .c...ERROR: %s %
  41dfbc:	00000a64 414d4778 69615743 3a534c74     d...xGMACWaitLS:
  41dfcc:	646c2520 48502820 64252059 72662029      %ld (PHY %d) fr
  41dfdc:	25207165 4d20756c 00000a7a 45767270     eq %lu Mz...prvE
  41dfec:	5243414d 6c6f5078 43203a6c 6e206e61     MACRxPoll: Can n
  41dffc:	7120746f 65756575 74657220 206e7275     ot queue return 
  41e00c:	6b636170 0a217465 00000000 75657551     packet!.....Queu
  41e01c:	70732065 3a656361 776f6c20 20747365     e space: lowest 
  41e02c:	0a756c25 00000000 7774654e 206b726f     %lu.....Network 
  41e03c:	66667562 3a737265 756c2520 776f6c20     buffers: %lu low
  41e04c:	20747365 0a756c25 00000000 45767270     est %lu.....prvE
  41e05c:	4843414d 6c646e61 61547265 203a6b73     MACHandlerTask: 
  41e06c:	20594850 6e20534c 2520776f 00000a64     PHY LS now %d...
  41e07c:	732f2e2e 412f6372 742f4653 64726968     ../src/ASF/third
  41e08c:	74726170 72462f79 54526565 462f534f     party/FreeRTOS/F
  41e09c:	52656572 2f534f54 72756f53 652f6563     reeRTOS/Source/e
  41e0ac:	746e6576 6f72675f 2e737075 00000063     vent_groups.c...
  41e0bc:	5252450a 203a524f 25207325 00000a64     .ERROR: %s %d...
  41e0cc:	732f2e2e 412f6372 742f4653 64726968     ../src/ASF/third
  41e0dc:	74726170 72462f79 54526565 462f534f     party/FreeRTOS/F
  41e0ec:	52656572 2f534f54 72756f53 702f6563     reeRTOS/Source/p
  41e0fc:	6174726f 2f656c62 2f434347 5f4d5241     ortable/GCC/ARM_
  41e10c:	2f334d43 74726f70 0000632e 5252450a     CM3/port.c...ERR
  41e11c:	203a524f 25207325 00000a64 52450a0a     OR: %s %d.....ER
  41e12c:	3a524f52 70417620 63696c70 6f697461     ROR: vApplicatio
  41e13c:	6c614d6e 46636f6c 656c6961 6f6f4864     nMallocFailedHoo
  41e14c:	0a29286b 0000000a 732f2e2e 412f6372     k()......./src/A
  41e15c:	742f4653 64726968 74726170 72462f79     SF/thirdparty/Fr
  41e16c:	54526565 462f534f 52656572 2f534f54     eeRTOS/FreeRTOS/
  41e17c:	72756f53 702f6563 6174726f 2f656c62     Source/portable/
  41e18c:	4d6d654d 2f676e61 70616568 632e345f     MemMang/heap_4.c
  41e19c:	00000000 5252450a 203a524f 25207325     .....ERROR: %s %
  41e1ac:	00000a64 732f2e2e 412f6372 742f4653     d...../src/ASF/t
  41e1bc:	64726968 74726170 72462f79 54526565     hirdparty/FreeRT
  41e1cc:	462f534f 52656572 2f534f54 72756f53     OS/FreeRTOS/Sour
  41e1dc:	712f6563 65756575 0000632e 5252450a     ce/queue.c...ERR
  41e1ec:	203a524f 25207325 00000a64 732f2e2e     OR: %s %d...../s
  41e1fc:	412f6372 742f4653 64726968 74726170     rc/ASF/thirdpart
  41e20c:	72462f79 54526565 462f534f 52656572     y/FreeRTOS/FreeR
  41e21c:	2f534f54 72756f53 742f6563 736b7361     TOS/Source/tasks
  41e22c:	0000632e 5252450a 203a524f 25207325     .c...ERROR: %s %
  41e23c:	00000a64 454c4449 00000000 52450a0a     d...IDLE......ER
  41e24c:	3a524f52 73617420 4548436b 465f4b43     ROR: taskCHECK_F
  41e25c:	535f524f 4b434154 45564f5f 4f4c4652     OR_STACK_OVERFLO
  41e26c:	20292857 0a0a7325 00000000 52450a0a     W() %s........ER
  41e27c:	3a524f52 6d754420 485f796d 6c646e61     ROR: Dummy_Handl
  41e28c:	29287265 70202d20 746e6168 53496d6f     er() - phantomIS
  41e29c:	203d2052 000a6425 3744410a 5f303737     R = %d...AD7770_
  41e2ac:	494e4974 45525f54 5f544553 616c6564     tINIT_RESET_dela
  41e2bc:	000a2179 3744410a 20303737 69676552     y!...AD7770 Regi
  41e2cc:	72657473 61642073 66206174 206d6f72     sters data from 
  41e2dc:	30307830 206f7420 58323025 00000a3a     0x00 to %02X:...
  41e2ec:	58323025 00000020 0000000a 3744410a     %02X ........AD7
  41e2fc:	20303737 666e6f63 6d206769 206e6961     770 config main 
  41e30c:	69676572 72657473 000a3a73 50203e3d     registers:..=> P
  41e31c:	5245574f 45444f4d 48203d20 20686769     OWERMODE = High 
  41e32c:	6f736572 6974756c 28206e6f 20676572     resolution (reg 
  41e33c:	31317830 74696220 29313d36 0000000a     0x11 bit6=1)....
  41e34c:	44203e3d 4d494345 4f495441 4152204e     => DECIMATION RA
  41e35c:	3d204554 34303220 4f282038 3d205244     TE = 2048 (ODR =
  41e36c:	484b3120 2820297a 20676572 30367830      1KHz) (reg 0x60
  41e37c:	3078303d 6e612038 65722064 78302067     =0x08 and reg 0x
  41e38c:	303d3136 000a2930 4e203e3d 4f207765     61=00)..=> New O
  41e39c:	76205244 65756c61 20736920 61647075     DR value is upda
  41e3ac:	20646574 73207962 69747465 7420676e     ted by setting t
  41e3bc:	53206568 4c5f4352 5f44414f 41445055     he SRC_LOAD_UPDA
  41e3cc:	62204554 74207469 0a31206f 00000000     TE bit to 1.....
  41e3dc:	3744410a 20303737 42414e45 5320454c     .AD7770 ENABLE S
  41e3ec:	73204950 6576616c 646f6d20 6f742065     PI slave mode to
  41e3fc:	61657220 61622064 41206b63 6f204344      read back ADC o
  41e40c:	4453206e 0a0a214f 00000000 3744410a     n SDO!.......AD7
  41e41c:	20303737 41534944 20454c42 20495053     770 DISABLE SPI 
  41e42c:	76616c73 6f6d2065 74206564 6572206f     slave mode to re
  41e43c:	62206461 206b6361 20434441 53206e6f     ad back ADC on S
  41e44c:	0a214f44 00000000 2a2a0a0a 4c50202a     DO!.......*** PL
  41e45c:	53414341 20437520 44412065 45442043     ACAS uC e ADC DE
  41e46c:	4f434153 44414c50 2a205341 0a0a2a2a     SACOPLADAS ***..
  41e47c:	00000000 7272450a 0a64253d 00000000     .....Err=%d.....
  41e48c:	656d4846 0a64253d 00000000 253d4846     FHme=%d.....FH=%
  41e49c:	00000a64 656d4642 0a64253d 00000000     d...BFme=%d.....
  41e4ac:	7a734642 0a64253d 00000000 3d6e4642     BFsz=%d.....BFn=
  41e4bc:	000a6425 74736f4c 2064253d 20642520     %d..Lost=%d  %d 
  41e4cc:	0a642520 00000000 3a73540a 0000000a      %d......Ts:....
  41e4dc:	253d7348 736d2064 0a64253d 00000000     Hs=%d ms=%d.....
  41e4ec:	253d734e 736d2064 0a64253d 00000000     Ns=%d ms=%d.....
  41e4fc:	253d684e 0a756c6c 00000000 66332e25     Nh=%llu.....%.3f
  41e50c:	00000000 66666944 7373253d 0000000a     ....Diff=%ss....
  41e51c:	636e7953 0000003d 00000a59 00000a4e     Sync=...Y...N...

0041e52c <SOCKET_ADC_TCP_IP>:
  41e52c:	2e323931 2e383631 30312e31 00000031     192.168.1.101...

0041e53c <SOCKET_SNTP_IP>:
  41e53c:	2e323931 2e383631 30312e31 00000031     192.168.1.101...
  41e54c:	5044550a 636f532d 2d74656b 20434441     .UDP-Socket-ADC 
  41e55c:	75207369 0a0a2170 00000000 52450a0a     is up!........ER
  41e56c:	3a524f52 50445520 636f532d 2d74656b     ROR: UDP-Socket-
  41e57c:	20434441 6e207369 6320746f 74616572     ADC is not creat
  41e58c:	0a216465 0000000a 732f2e2e 482f6372     ed!......./src/H
  41e59c:	2f534349 6b636f53 2f737465 6b636f73     ICS/Sockets/sock
  41e5ac:	2e737465 00000063 5252450a 203a524f     ets.c....ERROR: 
  41e5bc:	25207325 00000a64 5043540a 636f532d     %s %d....TCP-Soc
  41e5cc:	2d74656b 20434441 75207369 0a0a2170     ket-ADC is up!..
  41e5dc:	00000000 52450a0a 3a524f52 50435420     ......ERROR: TCP
  41e5ec:	636f532d 2d74656b 20434441 6e207369     -Socket-ADC is n
  41e5fc:	6320746f 74616572 0a216465 0000000a     ot created!.....
  41e60c:	5043540a 636f532d 2d74656b 20434441     .TCP-Socket-ADC 
  41e61c:	64207369 216e776f 00000a0a 636f530a     is down!.....Soc
  41e62c:	2d74656b 50544e53 20736920 0a217075     ket-SNTP is up!.
  41e63c:	0000000a 52450a0a 3a524f52 636f5320     ......ERROR: Soc
  41e64c:	2d74656b 50544e53 20736920 20746f6e     ket-SNTP is not 
  41e65c:	61657263 21646574 00000a0a 4349480a     created!.....HIC
  41e66c:	65642053 20677562 74617473 000a3a65     S debug state:..
  41e67c:	6d48462d 64253d65 0000000a 3d48462d     -FHme=%d....-FH=
  41e68c:	000a6425 78634d2d 0a64253d 00000000     %d..-Mcx=%d.....
  41e69c:	7863462d 0a64253d 00000000 69644d2d     -Fcx=%d.....-Mdi
  41e6ac:	0a64253d 00000000 4349480a 61772053     =%d......HICS wa
  41e6bc:	72207469 74657365 20796220 63746177     it reset by watc
  41e6cc:	676f6468 2e2e2e20 00000a0a              hdog .......

0041e6d8 <ucMACAddress>:
  41e6d8:	33221100 00005544                       .."3DU..

0041e6e0 <ucIPAddress>:
  41e6e0:	c901a8c0                                ....

0041e6e4 <ucNetMask>:
  41e6e4:	00ffffff                                ....

0041e6e8 <ucGatewayAddress>:
  41e6e8:	0101a8c0                                ....

0041e6ec <ucDNSServerAddress>:
  41e6ec:	dede43d0 00000a0a 202a2a2a 41415243     .C......*** CRAA
  41e6fc:	202d204d 746e6543 64206f72 61522065     M - Centro de Ra
  41e70c:	2d6f6964 72747341 6d6f6e6f 65206169     dio-Astronomia e
  41e71c:	74734120 69666f72 61636973 63614d20      Astrofisica Mac
  41e72c:	7a6e656b 20206569 20202020 20202020     kenzie          
  41e73c:	0a2a2a2a 00000000 202a2a2a 53544148     ***.....*** HATS
  41e74c:	49483a3a 2d205343 74614420 63412061     ::HICS - Data Ac
  41e75c:	73697571 6f697469 6f4d206e 656c7564     quisition Module
  41e76c:	20202020 20202020 20202020 20202020                     
  41e77c:	20202020 20202020 20202020 20202020                     
  41e78c:	0a2a2a2a 00000000 202a2a2a 6d726946     ***.....*** Firm
  41e79c:	65726177 6c657220 65736165 302e3120     ware release 1.0
  41e7ac:	202d2030 4a2f3232 2f656e75 30323032     0 - 22/June/2020
  41e7bc:	20202020 20202020 20202020 20202020                     
  41e7cc:	20202020 20202020 20202020 20202020                     
  41e7dc:	0a2a2a2a 0000000a 344d4153 50582d45     ***.....SAM4E-XP
  41e7ec:	00004f52 25202d2d 000a0d73 353a3431     RO..-- %s...14:5
  41e7fc:	30333a35 00000000 206e754a 32203632     5:30....Jun 26 2
  41e80c:	00303230 43202d2d 69706d6f 3a64656c     020.-- Compiled:
  41e81c:	20732520 2d207325 0d0a0d2d 0000000a      %s %s --.......
  41e82c:	49480a0a 452d5343 726f7272 65646f43     ..HICS-ErrorCode
  41e83c:	2578303d 0a583430 0000000a 696e694d     =0x%04X.....Mini
  41e84c:	456d756d 46726576 48656572 53706165     mumEverFreeHeapS
  41e85c:	20657a69 6425203d 0000000a 65657246     ize = %d....Free
  41e86c:	70616548 657a6953 20202020 20202020     HeapSize        
  41e87c:	20202020 6425203d 0000000a 7270730a         = %d.....spr
  41e88c:	66746e69 73657420 000a3a74 00006425     intf test:..%d..
  41e89c:	253d3175 000a7373 66332e25 00000000     u1=%ss..%.3f....
  41e8ac:	253d3166 000a7373 253d3164 0a0a7373     f1=%ss..d1=%ss..
  41e8bc:	00000000 657a6953 6220666f 65666675     ....Sizeof buffe
  41e8cc:	44412072 000a3a43 203e3d09 616d6154     r ADC:...=> Tama
  41e8dc:	206f686e 75206564 6572206d 74736967     nho de um regist
  41e8ec:	3a206f72 20642520 65747962 00000a73     ro : %d bytes...
  41e8fc:	203e3d09 6e617551 61646974 64206564     .=> Quantidade d
  41e90c:	65722065 74736967 3a736f72 0a642520     e registros: %d.
  41e91c:	00000000 203e3d09 616d6154 206f686e     .....=> Tamanho 
  41e92c:	42206f64 65666675 20203a72 20202020     do Buffer:      
  41e93c:	20642520 65747962 000a0a73 53434948      %d bytes...HICS
  41e94c:	7361545f 0000006b 50544e53 5341542d     _Task...SNTP-TAS
  41e95c:	0000004b 252e7525 75252e75 0075252e     K...%u.%u.%u.%u.
  41e96c:	0a0d0a0d 41205049 65726464 203a7373     ....IP Address: 
  41e97c:	0a0d7325 00000000 6e627553 4d207465     %s......Subnet M
  41e98c:	3a6b7361 0d732520 0000000a 65746147     ask: %s.....Gate
  41e99c:	20796177 72646441 3a737365 0d732520     way Address: %s.
  41e9ac:	0000000a 20534e44 76726553 41207265     ....DNS Server A
  41e9bc:	65726464 203a7373 0a0d7325 00000a0d     ddress: %s......

0041e9cc <_global_impure_ptr>:
  41e9cc:	20000180 00464e49 00666e69 004e414e     ... INF.inf.NAN.
  41e9dc:	006e616e 33323130 37363534 42413938     nan.0123456789AB
  41e9ec:	46454443 00000000 33323130 37363534     CDEF....01234567
  41e9fc:	62613938 66656463 00000000 6c756e28     89abcdef....(nul
  41ea0c:	0000296c 00000030                       l)..0...

0041ea14 <blanks.7223>:
  41ea14:	20202020 20202020 20202020 20202020                     

0041ea24 <zeroes.7224>:
  41ea24:	30303030 30303030 30303030 30303030     0000000000000000

0041ea34 <blanks.7217>:
  41ea34:	20202020 20202020 20202020 20202020                     

0041ea44 <zeroes.7218>:
  41ea44:	30303030 30303030 30303030 30303030     0000000000000000
  41ea54:	69666e49 7974696e 00000000 004e614e     Infinity....NaN.
  41ea64:	00000043 49534f50 00000058 0000002e     C...POSIX.......
  41ea74:	00000000                                ....

0041ea78 <__mprec_bigtens>:
  41ea78:	37e08000 4341c379 b5056e17 4693b8b5     ...7y.AC.n.....F
  41ea88:	e93ff9f5 4d384f03 f9301d32 5a827748     ..?..O8M2.0.Hw.Z
  41ea98:	7f73bf3c 75154fdd                       <.s..O.u

0041eaa0 <__mprec_tens>:
  41eaa0:	00000000 3ff00000 00000000 40240000     .......?......$@
  41eab0:	00000000 40590000 00000000 408f4000     ......Y@.....@.@
  41eac0:	00000000 40c38800 00000000 40f86a00     .......@.....j.@
  41ead0:	00000000 412e8480 00000000 416312d0     .......A......cA
  41eae0:	00000000 4197d784 00000000 41cdcd65     .......A....e..A
  41eaf0:	20000000 4202a05f e8000000 42374876     ... _..B....vH7B
  41eb00:	a2000000 426d1a94 e5400000 42a2309c     ......mB..@..0.B
  41eb10:	1e900000 42d6bcc4 26340000 430c6bf5     .......B..4&.k.C
  41eb20:	37e08000 4341c379 85d8a000 43763457     ...7y.AC....W4vC
  41eb30:	674ec800 43abc16d 60913d00 43e158e4     ..Ngm..C.=.`.X.C
  41eb40:	78b58c40 4415af1d d6e2ef50 444b1ae4     @..x...DP.....KD
  41eb50:	064dd592 4480f0cf c7e14af6 44b52d02     ..M....D.J...-.D
  41eb60:	79d99db4 44ea7843                       ...yCx.D

0041eb68 <p05.6055>:
  41eb68:	00000005 00000019 0000007d              ........}...

0041eb74 <_ctype_>:
  41eb74:	20202000 20202020 28282020 20282828     .         ((((( 
  41eb84:	20202020 20202020 20202020 20202020                     
  41eb94:	10108820 10101010 10101010 10101010      ...............
  41eba4:	04040410 04040404 10040404 10101010     ................
  41ebb4:	41411010 41414141 01010101 01010101     ..AAAAAA........
  41ebc4:	01010101 01010101 01010101 10101010     ................
  41ebd4:	42421010 42424242 02020202 02020202     ..BBBBBB........
  41ebe4:	02020202 02020202 02020202 10101010     ................
  41ebf4:	00000020 00000000 00000000 00000000      ...............
	...

0041ec78 <_init>:
  41ec78:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  41ec7a:	bf00      	nop
  41ec7c:	bcf8      	pop	{r3, r4, r5, r6, r7}
  41ec7e:	bc08      	pop	{r3}
  41ec80:	469e      	mov	lr, r3
  41ec82:	4770      	bx	lr

0041ec84 <__init_array_start>:
  41ec84:	004194d9 	.word	0x004194d9

0041ec88 <__frame_dummy_init_array_entry>:
  41ec88:	0040011d                                ..@.

0041ec8c <_fini>:
  41ec8c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  41ec8e:	bf00      	nop
  41ec90:	bcf8      	pop	{r3, r4, r5, r6, r7}
  41ec92:	bc08      	pop	{r3}
  41ec94:	469e      	mov	lr, r3
  41ec96:	4770      	bx	lr

0041ec98 <__fini_array_start>:
  41ec98:	004000f9 	.word	0x004000f9
